/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc(void); // idb
int *ftext();
_DWORD *ctor_002();
int __fastcall main(int, char **, char **); // idb
_DWORD *ctor_003();
int *ctor_004();
int *ctor_005();
int *ctor_006();
int *ctor_007();
_DWORD *ctor_008();
_DWORD *ctor_009();
_DWORD *ctor_010();
int *ctor_011();
_DWORD *ctor_012();
_DWORD *ctor_013();
int *ctor_014();
_DWORD *ctor_015();
_DWORD *ctor_016();
int *ctor_017();
_DWORD *ctor_018();
_DWORD *ctor_019();
int *ctor_020();
int *ctor_021();
_DWORD *ctor_022();
_DWORD *ctor_023();
_DWORD *ctor_024();
_DWORD *ctor_025();
int *ctor_026();
int *ctor_027();
int *ctor_028();
int *ctor_029();
_DWORD *ctor_030();
_DWORD *ctor_031();
int *ctor_032();
int *ctor_033();
int *ctor_034();
_DWORD *ctor_035();
int *ctor_036();
int *ctor_037();
int *ctor_038();
_DWORD *ctor_039();
_DWORD *ctor_040();
_DWORD *ctor_041();
int *ctor_042();
_DWORD *ctor_043();
int *ctor_044();
int *ctor_045();
_DWORD *ctor_046();
int *ctor_047();
_DWORD *ctor_048();
int *ctor_049();
int *ctor_050();
int *ctor_051();
_DWORD *ctor_052();
int *ctor_053();
_DWORD *ctor_054();
int *ctor_055();
_DWORD *ctor_056();
int *ctor_057();
_DWORD *ctor_058();
int *ctor_059();
int *ctor_060();
int *ctor_061();
int *ctor_062();
int *ctor_063();
_DWORD *ctor_064();
_DWORD *ctor_065();
int *ctor_066();
_DWORD *ctor_067();
int *ctor_068();
int *ctor_069();
_DWORD *ctor_070();
int *ctor_071();
int *ctor_072();
int *ctor_073();
int *ctor_074();
_DWORD *ctor_075();
int *ctor_076();
int *ctor_077();
int *ctor_078();
int *ctor_079();
int *ctor_080();
_DWORD *ctor_081();
int *ctor_082();
int *ctor_083();
int *ctor_084();
int *ctor_085();
int *ctor_086();
int *ctor_087();
int *ctor_088();
_DWORD *ctor_089();
_DWORD *ctor_090();
int *ctor_091();
int *ctor_092();
_DWORD *ctor_093();
_DWORD *ctor_094();
int *ctor_095();
int *ctor_096();
_DWORD *ctor_097();
int *ctor_098();
_DWORD *ctor_099();
int *ctor_100();
_DWORD *ctor_101();
int *ctor_102();
_DWORD *ctor_103();
int *ctor_104();
int start();
int sub_41FE04();
int sub_41FE70();
int (__fastcall *sub_41FF2C())(_DWORD, _DWORD);
int __fastcall _httpd_parm_do(char *a1);
char *__fastcall httpd_find_type(const char *a1);
char *httpd_find_type2_init();
char *__fastcall httpd_find_ext_name(const char *a1);
const char *__fastcall httpd_find_type2(const char *a1);
void __fastcall strlower(char *a1);
char *__fastcall unescape(char *a1);
int __fastcall do_file(const char *a1, int a2, int a3);
int httpd_get_cgi();
int __fastcall httpd_get_json_parm(int a1, int a2);
char *__fastcall httpd_get_parm(int a1, char *a2);
char *__fastcall sub_420900(int a1, char *a2);
int __fastcall httpd_send_data(int a1);
int __fastcall httpd_send_data_alloc(int a1, char *a2, signed int a3);
int __fastcall httpd_send_data_not_alloc(int a1, char *a2, signed int a3);
int __fastcall httpd_send_data_const(int a1, char *a2, signed int a3);
int __fastcall httpd_send_data_file(int a1, const char *a2, int a3, int a4);
bool __fastcall hs_addr_loopback(int a1);
int __fastcall httpd_send_data_file_ll(int a1, const char *a2, int a3, int a4, int a5);
int __fastcall httpd_check_parm_auth_xx(int a1);
int __fastcall httpd_formdata_parse(_DWORD *a1, _BYTE *a2, int a3);
int __fastcall httpd_check_aitoken(int a1);
int __fastcall httpd_send_referer(int a1);
void __fastcall sub_421B30(_DWORD *a1, const char *a2);
int __fastcall usb_httpd_user_check_cookie(int a1, int a2, const char *a3);
int __fastcall usb_httpd_cgi_user_check(const char *a1, int a2);
void __fastcall usb_httpd_conn_check_user(int a1);
int __fastcall usb_acc_check(int *a1);
void __fastcall check_client_is_or_not_mobile(int a1);
int __fastcall httpds_send_redirect(int a1, const char *a2);
int __fastcall jhl_get_hi_redirect_url(_DWORD *a1, char *a2, int a3);
int __fastcall httpds_send_redirect_ipmac(int a1, const char *a2, const char *a3);
int __fastcall jhl_get_hi_redirect_ipmac(_DWORD *a1, char *a2);
int __fastcall sub_4228B4(int a1);
int __fastcall httpd_do_wwwparm(_DWORD *a1, const char *a2);
int httpd_file_init();
int *__fastcall httpd_get_file(const char *a1, int a2);
int __fastcall sub_423418(int a1);
int __fastcall httpd_send_continue(int a1);
int __fastcall httpd_enable_write(int a1);
time_t get_sys_time();
char *__fastcall GetDateString(char *a1, const time_t *a2);
char *__fastcall sub_424324(char *a1, const time_t *a2);
int __fastcall httpd_start(int a1, int a2);
int __fastcall httpd_send_info(int a1, char *a2, int a3);
int __fastcall httpd_check_user(int a1, unsigned int a2);
int __fastcall httpd_send_404_info(int a1, char *a2, int a3);
int __fastcall httpd_dowith_post(int a1);
void __fastcall find_file_head(int a1, const char *a2);
char *__fastcall find_file_end(int a1, char *a2, signed int a3);
int __fastcall httpd_send_mime_file(int a1, const char *a2, void *a3, int a4);
int __fastcall httpd_send_html_file(int a1, const char *a2, char *a3, signed int a4);
int __fastcall httpd_send_redirect(int a1, const char *a2);
int __fastcall httpd_send_big_file(int a1, int a2, unsigned int a3);
int __fastcall sub_4260D4(int a1);
int __fastcall httpd_send_logs_file(int a1);
int __fastcall httpd_send_big_file_ll(int a1, int a2, unsigned int a3, signed int a4);
int __fastcall httpd_send_usb_file(int a1);
int __fastcall httpd_send_file(int a1, int a2);
int __fastcall httpd_cgi_ret(int a1, char *a2, int a3, int a4);
int __fastcall usb_httpd_send_login_html(int a1);
int __fastcall usb_httpd_user_auth_cookie(int a1);
int __fastcall usb_httpd_check_user(int a1, int a2);
int __fastcall sub_428FE8(int *a1);
int __fastcall httpd_send_usb_file_json(int *a1);
int __fastcall sub_429654(int a1);
int __fastcall httpd_send_auth_html_file(int a1);
int __fastcall httpd_send_auth_pic_file(int a1);
int __fastcall httpd_send_sj_file(_DWORD *a1);
int __fastcall jhl_data_giz(int a1, char *a2, int a3, int a4);
int __fastcall exec_service_timeout(int a1);
int __fastcall httpd_dowith_get(int a1);
int __fastcall httpd_do_recv(int a1);
int __fastcall exec_service(const char *a1);
int __fastcall sub_42BA64(int a1);
int __fastcall find_hs_mac(_DWORD *a1, int a2, _BYTE *a3);
int __fastcall websocket_respond_head(int a1);
int __fastcall websocket_send_data(int a1, int a2, int a3);
void __fastcall websocket_recv_data(_BYTE *a1, int a2, _BYTE *a3, unsigned int a4);
int __fastcall setnonblocking(int a1);
int __fastcall setblocking(int a1);
int _httpd_mem_clean();
int httpd_release_caches();
int *__fastcall _httpd_conn_find(int a1);
int httpd_mem_init();
_DWORD *__fastcall _httpd_enter_hash(int a1, int a2);
int __fastcall _httpd_out_hash(int a1);
int __fastcall close_socket(int fd);
void __fastcall __noreturn sub_42C3EC(int a1);
void *sub_42C4EC();
int __fastcall sub_42C508(int a1);
int __fastcall sub_42C640(int a1, int a2);
int __fastcall httpd_conn_epoll_add_pty(_DWORD *a1);
int __fastcall httpd_conn_epoll_read_pty(int a1);
int __fastcall httpd_conn_epoll_write_pty(int a1);
int __fastcall httpd_conn_epoll_del_pty(int a1);
int __fastcall httpd_conn_epoll_add_proxy(_DWORD *a1);
int __fastcall httpd_conn_epoll_read_proxy(int a1);
int __fastcall httpd_conn_epoll_write_proxy(int a1);
int __fastcall httpd_conn_epoll_del_proxy(int a1);
int __fastcall httpd_conn_epoll_add(int a1);
int __fastcall httpd_conn_epoll_read(int a1);
int __fastcall sub_42CAEC(int a1, int a2);
int __fastcall httpd_conn_epoll_write(int a1);
int __fastcall sub_42CB90(int a1, int a2);
int __fastcall httpd_conn_epoll_del(int a1);
int _httpd_conn_all_close_socket();
int exit_clean();
void __fastcall __noreturn sub_42CE20(int a1);
int httpd_poll_init();
int __fastcall httpd_sever_init(int a1, uint16_t a2, int a3);
int __fastcall httpd_tggl_init(int a1, uint16_t a2, int a3);
int __fastcall ip_allow_to_access_jhttpd(uint32_t a1);
bool __fastcall ip_allow_to_access(_DWORD *a1);
int mem_init_fun();
int __fastcall set_jhttpd_info(int a1, int a2, _WORD *a3, int a4, int a5, _WORD *a6, _WORD *a7);
int jhl_httpd_reset_user();
int cpu_rate_set();
__pid_t __fastcall safe_waitpid(__pid_t a1, int *a2, int a3);
__pid_t __fastcall wait_any_nohang(int *a1);
__sighandler_t unregister_signal();
__sighandler_t register_signal();
void __fastcall mem_list_del(int a1);
char *__fastcall mem_list_add(int a1, const char *a2, int a3, int a4);
void mem_list_show();
void jhl_httpd_just_debug_signal(int); // idb
void __fastcall _mem_malloc(int a1, const char *a2, int a3);
_DWORD *_httpd_conn_m_alloc();
void __fastcall _mem_free(void *a1);
void __fastcall _httpd_conn_m_free(void *a1);
int __fastcall httpd_conn_add(int a1, int a2, int a3);
int __fastcall httpd_conn_send_finish(int a1);
int __fastcall httpd_conn_close(int *a1);
int sub_42F56C();
int __fastcall httpd_keep_alive_timeout(int *a1);
int https_conn_clear();
int __fastcall httpd_poll(int timeout); // idb
__pid_t sub_42FB54();
int __fastcall get_name_hash(unsigned __int8 *a1);
int *__fastcall httpd_find_ext_file(const char *a1, int a2);
int __fastcall httpd_file_ext_add(int a1);
int *__fastcall httpd_find_ext_cgi(const char *a1, int a2);
int __fastcall sub_42FDF4(int a1);
int httpd_file_ext_init();
int httpd_cgi_ext_init();
int __fastcall FBR_MD5Init(_DWORD *a1);
int __fastcall FBR_MD5Update(unsigned int *a1, int a2, unsigned int a3);
unsigned int __fastcall FBR_MD5Final(unsigned int *a1);
int __fastcall httpd_passwd_md5(char *a1, const char *a2);
int jhl_user_login_init();
int jhl_user_login_save();
int __fastcall jhl_user_login_add(_DWORD *a1, void *a2, const char *a3, char a4);
int __fastcall sub_431784(_DWORD *a1, int a2, const char *a3, char a4);
int __fastcall httpd_user_check(int a1, const char *a2, const char *a3);
int __fastcall httpd_send_realm(int a1);
int __fastcall httpd_send_realm_admin(int a1);
int __fastcall sub_43217C(int a1);
int __fastcall httpd_user_check_cookie(int a1, const char *a2, const char *a3);
void __fastcall sub_432540(int a1);
int __fastcall httpd_send_login_html(int a1);
int __fastcall httpd_user_auth_cookie(int a1);
int __fastcall httpd_cgi_user_check(const char *a1, const char *a2, _DWORD *a3);
char *__fastcall httpd_cgi_user_check_admin(int a1, int a2, int a3);
int __fastcall sub_4331C0(int a1, char *a2);
int __fastcall usb_httpd_passwd_md5(char *a1, const char *a2);
void __fastcall httpd_set_cookie_language(int a1);
int httpd_unix_init();
int __fastcall httpd_unix_send_to_ai(void *buf, size_t a2);
int __fastcall httpd_unix_send_to_ac_server(void *buf, size_t a2);
void __fastcall sub_433A60(uint32_t a1, uint32_t a2, void *a3, int a4);
int httpd_unix_ac_cmd_do();
int __fastcall httpd_unix_cmd_do(int a1, int a2, const char *a3, int a4);
int httpd_unix_recv();
int _retset_timer_fun();
int _reboot_timer_fun();
int _poweroff_timer_fun();
int _net_restart_fun();
int _lan_restart_fun();
int _restart_jhttpd_fun(); // weak
int sub_434218();
int __fastcall sub_434288(int a1);
int __fastcall jhl_gl_reboot_timer(int a1);
int __fastcall jhl_gl_poweroff_timer(int a1);
int __fastcall sub_434514(int a1, int a2, int a3);
int __fastcall jhl_gl_net_restart_timer(int a1);
int __fastcall jhl_gl_lan_restart_timer(int a1);
int __fastcall jhl_gl_restart_jhttpd(char *src, int a2);
char *resmsg_get();
char *__fastcall resmsg_set(char *src);
int __fastcall save_variables_json(int a1, int a2);
int __fastcall save_variables(int a1, int a2);
int __fastcall sub_434B8C(int a1, int a2);
int __fastcall sub_434F48(int a1, int a2);
ssize_t __fastcall sub_435310(void *a1, size_t a2, char **a3);
int __fastcall sub_435548(int *a1, char **a2);
int __fastcall sub_4356D8(int *a1, char **a2);
int __fastcall sub_435880(__pid_t a1, int *a2);
int __fastcall httpd_proxy_is_self(int a1);
int __fastcall httdp_proxy_check_user(int a1);
int __fastcall httpd_proxy_check(int a1, _DWORD *a2);
int __fastcall httpd_proxy_xconnect(const struct sockaddr *a1);
int __fastcall httpd_proxy_client_close(int a1);
int __fastcall httpd_proxy_server_close(int a1);
int __fastcall httpd_proxy_do_rcv(int a1);
int __fastcall httpd_proxy_buf_init(int a1);
int __fastcall httpd_proxy_cgi(int a1);
int __fastcall mr_list_index_get(int a1, int a2, int a3);
bool __fastcall sub_43673C(int a1);
int __fastcall sub_4368E8(int a1);
int __fastcall sub_436A40(int a1);
int __fastcall sub_436E0C(int a1);
int __fastcall sub_437810(int a1);
int __fastcall sub_437B8C(int a1);
void *sdwan_get_ac_dev_list();
void __fastcall sdwan_check_in_ac(int *a1, unsigned __int8 *a2);
int __fastcall sdwan_id_init_get(int a1);
int __fastcall sub_438EA8(int a1);
int __fastcall sub_43937C(int a1);
int __fastcall sub_439B9C(int a1);
int __fastcall sub_43A1CC(int a1);
int __fastcall sub_43A4FC(int a1);
int __fastcall sub_43A91C(int a1);
int __fastcall sub_43AD7C(int a1);
int __fastcall sub_43B4C8(int a1);
int __fastcall sub_43B748(int a1);
int __fastcall sub_43BB5C(int a1);
int __fastcall sub_43BCA8(int a1);
int __fastcall sub_43BF50(int a1);
int __fastcall sub_43C2EC(int a1);
int __fastcall sub_43C524(int a1);
int __fastcall sub_43C894(int a1);
int __fastcall sub_43CE78(int a1);
int __fastcall sub_43D1CC(int a1);
int __fastcall sub_43D2C4(int a1);
int __fastcall sub_43D448(int a1);
int __fastcall sub_43D5D4(int a1);
int __fastcall sub_43D720(int a1);
int __fastcall sub_43D854(int a1);
int __fastcall sub_43D92C(int a1);
int __fastcall sub_43E11C(int a1);
int __fastcall sub_43E2A8(int a1);
int __fastcall sub_43ED6C(int a1);
int __fastcall sub_43EED0(int a1);
int __fastcall sub_43F0E4(int a1);
int __fastcall sub_43F378(int a1);
int __fastcall get_iface_increase_data(int a1, char *a2, int a3);
int __fastcall get_iface_pppoe_br_data(int a1, char *a2, int a3);
int __fastcall get_wans_data(char *a1, int a2);
int __fastcall sub_440C94(int a1);
int __fastcall sub_440FE4(int a1);
void __fastcall format_wanll_history_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4413B0(int a1);
void __fastcall format_hi_history_data(_DWORD *a1, int a2, char *a3, int a4);
int __fastcall sub_441AF0(int a1);
int __fastcall get_wan_nvarms(const char **a1, char *a2, int a3);
int __fastcall wan_webset_json(int a1);
int __fastcall wan_webset(int a1);
int __fastcall lan_webset(int a1);
int __fastcall get_dual_lan_list_data(char *a1, int a2);
void __fastcall dhcp_list_buf(int a1, int a2, int a3);
int __fastcall sub_443FA8(int a1);
int __fastcall get_lan_vlan_data(char *a1, int a2);
int __fastcall lans_data(int a1);
int __fastcall sub_4454A4(int a1);
int __fastcall _lan_vlan_asp(int a1);
int __fastcall sub_44581C(int a1);
int __fastcall sub_447AD4(int a1);
int __fastcall get_vlan_name_data(char *a1);
int __fastcall sub_4480DC(int a1);
int __fastcall sub_448510(int a1);
int __fastcall set_vlan_name_data(int a1);
int __fastcall sub_4486B8(int a1);
int __fastcall sub_44883C(int a1);
int __fastcall get_wans_increase_data(char *a1, int a2);
int __fastcall sub_448C00(int a1);
void __fastcall format_wan_extend_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_448F50(int a1);
void __fastcall format_wys_bonding_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_449520(int a1);
int __fastcall _wan_group_modify(const char *a1, int a2);
int __fastcall sub_44A1B8(int a1);
void __fastcall format_wan_groups_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_44A8A4(int a1);
int __fastcall jhl_web_save_json_parm(int a1, int a2, int a3);
int __fastcall jhl_web_save_parm(int a1, char *a2, int a3);
int __fastcall jhl_web_save_json_parm2(int a1, int a2, int a3, int a4);
int __fastcall sub_44B100(int a1, char *a2, int a3, int a4);
int __fastcall jhl_web_save_parms(int a1, char **a2, int a3);
int __fastcall get_nvarms(const char **a1, int a2, int a3);
int __fastcall set_nvrams(int a1, _BYTE **a2, int a3);
int __fastcall sub_44B60C(_BYTE **a1, int a2, int a3);
char *__fastcall reltime(char *a1, int a2);
int __fastcall jhl_link_uptime(char *a1, int a2, int a3);
_BYTE *__fastcall asp_jhl_dns(_BYTE *a1, int a2);
int __fastcall sub_44BB14(int a1, int a2);
void __fastcall get_client_info(int a1, int a2, int a3);
int __fastcall asp_time(char *a1);
int __fastcall sub_44BE00(int a1);
int __fastcall sub_44BF20(int a1);
int __fastcall ai_cgi_common_timeout(_DWORD *a1);
int __fastcall sub_44C09C(int a1);
int __fastcall sub_44C130(int a1);
int __fastcall sub_44C388(int a1);
int __fastcall sub_44CABC(int a1);
int __fastcall sub_44CCC4(int a1);
int __fastcall sub_44D5A8(int a1);
int __fastcall sub_44D610(int a1);
int __fastcall sub_44D870(int a1);
int __fastcall sub_44DD30(int a1);
int __fastcall sub_44E0C4(int a1);
int __fastcall ai_read_upgrade_state(int a1, int a2);
int __fastcall ai_check_upgrade_data(int a1);
int __fastcall get_duolanlist_data(char *a1, int a2);
bool __fastcall ai_is_running(int a1);
void __fastcall ai_unix_cgi_send(uint32_t a1, uint32_t a2, void *a3, int a4);
int __fastcall sub_44F02C(_DWORD *a1);
int __fastcall sub_44F178(int a1);
int __fastcall ai_wait_upgrade(unsigned int a1);
int __fastcall sub_44F9AC(int a1);
int check_net();
int get_nonce();
int __fastcall sub_450388(int a1);
int __fastcall jhl_link_uptime_s(int a1, int a2);
int __fastcall sub_450844(int a1);
int get_speed_test_iface();
int __fastcall speed_test_info_get(char *a1, int a2);
int __fastcall sub_45195C(int a1);
int __fastcall ai_sn_pub_check_token(int a1);
int __fastcall ai_sn_data(int a1);
int __fastcall sub_451FEC(int a1);
void __fastcall ai_ping_check_file_status(const char *a1, int a2, _DWORD *a3);
int __fastcall ai_ping_test(int a1, int a2);
int __fastcall sub_45217C(int a1);
void __fastcall ai_send_router_login(int a1, const char *a2, const char *a3, int a4, const char *a5);
int __fastcall sub_452698(int a1);
int init_diagnosis_timer();
int start_diagnosis();
int __fastcall sub_452BD0(int a1);
int __fastcall wan_port_max_speed_get(int a1);
int get_diagnosis_result();
int auto_diagnosis_timer_fun();
int __fastcall sub_453A04(int a1);
int del_vpnmessage_file();
char *__fastcall read_vpnmessage_file(char *a1, int a2);
char *__fastcall read_ipsec_file(char *a1, int a2);
char *__fastcall read_error_by_ipsec_file(char *a1, int a2);
int __fastcall sub_45461C(int a1);
int __fastcall sub_454B30(int a1);
int __fastcall sub_454E58(int a1);
int __fastcall sub_4552E0(int a1);
int __fastcall sub_4557F4(int a1);
void __fastcall qos_parm_apply(int a1, int a2, int a3);
void __fastcall format_spqos_data(const char **a1, int a2, char *a3, int a4);
int __fastcall spqos_data(const char *a1, int a2);
int __fastcall spqos_asp(const char *a1, int a2);
int __fastcall spqos_cgi(const char *a1, int a2);
int __fastcall spqos_txt(const char *a1, int a2);
int __fastcall sub_45805C(int a1);
int __fastcall sub_4585CC(int a1);
int __fastcall sub_458AAC(int a1);
int __fastcall sub_458AD0(int a1);
int __fastcall sub_458AF4(int a1);
int __fastcall sub_458B18(int a1);
int __fastcall sub_458B3C(int a1);
int __fastcall sub_458B60(int a1);
int __fastcall sub_458B84(int a1);
int __fastcall sub_458BA8(int a1);
int __fastcall sub_458BCC(int a1);
int __fastcall sub_458BF0(int a1);
int __fastcall sub_458C14(int a1);
int __fastcall sub_458C38(int a1);
int __fastcall sub_458C60(int a1);
int __fastcall sub_458F3C(int a1);
int __fastcall sub_4595C8(int a1);
int __fastcall sub_459774(int a1);
int __fastcall sub_4599F0(int a1);
int defaults_asp_timer_fun();
int __fastcall sub_459DEC(int a1);
int __fastcall sub_459E94(int a1);
int __fastcall sub_45A138(int a1);
int __fastcall sub_45A358(int a1);
int __fastcall sub_45A69C(int a1);
int __fastcall sub_45A930(int a1);
int __fastcall sub_45AD14(int a1);
int __fastcall sub_45B0C8(int a1);
int __fastcall proxy_client_data(int a1);
int __fastcall sub_45BE48(int a1);
bool __fastcall sub_45C384(int a1);
int __fastcall sub_45C3BC(int a1);
int __fastcall sub_45C558(int a1);
int __fastcall sub_45C810(int a1);
int __fastcall sub_45C96C(int a1);
int __fastcall sub_45CB40(int a1);
int __fastcall sub_45D140(int a1);
int __fastcall wan_ping_data(int a1);
int __fastcall sub_45D93C(int a1);
int __fastcall sub_45DBCC(int a1);
int __fastcall sub_45DFFC(int a1);
int __fastcall mac_filter_data(int a1);
int __fastcall sub_45E810(int a1);
int __fastcall sub_45E8B0(int a1);
int __fastcall sub_45F604(int a1);
int __fastcall sub_45FA4C(int a1);
int __fastcall sub_45FCC4(int a1);
int __fastcall sub_45FE14(int a1);
void sub_460000();
int __fastcall arp_st_getfile(void *a1, signed int a2);
int __fastcall sub_460CA4(int a1);
int __fastcall sub_460DC4(int a1);
void __fastcall format_ddos_rule_data(const char **a1, int a2, char *a3, int a4);
int __fastcall ddos_data(int a1);
int __fastcall sub_46175C(int a1);
int __fastcall ddos_fy_black_list(char *a1, int a2);
int __fastcall sub_462BF4(int a1);
void __fastcall format_ctxz_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_462EE0(int a1);
int __fastcall sub_4633B0(const char *a1, int a2);
int __fastcall check_ips_group_contain(const char *a1, const char *a2);
void __fastcall check_time_group_contain(const char *a1, const char *a2);
int __fastcall mrprot_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5);
int __fastcall ddos_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5);
int __fastcall xwgl_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5);
int __fastcall url_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5);
int __fastcall qq_rule_check_used_group(const char *a1, void *a2, size_t a3, int a4);
int qos_rule_check_used_group(int, int, int, int, size_t n, int); // idb
int __fastcall ctxz_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5);
int __fastcall macfilter_rule_check_used_group(const char *a1, void *a2, size_t a3, int a4);
int _get_timer_man_list();
_DWORD *__fastcall _get_timer_man_tid(int a1, const char *a2, const char *a3);
int __fastcall time_group_modify(int a1, int a2);
int __fastcall ips_group_is_used(int a1);
int __fastcall time_group_is_used(const char *a1);
void __fastcall format_ips_group_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_ips_group_data(char *a1, int a2);
int __fastcall sub_4655E8(int a1);
int __fastcall sub_4657C0(int a1);
int __fastcall time_group_get_id(int a1);
void __fastcall format_time_group_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_time_group_data(char *a1, int a2);
int __fastcall sub_4664F0(int a1);
int __fastcall sub_4666C8(int a1);
int __fastcall sub_467090(int a1);
void __fastcall format_hbmd_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_hbmd_data(const char *a1, char *a2, int a3);
int __fastcall sub_46769C(int a1);
int __fastcall sub_467900(int a1);
void __fastcall format_xwgl_ref_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4683AC(int a1);
int __fastcall sub_4687E0(int a1);
int __fastcall sub_469574(int a1);
int __fastcall sub_4696C4(int a1);
int dns_acc_delall();
int dns_url_delall();
int __fastcall sub_469F64(int a1);
int __fastcall sub_46A0B4(int a1);
int __fastcall sub_46A46C(int a1);
int __fastcall sub_46A5BC(int a1);
signed int __fastcall dns_acc_get(char *a1, size_t a2);
void __fastcall format_dns_acc_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_46AC30(int a1);
void __fastcall format_dns_url_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_46B0F4(int a1);
int __fastcall sub_46B4F4(int a1);
int __fastcall sub_46BDD4(int a1);
int __fastcall sub_46C4EC(int a1);
int __fastcall sub_46C654(int a1);
void __fastcall format_acc_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_46CC80(int a1);
int __fastcall sub_46D0D0(int a1);
int __fastcall sub_46DF20(int a1);
int __fastcall sub_46DF94(int a1);
int __fastcall sub_46E274(int a1);
int __fastcall sub_46E3A0(int a1);
int __fastcall sub_46E500(int a1);
int __fastcall sub_46EB48(int a1);
int __fastcall sub_46EFF8(int a1);
int __fastcall sub_46F1B8(int a1);
int __fastcall sub_46F4CC(int a1);
int __fastcall sub_46F750(int a1);
int __fastcall sub_46F864(int a1);
int sub_470000(void); // weak
int __fastcall sub_470464(int a1);
int __fastcall sub_470548(int a1);
int __fastcall user_lock_asp(int a1);
int __fastcall sub_470BEC(int a1);
int __fastcall sub_471174(int a1);
int __fastcall sub_471680(int a1);
int __fastcall sub_471870(int a1);
int __fastcall sub_471DB8(int a1);
int __fastcall sub_472234(int a1);
int __fastcall sub_472668(int a1);
int __fastcall sub_472988(int a1);
int __fastcall sub_472C90(int a1);
int __fastcall sub_472D44(int a1);
int __fastcall sub_472E50(int a1);
int __fastcall sub_4731AC(int a1);
int __fastcall sub_473268(int a1);
int __fastcall sub_473540(int a1);
int __fastcall sub_47383C(int a1);
int __fastcall sub_473B38(int a1);
int __fastcall sub_473E34(int a1);
int __fastcall sub_474130(int a1);
int __fastcall sub_4742B4(int a1);
int __fastcall sub_4743FC(int a1);
int __fastcall sub_4744F0(int a1);
int __fastcall sub_4746CC(int a1);
int __fastcall sub_47481C(int a1);
int __fastcall sub_474BE4(int a1);
int __fastcall sub_474FCC(int a1);
int __fastcall sub_475A18(int a1);
int __fastcall sub_476210(int a1);
int __fastcall sub_476A24(int a1);
int __fastcall sub_477F98(int a1);
int __fastcall _rzgl_ip_asp(int a1, int a2);
int __fastcall sub_479674(int a1);
int __fastcall _rzgl_mac_asp(int a1, int a2);
int __fastcall sub_479980(int a1);
int __fastcall user_get_state(int a1, char *a2, int a3);
int __fastcall user_data(int a1);
int __fastcall sub_47A918(int a1);
time_t __fastcall timeconvert(char *a1, struct tm *a2);
int __fastcall sub_47C34C(int a1);
int __fastcall sub_47CF20(int a1);
int __fastcall tg_url_get(char *a1, int a2, int *a3, int a4);
int __fastcall sub_47DB24(int a1);
int __fastcall get_web_language_type(int a1);
int __fastcall sub_47DD34(int a1);
int __fastcall sub_47E29C(int a1);
int __fastcall sub_47E464(int a1);
int __fastcall sub_47E62C(int a1);
int __fastcall sub_47E7F4(int a1);
int __fastcall org_html(int a1, int a2);
int __fastcall sub_47EAEC(int a1);
int __fastcall sub_47EB78(int a1);
int __fastcall sub_47EC04(int a1);
int __fastcall sub_47EC90(int a1);
int __fastcall sub_47ED1C(int a1);
int __fastcall sub_47EDA8(int a1);
int __fastcall sub_47EE34(int a1);
void __fastcall search_str(char *a1, int a2, const void *a3, size_t a4);
int __fastcall auth_html_upload_do_rcv(int a1);
int __fastcall sub_47FB20(int a1);
unsigned __int8 *__fastcall ShiBie_find(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4);
int __fastcall user_name_pwd_get(int *a1, char *a2, char *a3);
int __fastcall sub_47FDEC(int a1);
int __fastcall web_get_user_agent(unsigned __int8 *a1, int a2, _BYTE *a3, int a4);
int __fastcall webauth_data_send(int a1, int a2);
int __fastcall webauth_data_timeout(_DWORD *a1);
int __fastcall webauth_data(_DWORD *a1);
int __fastcall sub_480DC4(int a1);
int __fastcall fw_upgrade_timeout(int a1);
int __fastcall sub_481A0C(int a1);
int __fastcall sub_481D04(int a1);
int __fastcall sub_481FF4(int a1);
int __fastcall sub_4821E4(int a1);
int __fastcall sub_4823A4(int a1);
int __fastcall sub_482618(int a1);
int __fastcall sub_48295C(int a1);
int __fastcall sub_482CB4(int a1);
int __fastcall sub_482FD4(int a1);
int __fastcall sub_48328C(int a1);
int __fastcall sub_483564(int a1);
int __fastcall sub_48389C(int a1);
int __fastcall flash_Kernel_read(void *a1, int a2, int a3, int a4, size_t a5);
ssize_t __fastcall flash_Kernel_write(char *a1, int a2, int a3, int a4, unsigned int a5);
int __fastcall flash_Uboot_read(void *a1, int a2, int a3, int a4, size_t a5);
ssize_t __fastcall flash_Uboot_write(char *a1, int a2, int a3, int a4, unsigned int a5, char *s);
int __fastcall flash_art_read(void *a1, int a2, int a3, int a4, size_t a5);
ssize_t __fastcall flash_art_write(char *a1, int a2, int a3, int a4, unsigned int a5, char *s);
int __fastcall sub_4856BC(int a1);
void __fastcall format_url_group_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_url_group_data(char *a1, int a2);
int __fastcall get_url_update_data(char *a1);
int __fastcall sub_4869FC(int a1);
int __fastcall sub_486C1C(int a1);
void __fastcall format_url_member_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4870F8(int a1);
int __fastcall sub_487544(int a1);
int __fastcall url_member_get_file(char *a1, size_t a2);
int __fastcall sub_487F0C(int a1);
int __fastcall sub_48802C(int a1);
void __fastcall format_url_rule_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4882FC(int a1);
int __fastcall sub_488810(int a1);
int __fastcall sub_488B80(int a1);
int __fastcall sub_489B8C(int a1);
int __fastcall sub_489CDC(int a1);
int __fastcall sub_48A3F8(int a1);
int __fastcall sub_48A648(int a1);
void __fastcall read_file_buf(const char *a1, int *a2);
int __fastcall sub_48A974(int a1);
int __fastcall read_file_asp(int a1, int a2, const char *a3);
int __fastcall sub_48AC5C(int a1, int a2, int a3);
int __fastcall sub_48AE28(int a1);
int __fastcall sub_48B02C(int a1);
int __fastcall mask_addr_to_inet(const char *a1);
int __fastcall ipsec_road_data(int a1);
int __fastcall sub_48B714(int a1);
int __fastcall sub_48BCE8(int a1);
int __fastcall sub_48BF9C(int a1);
void __fastcall format_ipsec_net_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_48C594(int a1);
int __fastcall sub_48CCBC(int a1);
int __fastcall GetIpsecSaStatus(const char *a1, char *a2, const char *a3, void *a4, size_t n);
int show_ipsec_status();
int __fastcall sub_48E578(int a1);
int __fastcall sub_48E7F0(int a1);
void __fastcall format_user_state_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_vpn_user_state_data(int a1, char *a2, int a3);
void __fastcall format_vpn_user_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_vpn_user_data(int a1, char *a2, int a3);
int __fastcall sub_48F0F4(int a1);
int __fastcall sub_48F450(int a1);
char *__fastcall jhl_vpn_link_uptime(char *a1, int a2);
int __fastcall get_vpn_nvarms(const char **a1, char *a2, int a3);
int __fastcall get_vpn_state(char *a1, int a2);
int __fastcall sub_4905B8(int a1);
int __fastcall sub_4907EC(int a1);
int __fastcall sub_490F1C(int a1);
int __fastcall sub_491124(int a1);
int __fastcall get_vpns_iface(_BYTE *a1);
int __fastcall dns_more_rule_check_used_group(int a1, int a2);
int __fastcall dns_more_dnstype_is_used(int a1);
int __fastcall dns_more_dnswan_is_used(const char *a1);
void __fastcall format_dns_more_dnswan_data(const char **a1, int a2, char *a3, int a4);
void __fastcall format_dns_more_dnswan_rule_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_dns_more_dnswan_data(char *a1, int a2);
int __fastcall sub_491964(int a1);
int __fastcall sub_491F24(int a1);
int __fastcall dns_more_check_data(int a1);
int __fastcall sub_492BA4(int a1);
int __fastcall dns_more_dnstype_search(_WORD *a1, size_t a2, int a3);
int __fastcall sub_492EAC(int a1);
int __fastcall dns_more_get_dnstype_item_list_id(int a1);
int __fastcall sub_49320C(int a1);
int __fastcall dns_more_member_get_file(char *a1, size_t a2);
int __fastcall sub_494050(int a1);
int __fastcall sub_494170(int a1);
int __fastcall dns_more_dnstype_item_get_file(_DWORD *a1, size_t a2, const char *a3);
int __fastcall sub_494640(int a1);
int __fastcall sub_494788(int a1);
int __fastcall sub_494990(int a1);
int __fastcall sub_494C4C(int a1);
int __fastcall sub_4954DC(int a1);
int __fastcall sub_495764(int a1);
int __fastcall asp_activeroutes(char *a1, int a2);
void __fastcall format_routers_static(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_49635C(int a1);
int __fastcall sub_496CB8(int a1);
int __fastcall sub_497560(int a1);
int __fastcall sub_497D98(int a1);
int __fastcall pppoe_list_data(int a1);
int __fastcall pppoe_opt(__int16 a1, __int16 a2);
int __fastcall sub_498D50(int a1);
int __fastcall sub_498F4C(int a1);
int __fastcall sub_4995AC(int a1);
int __fastcall get_wans_pppoebr_data(char *a1, int a2);
void __fastcall format_pppoe_br_more_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_49A7E4(int a1);
int __fastcall sub_49ACB4(int a1);
int __fastcall sub_49B3AC(int a1);
int __fastcall sub_49B514(int a1);
int __fastcall pppoe_br_get_state(char *a1, size_t a2);
int __fastcall sub_49BC60(int a1);
int __fastcall sub_49C250(int a1);
int __fastcall pppoe_br_session_get_state(int a1, int a2);
int __fastcall sub_49D12C(int a1);
int __fastcall pppoe_br_user_get_state(char *a1, size_t a2);
int __fastcall sub_49D5E4(int a1);
int __fastcall pppoe_br_user_asp(int a1);
int __fastcall sub_49E740(int a1);
int __fastcall sub_49E860(int a1);
int __fastcall pppoe_bridge_md5(char *a1, int a2, int a3);
int __fastcall pppoe_bridge_user_md5(char *a1, const char *a2, const char *a3);
int __fastcall pppoe_bridge_check_token(int a1);
int __fastcall sub_49F2B8(int a1);
int __fastcall sub_49F4B8(int a1);
int __fastcall sub_49F91C(int a1);
int __fastcall pppoe_bridge_session_get_state(int a1, int a2, int a3);
int __fastcall sub_49FC90(int a1);
int __fastcall sub_49FEC4(int a1);
void __fastcall speed_test_mr_list(int a1);
int __fastcall sub_4A0268(int a1);
int __fastcall sub_4A0564(int a1);
int __fastcall sub_4A09B8(int a1);
int __fastcall ping_data(int a1);
int __fastcall sub_4A131C(int a1);
int __fastcall trace_data(int a1);
int __fastcall sub_4A1BEC(int a1);
int __fastcall sub_4A21C4(int a1);
int __fastcall sub_4A23C0(int a1);
int __fastcall sub_4A2640(int a1);
int __fastcall dhcp_detect_list_data_send(int a1);
int __fastcall dhcp_detect_list_data_timeout(_DWORD *a1);
int __fastcall sub_4A2DB8(int a1);
int __fastcall sub_4A2F10(int a1);
int __fastcall sub_4A3070(int a1);
int __fastcall menus_js_replace_text(int a1, const char *a2, int a3, int a4);
int __fastcall sub_4A3510(int a1);
int __fastcall upnp_ctrl_file_exists(int a1);
int __fastcall asp_lipp(char *a1);
void __fastcall format_nat_base_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4A3984(int a1);
int __fastcall sub_4A3E98(int a1);
int __fastcall sub_4A410C(int a1);
int __fastcall sub_4A4BA4(int a1);
int __fastcall sub_4A50C0(int a1);
int __fastcall sub_4A5210(int a1);
int __fastcall format_upnp_state_data(int a1, int a2);
int __fastcall upnp_data_send(int a1);
int __fastcall upnp_data_timeout(_DWORD *a1);
int __fastcall sub_4A5958(_DWORD *a1);
void __fastcall format_upnp_list_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4A5ACC(int a1);
int __fastcall sub_4A5F98(int a1);
int __fastcall sub_4A6154(int a1);
int __fastcall sub_4A6904(int a1);
void __fastcall format_menu_nat_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4A6B9C(int a1);
int __fastcall jhl_nat_onebyone_add_iface(int a1, int a2);
int __fastcall jhl_nat_onebyone_del_iface(int a1, const char *a2);
int __fastcall sub_4A75A4(int a1);
void __fastcall format_portward_nat_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4A827C(int a1);
int __fastcall sub_4A8758(int a1);
int __fastcall sub_4A94B0(int a1);
int __fastcall sub_4A9618(int a1);
int __fastcall jhl_nat_more_add_iface(int a1, int a2);
int __fastcall jhl_nat_more_del_iface(int a1, int a2);
int __fastcall jhl_nat_more_add_wanip(int a1, int a2);
int __fastcall jhl_nat_more_del_wanip(int a1, int a2);
int __fastcall sub_4AA5C8(int a1);
int __fastcall sub_4AA730(int a1);
void __fastcall format_menu_nat_more_data(const char **a1, int a2, char *a3, int a4);
int __fastcall sub_4AAE6C(int a1);
int __fastcall sub_4AB3F4(int a1);
int __fastcall sub_4AC3C0(int a1);
int __fastcall sub_4AC7A0(int a1);
int __fastcall sub_4ACA0C(int a1);
int __fastcall sub_4AD338(int a1);
int __fastcall sub_4ADC40(int a1);
int __fastcall sub_4ADF58(int a1);
int __fastcall sub_4AE1D4(int a1);
int __fastcall sub_4AE504(int a1);
int __fastcall sub_4AE5E4(int a1);
int sq_file_del_fun();
int __fastcall sq_file_get_fun(char *a1);
int __fastcall sub_4AEA34(int a1);
int __fastcall sq_data(int a1, int a2);
int __fastcall sub_4AEF40(int a1);
int __fastcall sub_4AEF5C(int a1);
int __fastcall sub_4AEF78(int a1);
int __fastcall sub_4AF038(int a1);
int __fastcall sub_4AF1A0(int a1);
int __fastcall sub_4AF590(int a1);
int __fastcall sub_4AF8F4(int a1);
int __fastcall sub_4AFC68(int a1);
int __fastcall sub_4AFEB4(int a1);
int __fastcall sub_4B0240(int a1);
int __fastcall sub_4B05C8(int a1);
int __fastcall sub_4B0B54(int a1);
int __fastcall sub_4B0DA8(int a1);
int __fastcall usb_upload_do_rcv(int a1);
int __fastcall sub_4B1AE4(int a1);
int __fastcall usb_upload_do_rcv2(int a1);
int __fastcall sub_4B2B98(int a1);
int __fastcall sub_4B2DF4(int a1);
int __fastcall sub_4B3344(int a1);
int __fastcall sub_4B3BB8(int a1);
bool __fastcall f_exists64(const char *a1);
int __fastcall sub_4B44B4(int a1);
int __fastcall sub_4B48CC(int a1);
void __fastcall format_usb_email_list_data(const char **a1, int a2, char *a3, int a4);
int __fastcall usb_get_current_device(int a1);
int __fastcall sub_4B4E18(int a1);
int usb_send_email();
int __fastcall usb_email_asp(int a1);
int __fastcall sub_4B5F5C(int a1);
int __fastcall sub_4B5FD0(int a1);
int __fastcall reset_sj_param(char a1);
int __fastcall sj_dev_info_asp(int a1);
int __fastcall sj_dev_info_data(int a1);
int __fastcall sub_4B9F7C(int a1);
ssize_t __fastcall shenji_send_to_ctrl(const char *a1);
ssize_t shenji_ctrl_set_en();
int __fastcall sub_4BA52C(int a1);
int __fastcall sub_4BA7EC(int a1);
int __fastcall sub_4BAA64(int a1);
int __fastcall sub_4BAC7C(int a1);
int __fastcall sub_4BB09C(int a1);
int __fastcall sub_4BB0B8(int a1);
int __fastcall sub_4BB0D4(int a1);
int __fastcall sub_4BB540(int a1);
int __fastcall sub_4BBC80(int a1);
int __fastcall sub_4BCA50(int a1);
int __fastcall sub_4BCC28(int a1);
int __fastcall sub_4BCED0(int a1);
int __fastcall sub_4BD3A8(int a1);
int __fastcall get_rule_num_limit(int a1);
int __fastcall sub_4BE0E4(int a1);
int __fastcall get_rule_num(int a1, int a2);
int check_rule_num_limit(int, int, int, int, char *s, size_t maxlen); // idb
int __fastcall sub_4BE4A0(int a1);
int __fastcall mr_addr_update_data(int a1);
int __fastcall sub_4BE93C(int a1);
int __fastcall sub_4BEA68(int a1);
int __fastcall sub_4BF098(int a1);
int __fastcall mr_list_get(int a1, int a2, int a3);
int __fastcall sub_4C0120(int a1);
int __fastcall sub_4C031C(int a1);
int __fastcall sub_4C0978(int a1);
int __fastcall sub_4C0BFC(int a1);
int __fastcall sub_4C0F00(int a1);
int __fastcall sub_4C0F20(int a1);
int __fastcall sub_4C0F40(int a1);
int __fastcall sub_4C0F60(int a1);
int __fastcall sub_4C0F80(int a1);
int __fastcall sub_4C0FA0(int a1);
int __fastcall sub_4C0FC0(int a1);
int __fastcall sub_4C0FE0(int a1);
int __fastcall sub_4C1000(int a1);
int __fastcall sub_4C1020(int a1);
int __fastcall sub_4C1040(int a1);
int __fastcall sub_4C1210(int a1);
int __fastcall sub_4C1360(int a1);
int __fastcall sub_4C1D58(int a1);
int __fastcall sub_4C2118(int a1);
void __fastcall format_mrprot_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_mrcl_type_data(int a1);
int __fastcall sub_4C3CB0(int a1);
int __fastcall mrcl_ips_get_type(const char *a1);
int __fastcall sub_4C42B4(int a1);
int __fastcall mrclfile_cgi(int a1, int a2, const char *a3);
int __fastcall sub_4C488C(int a1);
int __fastcall sub_4C48B0(int a1);
int __fastcall sub_4C48D4(int a1);
int __fastcall sub_4C48F8(int a1);
int __fastcall sub_4C491C(int a1);
int __fastcall sub_4C4940(int a1);
int __fastcall sub_4C4964(int a1);
int __fastcall sub_4C4988(int a1);
int __fastcall sub_4C49AC(int a1);
int __fastcall sub_4C49D0(int a1);
int __fastcall sub_4C4A00(int a1);
int __fastcall sub_4C4B88(int a1, int a2, const char *a3);
int __fastcall sub_4C4E38(int a1);
int __fastcall sub_4C4F78(int a1, int a2, const char *a3);
int __fastcall sub_4C50A8(int a1);
int sub_4C51B0(int, int, int, int, char *nptr); // idb
int __fastcall sub_4C5380(int a1);
int __fastcall sub_4C5A3C(int a1, int a2, const char *a3);
int __fastcall sub_4C5AC4(int a1);
int __fastcall sub_4C641C(int a1);
int __fastcall sub_4C6758(int a1);
int __fastcall get_ipv6_wans_data(char *a1, int a2);
int __fastcall sub_4C73B8(int a1);
void __fastcall format_ipv6_router_static_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_ipv6_router_static_data(char *a1, int a2);
void __fastcall format_ipv6_router_data(const char **a1, int a2, char *a3, int a4);
int __fastcall get_ipv6_router_data(char *a1, int a2);
int __fastcall sub_4C7B60(int a1);
int __fastcall websocket_console_do_rcv(int a1);
int __fastcall sub_4C83A8(int a1);
int __fastcall sub_4C8630(int a1);
int switch_reboot_auto_get();
int __fastcall switch_reboot_auto_set(int a1);
void __fastcall is_in_wday(_BYTE *a1, int a2);
int __fastcall is_in_time(int a1, int a2, int a3);
int __fastcall switch_reboot_auto_runing(_DWORD *a1);
int switch_reboot_auto_timeout();
int switch_reboot_auto_timer_init();
int __fastcall sub_4C933C(int a1);
int __fastcall switch_reboot_auto_asp(int a1);
int __fastcall sub_4C975C(int a1);
int __fastcall sub_4C99F8(_DWORD *a1);
int __fastcall sub_4C9AF8(int a1);
int https_ssl_init();
int __fastcall https_ssl_uninit(int a1);
int __fastcall https_sever_init(int a1, uint16_t a2, int a3);
int __fastcall sub_4CA3F0(int a1);
int __fastcall https_ssl_read(int a1);
int __fastcall https_ssl_write(int a1);
int __fastcall https_do_accept_recv(int a1);
int __fastcall sub_4CA7E0(int a1);
int __fastcall sub_4CA86C(int a1);
int __fastcall sub_4CA910(int a1);
int __fastcall sub_4CA9AC(int a1);
int __fastcall sub_4CAA38(int a1);
int __fastcall sub_4CAACC(int a1);
int __fastcall sub_4CAB60(int a1);
int __fastcall sub_4CABA8(int a1);
int __fastcall sub_4CAC78(int a1);
int __fastcall sub_4CADF0(int a1);
_DWORD *__fastcall iptv_token_create(const char *a1);
void __fastcall iptv_token_del(void *a1);
void **iptv_token_init_and_check_timeout();
char *iptv_get_new_token();
int __fastcall sub_4CB92C(int a1);
const char *__fastcall sub_4CBACC(const char *a1);
int __fastcall iptv_get_channel_list(int a1, int a2);
int __fastcall sub_4CC0F4(int a1);
int __fastcall sub_4CC344(int a1);
int sub_4CC640();
int printf(char *format, ...);
int start_qos_iface();
int J_atoi();
void jhl_wan_route_id();
void exit(int status);
int jhl_stop_redial();
int ping_wan_gw_stop();
int kill_by_pid_name();
int qos_default_low_limit_check();
int ipv6wan_start();
int jhl_langet();
int SSL_get_error();
int ip_get_tbm();
in_addr_t jhl_parm_get_def();
in_addr_t inet_addr(const char *cp);
int user_get_ddate();
int start_wan_gw_ping_check();
int start_rzgl();
void read_tg_html_from_usb();
void __fastcall memmove(void *dest, void *src, int n);
int del_timer();
int get_ifname_by_id();
int stop_mqtt_ai();
int ct_default_low_limit_check();
int stop_parm_auto_send_email();
int pppoe_br_user_mod();
int lan_showname_guess();
int f_size();
int usblogd_check_restart();
char *jhl_vpnget();
char *strstr(const char *haystack, const char *needle);
int f_write_string();
int restart_sfe();
int ai_hi_mem_json_get();
size_t dns_more_dnstype_get_json();
size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
int MD5Update();
int get_iplist_str();
void jhl_get_wangw();
void sync(void);
int nvram_set();
int get_all_disk_info();
int cJSON_GetObjectItem();
int jhl_nvget();
int SSL_write();
int str_to_utf8();
int jianhl_order_opt_fun();
char *wys_sj_module_del();
char *fgets(char *s, int n, FILE *stream);
int restart_wan_auto_conn();
int cJSON_IsNumber();
int close(int fd);
int httpd_check_sys_freemem2();
int pppoe_srv_start();
char *check_usb_state();
char *strchr(const char *s, int c);
int user_mod();
int check_ip_is_lanip();
int set_dns_more_dnstype_item_to_kernel();
int arp_st_disonline();
void *MacToStr();
void *calloc(size_t nmemb, size_t size);
int ping_wan_gw_get_state();
int read_log_data();
int strnicmp();
int wys_get_dns();
int strncmp(const char *s1, const char *s2, size_t n);
int restart_shenji_ctrl();
int str_to_gb2312();
int SSL_free();
int set_port_mode();
uint16_t htons(uint16_t hostshort);
char *upgrade_prepare();
char *strrchr(const char *s, int c);
int stat(const char *file, struct stat *buf);
uint16_t ntohs(uint16_t netshort);
int dns_url_del();
int jhl_str_to_utf8_max();
int GetJSONItemValueAsString();
int atol(const char *nptr);
char *strerror(int errnum);
void __fastcall free(void *ptr);
int jhl_ddns_del();
int start_mqtt_ai();
int jhl_vpnclient_route_id();
int SSL_set_fd();
int shenji_get_dev_info();
int cJSON_AddItemToArray();
int aes_set_key();
int MD5Final();
int jhl_start_3g();
int sq_file_get_state_new();
int cJSON_Delete();
int dns_url_get();
int flash_erase_mtd();
int fputs(const char *s, FILE *stream);
int split_string2();
int check_ifname_is_wan();
int SSL_CTX_set_verify();
int nvram_getdef_int();
int jiffies_get();
int arp_st_del();
int ip_get_duolan();
int unlink(const char *name);
int radius_server_start();
int wan_lan_confilict();
float jhl_get_3g_iface();
int get_uptime2();
int sq_file_get_ssid_en();
int jhl_string_encoding_json();
int nvparm_del_str_too_loog();
int jhl_vpndtime();
int dns_more_dnstype_item_buf();
int start_proxy_auto_send_email();
int jhl_stop_wan();
int start_wan_dns_check();
int IpaddrToStr2();
int dns_more_hitype_add();
int ApiFindWhiteIp();
int fflush(FILE *stream);
int dup2(int fd, int fd2);
int user_num_get();
int cJSON_AddNumberToObject();
float nvram_commit();
char *strpbrk(const char *s, const char *accept);
int params_sort();
char *find_old_sq_exist();
char *inet_ntoa(struct in_addr in);
int SSL_CTX_set_default_passwd_cb_userdata();
int fprintf(void *stream, char *format, ...);
int wan_proto_check();
__pid_t get_lans_num();
__pid_t waitpid(__pid_t pid, int *stat_loc, int options);
int __gtsf2();
void jhl_ddns_add();
void __fastcall memcpy(void *dest, void *src, int n);
int nvram_set_int();
int custom_tb_version();
int dns_acc_add();
int cJSON_Parse();
int httpd_check_sys_freemem();
int split_string();
int cJSON_SetValuestring();
int url_member_add();
int usleep(__useconds_t useconds);
void srand(unsigned int seed);
int cgi_signal_to_kernel();
int start_igmp_snooping();
int set_dns_more_dnswan_to_kernel();
int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
__pid_t fork(void);
int rand(void);
int get_ip_from_str();
int cJSON_GetIntvalue();
char *cJSON_PrintPreallocated();
char *asctime(const struct tm *tp);
ssize_t recv(int fd, void *buf, size_t n, int flags);
int SSL_get_version();
int get_log_data_in_sometime();
int tolower(int c);
time_t mktime(struct tm *tp);
struct tm *schedule_ipsec();
struct tm *localtime(const time_t *timer);
int get_json_data();
int httpd_wget();
int uv_inet_pton4();
int jhl_get_wanip();
int uv_inet_pton6();
int mr_set();
int user_del();
int sq_file_get_state();
int cJSON_GetArraySize();
int Ip6ToStr();
int jhl_nv_get_only_def();
int user_get_file_csv();
int closedir(DIR *dirp);
int sq_file_get_max_wan_no4g();
int custom_device_name();
int arp_st_get();
int macuser_conf_set();
int cJSON_DetachItemFromObject();
int cJSON_AddArrayToObject();
char *lanip_change();
char *strsep(char **stringp, const char *delim);
int stpcpy();
int url_member_del();
int SSL_library_init();
void *dns_more_dnstype_item_del();
void *memset(void *s, int c, size_t n);
int stop_proxy_auto_send_email();
int nvparm_get_str();
int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
int listen(int fd, int n);
int set_xwgl_ref_to_kernel();
int re_boot();
int f_read();
int start_wan_http_check();
int __fastcall execvp(char *file, char *argv[]);
int SSL_read();
int read_sysmessage_file();
int jhl_get_wan_name();
int mtd_open();
int https_post();
int SSL_get_current_cipher();
int url_group_add();
int ai_aes_cbc_decrypt();
int killall_arg();
int ApiDelWhiteMac();
int SSL_CTX_ctrl();
int getMD5Str();
int nvparm_find_str_too_loog();
int SSL_new();
int pppoe_br_user_del();
int qos_low_limit_check();
int get_usb_mount_dir();
int url_group_get();
int IpToStr();
int _eval_nowait_file();
int wys_mkstemp();
int __ltsf2();
int dns_redirect_write_hosts();
int ipv6lan_set_all();
struct hostent *StrToIp();
struct hostent *gethostbyname(const char *name);
int start_user_deltime();
int SSL_CTX_use_certificate_file();
int nvram_set_zipfile();
int SSL_shutdown();
int pidof();
int stop_wan_gw_ping_check();
int dns_more_dns_gid_member_get();
int get_lang_type();
int user_lock();
int jhl_parm_get();
int dhcp6s_restart();
void set_dns_more_dnswan_rule_to_kernel();
void perror(const char *s);
int reset_wtclient_rzgl_parm();
int StrToMac();
int jhl_stop_pptpd_srv();
int sq_file_get_jb();
int sq_file_get_max_wan();
int set_qos_to_kernel();
int create_dir();
int pppoe_group_get_username();
int cJSON_PrintUnformatted();
int get_memory();
int gbk_to_utf8();
int log_del_file_all();
char *ERR_free_strings();
char *__fastcall strcpy(char *dest, char *src);
int dns_more_dnstype_buf();
int get_realwans_data();
int random(void);
int _xstart();
ssize_t jhl_start_redial();
ssize_t read(int fd, void *buf, size_t nbytes);
int jhl_nv_is_def();
int start_parm_auto_send_email();
int wayos_file_upgrade();
int jhl_system();
int dns_more_dnstype_item_add();
int jhl_start_firewall();
int __fastcall system(char *command);
int create_dir2();
double jhl_get_dns();
int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
ssize_t __fastcall SSL_accept(int fd, int level, int optname, const void *optval, socklen_t optlen, socklen_t a6);
ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
ssize_t ipv6_router_set_to_server(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
int mkfs_disk_device();
int nvparm_del_str_too_too_long();
int arp_st_addall();
int get_duolan_ip();
int flash_sq_file_set();
char *jhl_check_and_tran_unicode2312();
char *__fastcall strcat(char *dest, char *src);
int dns_url_add();
int SSL_CTX_new();
int nvram_unset();
int J_ato10();
int jhl_check_wanup();
int set_usb_acc_conf();
int url_gid_member_get();
int _eval_nowait();
int user_namedown_set();
int pppoe_br_user_conf();
float get_md5_str();
int cJSON_GetArrayItem();
int restart_third_rzgl();
int ipv6in4_start();
int ipv6in4_stop();
int start_user_jsmod();
int jhl_stop_3g();
int wyaos_z_wan_out_set_macs();
int dns_more_dnswan_add();
int judge_ipaddr_file_valid();
int GenerateStr();
int set_systime();
int lan_iface_foreach();
int ApiFindWhiteMac();
int sq_file_get_id();
int jhl_get_wanstatus();
int user_add();
int iptv_channel_wan_set();
int atoi(const char *nptr);
int pppoe_group_del_kernel();
int GetJSONItemValueAsIntDef();
int jhl_nv_get_def();
int lan_name_get2();
size_t sq2_file_get_auth_errinfo();
size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
int start_dhcp_server();
int SSL_CTX_load_verify_locations();
struct tm *pppoe_br_user_get_file();
struct tm *gmtime(const time_t *timer);
DIR *opendir(const char *name);
void ct_low_limit_check();
void syslog(int pri, const char *fmt, ...);
int TLSv1_2_server_method();
int del_log_data();
int sq2_file_send_sq_num();
size_t cJSON_CreateArray();
size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
int puts(const char *s);
int start_version_upgrade_auto();
int strlcpy();
FILE *stop_wan_http_check();
FILE *fopen(const char *filename, const char *modes);
int base64_encode();
int url_memberfile_buf();
uint32_t f_exists();
uint32_t ntohl(uint32_t netlong);
int aes_aes();
int jhl_get_wan_proto();
int get_random_seed();
int load_module();
int f_read_json();
int mkdir(const char *path, __mode_t mode);
int cJSON_CodeString();
int SSL_get_ciphers();
int get_uptime_sys();
int get_lan_ifnames();
int IpaddrToStr();
int wys_get_mac_by_ipaddr();
uint32_t dual_lan_get_lan_showname();
uint32_t htonl(uint32_t hostlong);
int snprintf(char *str, int size, char *format, ...);
int start_module_upgrade_auto();
int power_off();
int fcntl(int fd, int cmd, ...);
int access(const char *name, int type);
int SSL_CTX_use_PrivateKey_file();
int mcl_bytearray_printf();
int set_host_domain_name();
int ApiAddWhiteMac();
int SSL_CTX_set_cipher_list();
int strdb_del();
int __get_cpu_uptime();
int cJSON_CreateString();
double get_devmg_lan_id();
int wan_iface_foreach();
int stop_wan_dns_check();
int dns_more_dnstype_get();
int nvram_match_def();
int nvram_reset_def();
int _eval();
int flash_get_sec_status();
ssize_t f_read_string();
ssize_t write(int fd, const void *buf, size_t n);
int duolan_do();
int nvparm_del_str();
int strcasecmp(const char *s1, const char *s2);
int start_auto_reboot();
int common_qq_val_edt();
int sq_file_get_device_id();
int url_member_delall();
int J_atoi_ull();
int socket(int domain, int type, int protocol);
int cJSON_AddStringToObject();
int mr_set_by_jh_en();
int mng_client_restart();
int pipe(int pipedes[2]);
int duolan_undo();
int jhl_hardversion_get();
int url_member_get();
int add_timer();
int ping_wan_gw_start();
int MD5Init();
int shared_get_sdwans_data();
int upgrade_after();
int wys_sj_module_add();
time_t sk_num();
time_t time(time_t *timer);
int fseek(FILE *stream, int off, int whence);
int init_timer();
int SHA1();
int remove(const char *filename);
int auth_write_usblog();
int memcmp(const void *s1, const void *s2, size_t n);
int wt_client_restart();
int fclose(FILE *stream);
void init_timers_cpu();
void srandom(unsigned int seed);
char *run_timers();
char *strdup(const char *s);
int SSL_CTX_free();
const char *write_tg_html_to_usb();
const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
int ioctl(int fd, unsigned int request, ...);
int set_rule_to_kernel();
int get_log_data_in_time();
int cJSON_free();
int common_get_token();
int SSL_load_error_strings();
int __GET_LANG_TEXT();
int shared_get_sd_wans_data();
ssize_t __fastcall ApiAddWhiteIp(int a1, int a2, int a3, int a4, struct sockaddr *a5, socklen_t *a6);
ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
ssize_t jhl_parm_set(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
int crypt_sha1();
int dns_srv_start();
int arp_st_delall();
int ApiDelWhiteIp();
int jhl_iface_link_up_check();
int jhl_vpnclient_stop();
int vpn_user_del();
int jingx_do();
int killall_tk();
int start_dhcp_server_just_check();
int inet_aton(const char *cp, struct in_addr *inp);
__off_t lseek(int fd, __off_t offset, int whence);
int set_dns_more_hitype_to_kernel();
int miitool_data_buf();
int kill(__pid_t pid, int sig);
int get_upfile_version_flag();
unsigned int user_ipdown_set();
unsigned int strtoul(const char *nptr, char **endptr, int base);
int restart_wys_billing();
int jhl_setwanxx();
int cJSON_IsArray();
int reset_billing_rzgl_parm();
int jhl_set_wan_name();
int pppoe_br_user_add();
int open(const char *file, int oflag, ...);
int user_delall();
int sprintf(char *str, char *format, ...);
int get_time_group();
int read_ovpn_file();
unsigned int dns_more_dnstype_item_delall();
unsigned int sleep(unsigned int seconds);
int arp_st_add();
int StrToIpaddr();
int sysinfo(struct sysinfo *info);
int SSL_CTX_check_private_key();
__sighandler_t set_dns_more_dnstype_to_kernel();
__sighandler_t signal(int sig, __sighandler_t handler);
int mr_parm_default();
int connect(int fd, const struct sockaddr *addr, socklen_t len);
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
int sscanf(char *format, ...);
int bind(int fd, const struct sockaddr *addr, socklen_t len);
size_t cJSON_CreateObject();
size_t strlen(const char *s);
int set_pppoe_group_to_kernel();
int stop_dhcp_server_just_check();
int cJSON_IsString();
int J_atohx16();
int SSL_CIPHER_get_version();
int strtol(const char *nptr, char **endptr, int base);
int pppoe_br_user_delall();
int dns_more_hitype_delall();
int cJSON_IsObject();
int set_link_status_by_id();
int is_domain();
int str2mac();
int GET_MENU_JS_TEXT();
int get_link_status_by_id();
int SSL_CIPHER_get_name();
int jhl_start_l2tpd_srv();
int vpn_user_add();
int f_write();
int ERR_print_errors_fp();
int get_json_data_safe2();
int rename(const char *old, const char *new);
int nvparm_find_str();
int jhl_stop_l2tpd_srv();
int start_arp_sys();
int jhl_ctreate_dmresolv();
int sys_runinfo_get();
int __fastcall eval_nowait_tty(int a1, int a2, int a3, int a4, socklen_t *a5);
int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
int get_sn(int fd, int level, int optname, void *optval, socklen_t *optlen);
int dns_acc_del();
int strdb_add();
int base64_decode();
int jhl_mr_set_dns();
int jiffies_init();
int prepare_upgrade();
int *nvram_get();
int *__errno_location(void);
int nvram_get_int();
int get_dhcp_left_num();
int get_netmask_wei();
int jhl_start_pptpd_srv();
int mod_timer();
int dns_more_hitype_del();
void *url_group_del();
void *malloc(size_t size);
ssize_t send(int fd, const void *buf, size_t n, int flags);
int dual_getIfMac();
int strcmp(const char *s1, const char *s2);
int check_ip_is_wanip();
int cJSON_NumberToString();
int jhl_parm_commit();
int shared_get_sd_vpns_data();
struct dirent *killall();
struct dirent *readdir(DIR *dirp);
int term_proc();
// int __fastcall __register_frame_info(_DWORD, _DWORD); weak
// int __fastcall __deregister_frame_info(_DWORD); weak
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// struct dirent *readdir(DIR *dirp);
// int __fastcall killall(_DWORD, _DWORD); weak
// int __fastcall shared_get_sd_vpns_data(_DWORD, _DWORD); weak
// int __fastcall jhl_parm_commit(_DWORD); weak
// int __fastcall cJSON_NumberToString(_DWORD); weak
// int __fastcall check_ip_is_wanip(_DWORD); weak
// int strcmp(const char *s1, const char *s2);
// int __fastcall dual_getIfMac(_DWORD, _DWORD); weak
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// void *malloc(size_t size);
// int __fastcall url_group_del(_DWORD); weak
// int __fastcall dns_more_hitype_del(_DWORD, _DWORD); weak
// int __fastcall mod_timer(_DWORD, _DWORD); weak
// int jhl_start_pptpd_srv(void); weak
// int __fastcall get_netmask_wei(_DWORD); weak
// int get_dhcp_left_num(void); weak
// int __fastcall nvram_get_int(_DWORD); weak
// int *_errno_location(void);
// int __fastcall nvram_get(_DWORD); weak
// int prepare_upgrade(void); weak
// int jiffies_init(void); weak
// int __fastcall jhl_mr_set_dns(_DWORD); weak
// int __fastcall base64_decode(_DWORD, _DWORD, _DWORD); weak
// int __fastcall strdb_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall dns_acc_del(_DWORD); weak
// int get_sn(void); weak
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// int __fastcall eval_nowait_tty(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall sys_runinfo_get(_DWORD); weak
// int jhl_ctreate_dmresolv(void); weak
// int start_arp_sys(void); weak
// int jhl_stop_l2tpd_srv(void); weak
// int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int rename(const char *old, const char *new);
// int __fastcall get_json_data_safe2(_DWORD, _DWORD); weak
// int __fastcall ERR_print_errors_fp(_DWORD); weak
// int __fastcall f_write(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall vpn_user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int jhl_start_l2tpd_srv(void); weak
// int __fastcall SSL_CIPHER_get_name(_DWORD); weak
// int __fastcall get_link_status_by_id(_DWORD, _DWORD); weak
// int __fastcall GET_MENU_JS_TEXT(_DWORD, _DWORD); weak
// int __fastcall str2mac(_DWORD, _DWORD); weak
// int __fastcall is_domain(_DWORD); weak
// int __fastcall set_link_status_by_id(_DWORD, _DWORD); weak
// int __fastcall cJSON_IsObject(_DWORD); weak
// int dns_more_hitype_delall(void); weak
// int pppoe_br_user_delall(void); weak
// int strtol(const char *nptr, char **endptr, int base);
// int __fastcall SSL_CIPHER_get_version(_DWORD); weak
// int __fastcall J_atohx16(_DWORD); weak
// int __fastcall cJSON_IsString(_DWORD); weak
// int stop_dhcp_server_just_check(void); weak
// int __fastcall set_pppoe_group_to_kernel(_DWORD, _DWORD, _DWORD); weak
// size_t strlen(const char *s);
// int cJSON_CreateObject(void); weak
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int sscanf(char *format, ...);
// int poll(struct pollfd *fds, nfds_t nfds, int timeout);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int __fastcall mr_parm_default(_DWORD, _DWORD, _DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __fastcall set_dns_more_dnstype_to_kernel(_DWORD, _DWORD); weak
// int __fastcall SSL_CTX_check_private_key(_DWORD); weak
// int sysinfo(struct sysinfo *info);
// int __fastcall StrToIpaddr(_DWORD, _DWORD); weak
// int __fastcall arp_st_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// unsigned int sleep(unsigned int seconds);
// int __fastcall dns_more_dnstype_item_delall(_DWORD); weak
// int __fastcall read_ovpn_file(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_time_group(_DWORD, _DWORD, _DWORD); weak
// int sprintf(char *str, char *format, ...);
// int __fastcall user_delall(_DWORD, _DWORD); weak
// int open(const char *file, int oflag, ...);
// int __fastcall pppoe_br_user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall jhl_set_wan_name(_DWORD, _DWORD); weak
// int __fastcall reset_billing_rzgl_parm(_DWORD); weak
// int __fastcall cJSON_IsArray(_DWORD); weak
// int jhl_setwanxx(void); weak
// int restart_wys_billing(void); weak
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// int __fastcall user_ipdown_set(_DWORD, _DWORD); weak
// int __fastcall get_upfile_version_flag(_DWORD); weak
// int kill(__pid_t pid, int sig);
// int __fastcall miitool_data_buf(_DWORD, _DWORD); weak
// int __fastcall set_dns_more_hitype_to_kernel(_DWORD, _DWORD); weak
// __off_t lseek(int fd, __off_t offset, int whence);
// int inet_aton(const char *cp, struct in_addr *inp);
// int start_dhcp_server_just_check(void); weak
// int __fastcall killall_tk(_DWORD); weak
// int __fastcall jingx_do(_DWORD, _DWORD); weak
// int __fastcall vpn_user_del(_DWORD, _DWORD); weak
// int __fastcall jhl_vpnclient_stop(_DWORD); weak
// int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD); weak
// int __fastcall ApiDelWhiteIp(_DWORD); weak
// int arp_st_delall(void); weak
// int dns_srv_start(void); weak
// int __fastcall crypt_sha1(_DWORD, _DWORD, _DWORD); weak
// int __fastcall jhl_parm_set(_DWORD, _DWORD); weak
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int __fastcall ApiAddWhiteIp(_DWORD); weak
// int __fastcall shared_get_sd_wans_data(_DWORD, _DWORD); weak
// int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD); weak
// int SSL_load_error_strings(void); weak
// int common_get_token(void); weak
// int __fastcall cJSON_free(_DWORD); weak
// int __fastcall get_log_data_in_time(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall set_rule_to_kernel(_DWORD, _DWORD, _DWORD); weak
// int ioctl(int fd, unsigned int request, ...);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int __fastcall write_tg_html_to_usb(_DWORD, _DWORD, _DWORD); weak
// int SSL_CTX_free(void); weak
// char *strdup(const char *s);
// int run_timers(void); weak
// void srandom(unsigned int seed);
// int init_timers_cpu(void); weak
// int fclose(FILE *stream);
// int __fastcall wt_client_restart(_DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int __fastcall auth_write_usblog(_DWORD, _DWORD, _DWORD); weak
// int remove(const char *filename);
// int __fastcall SHA1(_DWORD, _DWORD, _DWORD); weak
// int __fastcall init_timer(_DWORD); weak
// int fseek(FILE *stream, int off, int whence);
// time_t time(time_t *timer);
// int __fastcall sk_num(_DWORD); weak
// int wys_sj_module_add(void); weak
// int __fastcall upgrade_after(_DWORD); weak
// int __fastcall shared_get_sdwans_data(_DWORD, _DWORD); weak
// int __fastcall MD5Init(_DWORD); weak
// int __fastcall ping_wan_gw_start(_DWORD, _DWORD); weak
// int __fastcall add_timer(_DWORD); weak
// int __fastcall url_member_get(_DWORD, _DWORD); weak
// int jhl_hardversion_get(void); weak
// int duolan_undo(void); weak
// int pipe(int pipedes[2]);
// int __fastcall mng_client_restart(_DWORD); weak
// int __fastcall mr_set_by_jh_en(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall cJSON_AddStringToObject(_DWORD, _DWORD, _DWORD); weak
// int socket(int domain, int type, int protocol);
// __int64 __fastcall J_atoi_ull(_DWORD); weak
// int url_member_delall(void); weak
// int sq_file_get_device_id(void); weak
// int __fastcall common_qq_val_edt(_DWORD, _DWORD); weak
// int __fastcall start_auto_reboot(_DWORD); weak
// int strcasecmp(const char *s1, const char *s2);
// int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall duolan_do(_DWORD); weak
// ssize_t write(int fd, const void *buf, size_t n);
// int __fastcall f_read_string(_DWORD, _DWORD, _DWORD); weak
// int flash_get_sec_status(void); weak
// int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall nvram_reset_def(_DWORD); weak
// int __fastcall nvram_match_def(_DWORD, _DWORD); weak
// int __fastcall dns_more_dnstype_get(_DWORD, _DWORD); weak
// int stop_wan_dns_check(void); weak
// int __fastcall wan_iface_foreach(_DWORD, _DWORD); weak
// int get_devmg_lan_id(void); weak
// int __fastcall cJSON_CreateString(_DWORD); weak
// int __fastcall _get_cpu_uptime(_DWORD); weak
// int __fastcall strdb_del(_DWORD); weak
// int __fastcall SSL_CTX_set_cipher_list(_DWORD, _DWORD); weak
// int __fastcall ApiAddWhiteMac(_DWORD); weak
// int set_host_domain_name(void); weak
// int mcl_bytearray_printf(_DWORD, const char *, ...); weak
// int __fastcall SSL_CTX_use_PrivateKey_file(_DWORD, _DWORD, _DWORD); weak
// int access(const char *name, int type);
// int fcntl(int fd, int cmd, ...);
// int power_off(void); weak
// int start_module_upgrade_auto(void); weak
// int snprintf(char *str, int size, char *format, ...);
// uint32_t htonl(uint32_t hostlong);
// int __fastcall dual_lan_get_lan_showname(_DWORD, _DWORD); weak
// int __fastcall wys_get_mac_by_ipaddr(_DWORD, _DWORD); weak
// int __fastcall IpaddrToStr(_DWORD, _DWORD); weak
// int __fastcall get_lan_ifnames(_DWORD, _DWORD); weak
// int __fastcall get_uptime_sys(_DWORD); weak
// int __fastcall SSL_get_ciphers(_DWORD); weak
// int __fastcall cJSON_CodeString(_DWORD, _DWORD); weak
// int mkdir(const char *path, __mode_t mode);
// int __fastcall f_read_json(_DWORD); weak
// int __fastcall load_module(_DWORD); weak
// int __fastcall get_random_seed(_DWORD, _DWORD, _DWORD); weak
// int __fastcall jhl_get_wan_proto(_DWORD); weak
// int __fastcall aes_aes(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// uint32_t ntohl(uint32_t netlong);
// int __fastcall f_exists(_DWORD); weak
// int __fastcall url_memberfile_buf(_DWORD, _DWORD); weak
// int __fastcall base64_encode(_DWORD, _DWORD, _DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// int stop_wan_http_check(void); weak
// int __fastcall strlcpy(_DWORD, _DWORD, _DWORD); weak
// int start_version_upgrade_auto(void); weak
// int puts(const char *s);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int cJSON_CreateArray(void); weak
// int __fastcall sq2_file_send_sq_num(_DWORD, _DWORD); weak
// int __fastcall del_log_data(_DWORD); weak
// int TLSv1_2_server_method(void); weak
// void syslog(int pri, const char *fmt, ...);
// int __fastcall ct_low_limit_check(_DWORD); weak
// DIR *opendir(const char *name);
// struct tm *gmtime(const time_t *timer);
// int __fastcall pppoe_br_user_get_file(_DWORD, _DWORD); weak
// int __fastcall SSL_CTX_load_verify_locations(_DWORD, _DWORD, _DWORD); weak
// int start_dhcp_server(void); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int __fastcall sq2_file_get_auth_errinfo(_DWORD, _DWORD); weak
// int __fastcall lan_name_get2(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall jhl_nv_get_def(_DWORD); weak
// int __fastcall GetJSONItemValueAsIntDef(_DWORD, _DWORD, _DWORD); weak
// int __fastcall pppoe_group_del_kernel(_DWORD); weak
// int atoi(const char *nptr);
// int __fastcall iptv_channel_wan_set(_DWORD, _DWORD); weak
// int __fastcall user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall jhl_get_wanstatus(_DWORD); weak
// int __fastcall sq_file_get_id(_DWORD, _DWORD); weak
// int ApiFindWhiteMac(void); weak
// int __fastcall lan_iface_foreach(_DWORD, _DWORD); weak
// int __fastcall set_systime(_DWORD); weak
// int GenerateStr(void); weak
// int __fastcall judge_ipaddr_file_valid(_DWORD); weak
// int __fastcall dns_more_dnswan_add(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall wyaos_z_wan_out_set_macs(_DWORD); weak
// int __fastcall jhl_stop_3g(_DWORD); weak
// int start_user_jsmod(void); weak
// int __fastcall ipv6in4_stop(_DWORD); weak
// int __fastcall ipv6in4_start(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int restart_third_rzgl(void); weak
// int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD); weak
// int __fastcall get_md5_str(_DWORD, _DWORD, _DWORD); weak
// int __fastcall pppoe_br_user_conf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall user_namedown_set(_DWORD, _DWORD); weak
// int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall url_gid_member_get(_DWORD, _DWORD, _DWORD); weak
// int set_usb_acc_conf(void); weak
// int __fastcall jhl_check_wanup(_DWORD); weak
// int __fastcall J_ato10(_DWORD); weak
// int __fastcall nvram_unset(_DWORD); weak
// int __fastcall SSL_CTX_new(_DWORD); weak
// int __fastcall dns_url_add(_DWORD, _DWORD, _DWORD); weak
// char *__fastcall strcat(char *dest, char *src);
// int __fastcall jhl_check_and_tran_unicode2312(_DWORD, _DWORD); weak
// int __fastcall flash_sq_file_set(_DWORD, _DWORD); weak
// int __fastcall get_duolan_ip(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall arp_st_addall(_DWORD, _DWORD); weak
// int __fastcall nvparm_del_str_too_too_long(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall mkfs_disk_device(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall ipv6_router_set_to_server(_DWORD, _DWORD); weak
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int __fastcall SSL_accept(_DWORD); weak
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int __fastcall jhl_get_dns(_DWORD); weak
// int __fastcall create_dir2(_DWORD); weak
// int __fastcall system(char *command);
// int jhl_start_firewall(void); weak
// int __fastcall dns_more_dnstype_item_add(_DWORD, _DWORD); weak
// int __fastcall jhl_system(_DWORD); weak
// int __fastcall wayos_file_upgrade(_DWORD, _DWORD); weak
// int start_parm_auto_send_email(void); weak
// int __fastcall jhl_nv_is_def(_DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int __fastcall jhl_start_redial(_DWORD); weak
// int __fastcall xstart(_DWORD, _DWORD); weak
// int random(void);
// int __fastcall get_realwans_data(_DWORD, _DWORD, _DWORD); weak
// int __fastcall dns_more_dnstype_buf(_DWORD, _DWORD); weak
// char *__fastcall strcpy(char *dest, char *src);
// int ERR_free_strings(void); weak
// int __fastcall log_del_file_all(_DWORD); weak
// int __fastcall gbk_to_utf8(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_memory(_DWORD); weak
// int __fastcall cJSON_PrintUnformatted(_DWORD); weak
// int __fastcall pppoe_group_get_username(_DWORD); weak
// int __fastcall create_dir(_DWORD); weak
// int __fastcall set_qos_to_kernel(_DWORD, _DWORD, _DWORD); weak
// int sq_file_get_max_wan(void); weak
// int sq_file_get_jb(void); weak
// int jhl_stop_pptpd_srv(void); weak
// int __fastcall StrToMac(_DWORD, _DWORD); weak
// int __fastcall reset_wtclient_rzgl_parm(_DWORD); weak
// void perror(const char *s);
// int __fastcall set_dns_more_dnswan_rule_to_kernel(_DWORD, _DWORD); weak
// int dhcp6s_restart(void); weak
// int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD); weak
// int __fastcall user_lock(_DWORD, _DWORD, _DWORD); weak
// int __fastcall get_lang_type(_DWORD); weak
// int __fastcall dns_more_dns_gid_member_get(_DWORD, _DWORD, _DWORD); weak
// int stop_wan_gw_ping_check(void); weak
// int __fastcall pidof(_DWORD); weak
// int __fastcall SSL_shutdown(_DWORD); weak
// int __fastcall nvram_set_zipfile(_DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_CTX_use_certificate_file(_DWORD, _DWORD, _DWORD); weak
// int start_user_deltime(void); weak
// struct hostent *gethostbyname(const char *name);
// int __fastcall StrToIp(_DWORD); weak
// int ipv6lan_set_all(void); weak
// int dns_redirect_write_hosts(void); weak
// int __fastcall _ltsf2(_DWORD, _DWORD); weak
// int __fastcall wys_mkstemp(_DWORD); weak
// int __fastcall eval_nowait_file(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall IpToStr(_DWORD, _DWORD); weak
// int __fastcall url_group_get(_DWORD, _DWORD); weak
// int __fastcall get_usb_mount_dir(_DWORD, _DWORD); weak
// int __fastcall qos_low_limit_check(_DWORD); weak
// int pppoe_br_user_del(void); weak
// int __fastcall SSL_new(_DWORD); weak
// int __fastcall nvparm_find_str_too_loog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall getMD5Str(_DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_CTX_ctrl(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall ApiDelWhiteMac(_DWORD); weak
// int __fastcall killall_arg(_DWORD, _DWORD, _DWORD); weak
// int __fastcall ai_aes_cbc_decrypt(_DWORD, _DWORD, _DWORD); weak
// int __fastcall url_group_add(_DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_get_current_cipher(_DWORD); weak
// int __fastcall https_post(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall mtd_open(_DWORD, _DWORD); weak
// int __fastcall jhl_get_wan_name(_DWORD); weak
// int __fastcall read_sysmessage_file(_DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_read(_DWORD); weak
// int __fastcall execvp(char *file, char *argv[]);
// int start_wan_http_check(void); weak
// int __fastcall f_read(_DWORD, _DWORD, _DWORD); weak
// int re_boot(void); weak
// int __fastcall set_xwgl_ref_to_kernel(_DWORD, _DWORD); weak
// int listen(int fd, int n);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int stop_proxy_auto_send_email(void); weak
// void *memset(void *s, int c, size_t n);
// int __fastcall dns_more_dnstype_item_del(_DWORD, _DWORD); weak
// int SSL_library_init(void); weak
// int __fastcall url_member_del(_DWORD); weak
// int __fastcall stpcpy(_DWORD, _DWORD); weak
// char *strsep(char **stringp, const char *delim);
// int lanip_change(void); weak
// int __fastcall cJSON_AddArrayToObject(_DWORD, _DWORD); weak
// int macuser_conf_set(void); weak
// int __fastcall arp_st_get(_DWORD, _DWORD); weak
// int custom_device_name(void); weak
// int sq_file_get_max_wan_no4g(void); weak
// int closedir(DIR *dirp);
// int __fastcall user_get_file_csv(_DWORD, _DWORD, _DWORD); weak
// int __fastcall jhl_nv_get_only_def(_DWORD); weak
// int __fastcall Ip6ToStr(_DWORD, _DWORD); weak
// int __fastcall cJSON_GetArraySize(_DWORD); weak
// int sq_file_get_state(void); weak
// int __fastcall user_del(_DWORD); weak
// int __fastcall mr_set(_DWORD); weak
// int __fastcall uv_inet_pton6(_DWORD, _DWORD); weak
// int __fastcall jhl_get_wanip(_DWORD); weak
// int __fastcall uv_inet_pton4(_DWORD, _DWORD); weak
// int __fastcall httpd_wget(_DWORD, _DWORD); weak
// int __fastcall get_json_data(_DWORD); weak
// struct tm *localtime(const time_t *timer);
// int __fastcall schedule_ipsec(_DWORD, _DWORD); weak
// time_t mktime(struct tm *tp);
// int tolower(int c);
// int __fastcall get_log_data_in_sometime(_DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_get_version(_DWORD); weak
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// char *asctime(const struct tm *tp);
// int __fastcall cJSON_PrintPreallocated(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall cJSON_GetIntvalue(_DWORD); weak
// int __fastcall get_ip_from_str(_DWORD); weak
// int rand(void);
// __pid_t fork(void);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int __fastcall set_dns_more_dnswan_to_kernel(_DWORD, _DWORD); weak
// int start_igmp_snooping(void); weak
// int __fastcall cgi_signal_to_kernel(_DWORD, _DWORD, _DWORD); weak
// void srand(unsigned int seed);
// int usleep(__useconds_t useconds);
// int __fastcall url_member_add(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int httpd_check_sys_freemem(void); weak
// int __fastcall cJSON_Parse(_DWORD); weak
// int __fastcall dns_acc_add(_DWORD); weak
// int custom_tb_version(void); weak
// int __fastcall nvram_set_int(_DWORD, _DWORD); weak
// void __fastcall memcpy(void *dest, void *src, int n);
// int __fastcall jhl_ddns_add(_DWORD, _DWORD); weak
// int __fastcall _gtsf2(_DWORD, _DWORD); weak
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int get_lans_num(void); weak
// int __fastcall wan_proto_check(_DWORD); weak
// int fprintf(void *stream, char *format, ...);
// int __fastcall SSL_CTX_set_default_passwd_cb_userdata(_DWORD, _DWORD); weak
// char *inet_ntoa(struct in_addr in);
// int __fastcall find_old_sq_exist(_DWORD); weak
// int __fastcall params_sort(_DWORD, _DWORD); weak
// char *strpbrk(const char *s, const char *accept);
// int nvram_commit(void); weak
// int __fastcall cJSON_AddNumberToObject(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int user_num_get(void); weak
// int dup2(int fd, int fd2);
// int fflush(FILE *stream);
// int __fastcall ApiFindWhiteIp(_DWORD); weak
// int __fastcall dns_more_hitype_add(_DWORD, _DWORD, _DWORD); weak
// int __fastcall IpaddrToStr2(_DWORD, _DWORD); weak
// int start_wan_dns_check(void); weak
// int __fastcall jhl_stop_wan(_DWORD); weak
// int start_proxy_auto_send_email(void); weak
// int __fastcall dns_more_dnstype_item_buf(_DWORD, _DWORD, _DWORD); weak
// int __fastcall jhl_vpndtime(_DWORD); weak
// int __fastcall nvparm_del_str_too_loog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall jhl_string_encoding_json(_DWORD, _DWORD, _DWORD); weak
// int __fastcall sq_file_get_ssid_en(_DWORD, _DWORD); weak
// int __fastcall get_uptime2(_DWORD); weak
// int jhl_get_3g_iface(void); weak
// int wan_lan_confilict(void); weak
// int radius_server_start(void); weak
// int unlink(const char *name);
// int __fastcall ip_get_duolan(_DWORD, _DWORD, _DWORD); weak
// int __fastcall arp_st_del(_DWORD, _DWORD); weak
// int jiffies_get(void); weak
// int __fastcall nvram_getdef_int(_DWORD, _DWORD); weak
// int __fastcall SSL_CTX_set_verify(_DWORD, _DWORD, _DWORD); weak
// int __fastcall check_ifname_is_wan(_DWORD); weak
// int __fastcall split_string2(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int fputs(const char *s, FILE *stream);
// int __fastcall flash_erase_mtd(_DWORD, _DWORD, _DWORD); weak
// int __fastcall dns_url_get(_DWORD, _DWORD); weak
// int __fastcall cJSON_Delete(_DWORD); weak
// int __fastcall sq_file_get_state_new(_DWORD); weak
// int __fastcall jhl_start_3g(_DWORD); weak
// int __fastcall MD5Final(_DWORD); weak
// int __fastcall aes_set_key(_DWORD, _DWORD, _DWORD); weak
// int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD); weak
// int __fastcall shenji_get_dev_info(_DWORD, _DWORD); weak
// int __fastcall SSL_set_fd(_DWORD, _DWORD); weak
// int __fastcall jhl_vpnclient_route_id(_DWORD, _DWORD); weak
// int start_mqtt_ai(void); weak
// int __fastcall jhl_ddns_del(_DWORD, _DWORD); weak
// void __fastcall free(void *ptr);
// char *strerror(int errnum);
// int atol(const char *nptr);
// int __fastcall GetJSONItemValueAsString(_DWORD, _DWORD); weak
// int __fastcall jhl_str_to_utf8_max(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall dns_url_del(_DWORD); weak
// uint16_t ntohs(uint16_t netshort);
// int stat(const char *file, struct stat *buf);
// char *strrchr(const char *s, int c);
// int upgrade_prepare(void); weak
// uint16_t htons(uint16_t hostshort);
// int __fastcall set_port_mode(_DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_free(_DWORD); weak
// int __fastcall str_to_gb2312(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int restart_shenji_ctrl(void); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int wys_get_dns(void); weak
// int __fastcall strnicmp(_DWORD, _DWORD, _DWORD); weak
// int __fastcall read_log_data(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall ping_wan_gw_get_state(_DWORD); weak
// void *calloc(size_t nmemb, size_t size);
// int __fastcall MacToStr(_DWORD, _DWORD); weak
// int __fastcall arp_st_disonline(_DWORD); weak
// int __fastcall set_dns_more_dnstype_item_to_kernel(_DWORD, _DWORD); weak
// int __fastcall check_ip_is_lanip(_DWORD); weak
// int __fastcall user_mod(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// char *strchr(const char *s, int c);
// int check_usb_state(void); weak
// int __fastcall pppoe_srv_start(_DWORD); weak
// int httpd_check_sys_freemem2(void); weak
// int close(int fd);
// int __fastcall cJSON_IsNumber(_DWORD); weak
// int __fastcall restart_wan_auto_conn(_DWORD); weak
// char *fgets(char *s, int n, FILE *stream);
// int wys_sj_module_del(void); weak
// int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD); weak
// int __fastcall str_to_utf8(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_write(_DWORD); weak
// int __fastcall jhl_nvget(_DWORD, _DWORD); weak
// int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD); weak
// int __fastcall get_all_disk_info(_DWORD, _DWORD, _DWORD); weak
// int __fastcall nvram_set(_DWORD, _DWORD); weak
// void sync(void);
// int __fastcall jhl_get_wangw(_DWORD); weak
// int __fastcall get_iplist_str(_DWORD, _DWORD); weak
// int __fastcall MD5Update(_DWORD, _DWORD, _DWORD); weak
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int __fastcall dns_more_dnstype_get_json(_DWORD, _DWORD); weak
// int ai_hi_mem_json_get(void); weak
// int restart_sfe(void); weak
// int __fastcall f_write_string(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *strstr(const char *haystack, const char *needle);
// int __fastcall jhl_vpnget(_DWORD, _DWORD); weak
// int usblogd_check_restart(void); weak
// int __fastcall f_size(_DWORD); weak
// int __fastcall lan_showname_guess(_DWORD, _DWORD, _DWORD); weak
// int __fastcall pppoe_br_user_mod(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int stop_parm_auto_send_email(void); weak
// int __fastcall ct_default_low_limit_check(_DWORD, _DWORD, _DWORD); weak
// int stop_mqtt_ai(void); weak
// int __fastcall get_ifname_by_id(_DWORD, _DWORD); weak
// int __fastcall del_timer(_DWORD); weak
// void __fastcall memmove(void *dest, void *src, int n);
// int __fastcall read_tg_html_from_usb(_DWORD, _DWORD, _DWORD); weak
// int __fastcall start_rzgl(_DWORD); weak
// int start_wan_gw_ping_check(void); weak
// int __fastcall user_get_ddate(_DWORD, _DWORD, _DWORD, _DWORD); weak
// in_addr_t inet_addr(const char *cp);
// int __fastcall jhl_parm_get_def(_DWORD, _DWORD, _DWORD); weak
// int __fastcall ip_get_tbm(_DWORD, _DWORD, _DWORD); weak
// int __fastcall SSL_get_error(_DWORD, _DWORD); weak
// int __fastcall jhl_langet(_DWORD, _DWORD); weak
// int __fastcall ipv6wan_start(_DWORD, _DWORD, _DWORD); weak
// int __fastcall qos_default_low_limit_check(_DWORD); weak
// int __fastcall kill_by_pid_name(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall ping_wan_gw_stop(_DWORD); weak
// int __fastcall jhl_stop_redial(_DWORD); weak
// void exit(int status);
// int __fastcall jhl_wan_route_id(_DWORD, _DWORD); weak
// int __fastcall J_atoi(_DWORD); weak
// int __fastcall start_qos_iface(_DWORD, _DWORD); weak
// int printf(char *format, ...);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_42FE80; // weak
void *off_4CEDB4 = (void *)0x42494D; // weak
void *off_4CF0FC = &unk_646557; // weak
_UNKNOWN unk_4CF100; // weak
void *off_4CF104 = &unk_697246; // weak
_UNKNOWN unk_4CF108; // weak
char aD_0[3] = "%d "; // weak
char asc_4CF9E8[5] = "\r\n\r\n"; // weak
void *off_4CFA50 = &unk_627375; // weak
const char aUsbUpload2[] = "usb_upload2."; // idb
void *off_4CFE60 = &unk_696763; // weak
_UNKNOWN unk_4D0FF8; // weak
_UNKNOWN unk_4D15F8; // weak
_UNKNOWN unk_4D17B4; // weak
_UNKNOWN unk_5B3A22; // weak
void *off_63F984 = &unk_66666F; // weak
void *off_641118 = &unk_676663; // weak
int dword_641714 = 1886221359; // weak
__int16 word_642164 = 123; // weak
__int16 word_642A04 = 91; // weak
_UNKNOWN unk_642CE4; // weak
_UNKNOWN unk_642CF0; // weak
int dword_64331C = 1886790188; // weak
_UNKNOWN unk_64334C; // weak
_UNKNOWN unk_643358; // weak
_UNKNOWN unk_643780; // weak
void *off_643784 = &unk_687465; // weak
_UNKNOWN unk_643A20; // weak
_UNKNOWN unk_643A30; // weak
_UNKNOWN unk_643A40; // weak
_UNKNOWN unk_643A50; // weak
_UNKNOWN unk_643A5C; // weak
_UNKNOWN unk_643A6C; // weak
_UNKNOWN unk_643A80; // weak
_UNKNOWN unk_643A90; // weak
_UNKNOWN unk_643AA0; // weak
_UNKNOWN unk_643AB0; // weak
_UNKNOWN unk_643AC0; // weak
_UNKNOWN unk_643AD0; // weak
_UNKNOWN unk_643AE4; // weak
char byte_643D4C = ','; // weak
_UNKNOWN unk_6442E4; // weak
char byte_6445A0 = ']'; // weak
char aEnSSrvAddrSSrv[344] = "\"en\":\"%s\",\"srv_addr\":\"%s\",\"srv_port\":\"%s\",\"ping_addr1\":\"%s\",\"ping_addr2\":\"%s\",\"state\":\"%s\",\"online\":\"%s\",\"sdwan_iface\":%s,\"pversion\":\"%s\",\"login_count\":\"%s\",\"user_id\":\"%s\",\"user_name\":\"%s\",\"user_mobile\":\"%s\",\"scene_name\":\"%s\",\"server_mode\":\"%d\",\"client_mode\":\"%s\",\"main_mode\":\"%s\",\"sn\":\"%s\",\"server_url\":\"%s\",\"sdwan_mode\":\"%s\",\"only_sdwan\":\"%d\""; // weak
int dword_6448E0 = 1635197484; // weak
void *off_644A94 = &unk_636361; // weak
char aCode0MsgOkData[51] = "{\"code\":\"0\",\"msg\":\"ok\",\"data\":{\"current_test\":\"%s->"; // weak
_DWORD dword_6454D0[5] = { 2, 2, -1, 1, 0 }; // idb
void *off_645568 = &unk_4E4157; // weak
void *off_64556C = &unk_504653; // weak
char byte_6455B0[12] =
{
  '\xB9',
  '\xE3',
  '\xB2',
  '\xA5',
  '\xBB',
  '\xD8',
  '\xC2',
  '\xB7',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_6455BC[12] =
{
  '\xBD',
  '\xD3',
  '\xBF',
  '\xDA',
  '\xB5',
  '\xC4',
  'I',
  'P',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_645880; // weak
int dword_6459A8 = 1819042082; // weak
char *off_645A5C = "drop_broadcast"; // weak
void *off_645B94 = &unk_697270; // weak
_UNKNOWN unk_645EF8; // weak
_UNKNOWN unk_645FA8; // weak
_UNKNOWN unk_645FBC; // weak
int dword_6463E0 = 1998728285; // weak
_UNKNOWN unk_646418; // weak
_UNKNOWN unk_646444; // weak
_UNKNOWN unk_646654; // weak
_UNKNOWN unk_646720; // weak
void *off_646724 = &unk_63616D; // weak
char aIIpaddrMMacadd[41] = "I:IPaddr,M:MACaddr,d:devname,n:name\r\nI:IP"; // weak
void *off_646D54 = (void *)0x646974; // weak
void *off_646D58 = (void *)0x646D63; // weak
_UNKNOWN unk_646D7C; // weak
char *off_646D8C = "\"%s\",\"check\":\"%s\",\"notify_tm\":%s,\"check_tm\":%s,\"zn_jb\":%s,\"disonline\":%s"; // weak
_UNKNOWN unk_646EE4; // weak
_UNKNOWN unk_646F64; // weak
_UNKNOWN unk_647128; // weak
char **off_64712C = &off_666564; // weak
_UNKNOWN unk_647158; // weak
_UNKNOWN unk_647170; // weak
void *off_647174 = &unk_637273; // weak
_UNKNOWN unk_647E00; // weak
_UNKNOWN unk_6487EC; // weak
void *off_6489D8 = &unk_616F63; // weak
_UNKNOWN unk_648DBC; // weak
_UNKNOWN unk_648DD0; // weak
char *off_648DDC = "commqq"; // weak
void *off_649144 = (void *)0x4C4C41; // weak
_UNKNOWN unk_649164; // weak
_UNKNOWN unk_64917C; // weak
_UNKNOWN unk_649188; // weak
void *off_64918C = (void *)0x646967; // weak
_UNKNOWN unk_649190; // weak
char *off_649194 = "rzgl_pc_no_auth"; // weak
_UNKNOWN unk_649204; // weak
char byte_64920C[8] = { '\xC3', '\xDC', '\xC2', '\xEB', '\0', '\0', '\0', '\0' }; // idb
void *off_649214 = (void *)0x646975; // weak
char a04d02d02d02d02_0[33] = "%04d-%02d-%02d %02d:%02d:%02d\tWEB"; // weak
char aSS_14[7] = "\t%s\t%s\t"; // weak
_UNKNOWN unk_649D2C; // weak
_UNKNOWN unk_649DB8; // weak
_UNKNOWN unk_649E44; // weak
_UNKNOWN unk_64A61C; // weak
int dword_64A6B0 = 1768366636; // weak
_UNKNOWN unk_64A6D8; // weak
_UNKNOWN unk_64A708; // weak
_UNKNOWN unk_64A784; // weak
_UNKNOWN unk_64B158; // weak
_UNKNOWN unk_64BA34; // weak
_UNKNOWN unk_64BA54; // weak
int dword_64BD3C = 1667310124; // weak
_UNKNOWN unk_64BDF8; // weak
_UNKNOWN unk_64BE04; // weak
_UNKNOWN unk_64BE10; // weak
_UNKNOWN unk_64BE1C; // weak
_UNKNOWN unk_64BE28; // weak
void *off_64C72C = (void *)0x646963; // weak
_UNKNOWN unk_64C730; // weak
char byte_64C75C[16] =
{
  '\xBD',
  '\xFB',
  '\xD3',
  '\xC3',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xB2',
  '\xBB',
  '\xB0',
  '\xF3',
  '\xB6',
  '\xA8',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_64C76C; // weak
_UNKNOWN unk_64CC38; // weak
void *off_64CC40 = (void *)0x646970; // weak
void *off_64CCE8 = &unk_4E414C; // weak
_UNKNOWN unk_64CCF0; // weak
_UNKNOWN unk_64CCF4; // weak
_UNKNOWN unk_64CCF8; // weak
_UNKNOWN unk_64CCFC; // weak
_UNKNOWN unk_64D23C; // weak
_UNKNOWN unk_64D344; // weak
_UNKNOWN unk_64D350; // weak
_UNKNOWN unk_64D364; // weak
_UNKNOWN unk_64D734; // weak
void *off_64D744 = &unk_67736D; // weak
_UNKNOWN unk_64D83C; // weak
_UNKNOWN unk_64D87C; // weak
char byte_64D9E0[12] =
{
  '\xB2',
  '\xBB',
  '\xCA',
  '\xDC',
  '\xCF',
  '\xDE',
  '\xD6',
  '\xC6',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_64DDD0; // weak
_UNKNOWN unk_64DE5C; // weak
int (**off_64E034)() = &off_676F6C; // weak
_UNKNOWN unk_64E0E0; // weak
_UNKNOWN unk_64E0EC; // weak
void *off_64E318 = &unk_66722D; // weak
_UNKNOWN unk_64E388; // weak
_UNKNOWN unk_64E3C8; // weak
_UNKNOWN unk_64E3D4; // weak
_UNKNOWN unk_64E3E0; // weak
_UNKNOWN unk_64E404; // weak
_UNKNOWN unk_64E418; // weak
_UNKNOWN unk_64F808; // weak
_UNKNOWN unk_64F814; // weak
int dword_64FFDC = 1768170028; // weak
int dword_64FFF0 = 1768170028; // weak
int dword_650014 = 1635197484; // weak
int dword_650028 = 1635197484; // weak
int dword_650048 = 1769546284; // weak
int dword_65005C = 1769546284; // weak
int dword_65007C = 1768563244; // weak
int dword_650090 = 1768563244; // weak
int dword_6500B4 = 1751327276; // weak
int dword_6500CC = 1751327276; // weak
int dword_6500F0 = 1751327276; // weak
int dword_650104 = 1751327276; // weak
char byte_65078C = '}'; // weak
void *off_6508E4 = &unk_616C75; // weak
void *off_650A30 = (void *)0x64252F; // weak
_UNKNOWN unk_650A48; // weak
_UNKNOWN unk_650A58; // weak
int dword_650C90 = 1819042157; // weak
int dword_650CA4 = 1919250543; // weak
_UNKNOWN unk_65139C; // weak
_UNKNOWN unk_65503C; // weak
int (*off_665230)() = &ctor_104; // weak
int dword_665238[] = { -1 }; // weak
int dword_66523C = 0; // weak
char *off_665620 = "router_name"; // weak
char *off_665ED0 = "tm_tz"; // weak
char *fdata[2] = { "Jan", &off_4CF134 }; // weak
int gl_httpd_admin_en = 1; // weak
__int16 gl_httpd_https_port = 443; // weak
__int16 gl_httpd_tggl_port = 80; // weak
__int16 gl_httpd_port = 80; // weak
void *re_httphead_str1 = &unk_4D0044; // weak
char *gl_referer3[3] =
{
  "http://www.wayos.cn/bbs/",
  "http://www.wayos.net/bbs/",
  "http://www.wayos.cn/bbs/thread-256-1-1.html"
}; // weak
char *gl_referer2[2] = { "http://www.wayos.net/bbs/", "http://www.wayos.cn/bbs/thread-256-1-1.html" }; // weak
char *gl_referer = "http://www.wayos.cn/bbs/thread-256-1-1.html"; // weak
char **file_type2_str = &off_4D01A8; // weak
_UNKNOWN unk_66619C; // weak
char *httpd_not_found[27] =
{
  "<head><title>Not Found</title></head>\n<body><h2>The requested was not found on this server.</h2></body>\n",
  "X-JHL-ERR: id=%d;str=%s\r\n",
  "Cache-Control: private\r\nSet-Cookie: pref=id=%u:u=%s:p=%s\r\n",
  "Accept-Ranges: bytes\r\n",
  "Content-Length: %lld\r\n",
  "Content-Length: %d\r\n",
  "Content-Type: %s\r\n",
  "Keep-Alive: timeout=15, max=100\r\nConnection: Keep-Alive\r\n",
  "Connection: close\r\n",
  "Date: Sat, 21 Dec 2005 12:00:00 GMT\r\n",
  "Server: HTTPD_gw 1.0\r\n",
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_Accept_Ranges[24] =
{
  "Accept-Ranges: bytes\r\n",
  "Content-Length: %lld\r\n",
  "Content-Length: %d\r\n",
  "Content-Type: %s\r\n",
  "Keep-Alive: timeout=15, max=100\r\nConnection: Keep-Alive\r\n",
  "Connection: close\r\n",
  "Date: Sat, 21 Dec 2005 12:00:00 GMT\r\n",
  "Server: HTTPD_gw 1.0\r\n",
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_lengthtok_ll[23] =
{
  "Content-Length: %lld\r\n",
  "Content-Length: %d\r\n",
  "Content-Type: %s\r\n",
  "Keep-Alive: timeout=15, max=100\r\nConnection: Keep-Alive\r\n",
  "Connection: close\r\n",
  "Date: Sat, 21 Dec 2005 12:00:00 GMT\r\n",
  "Server: HTTPD_gw 1.0\r\n",
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_lengthtok[22] =
{
  "Content-Length: %d\r\n",
  "Content-Type: %s\r\n",
  "Keep-Alive: timeout=15, max=100\r\nConnection: Keep-Alive\r\n",
  "Connection: close\r\n",
  "Date: Sat, 21 Dec 2005 12:00:00 GMT\r\n",
  "Server: HTTPD_gw 1.0\r\n",
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_typetok[21] =
{
  "Content-Type: %s\r\n",
  "Keep-Alive: timeout=15, max=100\r\nConnection: Keep-Alive\r\n",
  "Connection: close\r\n",
  "Date: Sat, 21 Dec 2005 12:00:00 GMT\r\n",
  "Server: HTTPD_gw 1.0\r\n",
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_ctalive[20] =
{
  "Keep-Alive: timeout=15, max=100\r\nConnection: Keep-Alive\r\n",
  "Connection: close\r\n",
  "Date: Sat, 21 Dec 2005 12:00:00 GMT\r\n",
  "Server: HTTPD_gw 1.0\r\n",
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_ctclose[19] =
{
  "Connection: close\r\n",
  "Date: Sat, 21 Dec 2005 12:00:00 GMT\r\n",
  "Server: HTTPD_gw 1.0\r\n",
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_servertok[17] =
{
  "Server: HTTPD_gw 1.0\r\n",
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_oktok[16] =
{
  "HTTP/1.1 200 OK\r\n",
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_errtok[15] =
{
  "HTTP/1.1 %u %s\r\n",
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *httpd_file_xtypes[14] =
{
  "text/html",
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676DC[13] =
{
  "text/xml",
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676E0[12] =
{
  "text/css",
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676E4[11] =
{
  "image/gif",
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676E8[10] =
{
  "image/jpeg",
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676EC[9] =
{
  "image/png",
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676F0[8] =
{
  "image/x-icon",
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676F4[7] =
{
  "application/x-javascript",
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676F8[6] =
{
  "text/plain",
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_6676FC[5] =
{
  "application/x-zip-compressed",
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_667700[4] =
{
  "application/x-tar",
  "application/octet-stream",
  "application/x-shockwave-flash",
  "image/svg+xml"
}; // weak
char *off_667704[3] = { "application/octet-stream", "application/x-shockwave-flash", "image/svg+xml" }; // weak
char *off_667708[2] = { "application/x-shockwave-flash", "image/svg+xml" }; // weak
char *off_66770C = "image/svg+xml"; // weak
int dword_667720 = -1; // weak
int dword_667724 = -1; // weak
_DWORD dword_667730[7] = { 0, 0, 0, 0, 2, 5054556, 4849348 }; // idb
int dword_66774C = 0; // weak
int dword_667750 = 0; // weak
int dword_667768 = 0; // weak
int dword_66776C = 0; // weak
int dword_667784 = 0; // weak
int dword_667788 = 0; // weak
int dword_6677A0 = 0; // weak
char algn_6677A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6677BC = 0; // weak
_UNKNOWN unk_6677C0; // weak
int dword_6677D8 = 0; // weak
int dword_6677DC = 0; // weak
int dword_6677F4 = 0; // weak
int dword_6677F8 = 0; // weak
int dword_667810 = 0; // weak
int dword_667814 = 0; // weak
int dword_66782C = 0; // weak
int dword_667830 = 0; // weak
_DWORD dword_667848 = 0; // idb
int dword_66784C = 0; // weak
_DWORD dword_667864 = 0; // idb
int dword_667868 = 0; // weak
_DWORD dword_667880 = 0; // idb
int dword_667884 = 0; // weak
_DWORD dword_66789C = 0; // idb
int dword_6678A0 = 0; // weak
_DWORD dword_6678B8 = 0; // idb
int dword_6678BC = 0; // weak
_DWORD dword_6678D4 = 0; // idb
int dword_6678D8 = 0; // weak
_DWORD dword_6678F0 = 0; // idb
int dword_6678F4 = 0; // weak
_DWORD dword_66790C = 0; // idb
int dword_667910 = 0; // weak
_DWORD dword_667928 = 0; // idb
int dword_66792C = 0; // weak
_DWORD dword_667944 = 0; // idb
int dword_667948 = 0; // weak
_DWORD dword_667960 = 0; // idb
int dword_667964 = 0; // weak
int dword_66797C = 0; // weak
int dword_667980 = 0; // weak
int dword_667998 = 0; // weak
int dword_66799C = 0; // weak
int dword_6679B4 = 0; // weak
int dword_6679B8 = 0; // weak
void *httpd_all_file = &unk_668450; // weak
_DWORD dword_668480 = 0; // idb
int dword_668484 = 0; // weak
_DWORD dword_66849C = 0; // idb
int dword_6684A0 = 0; // weak
_DWORD dword_6684B8 = 0; // idb
int dword_6684BC = 0; // weak
int dword_6684D4 = 0; // weak
int dword_6684D8 = 0; // weak
int dword_6684F0 = 0; // weak
int dword_6684F4 = 0; // weak
int dword_66850C = 0; // weak
int dword_668510 = 0; // weak
int dword_668528 = 0; // weak
int dword_66852C = 0; // weak
int dword_668544 = 0; // weak
int dword_668548 = 0; // weak
int dword_668560 = 0; // weak
int dword_668564 = 0; // weak
int dword_66857C = 0; // weak
int dword_668580 = 0; // weak
int dword_668598 = 0; // weak
int dword_66859C = 0; // weak
int dword_6685B4 = 0; // weak
int dword_6685B8 = 0; // weak
int dword_6685D0 = 0; // weak
int dword_6685D4 = 0; // weak
int dword_6685EC = 0; // weak
int dword_6685F0 = 0; // weak
int dword_668608 = 0; // weak
int dword_66860C = 0; // weak
int dword_668624 = 0; // weak
int dword_668628 = 0; // weak
int dword_668640 = 0; // weak
int dword_668644 = 0; // weak
int dword_66865C = 0; // weak
int dword_668660 = 0; // weak
int dword_668678 = 0; // weak
int dword_66867C = 0; // weak
int dword_668694 = 0; // weak
int dword_668698 = 0; // weak
int dword_6686B0 = 0; // weak
int dword_6686B4 = 0; // weak
int dword_6686CC = 0; // weak
int dword_6686D0 = 0; // weak
_DWORD dword_6686E8 = 0; // idb
int dword_6686EC = 0; // weak
int dword_668704 = 0; // weak
int dword_668708 = 0; // weak
int dword_668720 = 0; // weak
int dword_668724 = 0; // weak
_DWORD dword_66873C = 0; // idb
int dword_668740 = 0; // weak
_DWORD dword_668758 = 0; // idb
int dword_66875C = 0; // weak
_DWORD dword_668774 = 0; // idb
int dword_668778 = 0; // weak
_DWORD dword_668790 = 0; // idb
int dword_668794 = 0; // weak
int dword_6687AC = 0; // weak
int dword_6687B0 = 0; // weak
int dword_6687C8 = 0; // weak
int dword_6687CC = 0; // weak
int dword_6687E4 = 0; // weak
int dword_6687E8 = 0; // weak
int dword_668800 = 0; // weak
int dword_668804 = 0; // weak
int dword_66881C = 0; // weak
int dword_668820 = 0; // weak
int dword_668838 = 0; // weak
int dword_66883C = 0; // weak
int dword_668854 = 0; // weak
int dword_668858 = 0; // weak
int dword_668870 = 0; // weak
int dword_668874 = 0; // weak
_DWORD dword_66888C[7] = { 0, 0, 0, 0, 1, 6552912, 4926964 }; // idb
int dword_6688A8 = 0; // weak
int dword_6688AC = 0; // weak
int dword_6688C4 = 0; // weak
int dword_6688C8 = 0; // weak
int dword_6688E0 = 0; // weak
int dword_6688E4 = 0; // weak
int dword_6688FC = 0; // weak
int dword_668900 = 0; // weak
int dword_668918 = 0; // weak
int dword_66891C = 0; // weak
int dword_668934 = 0; // weak
int dword_668938 = 0; // weak
int dword_668950 = 0; // weak
int dword_668954 = 0; // weak
int dword_66896C = 0; // weak
int dword_668970 = 0; // weak
_DWORD dword_668988 = 0; // idb
int dword_66898C = 0; // weak
_DWORD dword_6689A4 = 0; // idb
int dword_6689A8 = 0; // weak
_DWORD dword_6689C0 = 0; // idb
int dword_6689C4 = 0; // weak
_DWORD dword_6689DC = 0; // idb
int dword_6689E0 = 0; // weak
_DWORD dword_6689F8 = 0; // idb
int dword_6689FC = 0; // weak
_DWORD dword_668A14 = 0; // idb
int dword_668A18 = 0; // weak
_DWORD dword_668A30 = 0; // idb
int dword_668A34 = 0; // weak
_DWORD dword_668A4C = 0; // idb
int dword_668A50 = 0; // weak
_DWORD dword_668A68 = 0; // idb
int dword_668A6C = 0; // weak
_DWORD dword_668A84 = 0; // idb
int dword_668A88 = 0; // weak
int dword_668AA0 = 0; // weak
int dword_668AA4 = 0; // weak
int dword_668ABC = 0; // weak
int dword_668AC0 = 0; // weak
_DWORD dword_668AD8 = 0; // idb
int dword_668ADC = 0; // weak
int dword_668AF4 = 0; // weak
int dword_668AF8 = 0; // weak
_DWORD dword_668B10 = 0; // idb
int dword_668B14 = 0; // weak
_DWORD dword_668B2C = 0; // idb
int dword_668B30 = 0; // weak
_DWORD dword_668B48 = 0; // idb
int dword_668B4C = 0; // weak
int dword_668B64 = 0; // weak
int dword_668B68 = 0; // weak
int dword_668B80 = 0; // weak
int dword_668B84 = 0; // weak
int dword_668B9C = 0; // weak
int dword_668BA0 = 0; // weak
int dword_668BB8 = 0; // weak
int dword_668BBC = 0; // weak
int dword_668BD4 = 0; // weak
int dword_668BD8 = 0; // weak
int dword_668BF0 = 0; // weak
int dword_668BF4 = 0; // weak
int dword_668C0C = 0; // weak
int dword_668C10 = 0; // weak
int dword_668C28 = 0; // weak
int dword_668C2C = 0; // weak
int dword_668C44 = 0; // weak
int dword_668C48 = 0; // weak
_DWORD dword_668C60[7] = { 0, 0, 0, 0, 4, 6553412, 4892464 }; // idb
int dword_668C7C = 0; // weak
int dword_668C80 = 0; // weak
int dword_668C98 = 0; // weak
int dword_668C9C = 0; // weak
int dword_668CB4 = 0; // weak
int dword_668CB8 = 0; // weak
int dword_668CD0 = 0; // weak
int dword_668CD4 = 0; // weak
int dword_668CEC = 0; // weak
int dword_668CF0 = 0; // weak
int dword_668D08 = 0; // weak
int dword_668D0C = 0; // weak
int dword_668D24 = 0; // weak
int dword_668D28 = 0; // weak
int dword_668D40 = 0; // weak
int dword_668D44 = 0; // weak
_DWORD dword_668D5C = 0; // idb
int dword_668D60 = 0; // weak
_DWORD dword_668D78 = 0; // idb
int dword_668D7C = 0; // weak
_DWORD dword_668D94 = 0; // idb
int dword_668D98 = 0; // weak
_DWORD dword_668DB0 = 0; // idb
int dword_668DB4 = 0; // weak
_DWORD dword_668DCC = 0; // idb
int dword_668DD0 = 0; // weak
_DWORD dword_668DE8 = 0; // idb
int dword_668DEC = 0; // weak
_DWORD dword_668E04 = 0; // idb
int dword_668E08 = 0; // weak
_DWORD dword_668E20 = 0; // idb
int dword_668E24 = 0; // weak
_DWORD dword_668E3C = 0; // idb
int dword_668E40 = 0; // weak
_DWORD dword_668E58 = 0; // idb
int dword_668E5C = 0; // weak
int dword_668E74 = 0; // weak
int dword_668E78 = 0; // weak
int dword_668E90 = 0; // weak
int dword_668E94 = 0; // weak
int dword_668EAC = 0; // weak
int dword_668EB0 = 0; // weak
int dword_668EC8 = 0; // weak
int dword_668ECC = 0; // weak
int dword_668EE4 = 0; // weak
int dword_668EE8 = 0; // weak
int dword_668F00 = 0; // weak
int dword_668F04 = 0; // weak
int dword_668F1C = 0; // weak
int dword_668F20 = 0; // weak
int dword_668F38 = 0; // weak
int dword_668F3C = 0; // weak
int dword_668F54 = 0; // weak
int dword_668F58 = 0; // weak
int dword_668F70 = 0; // weak
int dword_668F74 = 0; // weak
int dword_668F8C = 0; // weak
int dword_668F90 = 0; // weak
int dword_668FA8 = 0; // weak
int dword_668FAC = 0; // weak
int dword_668FC4 = 0; // weak
int dword_668FC8 = 0; // weak
int dword_668FE0 = 0; // weak
int dword_668FE4 = 0; // weak
int dword_668FFC = 0; // weak
int dword_669000 = 0; // weak
int dword_669018 = 0; // weak
int dword_66901C = 0; // weak
_DWORD dword_669034[7] = { 0, 0, 0, 0, 2, 5054556, 4849348 }; // idb
int dword_669050 = 0; // weak
int dword_669054 = 0; // weak
int dword_66906C = 0; // weak
int dword_669070 = 0; // weak
int dword_669088 = 0; // weak
int dword_66908C = 0; // weak
int dword_6690A4 = 0; // weak
_UNKNOWN unk_6690A8; // weak
int dword_6690C0 = 0; // weak
char algn_6690C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6690DC = 0; // weak
int dword_6690E0 = 0; // weak
int dword_6690F8 = 0; // weak
int dword_6690FC = 0; // weak
int dword_669114 = 0; // weak
int dword_669118 = 0; // weak
int dword_669130 = 0; // weak
int dword_669134 = 0; // weak
_DWORD dword_66914C = 0; // idb
int dword_669150 = 0; // weak
_DWORD dword_669168 = 0; // idb
int dword_66916C = 0; // weak
_DWORD dword_669184 = 0; // idb
int dword_669188 = 0; // weak
_DWORD dword_6691A0 = 0; // idb
int dword_6691A4 = 0; // weak
_DWORD dword_6691BC = 0; // idb
int dword_6691C0 = 0; // weak
_DWORD dword_6691D8 = 0; // idb
int dword_6691DC = 0; // weak
_DWORD dword_6691F4 = 0; // idb
int dword_6691F8 = 0; // weak
_DWORD dword_669210 = 0; // idb
int dword_669214 = 0; // weak
_DWORD dword_66922C = 0; // idb
int dword_669230 = 0; // weak
_DWORD dword_669248 = 0; // idb
int dword_66924C = 0; // weak
_DWORD dword_669264 = 0; // idb
int dword_669268 = 0; // weak
int dword_669280 = 0; // weak
int dword_669284 = 0; // weak
_DWORD dword_66929C = 0; // idb
int dword_6692A0 = 0; // weak
int dword_6692B8 = 0; // weak
int dword_6692BC = 0; // weak
_DWORD dword_6692D4 = 0; // idb
int dword_6692D8 = 0; // weak
_DWORD dword_6692F0 = 0; // idb
int dword_6692F4 = 0; // weak
_DWORD dword_66930C = 0; // idb
int dword_669310 = 0; // weak
int dword_669328 = 0; // weak
int dword_66932C = 0; // weak
int dword_669344 = 0; // weak
int dword_669348 = 0; // weak
int dword_669360 = 0; // weak
int dword_669364 = 0; // weak
int dword_66937C = 0; // weak
int dword_669380 = 0; // weak
int dword_669398 = 0; // weak
int dword_66939C = 0; // weak
int dword_6693B4 = 0; // weak
int dword_6693B8 = 0; // weak
int dword_6693D0 = 0; // weak
int dword_6693D4 = 0; // weak
int dword_6693EC = 0; // weak
int dword_6693F0 = 0; // weak
int dword_669408 = 0; // weak
int dword_66940C = 0; // weak
int dword_669424 = 0; // weak
int dword_669428 = 0; // weak
int dword_669440 = 0; // weak
int dword_669444 = 0; // weak
_DWORD dword_66945C = 0; // idb
int dword_669460 = 0; // weak
int dword_669478 = 0; // weak
int dword_66947C = 0; // weak
_DWORD dword_669494 = 0; // idb
int dword_669498 = 0; // weak
_DWORD dword_6694B0 = 0; // idb
int dword_6694B4 = 0; // weak
_DWORD dword_6694CC = 0; // idb
int dword_6694D0 = 0; // weak
int dword_6694E8 = 0; // weak
int dword_6694EC = 0; // weak
int dword_669504 = 0; // weak
int dword_669508 = 0; // weak
int dword_669520 = 0; // weak
int dword_669524 = 0; // weak
int dword_66953C = 0; // weak
int dword_669540 = 0; // weak
int dword_669558 = 0; // weak
int dword_66955C = 0; // weak
int dword_669574 = 0; // weak
int dword_669578 = 0; // weak
int dword_669590 = 0; // weak
int dword_669594 = 0; // weak
int dword_6695AC = 0; // weak
int dword_6695B0 = 0; // weak
int dword_6695C8 = 0; // weak
int dword_6695CC = 0; // weak
_DWORD dword_6695E4 = 0; // idb
int dword_6695E8 = 0; // weak
int dword_669600 = 0; // weak
int dword_669604 = 0; // weak
int dword_66961C = 0; // weak
int dword_669620 = 0; // weak
int dword_669638 = 0; // weak
int dword_66963C = 0; // weak
_DWORD dword_669654 = 0; // idb
int dword_669658 = 0; // weak
_DWORD dword_669670 = 0; // idb
int dword_669674 = 0; // weak
_DWORD dword_66968C = 0; // idb
int dword_669690 = 0; // weak
_DWORD dword_6696A8 = 0; // idb
int dword_6696AC = 0; // weak
_DWORD dword_6696C4 = 0; // idb
int dword_6696C8 = 0; // weak
int dword_6696E0 = 0; // weak
int dword_6696E4 = 0; // weak
int dword_6696FC = 0; // weak
int dword_669700 = 0; // weak
int dword_669718 = 0; // weak
int dword_66971C = 0; // weak
int dword_669734 = 0; // weak
int dword_669738 = 0; // weak
int dword_669750 = 0; // weak
int dword_669754 = 0; // weak
int dword_66976C = 0; // weak
int dword_669770 = 0; // weak
int dword_669788 = 0; // weak
int dword_66978C = 0; // weak
int dword_6697A4 = 0; // weak
int dword_6697A8 = 0; // weak
_DWORD dword_6697C0 = 0; // idb
int dword_6697C4 = 0; // weak
int dword_6697DC = 0; // weak
int dword_6697E0 = 0; // weak
int dword_6697F8 = 0; // weak
int dword_6697FC = 0; // weak
int dword_669814 = 0; // weak
int dword_669818 = 0; // weak
int dword_669830 = 0; // weak
int dword_669834 = 0; // weak
int dword_66984C = 0; // weak
int dword_669850 = 0; // weak
int dword_669868 = 0; // weak
int dword_66986C = 0; // weak
int dword_669884 = 0; // weak
int dword_669888 = 0; // weak
int dword_6698A0 = 0; // weak
int dword_6698A4 = 0; // weak
int dword_6698BC = 0; // weak
int dword_6698C0 = 0; // weak
int dword_6698D8 = 0; // weak
int dword_6698DC = 0; // weak
_DWORD dword_6698F4 = 0; // idb
int dword_6698F8 = 0; // weak
_DWORD dword_669910 = 0; // idb
int dword_669914 = 0; // weak
_DWORD dword_66992C = 0; // idb
int dword_669930 = 0; // weak
int dword_669948 = 0; // weak
int dword_66994C = 0; // weak
int dword_669964 = 0; // weak
int dword_669968 = 0; // weak
int dword_669980 = 0; // weak
int dword_669984 = 0; // weak
int dword_66999C = 0; // weak
int dword_6699A0 = 0; // weak
int dword_6699B8 = 0; // weak
int dword_6699BC = 0; // weak
int dword_6699D4 = 0; // weak
int dword_6699D8 = 0; // weak
int dword_6699F0 = 0; // weak
int dword_6699F4 = 0; // weak
int dword_669A0C = 0; // weak
int dword_669A10 = 0; // weak
int dword_669A28 = 0; // weak
int dword_669A2C = 0; // weak
int dword_669A44 = 0; // weak
int dword_669A48 = 0; // weak
_DWORD dword_669A60[7] = { 0, 0, 0, 0, 3, 6555232, 4516572 }; // idb
int dword_669A7C = 0; // weak
int dword_669A80 = 0; // weak
int dword_669A98 = 0; // weak
int dword_669A9C = 0; // weak
int dword_669AB4 = 0; // weak
int dword_669AB8 = 0; // weak
int dword_669AD0 = 0; // weak
int dword_669AD4 = 0; // weak
int dword_669AEC = 0; // weak
int dword_669AF0 = 0; // weak
int dword_669B08 = 0; // weak
int dword_669B0C = 0; // weak
int dword_669B24 = 0; // weak
int dword_669B28 = 0; // weak
int dword_669B40 = 0; // weak
int dword_669B44 = 0; // weak
_DWORD dword_669B5C = 0; // idb
int dword_669B60 = 0; // weak
_DWORD dword_669B78 = 0; // idb
int dword_669B7C = 0; // weak
_DWORD dword_669B94 = 0; // idb
int dword_669B98 = 0; // weak
_DWORD dword_669BB0 = 0; // idb
int dword_669BB4 = 0; // weak
_DWORD dword_669BCC = 0; // idb
int dword_669BD0 = 0; // weak
_DWORD dword_669BE8 = 0; // idb
int dword_669BEC = 0; // weak
_DWORD dword_669C04 = 0; // idb
int dword_669C08 = 0; // weak
_DWORD dword_669C20 = 0; // idb
int dword_669C24 = 0; // weak
_DWORD dword_669C3C = 0; // idb
int dword_669C40 = 0; // weak
_DWORD dword_669C58 = 0; // idb
int dword_669C5C = 0; // weak
int dword_669C74 = 0; // weak
int dword_669C78 = 0; // weak
int dword_669C90 = 0; // weak
int dword_669C94 = 0; // weak
int dword_669CAC = 0; // weak
char algn_669CB0[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_669CC8 = 0; // weak
_UNKNOWN unk_669CCC; // weak
int dword_669CE4 = 0; // weak
_UNKNOWN unk_669CE8; // weak
int dword_669D00 = 0; // weak
_UNKNOWN unk_669D04; // weak
int dword_669D1C = 0; // weak
_UNKNOWN unk_669D20; // weak
int dword_669D38 = 0; // weak
_UNKNOWN unk_669D3C; // weak
int dword_669D54 = 0; // weak
_UNKNOWN unk_669D58; // weak
int dword_669D70 = 0; // weak
_UNKNOWN unk_669D74; // weak
int dword_669D8C = 0; // weak
char algn_669D90[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_669DA8 = 0; // weak
_UNKNOWN unk_669DAC; // weak
int dword_669DC4 = 0; // weak
_UNKNOWN unk_669DC8; // weak
int dword_669DE0 = 0; // weak
char algn_669DE4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_669DFC = 0; // weak
_UNKNOWN unk_669E00; // weak
int dword_669E18 = 0; // weak
_UNKNOWN unk_669E1C; // weak
int dword_669E34 = 0; // weak
_UNKNOWN unk_669E38; // weak
int dword_669E50 = 0; // weak
int dword_669E54 = 0; // weak
int dword_669E6C = 0; // weak
_UNKNOWN unk_669E70; // weak
int dword_669E88 = 0; // weak
int dword_669E8C = 0; // weak
int dword_669EA4 = 0; // weak
_UNKNOWN unk_669EA8; // weak
int dword_669EC0 = 0; // weak
int dword_669EC4 = 0; // weak
int dword_669EDC = 0; // weak
_UNKNOWN unk_669EE0; // weak
int dword_669EF8 = 0; // weak
int dword_669EFC = 0; // weak
int dword_669F14 = 0; // weak
_UNKNOWN unk_669F18; // weak
int dword_669F30 = 0; // weak
int dword_669F34 = 0; // weak
int dword_669F4C = 0; // weak
_UNKNOWN unk_669F50; // weak
int dword_669F68 = 0; // weak
int dword_669F6C = 0; // weak
int dword_669F84 = 0; // weak
_UNKNOWN unk_669F88; // weak
int dword_669FA0 = 0; // weak
int dword_669FA4 = 0; // weak
int dword_669FBC = 0; // weak
_UNKNOWN unk_669FC0; // weak
int dword_669FD8 = 0; // weak
_UNKNOWN unk_669FDC; // weak
int dword_669FF4 = 0; // weak
_UNKNOWN unk_669FF8; // weak
int dword_66A010 = 0; // weak
int dword_66A014 = 0; // weak
int dword_66A02C = 0; // weak
_UNKNOWN unk_66A030; // weak
int dword_66A048 = 0; // weak
int dword_66A04C = 0; // weak
int dword_66A064 = 0; // weak
_UNKNOWN unk_66A068; // weak
int dword_66A080 = 0; // weak
char algn_66A084[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66A09C = 0; // weak
_UNKNOWN unk_66A0A0; // weak
int dword_66A0B8 = 0; // weak
_UNKNOWN unk_66A0BC; // weak
int dword_66A0D4 = 0; // weak
_UNKNOWN unk_66A0D8; // weak
_DWORD dword_66A0F0[7] = { 0, 0, 0, 0, 3, 6556248, 4644756 }; // idb
_DWORD dword_66A10C[7] = { 0, 0, 0, 0, 4, 6556264, 4678160 }; // idb
_DWORD dword_66A128[7] = { 0, 0, 0, 0, 3, 6556280, 4646144 }; // idb
_DWORD dword_66A144[7] = { 0, 0, 0, 0, 4, 6556296, 4685720 }; // idb
_DWORD dword_66A160[7] = { 0, 0, 0, 0, 4, 6556312, 4661812 }; // idb
_DWORD dword_66A17C[7] = { 0, 0, 0, 0, 3, 6556332, 4660664 }; // idb
_DWORD dword_66A198[7] = { 0, 0, 0, 0, 3, 6556352, 4659312 }; // idb
_DWORD dword_66A1B4[7] = { 0, 0, 0, 0, 4, 6556368, 4654408 }; // idb
_DWORD off_66A1D0[7] = { 0, 0, 0, 0, 0, 6556388, 4656108 }; // idb
_DWORD off_66A1EC[7] = { 0, 0, 0, 0, 0, 6556404, 4657524 }; // idb
_DWORD dword_66A208[7] = { 0, 0, 0, 0, 4, 6556420, 4658816 }; // idb
_DWORD dword_66A224[7] = { 0, 0, 0, 0, 4, 6556440, 4706080 }; // idb
_DWORD dword_66A240[7] = { 0, 0, 0, 0, 4, 6556460, 4703052 }; // idb
_DWORD dword_66A25C[7] = { 0, 0, 0, 0, 4, 6556476, 4670132 }; // idb
_DWORD off_66A278[7] = { 0, 0, 0, 0, 0, 6556488, 4665772 }; // idb
_DWORD off_66A294[7] = { 0, 0, 0, 0, 0, 6556504, 4650832 }; // idb
_DWORD dword_66A2B0[7] = { 0, 0, 0, 0, 4, 6556516, 4654180 }; // idb
_DWORD dword_66A2CC[7] = { 0, 0, 0, 0, 4, 6555960, 4696344 }; // idb
_DWORD dword_66A2E8[7] = { 0, 0, 0, 0, 4, 6556528, 4655136 }; // idb
_DWORD dword_66A304[7] = { 0, 0, 0, 0, 3, 6556356, 4695436 }; // idb
_DWORD dword_66A320[7] = { 0, 0, 0, 0, 4, 6556544, 4671516 }; // idb
_DWORD dword_66A33C[7] = { 0, 0, 0, 0, 4, 6556560, 4680228 }; // idb
int dword_66A358 = 0; // weak
_UNKNOWN unk_66A35C; // weak
_DWORD dword_66A374[7] = { 0, 0, 0, 0, 4, 6556584, 4692352 }; // idb
_DWORD dword_66A390[7] = { 0, 0, 0, 0, 4, 6556600, 4691572 }; // idb
_DWORD dword_66A3AC[7] = { 0, 0, 0, 0, 4, 6556616, 4638292 }; // idb
int dword_66A3C8 = 0; // weak
int dword_66A3CC = 0; // weak
int dword_66A3E4 = 0; // weak
int dword_66A3E8 = 0; // weak
int dword_66A400 = 0; // weak
int dword_66A404 = 0; // weak
int dword_66A41C = 0; // weak
int dword_66A420 = 0; // weak
int dword_66A438 = 0; // weak
int dword_66A43C = 0; // weak
int dword_66A454 = 0; // weak
_UNKNOWN unk_66A458; // weak
int dword_66A470 = 0; // weak
int dword_66A474 = 0; // weak
int dword_66A48C = 0; // weak
int dword_66A490 = 0; // weak
int dword_66A4A8 = 0; // weak
int dword_66A4AC = 0; // weak
int dword_66A4C4 = 0; // weak
int dword_66A4C8 = 0; // weak
_DWORD dword_66A4E0 = 0; // idb
int dword_66A4E4 = 0; // weak
_DWORD dword_66A4FC = 0; // idb
int dword_66A500 = 0; // weak
_DWORD dword_66A518 = 0; // idb
int dword_66A51C = 0; // weak
_DWORD dword_66A534 = 0; // idb
int dword_66A538 = 0; // weak
_DWORD dword_66A550 = 0; // idb
int dword_66A554 = 0; // weak
_DWORD dword_66A56C = 0; // idb
int dword_66A570 = 0; // weak
_DWORD dword_66A588 = 0; // idb
int dword_66A58C = 0; // weak
_DWORD dword_66A5A4 = 0; // idb
int dword_66A5A8 = 0; // weak
_DWORD dword_66A5C0 = 0; // idb
int dword_66A5C4 = 0; // weak
_DWORD dword_66A5DC = 0; // idb
int dword_66A5E0 = 0; // weak
_DWORD dword_66A5F8 = 0; // idb
int dword_66A5FC = 0; // weak
_DWORD dword_66A614 = 0; // idb
int dword_66A618 = 0; // weak
_DWORD dword_66A630[7] = { 0, 0, 0, 0, 3, 6556888, 4599520 }; // idb
int dword_66A64C = 0; // weak
int dword_66A650 = 0; // weak
int dword_66A668 = 0; // weak
int dword_66A66C = 0; // weak
int dword_66A684 = 0; // weak
int dword_66A688 = 0; // weak
int dword_66A6A0 = 0; // weak
int dword_66A6A4 = 0; // weak
int dword_66A6BC = 0; // weak
int dword_66A6C0 = 0; // weak
_DWORD dword_66A6D8 = 0; // idb
int dword_66A6DC = 0; // weak
_DWORD dword_66A6F4 = 0; // idb
int dword_66A6F8 = 0; // weak
_DWORD dword_66A710 = 0; // idb
int dword_66A714 = 0; // weak
_DWORD dword_66A72C = 0; // idb
int dword_66A730 = 0; // weak
_DWORD dword_66A748 = 0; // idb
int dword_66A74C = 0; // weak
_DWORD dword_66A764 = 0; // idb
int dword_66A768 = 0; // weak
_DWORD dword_66A780 = 0; // idb
int dword_66A784 = 0; // weak
int dword_66A79C = 0; // weak
int dword_66A7A0 = 0; // weak
int dword_66A7B8 = 0; // weak
int dword_66A7BC = 0; // weak
int dword_66A7D4 = 0; // weak
int dword_66A7D8 = 0; // weak
int dword_66A7F0 = 0; // weak
int dword_66A7F4 = 0; // weak
int dword_66A80C = 0; // weak
int dword_66A810 = 0; // weak
_DWORD dword_66A828[7] = { 0, 0, 0, 0, 5, 6557140, 4573548 }; // idb
int dword_66A844 = 0; // weak
int dword_66A848 = 0; // weak
int dword_66A860 = 0; // weak
int dword_66A864 = 0; // weak
int dword_66A87C = 0; // weak
int dword_66A880 = 0; // weak
int dword_66A898 = 0; // weak
int dword_66A89C = 0; // weak
int dword_66A8B4 = 0; // weak
int dword_66A8B8 = 0; // weak
int dword_66A8D0 = 0; // weak
int dword_66A8D4 = 0; // weak
int dword_66A8EC = 0; // weak
int dword_66A8F0 = 0; // weak
_DWORD dword_66A908 = 0; // idb
int dword_66A90C = 0; // weak
_DWORD dword_66A924 = 0; // idb
int dword_66A928 = 0; // weak
_DWORD dword_66A940 = 0; // idb
int dword_66A944 = 0; // weak
_DWORD dword_66A95C = 0; // idb
int dword_66A960 = 0; // weak
_DWORD dword_66A978 = 0; // idb
int dword_66A97C = 0; // weak
_DWORD dword_66A994 = 0; // idb
int dword_66A998 = 0; // weak
_DWORD dword_66A9B0 = 0; // idb
int dword_66A9B4 = 0; // weak
_DWORD dword_66A9CC = 0; // idb
int dword_66A9D0 = 0; // weak
_DWORD dword_66A9E8 = 0; // idb
int dword_66A9EC = 0; // weak
int dword_66AA04 = 0; // weak
int dword_66AA08 = 0; // weak
int dword_66AA20 = 0; // weak
int dword_66AA24 = 0; // weak
int dword_66AA3C = 0; // weak
int dword_66AA40 = 0; // weak
int dword_66AA58 = 0; // weak
int dword_66AA5C = 0; // weak
int dword_66AA74 = 0; // weak
int dword_66AA78 = 0; // weak
int dword_66AA90 = 0; // weak
int dword_66AA94 = 0; // weak
int dword_66AAAC = 0; // weak
int dword_66AAB0 = 0; // weak
int dword_66AAC8 = 0; // weak
int dword_66AACC = 0; // weak
int dword_66AAE4 = 0; // weak
int dword_66AAE8 = 0; // weak
int dword_66AB00 = 0; // weak
int dword_66AB04 = 0; // weak
int dword_66AB1C = 0; // weak
_UNKNOWN unk_66AB20; // weak
int dword_66AB38 = 0; // weak
_UNKNOWN unk_66AB3C; // weak
int dword_66AB54 = 0; // weak
_UNKNOWN unk_66AB58; // weak
int dword_66AB70 = 0; // weak
char algn_66AB74[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66AB8C = 0; // weak
_UNKNOWN unk_66AB90; // weak
int dword_66ABA8 = 0; // weak
_UNKNOWN unk_66ABAC; // weak
int dword_66ABC4 = 0; // weak
_UNKNOWN unk_66ABC8; // weak
int dword_66ABE0 = 0; // weak
char algn_66ABE4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66ABFC = 0; // weak
_UNKNOWN unk_66AC00; // weak
int dword_66AC18 = 0; // weak
_UNKNOWN unk_66AC1C; // weak
int dword_66AC34 = 0; // weak
_UNKNOWN unk_66AC38; // weak
int dword_66AC50 = 0; // weak
char algn_66AC54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66AC6C = 0; // weak
_UNKNOWN unk_66AC70; // weak
int dword_66AC88 = 0; // weak
_UNKNOWN unk_66AC8C; // weak
int dword_66ACA4 = 0; // weak
_UNKNOWN unk_66ACA8; // weak
int dword_66ACC0 = 0; // weak
char algn_66ACC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66ACDC = 0; // weak
_UNKNOWN unk_66ACE0; // weak
int dword_66ACF8 = 0; // weak
_UNKNOWN unk_66ACFC; // weak
int dword_66AD14 = 0; // weak
_UNKNOWN unk_66AD18; // weak
int dword_66AD30 = 0; // weak
char algn_66AD34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66AD4C = 0; // weak
_UNKNOWN unk_66AD50; // weak
int dword_66AD68 = 0; // weak
_UNKNOWN unk_66AD6C; // weak
int dword_66AD84 = 0; // weak
_UNKNOWN unk_66AD88; // weak
int dword_66ADA0 = 0; // weak
char algn_66ADA4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66ADBC = 0; // weak
_UNKNOWN unk_66ADC0; // weak
int dword_66ADD8 = 0; // weak
_UNKNOWN unk_66ADDC; // weak
int dword_66ADF4 = 0; // weak
_UNKNOWN unk_66ADF8; // weak
int dword_66AE10 = 0; // weak
char algn_66AE14[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66AE2C = 0; // weak
_UNKNOWN unk_66AE30; // weak
int dword_66AE48 = 0; // weak
_UNKNOWN unk_66AE4C; // weak
int dword_66AE64 = 0; // weak
int dword_66AE68 = 0; // weak
int dword_66AE80 = 0; // weak
char algn_66AE84[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66AE9C = 0; // weak
int dword_66AEA0 = 0; // weak
int dword_66AEB8 = 0; // weak
_UNKNOWN unk_66AEBC; // weak
int dword_66AED4 = 0; // weak
int dword_66AED8 = 0; // weak
int dword_66AEF0 = 0; // weak
char algn_66AEF4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66AF0C = 0; // weak
int dword_66AF10 = 0; // weak
int dword_66AF28 = 0; // weak
_UNKNOWN unk_66AF2C; // weak
int dword_66AF44 = 0; // weak
int dword_66AF48 = 0; // weak
int dword_66AF60 = 0; // weak
char algn_66AF64[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66AF7C = 0; // weak
int dword_66AF80 = 0; // weak
int dword_66AF98 = 0; // weak
_UNKNOWN unk_66AF9C; // weak
int dword_66AFB4 = 0; // weak
int dword_66AFB8 = 0; // weak
int dword_66AFD0 = 0; // weak
char algn_66AFD4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66AFEC = 0; // weak
int dword_66AFF0 = 0; // weak
int dword_66B008 = 0; // weak
_UNKNOWN unk_66B00C; // weak
int dword_66B024 = 0; // weak
_UNKNOWN unk_66B028; // weak
int dword_66B040 = 0; // weak
char algn_66B044[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B05C = 0; // weak
_UNKNOWN unk_66B060; // weak
int dword_66B078 = 0; // weak
_UNKNOWN unk_66B07C; // weak
int dword_66B094 = 0; // weak
_UNKNOWN unk_66B098; // weak
int dword_66B0B0 = 0; // weak
char algn_66B0B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B0CC = 0; // weak
_UNKNOWN unk_66B0D0; // weak
int dword_66B0E8 = 0; // weak
_UNKNOWN unk_66B0EC; // weak
_DWORD dword_66B104[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_66B120[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_66B13C[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_66B158[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_66B174[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_66B190[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_66B1AC[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_66B1C8[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_66B1E4[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_66B200[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_66B21C[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_66B238[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_66B254[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_66B270[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_66B28C[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_66B2A8[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_66B2C4[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_66B2E0[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_66B2FC[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_66B318[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_66B334[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_66B350[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_66B36C = 0; // weak
_UNKNOWN unk_66B370; // weak
_DWORD dword_66B388[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_66B3A4[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
_DWORD dword_66B3C0 = 0; // idb
int dword_66B3C4 = 0; // weak
int dword_66B3DC = 0; // weak
int dword_66B3E0 = 0; // weak
int dword_66B3F8 = 0; // weak
int dword_66B3FC = 0; // weak
int dword_66B414 = 0; // weak
int dword_66B418 = 0; // weak
_DWORD dword_66B430 = 0; // idb
int dword_66B434 = 0; // weak
_DWORD dword_66B44C = 0; // idb
int dword_66B450 = 0; // weak
_DWORD dword_66B468 = 0; // idb
int dword_66B46C = 0; // weak
_DWORD dword_66B484 = 0; // idb
int dword_66B488 = 0; // weak
_DWORD dword_66B4A0 = 0; // idb
int dword_66B4A4 = 0; // weak
int dword_66B4BC = 0; // weak
int dword_66B4C0 = 0; // weak
int dword_66B4D8 = 0; // weak
int dword_66B4DC = 0; // weak
int dword_66B4F4 = 0; // weak
int dword_66B4F8 = 0; // weak
int dword_66B510 = 0; // weak
int dword_66B514 = 0; // weak
int dword_66B52C = 0; // weak
int dword_66B530 = 0; // weak
int dword_66B548 = 0; // weak
int dword_66B54C = 0; // weak
int dword_66B564 = 0; // weak
int dword_66B568 = 0; // weak
void *_httpd_cgi_all_fun = &_httpd_cgi_all_fun; // weak
void **off_66B584 = &_httpd_cgi_all_fun; // weak
_UNKNOWN unk_66B590; // weak
char byte_66B592 = '3'; // weak
char byte_66B597 = '0'; // weak
char byte_66B59D = 'w'; // weak
_UNKNOWN unk_66B5A0; // weak
void *user_login_list = &user_login_list; // weak
void **off_66B5E4 = &user_login_list; // weak
int gl_httpd_unix_fd = -1; // weak
int dword_66B600 = 0; // weak
char algn_66B604[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B61C = 0; // weak
_UNKNOWN unk_66B620; // weak
int dword_66B638 = 0; // weak
_UNKNOWN unk_66B63C; // weak
int dword_66B654 = 0; // weak
_UNKNOWN unk_66B658; // weak
int dword_66B670 = 0; // weak
char algn_66B674[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B68C = 0; // weak
_UNKNOWN unk_66B690; // weak
int dword_66B6A8 = 0; // weak
_UNKNOWN unk_66B6AC; // weak
int dword_66B6C4 = 0; // weak
_UNKNOWN unk_66B6C8; // weak
int dword_66B6E0 = 0; // weak
char algn_66B6E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B6FC = 0; // weak
_UNKNOWN unk_66B700; // weak
int dword_66B718 = 0; // weak
_UNKNOWN unk_66B71C; // weak
int dword_66B734 = 0; // weak
_UNKNOWN unk_66B738; // weak
int dword_66B750 = 0; // weak
char algn_66B754[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B76C = 0; // weak
_UNKNOWN unk_66B770; // weak
int dword_66B788 = 0; // weak
_UNKNOWN unk_66B78C; // weak
int dword_66B7A4 = 0; // weak
_UNKNOWN unk_66B7A8; // weak
int dword_66B7C0 = 0; // weak
char algn_66B7C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B7DC = 0; // weak
_UNKNOWN unk_66B7E0; // weak
int dword_66B7F8 = 0; // weak
_UNKNOWN unk_66B7FC; // weak
int dword_66B814 = 0; // weak
_UNKNOWN unk_66B818; // weak
int dword_66B830 = 0; // weak
char algn_66B834[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B84C = 0; // weak
_UNKNOWN unk_66B850; // weak
int dword_66B868 = 0; // weak
_UNKNOWN unk_66B86C; // weak
int dword_66B884 = 0; // weak
_UNKNOWN unk_66B888; // weak
int dword_66B8A0 = 0; // weak
char algn_66B8A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B8BC = 0; // weak
_UNKNOWN unk_66B8C0; // weak
int dword_66B8D8 = 0; // weak
_UNKNOWN unk_66B8DC; // weak
int dword_66B8F4 = 0; // weak
_UNKNOWN unk_66B8F8; // weak
int dword_66B910 = 0; // weak
char algn_66B914[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66B92C = 0; // weak
_UNKNOWN unk_66B930; // weak
int dword_66B948 = 0; // weak
int dword_66B94C = 0; // weak
int dword_66B964 = 0; // weak
_UNKNOWN unk_66B968; // weak
int dword_66B980 = 0; // weak
int dword_66B984 = 0; // weak
int dword_66B99C = 0; // weak
_UNKNOWN unk_66B9A0; // weak
int dword_66B9B8 = 0; // weak
int dword_66B9BC = 0; // weak
int dword_66B9D4 = 0; // weak
_UNKNOWN unk_66B9D8; // weak
int dword_66B9F0 = 0; // weak
int dword_66B9F4 = 0; // weak
int dword_66BA0C = 0; // weak
_UNKNOWN unk_66BA10; // weak
int dword_66BA28 = 0; // weak
int dword_66BA2C = 0; // weak
int dword_66BA44 = 0; // weak
_UNKNOWN unk_66BA48; // weak
int dword_66BA60 = 0; // weak
int dword_66BA64 = 0; // weak
int dword_66BA7C = 0; // weak
_UNKNOWN unk_66BA80; // weak
int dword_66BA98 = 0; // weak
int dword_66BA9C = 0; // weak
int dword_66BAB4 = 0; // weak
_UNKNOWN unk_66BAB8; // weak
int dword_66BAD0 = 0; // weak
int dword_66BAD4 = 0; // weak
int dword_66BAEC = 0; // weak
_UNKNOWN unk_66BAF0; // weak
int dword_66BB08 = 0; // weak
_UNKNOWN unk_66BB0C; // weak
int dword_66BB24 = 0; // weak
_UNKNOWN unk_66BB28; // weak
int dword_66BB40 = 0; // weak
char algn_66BB44[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66BB5C = 0; // weak
_UNKNOWN unk_66BB60; // weak
int dword_66BB78 = 0; // weak
_UNKNOWN unk_66BB7C; // weak
int dword_66BB94 = 0; // weak
_UNKNOWN unk_66BB98; // weak
int dword_66BBB0 = 0; // weak
char algn_66BBB4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66BBCC = 0; // weak
_UNKNOWN unk_66BBD0; // weak
_DWORD dword_66BBE8[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_66BC04[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_66BC20[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_66BC3C[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_66BC58[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_66BC74[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_66BC90[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_66BCAC[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_66BCC8[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_66BCE4[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_66BD00[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_66BD1C[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_66BD38[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_66BD54[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_66BD70[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_66BD8C[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_66BDA8[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_66BDC4[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_66BDE0[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_66BDFC[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_66BE18[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_66BE34[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_66BE50 = 0; // weak
char algn_66BE54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_66BE6C[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_66BE88[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
_DWORD dword_66BEA4 = 0; // idb
int dword_66BEA8 = 0; // weak
int dword_66BEC0 = 0; // weak
int dword_66BEC4 = 0; // weak
_DWORD dword_66BEDC = 0; // idb
int dword_66BEE0 = 0; // weak
_DWORD dword_66BEF8 = 0; // idb
int dword_66BEFC = 0; // weak
_DWORD dword_66BF14 = 0; // idb
int dword_66BF18 = 0; // weak
int dword_66BF30 = 0; // weak
int dword_66BF34 = 0; // weak
int dword_66BF4C = 0; // weak
int dword_66BF50 = 0; // weak
int dword_66BF68 = 0; // weak
int dword_66BF6C = 0; // weak
int dword_66BF84 = 0; // weak
int dword_66BF88 = 0; // weak
int dword_66BFA0 = 0; // weak
int dword_66BFA4 = 0; // weak
int dword_66BFBC = 0; // weak
int dword_66BFC0 = 0; // weak
int dword_66BFD8 = 0; // weak
int dword_66BFDC = 0; // weak
int dword_66BFF4 = 0; // weak
int dword_66BFF8 = 0; // weak
int dword_66C010 = 0; // weak
int dword_66C014 = 0; // weak
int dword_66C030 = 0; // weak
int dword_66C034 = 0; // weak
int dword_66C050 = 0; // weak
_UNKNOWN unk_66C054; // weak
int dword_66C06C = 0; // weak
char algn_66C070[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_66C088 = 0; // weak
_UNKNOWN unk_66C08C; // weak
int dword_66C0A4 = 0; // weak
_UNKNOWN unk_66C0A8; // weak
int dword_66C0C0 = 0; // weak
_UNKNOWN unk_66C0C4; // weak
int dword_66C0DC = 0; // weak
_UNKNOWN unk_66C0E0; // weak
int dword_66C0F8 = 0; // weak
_UNKNOWN unk_66C0FC; // weak
int dword_66C114 = 0; // weak
_UNKNOWN unk_66C118; // weak
int dword_66C130 = 0; // weak
_UNKNOWN unk_66C134; // weak
int dword_66C14C = 0; // weak
char algn_66C150[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_66C168 = 0; // weak
_UNKNOWN unk_66C16C; // weak
int dword_66C184 = 0; // weak
_UNKNOWN unk_66C188; // weak
int dword_66C1A0 = 0; // weak
char algn_66C1A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66C1BC = 0; // weak
_UNKNOWN unk_66C1C0; // weak
int dword_66C1D8 = 0; // weak
_UNKNOWN unk_66C1DC; // weak
int dword_66C1F4 = 0; // weak
int dword_66C1F8 = 0; // weak
int dword_66C210 = 0; // weak
char algn_66C214[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66C22C = 0; // weak
int dword_66C230 = 0; // weak
int dword_66C248 = 0; // weak
_UNKNOWN unk_66C24C; // weak
int dword_66C264 = 0; // weak
int dword_66C268 = 0; // weak
int dword_66C280 = 0; // weak
char algn_66C284[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66C29C = 0; // weak
int dword_66C2A0 = 0; // weak
int dword_66C2B8 = 0; // weak
_UNKNOWN unk_66C2BC; // weak
int dword_66C2D4 = 0; // weak
int dword_66C2D8 = 0; // weak
int dword_66C2F0 = 0; // weak
char algn_66C2F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66C30C = 0; // weak
int dword_66C310 = 0; // weak
int dword_66C328 = 0; // weak
_UNKNOWN unk_66C32C; // weak
int dword_66C344 = 0; // weak
int dword_66C348 = 0; // weak
int dword_66C360 = 0; // weak
char algn_66C364[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66C37C = 0; // weak
_UNKNOWN unk_66C380; // weak
int dword_66C398 = 0; // weak
_UNKNOWN unk_66C39C; // weak
int dword_66C3B4 = 0; // weak
int dword_66C3B8 = 0; // weak
int dword_66C3D0 = 0; // weak
char algn_66C3D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66C3EC = 0; // weak
int dword_66C3F0 = 0; // weak
int dword_66C408 = 0; // weak
_UNKNOWN unk_66C40C; // weak
int dword_66C424 = 0; // weak
_UNKNOWN unk_66C428; // weak
int dword_66C440 = 0; // weak
char algn_66C444[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66C45C = 0; // weak
_UNKNOWN unk_66C460; // weak
int dword_66C478 = 0; // weak
_UNKNOWN unk_66C47C; // weak
_DWORD dword_66C494[7] = { 0, 0, 0, 0, 3, 6556248, 4644756 }; // idb
_DWORD dword_66C4B0[7] = { 0, 0, 0, 0, 4, 6556264, 4678160 }; // idb
_DWORD dword_66C4CC[7] = { 0, 0, 0, 0, 3, 6556280, 4646144 }; // idb
_DWORD dword_66C4E8[7] = { 0, 0, 0, 0, 4, 6556296, 4685720 }; // idb
_DWORD dword_66C504[7] = { 0, 0, 0, 0, 4, 6556312, 4661812 }; // idb
_DWORD dword_66C520[7] = { 0, 0, 0, 0, 3, 6556332, 4660664 }; // idb
_DWORD dword_66C53C[7] = { 0, 0, 0, 0, 3, 6556352, 4659312 }; // idb
_DWORD dword_66C558[7] = { 0, 0, 0, 0, 4, 6556368, 4654408 }; // idb
_DWORD off_66C574[7] = { 0, 0, 0, 0, 0, 6556388, 4656108 }; // idb
_DWORD off_66C590[7] = { 0, 0, 0, 0, 0, 6556404, 4657524 }; // idb
_DWORD dword_66C5AC[7] = { 0, 0, 0, 0, 4, 6556420, 4658816 }; // idb
_DWORD dword_66C5C8[7] = { 0, 0, 0, 0, 4, 6556440, 4706080 }; // idb
_DWORD dword_66C5E4[7] = { 0, 0, 0, 0, 4, 6556460, 4703052 }; // idb
_DWORD dword_66C600[7] = { 0, 0, 0, 0, 4, 6556476, 4670132 }; // idb
_DWORD off_66C61C[7] = { 0, 0, 0, 0, 0, 6556488, 4665772 }; // idb
_DWORD off_66C638[7] = { 0, 0, 0, 0, 0, 6556504, 4650832 }; // idb
_DWORD dword_66C654[7] = { 0, 0, 0, 0, 4, 6556516, 4654180 }; // idb
_DWORD dword_66C670[7] = { 0, 0, 0, 0, 4, 6555960, 4696344 }; // idb
_DWORD dword_66C68C[7] = { 0, 0, 0, 0, 4, 6556528, 4655136 }; // idb
_DWORD dword_66C6A8[7] = { 0, 0, 0, 0, 3, 6556356, 4695436 }; // idb
_DWORD dword_66C6C4[7] = { 0, 0, 0, 0, 4, 6556544, 4671516 }; // idb
_DWORD dword_66C6E0[7] = { 0, 0, 0, 0, 4, 6556560, 4680228 }; // idb
int dword_66C6FC = 0; // weak
_UNKNOWN unk_66C700; // weak
_DWORD dword_66C718[7] = { 0, 0, 0, 0, 4, 6556584, 4692352 }; // idb
_DWORD dword_66C734[7] = { 0, 0, 0, 0, 4, 6556600, 4691572 }; // idb
_DWORD dword_66C750[7] = { 0, 0, 0, 0, 3, 6555232, 4516572 }; // idb
int dword_66C76C = 0; // weak
int dword_66C770 = 0; // weak
int dword_66C788 = 0; // weak
int dword_66C78C = 0; // weak
int dword_66C7A4 = 0; // weak
int dword_66C7A8 = 0; // weak
int dword_66C7C0 = 0; // weak
int dword_66C7C4 = 0; // weak
int dword_66C7DC = 0; // weak
int dword_66C7E0 = 0; // weak
int dword_66C7F8 = 0; // weak
int dword_66C7FC = 0; // weak
int dword_66C814 = 0; // weak
int dword_66C818 = 0; // weak
int dword_66C830 = 0; // weak
int dword_66C834 = 0; // weak
_DWORD dword_66C84C = 0; // idb
int dword_66C850 = 0; // weak
_DWORD dword_66C868 = 0; // idb
int dword_66C86C = 0; // weak
_DWORD dword_66C884 = 0; // idb
int dword_66C888 = 0; // weak
_DWORD dword_66C8A0 = 0; // idb
int dword_66C8A4 = 0; // weak
_DWORD dword_66C8BC = 0; // idb
int dword_66C8C0 = 0; // weak
_DWORD dword_66C8D8 = 0; // idb
int dword_66C8DC = 0; // weak
_DWORD dword_66C8F4 = 0; // idb
int dword_66C8F8 = 0; // weak
_DWORD dword_66C910 = 0; // idb
int dword_66C914 = 0; // weak
_DWORD dword_66C92C = 0; // idb
int dword_66C930 = 0; // weak
_DWORD dword_66C948 = 0; // idb
int dword_66C94C = 0; // weak
int dword_66C964 = 0; // weak
int dword_66C968 = 0; // weak
int dword_66C980 = 0; // weak
int dword_66C984 = 0; // weak
int dword_66C99C = 0; // weak
_UNKNOWN unk_66C9A0; // weak
int dword_66C9B8 = 0; // weak
_UNKNOWN unk_66C9BC; // weak
int dword_66C9D4 = 0; // weak
_UNKNOWN unk_66C9D8; // weak
int dword_66C9F0 = 0; // weak
char algn_66C9F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CA0C = 0; // weak
_UNKNOWN unk_66CA10; // weak
int dword_66CA28 = 0; // weak
_UNKNOWN unk_66CA2C; // weak
int dword_66CA44 = 0; // weak
_UNKNOWN unk_66CA48; // weak
int dword_66CA60 = 0; // weak
char algn_66CA64[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CA7C = 0; // weak
_UNKNOWN unk_66CA80; // weak
int dword_66CA98 = 0; // weak
_UNKNOWN unk_66CA9C; // weak
int dword_66CAB4 = 0; // weak
_UNKNOWN unk_66CAB8; // weak
int dword_66CAD0 = 0; // weak
char algn_66CAD4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CAEC = 0; // weak
_UNKNOWN unk_66CAF0; // weak
int dword_66CB08 = 0; // weak
_UNKNOWN unk_66CB0C; // weak
int dword_66CB24 = 0; // weak
_UNKNOWN unk_66CB28; // weak
int dword_66CB40 = 0; // weak
char algn_66CB44[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CB5C = 0; // weak
_UNKNOWN unk_66CB60; // weak
int dword_66CB78 = 0; // weak
_UNKNOWN unk_66CB7C; // weak
int dword_66CB94 = 0; // weak
_UNKNOWN unk_66CB98; // weak
int dword_66CBB0 = 0; // weak
char algn_66CBB4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CBCC = 0; // weak
_UNKNOWN unk_66CBD0; // weak
int dword_66CBE8 = 0; // weak
_UNKNOWN unk_66CBEC; // weak
int dword_66CC04 = 0; // weak
_UNKNOWN unk_66CC08; // weak
int dword_66CC20 = 0; // weak
char algn_66CC24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CC3C = 0; // weak
_UNKNOWN unk_66CC40; // weak
int dword_66CC58 = 0; // weak
_UNKNOWN unk_66CC5C; // weak
int dword_66CC74 = 0; // weak
_UNKNOWN unk_66CC78; // weak
int dword_66CC90 = 0; // weak
char algn_66CC94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CCAC = 0; // weak
_UNKNOWN unk_66CCB0; // weak
int dword_66CCC8 = 0; // weak
_UNKNOWN unk_66CCCC; // weak
int dword_66CCE4 = 0; // weak
int dword_66CCE8 = 0; // weak
int dword_66CD00 = 0; // weak
char algn_66CD04[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CD1C = 0; // weak
int dword_66CD20 = 0; // weak
int dword_66CD38 = 0; // weak
_UNKNOWN unk_66CD3C; // weak
int dword_66CD54 = 0; // weak
int dword_66CD58 = 0; // weak
int dword_66CD70 = 0; // weak
char algn_66CD74[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CD8C = 0; // weak
int dword_66CD90 = 0; // weak
int dword_66CDA8 = 0; // weak
_UNKNOWN unk_66CDAC; // weak
int dword_66CDC4 = 0; // weak
int dword_66CDC8 = 0; // weak
int dword_66CDE0 = 0; // weak
char algn_66CDE4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CDFC = 0; // weak
int dword_66CE00 = 0; // weak
int dword_66CE18 = 0; // weak
_UNKNOWN unk_66CE1C; // weak
int dword_66CE34 = 0; // weak
int dword_66CE38 = 0; // weak
int dword_66CE50 = 0; // weak
char algn_66CE54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CE6C = 0; // weak
int dword_66CE70 = 0; // weak
int dword_66CE88 = 0; // weak
_UNKNOWN unk_66CE8C; // weak
int dword_66CEA4 = 0; // weak
_UNKNOWN unk_66CEA8; // weak
int dword_66CEC0 = 0; // weak
char algn_66CEC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CEDC = 0; // weak
_UNKNOWN unk_66CEE0; // weak
int dword_66CEF8 = 0; // weak
_UNKNOWN unk_66CEFC; // weak
int dword_66CF14 = 0; // weak
_UNKNOWN unk_66CF18; // weak
int dword_66CF30 = 0; // weak
char algn_66CF34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66CF4C = 0; // weak
_UNKNOWN unk_66CF50; // weak
int dword_66CF68 = 0; // weak
_UNKNOWN unk_66CF6C; // weak
_DWORD dword_66CF84[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_66CFA0[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_66CFBC[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_66CFD8[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_66CFF4[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_66D010[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_66D02C[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_66D048[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_66D064[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_66D080[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_66D09C[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_66D0B8[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_66D0D4[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_66D0F0[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_66D10C[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_66D128[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_66D144[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_66D160[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_66D17C[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_66D198[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_66D1B4[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_66D1D0[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_66D1EC = 0; // weak
_UNKNOWN unk_66D1F0; // weak
_DWORD dword_66D208[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_66D224[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
char *base_ident_nvarms[5] = { "network_name", "router_name", "wan_hostname", "wan_domain", "router_domain" }; // weak
char *off_66D260[11] =
{
  "dhcp_type",
  "dhcp_start",
  "dhcp_end",
  "dhcp_lease",
  "dhcp_gw",
  "dhcp_mask",
  "dhcp_dns0",
  "dhcp_dns1",
  "dhcp_bind_ipmac_en",
  "dhcp_option43",
  "dhcp_filter"
}; // weak
void *off_66D290 = (void *)0x4CF9EC; // weak
char *off_66D294[23] =
{
  "iface",
  "lan_showname",
  "lan_ipaddr",
  "lan_netmask",
  "mac_lan",
  "dhcp_type",
  "dhcp_start",
  "dhcp_end",
  "dhcp_lease",
  "dhcp_gw",
  "dhcp_mask",
  "dhcp_dns0",
  "dhcp_dns1",
  "dhcp_static_en",
  "dhcp_static_addr",
  "dhcp_notan_en",
  "dhcp_notan_addr",
  "dhcp_pool_en",
  "dhcp_ip_pool",
  "lan_mem",
  "lan_ifacebind",
  "dhcp_option43",
  "dhcp_filter"
}; // weak
char *off_66D2E4[3] = { "lan_ifacebind", "dhcp_option43", "dhcp_filter" }; // weak
_DWORD dword_66D2F0 = 0; // idb
int dword_66D2F4 = 0; // weak
int dword_66D30C = 0; // weak
int dword_66D310 = 0; // weak
int dword_66D328 = 0; // weak
int dword_66D32C = 0; // weak
int dword_66D344 = 0; // weak
int dword_66D348 = 0; // weak
_DWORD dword_66D360 = 0; // idb
int dword_66D364 = 0; // weak
_DWORD dword_66D37C = 0; // idb
int dword_66D380 = 0; // weak
_DWORD dword_66D398 = 0; // idb
int dword_66D39C = 0; // weak
_DWORD dword_66D3B4 = 0; // idb
int dword_66D3B8 = 0; // weak
_DWORD dword_66D3D0 = 0; // idb
int dword_66D3D4 = 0; // weak
int dword_66D3EC = 0; // weak
int dword_66D3F0 = 0; // weak
int dword_66D408 = 0; // weak
int dword_66D40C = 0; // weak
int dword_66D424 = 0; // weak
int dword_66D428 = 0; // weak
int dword_66D440 = 0; // weak
int dword_66D444 = 0; // weak
int dword_66D45C = 0; // weak
int dword_66D460 = 0; // weak
int dword_66D478 = 0; // weak
int dword_66D47C = 0; // weak
int dword_66D494 = 0; // weak
int dword_66D498 = 0; // weak
_DWORD dword_66D4B0[7] = { 0, 0, 0, 0, 3, 6555232, 4516572 }; // idb
int dword_66D4CC = 0; // weak
int dword_66D4D0 = 0; // weak
int dword_66D4E8 = 0; // weak
int dword_66D4EC = 0; // weak
int dword_66D504 = 0; // weak
int dword_66D508 = 0; // weak
int dword_66D520 = 0; // weak
int dword_66D524 = 0; // weak
int dword_66D53C = 0; // weak
int dword_66D540 = 0; // weak
int dword_66D558 = 0; // weak
int dword_66D55C = 0; // weak
int dword_66D574 = 0; // weak
int dword_66D578 = 0; // weak
int dword_66D590 = 0; // weak
int dword_66D594 = 0; // weak
_DWORD dword_66D5AC = 0; // idb
int dword_66D5B0 = 0; // weak
_DWORD dword_66D5C8 = 0; // idb
int dword_66D5CC = 0; // weak
_DWORD dword_66D5E4 = 0; // idb
int dword_66D5E8 = 0; // weak
_DWORD dword_66D600 = 0; // idb
int dword_66D604 = 0; // weak
_DWORD dword_66D61C = 0; // idb
int dword_66D620 = 0; // weak
_DWORD dword_66D638 = 0; // idb
int dword_66D63C = 0; // weak
_DWORD dword_66D654 = 0; // idb
int dword_66D658 = 0; // weak
_DWORD dword_66D670 = 0; // idb
int dword_66D674 = 0; // weak
_DWORD dword_66D68C = 0; // idb
int dword_66D690 = 0; // weak
_DWORD dword_66D6A8 = 0; // idb
int dword_66D6AC = 0; // weak
int dword_66D6C4 = 0; // weak
int dword_66D6C8 = 0; // weak
int dword_66D6E0 = 0; // weak
int dword_66D6E4 = 0; // weak
_DWORD dword_66D6FC[7] = { 0, 0, 0, 0, 2, 5054556, 4849348 }; // idb
int dword_66D718 = 0; // weak
int dword_66D71C = 0; // weak
int dword_66D734 = 0; // weak
int dword_66D738 = 0; // weak
int dword_66D750 = 0; // weak
int dword_66D754 = 0; // weak
int dword_66D76C = 0; // weak
_UNKNOWN unk_66D770; // weak
int dword_66D788 = 0; // weak
_UNKNOWN unk_66D78C; // weak
int dword_66D7A4 = 0; // weak
int dword_66D7A8 = 0; // weak
int dword_66D7C0 = 0; // weak
int dword_66D7C4 = 0; // weak
int dword_66D7DC = 0; // weak
int dword_66D7E0 = 0; // weak
int dword_66D7F8 = 0; // weak
int dword_66D7FC = 0; // weak
_DWORD dword_66D814 = 0; // idb
int dword_66D818 = 0; // weak
_DWORD dword_66D830 = 0; // idb
int dword_66D834 = 0; // weak
_DWORD dword_66D84C = 0; // idb
int dword_66D850 = 0; // weak
_DWORD dword_66D868 = 0; // idb
int dword_66D86C = 0; // weak
_DWORD dword_66D884 = 0; // idb
int dword_66D888 = 0; // weak
_DWORD dword_66D8A0 = 0; // idb
int dword_66D8A4 = 0; // weak
_DWORD dword_66D8BC = 0; // idb
int dword_66D8C0 = 0; // weak
_DWORD dword_66D8D8 = 0; // idb
int dword_66D8DC = 0; // weak
_DWORD dword_66D8F4 = 0; // idb
int dword_66D8F8 = 0; // weak
_DWORD dword_66D910 = 0; // idb
int dword_66D914 = 0; // weak
_DWORD dword_66D92C = 0; // idb
int dword_66D930 = 0; // weak
int dword_66D948 = 0; // weak
int dword_66D94C = 0; // weak
int dword_66D964 = 0; // weak
int dword_66D968 = 0; // weak
int dword_66D980 = 0; // weak
char algn_66D984[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66D99C = 0; // weak
_UNKNOWN unk_66D9A0; // weak
int dword_66D9B8 = 0; // weak
_UNKNOWN unk_66D9BC; // weak
int dword_66D9D4 = 0; // weak
_UNKNOWN unk_66D9D8; // weak
int dword_66D9F0 = 0; // weak
char algn_66D9F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DA0C = 0; // weak
_UNKNOWN unk_66DA10; // weak
int dword_66DA28 = 0; // weak
_UNKNOWN unk_66DA2C; // weak
int dword_66DA44 = 0; // weak
_UNKNOWN unk_66DA48; // weak
int dword_66DA60 = 0; // weak
char algn_66DA64[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DA7C = 0; // weak
_UNKNOWN unk_66DA80; // weak
int dword_66DA98 = 0; // weak
_UNKNOWN unk_66DA9C; // weak
int dword_66DAB4 = 0; // weak
_UNKNOWN unk_66DAB8; // weak
int dword_66DAD0 = 0; // weak
char algn_66DAD4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DAEC = 0; // weak
_UNKNOWN unk_66DAF0; // weak
int dword_66DB08 = 0; // weak
_UNKNOWN unk_66DB0C; // weak
int dword_66DB24 = 0; // weak
_UNKNOWN unk_66DB28; // weak
int dword_66DB40 = 0; // weak
char algn_66DB44[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DB5C = 0; // weak
_UNKNOWN unk_66DB60; // weak
int dword_66DB78 = 0; // weak
_UNKNOWN unk_66DB7C; // weak
int dword_66DB94 = 0; // weak
_UNKNOWN unk_66DB98; // weak
int dword_66DBB0 = 0; // weak
char algn_66DBB4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DBCC = 0; // weak
_UNKNOWN unk_66DBD0; // weak
int dword_66DBE8 = 0; // weak
_UNKNOWN unk_66DBEC; // weak
int dword_66DC04 = 0; // weak
_UNKNOWN unk_66DC08; // weak
int dword_66DC20 = 0; // weak
char algn_66DC24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DC3C = 0; // weak
_UNKNOWN unk_66DC40; // weak
int dword_66DC58 = 0; // weak
_UNKNOWN unk_66DC5C; // weak
int dword_66DC74 = 0; // weak
_UNKNOWN unk_66DC78; // weak
int dword_66DC90 = 0; // weak
char algn_66DC94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DCAC = 0; // weak
_UNKNOWN unk_66DCB0; // weak
int dword_66DCC8 = 0; // weak
int dword_66DCCC = 0; // weak
int dword_66DCE4 = 0; // weak
_UNKNOWN unk_66DCE8; // weak
int dword_66DD00 = 0; // weak
int dword_66DD04 = 0; // weak
int dword_66DD1C = 0; // weak
_UNKNOWN unk_66DD20; // weak
int dword_66DD38 = 0; // weak
int dword_66DD3C = 0; // weak
int dword_66DD54 = 0; // weak
_UNKNOWN unk_66DD58; // weak
int dword_66DD70 = 0; // weak
int dword_66DD74 = 0; // weak
int dword_66DD8C = 0; // weak
_UNKNOWN unk_66DD90; // weak
int dword_66DDA8 = 0; // weak
int dword_66DDAC = 0; // weak
int dword_66DDC4 = 0; // weak
_UNKNOWN unk_66DDC8; // weak
int dword_66DDE0 = 0; // weak
int dword_66DDE4 = 0; // weak
int dword_66DDFC = 0; // weak
_UNKNOWN unk_66DE00; // weak
int dword_66DE18 = 0; // weak
int dword_66DE1C = 0; // weak
int dword_66DE34 = 0; // weak
_UNKNOWN unk_66DE38; // weak
int dword_66DE50 = 0; // weak
int dword_66DE54 = 0; // weak
int dword_66DE6C = 0; // weak
_UNKNOWN unk_66DE70; // weak
int dword_66DE88 = 0; // weak
_UNKNOWN unk_66DE8C; // weak
int dword_66DEA4 = 0; // weak
_UNKNOWN unk_66DEA8; // weak
int dword_66DEC0 = 0; // weak
char algn_66DEC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DEDC = 0; // weak
_UNKNOWN unk_66DEE0; // weak
int dword_66DEF8 = 0; // weak
_UNKNOWN unk_66DEFC; // weak
int dword_66DF14 = 0; // weak
_UNKNOWN unk_66DF18; // weak
int dword_66DF30 = 0; // weak
char algn_66DF34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66DF4C = 0; // weak
_UNKNOWN unk_66DF50; // weak
_DWORD dword_66DF68[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_66DF84[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_66DFA0[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_66DFBC[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_66DFD8[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_66DFF4[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_66E010[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_66E02C[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_66E048[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_66E064[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_66E080[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_66E09C[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_66E0B8[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_66E0D4[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_66E0F0[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_66E10C[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_66E128[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_66E144[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_66E160[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_66E17C[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_66E198[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_66E1B4[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_66E1D0 = 0; // weak
char algn_66E1D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_66E1EC[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_66E208[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
char *wan_parms[4] = { "mtu_enable", "ppp_demand", "ppp_idletime", "ppp_redialperiod" }; // weak
char *base_network_nvarms_dns[4] = { "dnsEn", "dnsMaxtm", "dnsMintm", "dnsShowct" }; // weak
char *off_66E300[7] =
{
  "ppp_username",
  "ppp_passwd",
  "wan_dns",
  "wan_gateway",
  "wan_ipaddr",
  "wan_netmask",
  "wan_proto"
}; // weak
void *off_66E320 = (void *)0x4CF9EC; // weak
int dword_66E330 = 0; // weak
int dword_66E334 = 0; // weak
int dword_66E34C = 0; // weak
int dword_66E350 = 0; // weak
int dword_66E368 = 0; // weak
int dword_66E36C = 0; // weak
_DWORD dword_66E384[7] = { 0, 0, 0, 0, 3, 6555232, 4516572 }; // idb
int dword_66E3A0 = 0; // weak
int dword_66E3A4 = 0; // weak
int dword_66E3BC = 0; // weak
int dword_66E3C0 = 0; // weak
int dword_66E3D8 = 0; // weak
int dword_66E3DC = 0; // weak
int dword_66E3F4 = 0; // weak
int dword_66E3F8 = 0; // weak
int dword_66E410 = 0; // weak
int dword_66E414 = 0; // weak
int dword_66E42C = 0; // weak
int dword_66E430 = 0; // weak
int dword_66E448 = 0; // weak
int dword_66E44C = 0; // weak
int dword_66E464 = 0; // weak
int dword_66E468 = 0; // weak
_DWORD dword_66E480 = 0; // idb
int dword_66E484 = 0; // weak
_DWORD dword_66E49C = 0; // idb
int dword_66E4A0 = 0; // weak
_DWORD dword_66E4B8 = 0; // idb
int dword_66E4BC = 0; // weak
_DWORD dword_66E4D4 = 0; // idb
int dword_66E4D8 = 0; // weak
_DWORD dword_66E4F0 = 0; // idb
int dword_66E4F4 = 0; // weak
_DWORD dword_66E50C = 0; // idb
int dword_66E510 = 0; // weak
_DWORD dword_66E528 = 0; // idb
int dword_66E52C = 0; // weak
_DWORD dword_66E544 = 0; // idb
int dword_66E548 = 0; // weak
_DWORD dword_66E560 = 0; // idb
int dword_66E564 = 0; // weak
_DWORD dword_66E57C = 0; // idb
int dword_66E580 = 0; // weak
int dword_66E598 = 0; // weak
int dword_66E59C = 0; // weak
int dword_66E5B4 = 0; // weak
int dword_66E5B8 = 0; // weak
int dword_66E5D0 = 0; // weak
char algn_66E5D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66E5EC = 0; // weak
_UNKNOWN unk_66E5F0; // weak
int dword_66E608 = 0; // weak
_UNKNOWN unk_66E60C; // weak
int dword_66E624 = 0; // weak
_UNKNOWN unk_66E628; // weak
int dword_66E640 = 0; // weak
char algn_66E644[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66E65C = 0; // weak
_UNKNOWN unk_66E660; // weak
int dword_66E678 = 0; // weak
_UNKNOWN unk_66E67C; // weak
int dword_66E694 = 0; // weak
_UNKNOWN unk_66E698; // weak
int dword_66E6B0 = 0; // weak
char algn_66E6B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66E6CC = 0; // weak
_UNKNOWN unk_66E6D0; // weak
int dword_66E6E8 = 0; // weak
_UNKNOWN unk_66E6EC; // weak
int dword_66E704 = 0; // weak
_UNKNOWN unk_66E708; // weak
int dword_66E720 = 0; // weak
char algn_66E724[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66E73C = 0; // weak
_UNKNOWN unk_66E740; // weak
int dword_66E758 = 0; // weak
_UNKNOWN unk_66E75C; // weak
int dword_66E774 = 0; // weak
_UNKNOWN unk_66E778; // weak
int dword_66E790 = 0; // weak
char algn_66E794[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66E7AC = 0; // weak
_UNKNOWN unk_66E7B0; // weak
int dword_66E7C8 = 0; // weak
_UNKNOWN unk_66E7CC; // weak
int dword_66E7E4 = 0; // weak
_UNKNOWN unk_66E7E8; // weak
int dword_66E800 = 0; // weak
char algn_66E804[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66E81C = 0; // weak
_UNKNOWN unk_66E820; // weak
int dword_66E838 = 0; // weak
_UNKNOWN unk_66E83C; // weak
int dword_66E854 = 0; // weak
_UNKNOWN unk_66E858; // weak
int dword_66E870 = 0; // weak
char algn_66E874[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66E88C = 0; // weak
_UNKNOWN unk_66E890; // weak
int dword_66E8A8 = 0; // weak
_UNKNOWN unk_66E8AC; // weak
int dword_66E8C4 = 0; // weak
_UNKNOWN unk_66E8C8; // weak
int dword_66E8E0 = 0; // weak
char algn_66E8E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66E8FC = 0; // weak
_UNKNOWN unk_66E900; // weak
int dword_66E918 = 0; // weak
int dword_66E91C = 0; // weak
int dword_66E934 = 0; // weak
_UNKNOWN unk_66E938; // weak
int dword_66E950 = 0; // weak
int dword_66E954 = 0; // weak
int dword_66E96C = 0; // weak
_UNKNOWN unk_66E970; // weak
int dword_66E988 = 0; // weak
int dword_66E98C = 0; // weak
int dword_66E9A4 = 0; // weak
_UNKNOWN unk_66E9A8; // weak
int dword_66E9C0 = 0; // weak
int dword_66E9C4 = 0; // weak
int dword_66E9DC = 0; // weak
_UNKNOWN unk_66E9E0; // weak
int dword_66E9F8 = 0; // weak
int dword_66E9FC = 0; // weak
int dword_66EA14 = 0; // weak
_UNKNOWN unk_66EA18; // weak
int dword_66EA30 = 0; // weak
int dword_66EA34 = 0; // weak
int dword_66EA4C = 0; // weak
_UNKNOWN unk_66EA50; // weak
int dword_66EA68 = 0; // weak
int dword_66EA6C = 0; // weak
int dword_66EA84 = 0; // weak
_UNKNOWN unk_66EA88; // weak
int dword_66EAA0 = 0; // weak
int dword_66EAA4 = 0; // weak
int dword_66EABC = 0; // weak
_UNKNOWN unk_66EAC0; // weak
int dword_66EAD8 = 0; // weak
_UNKNOWN unk_66EADC; // weak
int dword_66EAF4 = 0; // weak
_UNKNOWN unk_66EAF8; // weak
int dword_66EB10 = 0; // weak
char algn_66EB14[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66EB2C = 0; // weak
_UNKNOWN unk_66EB30; // weak
int dword_66EB48 = 0; // weak
_UNKNOWN unk_66EB4C; // weak
int dword_66EB64 = 0; // weak
_UNKNOWN unk_66EB68; // weak
int dword_66EB80 = 0; // weak
char algn_66EB84[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66EB9C = 0; // weak
_UNKNOWN unk_66EBA0; // weak
_DWORD dword_66EBB8[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_66EBD4[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_66EBF0[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_66EC0C[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_66EC28[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_66EC44[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_66EC60[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_66EC7C[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_66EC98[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_66ECB4[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_66ECD0[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_66ECEC[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_66ED08[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_66ED24[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_66ED40[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_66ED5C[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_66ED78[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_66ED94[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_66EDB0[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_66EDCC[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_66EDE8[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_66EE04[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_66EE20 = 0; // weak
char algn_66EE24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_66EE3C[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_66EE58[10] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0, 0 }; // idb
_DWORD dword_66EE80[7] = { 0, 0, 0, 0, 3, 6555232, 4516572 }; // idb
int dword_66EE9C = 0; // weak
int dword_66EEA0 = 0; // weak
int dword_66EEB8 = 0; // weak
int dword_66EEBC = 0; // weak
int dword_66EED4 = 0; // weak
int dword_66EED8 = 0; // weak
int dword_66EEF0 = 0; // weak
int dword_66EEF4 = 0; // weak
int dword_66EF0C = 0; // weak
int dword_66EF10 = 0; // weak
int dword_66EF28 = 0; // weak
int dword_66EF2C = 0; // weak
int dword_66EF44 = 0; // weak
int dword_66EF48 = 0; // weak
int dword_66EF60 = 0; // weak
int dword_66EF64 = 0; // weak
_DWORD dword_66EF7C = 0; // idb
int dword_66EF80 = 0; // weak
_DWORD dword_66EF98 = 0; // idb
int dword_66EF9C = 0; // weak
_DWORD dword_66EFB4 = 0; // idb
int dword_66EFB8 = 0; // weak
_DWORD dword_66EFD0 = 0; // idb
int dword_66EFD4 = 0; // weak
_DWORD dword_66EFEC = 0; // idb
int dword_66EFF0 = 0; // weak
_DWORD dword_66F008 = 0; // idb
int dword_66F00C = 0; // weak
_DWORD dword_66F024 = 0; // idb
int dword_66F028 = 0; // weak
_DWORD dword_66F040 = 0; // idb
int dword_66F044 = 0; // weak
_DWORD dword_66F05C = 0; // idb
int dword_66F060 = 0; // weak
_DWORD dword_66F078 = 0; // idb
int dword_66F07C = 0; // weak
int dword_66F094 = 0; // weak
int dword_66F098 = 0; // weak
int dword_66F0B0 = 0; // weak
int dword_66F0B4 = 0; // weak
int dword_66F0CC = 0; // weak
int dword_66F0D0 = 0; // weak
int dword_66F0E8 = 0; // weak
int dword_66F0EC = 0; // weak
char *ll_log_str = "arp"; // weak
void *off_66F118 = (void *)0x641C38; // weak
int dword_66F220 = 0; // weak
int dword_66F224 = 0; // weak
_DWORD dword_66F23C = 0; // idb
int dword_66F240 = 0; // weak
int dword_66F258 = 0; // weak
int dword_66F25C = 0; // weak
int dword_66F274 = 0; // weak
int dword_66F278 = 0; // weak
int dword_66F290 = 0; // weak
int dword_66F294 = 0; // weak
_DWORD dword_66F2AC = 0; // idb
int dword_66F2B0 = 0; // weak
_DWORD dword_66F2C8 = 0; // idb
int dword_66F2CC = 0; // weak
_DWORD dword_66F2E4 = 0; // idb
int dword_66F2E8 = 0; // weak
_DWORD dword_66F300 = 0; // idb
int dword_66F304 = 0; // weak
_DWORD dword_66F31C = 0; // idb
int dword_66F320 = 0; // weak
int dword_66F338 = 0; // weak
int dword_66F33C = 0; // weak
int dword_66F354 = 0; // weak
int dword_66F358 = 0; // weak
int dword_66F370 = 0; // weak
int dword_66F374 = 0; // weak
int dword_66F38C = 0; // weak
int dword_66F390 = 0; // weak
int dword_66F3A8 = 0; // weak
int dword_66F3AC = 0; // weak
int dword_66F3C4 = 0; // weak
int dword_66F3C8 = 0; // weak
int dword_66F3E0 = 0; // weak
int dword_66F3E4 = 0; // weak
int dword_66F3FC = 0; // weak
_UNKNOWN unk_66F400; // weak
int dword_66F418 = 0; // weak
_UNKNOWN unk_66F41C; // weak
int dword_66F434 = 0; // weak
_UNKNOWN unk_66F438; // weak
int dword_66F450 = 0; // weak
char algn_66F454[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F46C = 0; // weak
_UNKNOWN unk_66F470; // weak
int dword_66F488 = 0; // weak
_UNKNOWN unk_66F48C; // weak
int dword_66F4A4 = 0; // weak
_UNKNOWN unk_66F4A8; // weak
int dword_66F4C0 = 0; // weak
char algn_66F4C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F4DC = 0; // weak
_UNKNOWN unk_66F4E0; // weak
int dword_66F4F8 = 0; // weak
_UNKNOWN unk_66F4FC; // weak
int dword_66F514 = 0; // weak
_UNKNOWN unk_66F518; // weak
int dword_66F530 = 0; // weak
char algn_66F534[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F54C = 0; // weak
_UNKNOWN unk_66F550; // weak
int dword_66F568 = 0; // weak
_UNKNOWN unk_66F56C; // weak
int dword_66F584 = 0; // weak
_UNKNOWN unk_66F588; // weak
int dword_66F5A0 = 0; // weak
char algn_66F5A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F5BC = 0; // weak
_UNKNOWN unk_66F5C0; // weak
int dword_66F5D8 = 0; // weak
_UNKNOWN unk_66F5DC; // weak
int dword_66F5F4 = 0; // weak
_UNKNOWN unk_66F5F8; // weak
int dword_66F610 = 0; // weak
char algn_66F614[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F62C = 0; // weak
_UNKNOWN unk_66F630; // weak
int dword_66F648 = 0; // weak
_UNKNOWN unk_66F64C; // weak
int dword_66F664 = 0; // weak
_UNKNOWN unk_66F668; // weak
int dword_66F680 = 0; // weak
char algn_66F684[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F69C = 0; // weak
_UNKNOWN unk_66F6A0; // weak
int dword_66F6B8 = 0; // weak
_UNKNOWN unk_66F6BC; // weak
int dword_66F6D4 = 0; // weak
_UNKNOWN unk_66F6D8; // weak
int dword_66F6F0 = 0; // weak
char algn_66F6F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F70C = 0; // weak
_UNKNOWN unk_66F710; // weak
int dword_66F728 = 0; // weak
_UNKNOWN unk_66F72C; // weak
int dword_66F744 = 0; // weak
int dword_66F748 = 0; // weak
int dword_66F760 = 0; // weak
char algn_66F764[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F77C = 0; // weak
int dword_66F780 = 0; // weak
int dword_66F798 = 0; // weak
_UNKNOWN unk_66F79C; // weak
int dword_66F7B4 = 0; // weak
int dword_66F7B8 = 0; // weak
int dword_66F7D0 = 0; // weak
char algn_66F7D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F7EC = 0; // weak
int dword_66F7F0 = 0; // weak
int dword_66F808 = 0; // weak
_UNKNOWN unk_66F80C; // weak
int dword_66F824 = 0; // weak
int dword_66F828 = 0; // weak
int dword_66F840 = 0; // weak
char algn_66F844[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F85C = 0; // weak
int dword_66F860 = 0; // weak
int dword_66F878 = 0; // weak
_UNKNOWN unk_66F87C; // weak
int dword_66F894 = 0; // weak
int dword_66F898 = 0; // weak
int dword_66F8B0 = 0; // weak
char algn_66F8B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F8CC = 0; // weak
int dword_66F8D0 = 0; // weak
int dword_66F8E8 = 0; // weak
_UNKNOWN unk_66F8EC; // weak
int dword_66F904 = 0; // weak
_UNKNOWN unk_66F908; // weak
int dword_66F920 = 0; // weak
char algn_66F924[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F93C = 0; // weak
_UNKNOWN unk_66F940; // weak
int dword_66F958 = 0; // weak
_UNKNOWN unk_66F95C; // weak
int dword_66F974 = 0; // weak
_UNKNOWN unk_66F978; // weak
int dword_66F990 = 0; // weak
char algn_66F994[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66F9AC = 0; // weak
_UNKNOWN unk_66F9B0; // weak
int dword_66F9C8 = 0; // weak
_UNKNOWN unk_66F9CC; // weak
_DWORD dword_66F9E4[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_66FA00[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_66FA1C[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_66FA38[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_66FA54[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_66FA70[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_66FA8C[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_66FAA8[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_66FAC4[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_66FAE0[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_66FAFC[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_66FB18[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_66FB34[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_66FB50[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_66FB6C[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_66FB88[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_66FBA4[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_66FBC0[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_66FBDC[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_66FBF8[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_66FC14[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_66FC30[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_66FC4C = 0; // weak
_UNKNOWN unk_66FC50; // weak
_DWORD dword_66FC68[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_66FC84[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
char *off_66FCA0[24] =
{
  "http_lanport",
  "remote_management",
  "http_wanport",
  "http_username",
  "http_gname_en",
  "http_gname",
  "sshd_eas",
  "sshd_port",
  "sshd_remote",
  "sshd_rport",
  "sshd_authkeys",
  "sshd_pass",
  "telnetd_eas",
  "telnetd_port",
  "rmgt_sip",
  "wan_ping",
  "tggl_port",
  "telnetd_remote",
  "telnetd_rport",
  "http_guest_en",
  "http_guest_user",
  "http_guest_pwd",
  "allow_ips",
  "http_token_time"
}; // weak
void *off_66FD00 = (void *)0x4CF9EC; // weak
char *off_66FD10[2] = { "nvram", "restore" }; // weak
int dword_66FD18 = 0; // weak
char *off_66FD20[2] = { "nvram", "backup" }; // weak
int dword_66FD28 = 0; // weak
char *base_time_nvarms[8] =
{
  "tm_sel",
  "tm_dst",
  "tm_tz",
  "ntp_updates",
  "ntp_server",
  "ntp_tdod",
  "ntp_kiss",
  "ntp_dev"
}; // weak
int dword_66FD58 = 0; // weak
_UNKNOWN unk_66FD5C; // weak
int dword_66FD74 = 0; // weak
_UNKNOWN unk_66FD78; // weak
int dword_66FD90 = 0; // weak
char algn_66FD94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66FDAC = 0; // weak
_UNKNOWN unk_66FDB0; // weak
int dword_66FDC8 = 0; // weak
_UNKNOWN unk_66FDCC; // weak
int dword_66FDE4 = 0; // weak
_UNKNOWN unk_66FDE8; // weak
int dword_66FE00 = 0; // weak
char algn_66FE04[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66FE1C = 0; // weak
_UNKNOWN unk_66FE20; // weak
int dword_66FE38 = 0; // weak
_UNKNOWN unk_66FE3C; // weak
int dword_66FE54 = 0; // weak
_UNKNOWN unk_66FE58; // weak
int dword_66FE70 = 0; // weak
char algn_66FE74[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66FE8C = 0; // weak
_UNKNOWN unk_66FE90; // weak
int dword_66FEA8 = 0; // weak
_UNKNOWN unk_66FEAC; // weak
int dword_66FEC4 = 0; // weak
_UNKNOWN unk_66FEC8; // weak
int dword_66FEE0 = 0; // weak
char algn_66FEE4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66FEFC = 0; // weak
_UNKNOWN unk_66FF00; // weak
int dword_66FF18 = 0; // weak
_UNKNOWN unk_66FF1C; // weak
int dword_66FF34 = 0; // weak
_UNKNOWN unk_66FF38; // weak
int dword_66FF50 = 0; // weak
char algn_66FF54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66FF6C = 0; // weak
_UNKNOWN unk_66FF70; // weak
int dword_66FF88 = 0; // weak
_UNKNOWN unk_66FF8C; // weak
int dword_66FFA4 = 0; // weak
_UNKNOWN unk_66FFA8; // weak
int dword_66FFC0 = 0; // weak
char algn_66FFC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_66FFDC = 0; // weak
_UNKNOWN unk_66FFE0; // weak
int dword_66FFF8 = 0; // weak
char algn_66FFFC[4] = { '\0', '\0', '\0', '\0' }; // weak
int dword_670014 = 0; // weak
_UNKNOWN unk_670018; // weak
int dword_670030 = 0; // weak
char algn_670034[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67004C = 0; // weak
_UNKNOWN unk_670050; // weak
int dword_670068 = 0; // weak
_UNKNOWN unk_67006C; // weak
int dword_670084 = 0; // weak
_UNKNOWN unk_670088; // weak
int dword_6700A0 = 0; // weak
int dword_6700A4 = 0; // weak
int dword_6700BC = 0; // weak
_UNKNOWN unk_6700C0; // weak
int dword_6700D8 = 0; // weak
int dword_6700DC = 0; // weak
int dword_6700F4 = 0; // weak
_UNKNOWN unk_6700F8; // weak
int dword_670110 = 0; // weak
int dword_670114 = 0; // weak
int dword_67012C = 0; // weak
_UNKNOWN unk_670130; // weak
int dword_670148 = 0; // weak
int dword_67014C = 0; // weak
int dword_670164 = 0; // weak
_UNKNOWN unk_670168; // weak
int dword_670180 = 0; // weak
int dword_670184 = 0; // weak
int dword_67019C = 0; // weak
_UNKNOWN unk_6701A0; // weak
int dword_6701B8 = 0; // weak
int dword_6701BC = 0; // weak
int dword_6701D4 = 0; // weak
_UNKNOWN unk_6701D8; // weak
int dword_6701F0 = 0; // weak
int dword_6701F4 = 0; // weak
int dword_67020C = 0; // weak
_UNKNOWN unk_670210; // weak
int dword_670228 = 0; // weak
int dword_67022C = 0; // weak
int dword_670244 = 0; // weak
_UNKNOWN unk_670248; // weak
int dword_670260 = 0; // weak
char algn_670264[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67027C = 0; // weak
_UNKNOWN unk_670280; // weak
int dword_670298 = 0; // weak
_UNKNOWN unk_67029C; // weak
int dword_6702B4 = 0; // weak
_UNKNOWN unk_6702B8; // weak
int dword_6702D0 = 0; // weak
char algn_6702D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6702EC = 0; // weak
_UNKNOWN unk_6702F0; // weak
int dword_670308 = 0; // weak
_UNKNOWN unk_67030C; // weak
int dword_670324 = 0; // weak
_UNKNOWN unk_670328; // weak
_DWORD dword_670340[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_67035C[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_670378[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_670394[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_6703B0[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_6703CC[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_6703E8[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_670404[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_670420[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_67043C[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_670458[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_670474[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_670490[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_6704AC[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_6704C8[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_6704E4[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_670500[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_67051C[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_670538[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_670554[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_670570[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_67058C[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_6705A8 = 0; // weak
_UNKNOWN unk_6705AC; // weak
_DWORD dword_6705C4[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_6705E0[8] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0 }; // idb
char *off_670600[7] =
{
  "ct_icmp_timeout",
  "ct_tcp_timeout",
  "ct_udp_timeout",
  "ct_max",
  "firewall_ct_connum_high",
  "firewall_ct_connum_low",
  "firewall_ct_multiple"
}; // weak
void *off_670620 = (void *)0x4CF9EC; // weak
int dword_670630 = 0; // weak
int dword_670634 = 0; // weak
_DWORD dword_67064C[7] = { 0, 0, 0, 0, 3, 6556888, 4599520 }; // idb
int dword_670668 = 0; // weak
int dword_67066C = 0; // weak
int dword_670684 = 0; // weak
int dword_670688 = 0; // weak
int dword_6706A0 = 0; // weak
int dword_6706A4 = 0; // weak
int dword_6706BC = 0; // weak
int dword_6706C0 = 0; // weak
int dword_6706D8 = 0; // weak
int dword_6706DC = 0; // weak
_DWORD dword_6706F4 = 0; // idb
int dword_6706F8 = 0; // weak
_DWORD dword_670710 = 0; // idb
int dword_670714 = 0; // weak
_DWORD dword_67072C = 0; // idb
int dword_670730 = 0; // weak
_DWORD dword_670748 = 0; // idb
int dword_67074C = 0; // weak
_DWORD dword_670764 = 0; // idb
int dword_670768 = 0; // weak
_DWORD dword_670780 = 0; // idb
int dword_670784 = 0; // weak
_DWORD dword_67079C = 0; // idb
int dword_6707A0 = 0; // weak
int dword_6707B8 = 0; // weak
int dword_6707BC = 0; // weak
int dword_6707D4 = 0; // weak
int dword_6707D8 = 0; // weak
int dword_6707F0 = 0; // weak
int dword_6707F4 = 0; // weak
int dword_67080C = 0; // weak
int dword_670810 = 0; // weak
int dword_670828 = 0; // weak
int dword_67082C = 0; // weak
int dword_670844 = 0; // weak
_UNKNOWN unk_670848; // weak
int dword_670860 = 0; // weak
char algn_670864[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67087C = 0; // weak
_UNKNOWN unk_670880; // weak
int dword_670898 = 0; // weak
_UNKNOWN unk_67089C; // weak
int dword_6708B4 = 0; // weak
_UNKNOWN unk_6708B8; // weak
int dword_6708D0 = 0; // weak
char algn_6708D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6708EC = 0; // weak
_UNKNOWN unk_6708F0; // weak
int dword_670908 = 0; // weak
_UNKNOWN unk_67090C; // weak
int dword_670924 = 0; // weak
_UNKNOWN unk_670928; // weak
int dword_670940 = 0; // weak
char algn_670944[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67095C = 0; // weak
_UNKNOWN unk_670960; // weak
int dword_670978 = 0; // weak
_UNKNOWN unk_67097C; // weak
int dword_670994 = 0; // weak
_UNKNOWN unk_670998; // weak
int dword_6709B0 = 0; // weak
char algn_6709B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6709CC = 0; // weak
_UNKNOWN unk_6709D0; // weak
int dword_6709E8 = 0; // weak
_UNKNOWN unk_6709EC; // weak
int dword_670A04 = 0; // weak
_UNKNOWN unk_670A08; // weak
int dword_670A20 = 0; // weak
char algn_670A24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670A3C = 0; // weak
_UNKNOWN unk_670A40; // weak
int dword_670A58 = 0; // weak
_UNKNOWN unk_670A5C; // weak
int dword_670A74 = 0; // weak
_UNKNOWN unk_670A78; // weak
int dword_670A90 = 0; // weak
char algn_670A94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670AAC = 0; // weak
_UNKNOWN unk_670AB0; // weak
int dword_670AC8 = 0; // weak
_UNKNOWN unk_670ACC; // weak
int dword_670AE4 = 0; // weak
_UNKNOWN unk_670AE8; // weak
int dword_670B00 = 0; // weak
char algn_670B04[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670B1C = 0; // weak
_UNKNOWN unk_670B20; // weak
int dword_670B38 = 0; // weak
_UNKNOWN unk_670B3C; // weak
int dword_670B54 = 0; // weak
_UNKNOWN unk_670B58; // weak
int dword_670B70 = 0; // weak
char algn_670B74[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670B8C = 0; // weak
int dword_670B90 = 0; // weak
int dword_670BA8 = 0; // weak
_UNKNOWN unk_670BAC; // weak
int dword_670BC4 = 0; // weak
int dword_670BC8 = 0; // weak
int dword_670BE0 = 0; // weak
char algn_670BE4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670BFC = 0; // weak
int dword_670C00 = 0; // weak
int dword_670C18 = 0; // weak
_UNKNOWN unk_670C1C; // weak
int dword_670C34 = 0; // weak
int dword_670C38 = 0; // weak
int dword_670C50 = 0; // weak
char algn_670C54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670C6C = 0; // weak
int dword_670C70 = 0; // weak
int dword_670C88 = 0; // weak
_UNKNOWN unk_670C8C; // weak
int dword_670CA4 = 0; // weak
int dword_670CA8 = 0; // weak
int dword_670CC0 = 0; // weak
char algn_670CC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670CDC = 0; // weak
int dword_670CE0 = 0; // weak
int dword_670CF8 = 0; // weak
_UNKNOWN unk_670CFC; // weak
int dword_670D14 = 0; // weak
int dword_670D18 = 0; // weak
int dword_670D30 = 0; // weak
char algn_670D34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670D4C = 0; // weak
_UNKNOWN unk_670D50; // weak
int dword_670D68 = 0; // weak
_UNKNOWN unk_670D6C; // weak
int dword_670D84 = 0; // weak
_UNKNOWN unk_670D88; // weak
int dword_670DA0 = 0; // weak
char algn_670DA4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_670DBC = 0; // weak
_UNKNOWN unk_670DC0; // weak
int dword_670DD8 = 0; // weak
_UNKNOWN unk_670DDC; // weak
int dword_670DF4 = 0; // weak
_UNKNOWN unk_670DF8; // weak
int dword_670E10 = 0; // weak
char algn_670E14[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_670E2C[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_670E48[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_670E64[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_670E80[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_670E9C[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_670EB8[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_670ED4[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_670EF0[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_670F0C[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_670F28[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_670F44[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_670F60[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_670F7C[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_670F98[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_670FB4[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_670FD0[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_670FEC[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_671008[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_671024[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_671040[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_67105C[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_671078[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_671094 = 0; // weak
_UNKNOWN unk_671098; // weak
_DWORD dword_6710B0[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_6710CC[9] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0 }; // idb
int dword_6710F0 = 0; // weak
int dword_6710F4 = 0; // weak
_DWORD dword_67110C = 0; // idb
int dword_671110 = 0; // weak
int dword_671128 = 0; // weak
int dword_67112C = 0; // weak
int dword_671144 = 0; // weak
int dword_671148 = 0; // weak
int dword_671160 = 0; // weak
int dword_671164 = 0; // weak
_DWORD dword_67117C = 0; // idb
int dword_671180 = 0; // weak
_DWORD dword_671198 = 0; // idb
int dword_67119C = 0; // weak
_DWORD dword_6711B4 = 0; // idb
int dword_6711B8 = 0; // weak
_DWORD dword_6711D0 = 0; // idb
int dword_6711D4 = 0; // weak
_DWORD dword_6711EC = 0; // idb
int dword_6711F0 = 0; // weak
int dword_671208 = 0; // weak
int dword_67120C = 0; // weak
int dword_671224 = 0; // weak
int dword_671228 = 0; // weak
int dword_671240 = 0; // weak
int dword_671244 = 0; // weak
int dword_67125C = 0; // weak
int dword_671260 = 0; // weak
int dword_671278 = 0; // weak
int dword_67127C = 0; // weak
int dword_671294 = 0; // weak
int dword_671298 = 0; // weak
int dword_6712B0 = 0; // weak
int dword_6712B4 = 0; // weak
int dword_6712CC = 0; // weak
_UNKNOWN unk_6712D0; // weak
int dword_6712E8 = 0; // weak
_UNKNOWN unk_6712EC; // weak
int dword_671304 = 0; // weak
_UNKNOWN unk_671308; // weak
int dword_671320 = 0; // weak
char algn_671324[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67133C = 0; // weak
_UNKNOWN unk_671340; // weak
int dword_671358 = 0; // weak
_UNKNOWN unk_67135C; // weak
int dword_671374 = 0; // weak
_UNKNOWN unk_671378; // weak
int dword_671390 = 0; // weak
char algn_671394[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6713AC = 0; // weak
_UNKNOWN unk_6713B0; // weak
int dword_6713C8 = 0; // weak
_UNKNOWN unk_6713CC; // weak
int dword_6713E4 = 0; // weak
_UNKNOWN unk_6713E8; // weak
int dword_671400 = 0; // weak
char algn_671404[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67141C = 0; // weak
_UNKNOWN unk_671420; // weak
int dword_671438 = 0; // weak
_UNKNOWN unk_67143C; // weak
int dword_671454 = 0; // weak
_UNKNOWN unk_671458; // weak
int dword_671470 = 0; // weak
char algn_671474[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67148C = 0; // weak
_UNKNOWN unk_671490; // weak
int dword_6714A8 = 0; // weak
_UNKNOWN unk_6714AC; // weak
int dword_6714C4 = 0; // weak
_UNKNOWN unk_6714C8; // weak
int dword_6714E0 = 0; // weak
char algn_6714E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6714FC = 0; // weak
_UNKNOWN unk_671500; // weak
int dword_671518 = 0; // weak
_UNKNOWN unk_67151C; // weak
int dword_671534 = 0; // weak
_UNKNOWN unk_671538; // weak
int dword_671550 = 0; // weak
char algn_671554[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67156C = 0; // weak
_UNKNOWN unk_671570; // weak
int dword_671588 = 0; // weak
_UNKNOWN unk_67158C; // weak
int dword_6715A4 = 0; // weak
_UNKNOWN unk_6715A8; // weak
int dword_6715C0 = 0; // weak
char algn_6715C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6715DC = 0; // weak
_UNKNOWN unk_6715E0; // weak
int dword_6715F8 = 0; // weak
_UNKNOWN unk_6715FC; // weak
int dword_671614 = 0; // weak
int dword_671618 = 0; // weak
int dword_671630 = 0; // weak
char algn_671634[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67164C = 0; // weak
int dword_671650 = 0; // weak
int dword_671668 = 0; // weak
_UNKNOWN unk_67166C; // weak
int dword_671684 = 0; // weak
int dword_671688 = 0; // weak
int dword_6716A0 = 0; // weak
char algn_6716A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6716BC = 0; // weak
int dword_6716C0 = 0; // weak
int dword_6716D8 = 0; // weak
_UNKNOWN unk_6716DC; // weak
int dword_6716F4 = 0; // weak
int dword_6716F8 = 0; // weak
int dword_671710 = 0; // weak
char algn_671714[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67172C = 0; // weak
int dword_671730 = 0; // weak
int dword_671748 = 0; // weak
_UNKNOWN unk_67174C; // weak
int dword_671764 = 0; // weak
int dword_671768 = 0; // weak
int dword_671780 = 0; // weak
char algn_671784[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67179C = 0; // weak
int dword_6717A0 = 0; // weak
int dword_6717B8 = 0; // weak
_UNKNOWN unk_6717BC; // weak
int dword_6717D4 = 0; // weak
_UNKNOWN unk_6717D8; // weak
int dword_6717F0 = 0; // weak
char algn_6717F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67180C = 0; // weak
_UNKNOWN unk_671810; // weak
int dword_671828 = 0; // weak
_UNKNOWN unk_67182C; // weak
int dword_671844 = 0; // weak
_UNKNOWN unk_671848; // weak
int dword_671860 = 0; // weak
char algn_671864[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67187C = 0; // weak
_UNKNOWN unk_671880; // weak
int dword_671898 = 0; // weak
_UNKNOWN unk_67189C; // weak
_DWORD dword_6718B4[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_6718D0[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_6718EC[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_671908[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_671924[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_671940[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_67195C[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_671978[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_671994[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_6719B0[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_6719CC[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_6719E8[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_671A04[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_671A20[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_671A3C[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_671A58[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_671A74[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_671A90[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_671AAC[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_671AC8[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_671AE4[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_671B00[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_671B1C = 0; // weak
_UNKNOWN unk_671B20; // weak
_DWORD dword_671B38[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_671B54[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
_DWORD dword_671B70 = 0; // idb
int dword_671B74 = 0; // weak
int dword_671B8C = 0; // weak
int dword_671B90 = 0; // weak
_DWORD dword_671BA8 = 0; // idb
int dword_671BAC = 0; // weak
_DWORD dword_671BC4 = 0; // idb
int dword_671BC8 = 0; // weak
_DWORD dword_671BE0 = 0; // idb
int dword_671BE4 = 0; // weak
int dword_671BFC = 0; // weak
int dword_671C00 = 0; // weak
int dword_671C18 = 0; // weak
int dword_671C1C = 0; // weak
int dword_671C34 = 0; // weak
int dword_671C38 = 0; // weak
int dword_671C50 = 0; // weak
int dword_671C54 = 0; // weak
int dword_671C6C = 0; // weak
int dword_671C70 = 0; // weak
int dword_671C88 = 0; // weak
int dword_671C8C = 0; // weak
int dword_671CA4 = 0; // weak
int dword_671CA8 = 0; // weak
int dword_671CC0 = 0; // weak
int dword_671CC4 = 0; // weak
int dword_671CDC = 0; // weak
int dword_671CE0 = 0; // weak
int dword_671D00 = 0; // weak
_UNKNOWN unk_671D04; // weak
int dword_671D1C = 0; // weak
_UNKNOWN unk_671D20; // weak
int dword_671D38 = 0; // weak
_UNKNOWN unk_671D3C; // weak
int dword_671D54 = 0; // weak
_UNKNOWN unk_671D58; // weak
int dword_671D70 = 0; // weak
_UNKNOWN unk_671D74; // weak
int dword_671D8C = 0; // weak
char algn_671D90[16] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_671DA8 = 0; // weak
_UNKNOWN unk_671DAC; // weak
int dword_671DC4 = 0; // weak
_UNKNOWN unk_671DC8; // weak
int dword_671DE0 = 0; // weak
_UNKNOWN unk_671DE4; // weak
int dword_671DFC = 0; // weak
_UNKNOWN unk_671E00; // weak
int dword_671E18 = 0; // weak
_UNKNOWN unk_671E1C; // weak
int dword_671E34 = 0; // weak
_UNKNOWN unk_671E38; // weak
int dword_671E50 = 0; // weak
char algn_671E54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_671E6C = 0; // weak
_UNKNOWN unk_671E70; // weak
int dword_671E88 = 0; // weak
_UNKNOWN unk_671E8C; // weak
int dword_671EA4 = 0; // weak
int dword_671EA8 = 0; // weak
int dword_671EC0 = 0; // weak
char algn_671EC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_671EDC = 0; // weak
int dword_671EE0 = 0; // weak
int dword_671EF8 = 0; // weak
_UNKNOWN unk_671EFC; // weak
int dword_671F14 = 0; // weak
int dword_671F18 = 0; // weak
int dword_671F30 = 0; // weak
char algn_671F34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_671F4C = 0; // weak
int dword_671F50 = 0; // weak
int dword_671F68 = 0; // weak
_UNKNOWN unk_671F6C; // weak
int dword_671F84 = 0; // weak
int dword_671F88 = 0; // weak
int dword_671FA0 = 0; // weak
char algn_671FA4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_671FBC = 0; // weak
int dword_671FC0 = 0; // weak
int dword_671FD8 = 0; // weak
_UNKNOWN unk_671FDC; // weak
int dword_671FF4 = 0; // weak
int dword_671FF8 = 0; // weak
int dword_672010 = 0; // weak
char algn_672014[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67202C = 0; // weak
_UNKNOWN unk_672030; // weak
int dword_672048 = 0; // weak
_UNKNOWN unk_67204C; // weak
int dword_672064 = 0; // weak
int dword_672068 = 0; // weak
int dword_672080 = 0; // weak
char algn_672084[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67209C = 0; // weak
int dword_6720A0 = 0; // weak
int dword_6720B8 = 0; // weak
_UNKNOWN unk_6720BC; // weak
int dword_6720D4 = 0; // weak
_UNKNOWN unk_6720D8; // weak
int dword_6720F0 = 0; // weak
char algn_6720F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67210C = 0; // weak
_UNKNOWN unk_672110; // weak
int dword_672128 = 0; // weak
_UNKNOWN unk_67212C; // weak
_DWORD dword_672144[7] = { 0, 0, 0, 0, 3, 6556248, 4644756 }; // idb
_DWORD dword_672160[7] = { 0, 0, 0, 0, 4, 6556264, 4678160 }; // idb
_DWORD dword_67217C[7] = { 0, 0, 0, 0, 3, 6556280, 4646144 }; // idb
_DWORD dword_672198[7] = { 0, 0, 0, 0, 4, 6556296, 4685720 }; // idb
_DWORD dword_6721B4[7] = { 0, 0, 0, 0, 4, 6556312, 4661812 }; // idb
_DWORD dword_6721D0[7] = { 0, 0, 0, 0, 3, 6556332, 4660664 }; // idb
_DWORD dword_6721EC[7] = { 0, 0, 0, 0, 3, 6556352, 4659312 }; // idb
_DWORD dword_672208[7] = { 0, 0, 0, 0, 4, 6556368, 4654408 }; // idb
_DWORD off_672224[7] = { 0, 0, 0, 0, 0, 6556388, 4656108 }; // idb
_DWORD off_672240[7] = { 0, 0, 0, 0, 0, 6556404, 4657524 }; // idb
_DWORD dword_67225C[7] = { 0, 0, 0, 0, 4, 6556420, 4658816 }; // idb
_DWORD dword_672278[7] = { 0, 0, 0, 0, 4, 6556440, 4706080 }; // idb
_DWORD dword_672294[7] = { 0, 0, 0, 0, 4, 6556460, 4703052 }; // idb
_DWORD dword_6722B0[7] = { 0, 0, 0, 0, 4, 6556476, 4670132 }; // idb
_DWORD off_6722CC[7] = { 0, 0, 0, 0, 0, 6556488, 4665772 }; // idb
_DWORD off_6722E8[7] = { 0, 0, 0, 0, 0, 6556504, 4650832 }; // idb
_DWORD dword_672304[7] = { 0, 0, 0, 0, 4, 6556516, 4654180 }; // idb
_DWORD dword_672320[7] = { 0, 0, 0, 0, 4, 6555960, 4696344 }; // idb
_DWORD dword_67233C[7] = { 0, 0, 0, 0, 4, 6556528, 4655136 }; // idb
_DWORD dword_672358[7] = { 0, 0, 0, 0, 3, 6556356, 4695436 }; // idb
_DWORD dword_672374[7] = { 0, 0, 0, 0, 4, 6556544, 4671516 }; // idb
_DWORD dword_672390[7] = { 0, 0, 0, 0, 4, 6556560, 4680228 }; // idb
int dword_6723AC = 0; // weak
_UNKNOWN unk_6723B0; // weak
_DWORD dword_6723C8[7] = { 0, 0, 0, 0, 4, 6556584, 4692352 }; // idb
_DWORD dword_6723E4[7] = { 0, 0, 0, 0, 4, 6556600, 4691572 }; // idb
_DWORD dword_672400 = 0; // idb
int dword_672404 = 0; // weak
int dword_67241C = 0; // weak
int dword_672420 = 0; // weak
int dword_672438 = 0; // weak
int dword_67243C = 0; // weak
int dword_672454 = 0; // weak
int dword_672458 = 0; // weak
_DWORD dword_672470 = 0; // idb
int dword_672474 = 0; // weak
_DWORD dword_67248C = 0; // idb
int dword_672490 = 0; // weak
_DWORD dword_6724A8 = 0; // idb
int dword_6724AC = 0; // weak
_DWORD dword_6724C4 = 0; // idb
int dword_6724C8 = 0; // weak
_DWORD dword_6724E0 = 0; // idb
int dword_6724E4 = 0; // weak
int dword_6724FC = 0; // weak
int dword_672500 = 0; // weak
int dword_672518 = 0; // weak
int dword_67251C = 0; // weak
int dword_672534 = 0; // weak
int dword_672538 = 0; // weak
int dword_672550 = 0; // weak
int dword_672554 = 0; // weak
int dword_67256C = 0; // weak
int dword_672570 = 0; // weak
int dword_672588 = 0; // weak
int dword_67258C = 0; // weak
int dword_6725A4 = 0; // weak
int dword_6725A8 = 0; // weak
int dword_6725C0 = 0; // weak
int dword_6725C4 = 0; // weak
int dword_6725E0 = 0; // weak
int dword_6725E4 = 0; // weak
int dword_6725FC = 0; // weak
_UNKNOWN unk_672600; // weak
int dword_672618 = 0; // weak
_UNKNOWN unk_67261C; // weak
int dword_672634 = 0; // weak
_UNKNOWN unk_672638; // weak
int dword_672650 = 0; // weak
char algn_672654[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67266C = 0; // weak
_UNKNOWN unk_672670; // weak
int dword_672688 = 0; // weak
_UNKNOWN unk_67268C; // weak
int dword_6726A4 = 0; // weak
_UNKNOWN unk_6726A8; // weak
int dword_6726C0 = 0; // weak
char algn_6726C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6726DC = 0; // weak
_UNKNOWN unk_6726E0; // weak
int dword_6726F8 = 0; // weak
_UNKNOWN unk_6726FC; // weak
int dword_672714 = 0; // weak
_UNKNOWN unk_672718; // weak
int dword_672730 = 0; // weak
char algn_672734[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67274C = 0; // weak
_UNKNOWN unk_672750; // weak
int dword_672768 = 0; // weak
_UNKNOWN unk_67276C; // weak
int dword_672784 = 0; // weak
_UNKNOWN unk_672788; // weak
int dword_6727A0 = 0; // weak
char algn_6727A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6727BC = 0; // weak
_UNKNOWN unk_6727C0; // weak
int dword_6727D8 = 0; // weak
_UNKNOWN unk_6727DC; // weak
int dword_6727F4 = 0; // weak
_UNKNOWN unk_6727F8; // weak
int dword_672810 = 0; // weak
char algn_672814[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67282C = 0; // weak
_UNKNOWN unk_672830; // weak
int dword_672848 = 0; // weak
_UNKNOWN unk_67284C; // weak
int dword_672864 = 0; // weak
_UNKNOWN unk_672868; // weak
int dword_672880 = 0; // weak
char algn_672884[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67289C = 0; // weak
_UNKNOWN unk_6728A0; // weak
int dword_6728B8 = 0; // weak
_UNKNOWN unk_6728BC; // weak
int dword_6728D4 = 0; // weak
_UNKNOWN unk_6728D8; // weak
int dword_6728F0 = 0; // weak
char algn_6728F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67290C = 0; // weak
_UNKNOWN unk_672910; // weak
int dword_672928 = 0; // weak
_UNKNOWN unk_67292C; // weak
int dword_672944 = 0; // weak
int dword_672948 = 0; // weak
int dword_672960 = 0; // weak
char algn_672964[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67297C = 0; // weak
int dword_672980 = 0; // weak
int dword_672998 = 0; // weak
_UNKNOWN unk_67299C; // weak
int dword_6729B4 = 0; // weak
int dword_6729B8 = 0; // weak
int dword_6729D0 = 0; // weak
char algn_6729D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6729EC = 0; // weak
int dword_6729F0 = 0; // weak
int dword_672A08 = 0; // weak
_UNKNOWN unk_672A0C; // weak
int dword_672A24 = 0; // weak
int dword_672A28 = 0; // weak
int dword_672A40 = 0; // weak
char algn_672A44[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_672A5C = 0; // weak
int dword_672A60 = 0; // weak
int dword_672A78 = 0; // weak
_UNKNOWN unk_672A7C; // weak
int dword_672A94 = 0; // weak
int dword_672A98 = 0; // weak
int dword_672AB0 = 0; // weak
char algn_672AB4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_672ACC = 0; // weak
int dword_672AD0 = 0; // weak
int dword_672AE8 = 0; // weak
_UNKNOWN unk_672AEC; // weak
int dword_672B04 = 0; // weak
_UNKNOWN unk_672B08; // weak
int dword_672B20 = 0; // weak
char algn_672B24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_672B3C = 0; // weak
_UNKNOWN unk_672B40; // weak
int dword_672B58 = 0; // weak
_UNKNOWN unk_672B5C; // weak
int dword_672B74 = 0; // weak
_UNKNOWN unk_672B78; // weak
int dword_672B90 = 0; // weak
char algn_672B94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_672BAC = 0; // weak
_UNKNOWN unk_672BB0; // weak
int dword_672BC8 = 0; // weak
_UNKNOWN unk_672BCC; // weak
_DWORD dword_672BE4[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_672C00[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_672C1C[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_672C38[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_672C54[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_672C70[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_672C8C[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_672CA8[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_672CC4[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_672CE0[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_672CFC[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_672D18[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_672D34[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_672D50[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_672D6C[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_672D88[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_672DA4[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_672DC0[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_672DDC[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_672DF8[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_672E14[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_672E30[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_672E4C = 0; // weak
_UNKNOWN unk_672E50; // weak
_DWORD dword_672E68[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_672E84[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
char *vpn_parms[3] = { "vpn_wan", "vpn_pwd", "vpn_user" }; // weak
char *l2tp_parms[6] =
{
  "l2tpd_en",
  "l2tpd_port",
  "l2tpd_stip",
  "l2tpd_endip",
  "l2tpd_dns1",
  "l2tpd_dns2"
}; // weak
char *pptp_parms[8] =
{
  "pptpd_en",
  "pptpd_port",
  "pptpd_stip",
  "pptpd_endip",
  "pptpd_dns1",
  "pptpd_dns2",
  "pptpd_ccp_en",
  "pptpd_mppe_en"
}; // weak
int dword_672F40 = 0; // weak
int dword_672F44 = 0; // weak
_DWORD dword_672F5C = 0; // idb
int dword_672F60 = 0; // weak
int dword_672F78 = 0; // weak
int dword_672F7C = 0; // weak
int dword_672F94 = 0; // weak
int dword_672F98 = 0; // weak
int dword_672FB0 = 0; // weak
int dword_672FB4 = 0; // weak
_DWORD dword_672FCC = 0; // idb
int dword_672FD0 = 0; // weak
_DWORD dword_672FE8 = 0; // idb
int dword_672FEC = 0; // weak
_DWORD dword_673004 = 0; // idb
int dword_673008 = 0; // weak
_DWORD dword_673020 = 0; // idb
int dword_673024 = 0; // weak
_DWORD dword_67303C = 0; // idb
int dword_673040 = 0; // weak
int dword_673058 = 0; // weak
int dword_67305C = 0; // weak
int dword_673074 = 0; // weak
int dword_673078 = 0; // weak
int dword_673090 = 0; // weak
int dword_673094 = 0; // weak
int dword_6730AC = 0; // weak
int dword_6730B0 = 0; // weak
int dword_6730C8 = 0; // weak
int dword_6730CC = 0; // weak
int dword_6730E4 = 0; // weak
int dword_6730E8 = 0; // weak
int dword_673100 = 0; // weak
int dword_673104 = 0; // weak
_DWORD dword_67311C[7] = { 0, 0, 0, 0, 4, 6556616, 4638292 }; // idb
int dword_673138 = 0; // weak
int dword_67313C = 0; // weak
int dword_673154 = 0; // weak
int dword_673158 = 0; // weak
int dword_673170 = 0; // weak
int dword_673174 = 0; // weak
int dword_67318C = 0; // weak
int dword_673190 = 0; // weak
int dword_6731A8 = 0; // weak
int dword_6731AC = 0; // weak
int dword_6731C4 = 0; // weak
_UNKNOWN unk_6731C8; // weak
int dword_6731E0 = 0; // weak
int dword_6731E4 = 0; // weak
int dword_6731FC = 0; // weak
int dword_673200 = 0; // weak
int dword_673218 = 0; // weak
int dword_67321C = 0; // weak
int dword_673234 = 0; // weak
int dword_673238 = 0; // weak
_DWORD dword_673250 = 0; // idb
int dword_673254 = 0; // weak
_DWORD dword_67326C = 0; // idb
int dword_673270 = 0; // weak
_DWORD dword_673288 = 0; // idb
int dword_67328C = 0; // weak
_DWORD dword_6732A4 = 0; // idb
int dword_6732A8 = 0; // weak
_DWORD dword_6732C0 = 0; // idb
int dword_6732C4 = 0; // weak
_DWORD dword_6732DC = 0; // idb
int dword_6732E0 = 0; // weak
_DWORD dword_6732F8 = 0; // idb
int dword_6732FC = 0; // weak
_DWORD dword_673314 = 0; // idb
int dword_673318 = 0; // weak
_DWORD dword_673330 = 0; // idb
int dword_673334 = 0; // weak
_DWORD dword_67334C = 0; // idb
int dword_673350 = 0; // weak
_DWORD dword_673368 = 0; // idb
int dword_67336C = 0; // weak
_DWORD dword_673384 = 0; // idb
int dword_673388 = 0; // weak
int dword_6733A0 = 0; // weak
char algn_6733A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6733BC = 0; // weak
_UNKNOWN unk_6733C0; // weak
int dword_6733D8 = 0; // weak
_UNKNOWN unk_6733DC; // weak
int dword_6733F4 = 0; // weak
_UNKNOWN unk_6733F8; // weak
int dword_673410 = 0; // weak
char algn_673414[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67342C = 0; // weak
_UNKNOWN unk_673430; // weak
int dword_673448 = 0; // weak
_UNKNOWN unk_67344C; // weak
int dword_673464 = 0; // weak
_UNKNOWN unk_673468; // weak
int dword_673480 = 0; // weak
char algn_673484[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67349C = 0; // weak
_UNKNOWN unk_6734A0; // weak
int dword_6734B8 = 0; // weak
_UNKNOWN unk_6734BC; // weak
int dword_6734D4 = 0; // weak
_UNKNOWN unk_6734D8; // weak
int dword_6734F0 = 0; // weak
char algn_6734F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67350C = 0; // weak
_UNKNOWN unk_673510; // weak
int dword_673528 = 0; // weak
_UNKNOWN unk_67352C; // weak
int dword_673544 = 0; // weak
_UNKNOWN unk_673548; // weak
int dword_673560 = 0; // weak
char algn_673564[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67357C = 0; // weak
_UNKNOWN unk_673580; // weak
int dword_673598 = 0; // weak
_UNKNOWN unk_67359C; // weak
int dword_6735B4 = 0; // weak
_UNKNOWN unk_6735B8; // weak
int dword_6735D0 = 0; // weak
char algn_6735D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6735EC = 0; // weak
_UNKNOWN unk_6735F0; // weak
int dword_673608 = 0; // weak
_UNKNOWN unk_67360C; // weak
int dword_673624 = 0; // weak
_UNKNOWN unk_673628; // weak
int dword_673640 = 0; // weak
char algn_673644[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67365C = 0; // weak
_UNKNOWN unk_673660; // weak
int dword_673678 = 0; // weak
_UNKNOWN unk_67367C; // weak
int dword_673694 = 0; // weak
_UNKNOWN unk_673698; // weak
int dword_6736B0 = 0; // weak
char algn_6736B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6736CC = 0; // weak
_UNKNOWN unk_6736D0; // weak
int dword_6736E8 = 0; // weak
int dword_6736EC = 0; // weak
int dword_673704 = 0; // weak
_UNKNOWN unk_673708; // weak
int dword_673720 = 0; // weak
int dword_673724 = 0; // weak
int dword_67373C = 0; // weak
_UNKNOWN unk_673740; // weak
int dword_673758 = 0; // weak
int dword_67375C = 0; // weak
int dword_673774 = 0; // weak
_UNKNOWN unk_673778; // weak
int dword_673790 = 0; // weak
int dword_673794 = 0; // weak
int dword_6737AC = 0; // weak
_UNKNOWN unk_6737B0; // weak
int dword_6737C8 = 0; // weak
int dword_6737CC = 0; // weak
int dword_6737E4 = 0; // weak
_UNKNOWN unk_6737E8; // weak
int dword_673800 = 0; // weak
int dword_673804 = 0; // weak
int dword_67381C = 0; // weak
_UNKNOWN unk_673820; // weak
int dword_673838 = 0; // weak
int dword_67383C = 0; // weak
int dword_673854 = 0; // weak
_UNKNOWN unk_673858; // weak
int dword_673870 = 0; // weak
int dword_673874 = 0; // weak
int dword_67388C = 0; // weak
_UNKNOWN unk_673890; // weak
int dword_6738A8 = 0; // weak
_UNKNOWN unk_6738AC; // weak
int dword_6738C4 = 0; // weak
_UNKNOWN unk_6738C8; // weak
int dword_6738E0 = 0; // weak
char algn_6738E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6738FC = 0; // weak
_UNKNOWN unk_673900; // weak
int dword_673918 = 0; // weak
_UNKNOWN unk_67391C; // weak
int dword_673934 = 0; // weak
_UNKNOWN unk_673938; // weak
int dword_673950 = 0; // weak
char algn_673954[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67396C = 0; // weak
_UNKNOWN unk_673970; // weak
_DWORD dword_673988[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_6739A4[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_6739C0[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_6739DC[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_6739F8[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_673A14[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_673A30[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_673A4C[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_673A68[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_673A84[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_673AA0[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_673ABC[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_673AD8[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_673AF4[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_673B10[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_673B2C[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_673B48[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_673B64[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_673B80[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_673B9C[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_673BB8[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_673BD4[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_673BF0 = 0; // weak
char algn_673BF4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_673C0C[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_673C28[10] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0, 0 }; // idb
int dword_673C50 = 0; // weak
int dword_673C54 = 0; // weak
int dword_673C6C = 0; // weak
_UNKNOWN unk_673C70; // weak
int dword_673C88 = 0; // weak
_UNKNOWN unk_673C8C; // weak
int dword_673CA4 = 0; // weak
_UNKNOWN unk_673CA8; // weak
int dword_673CC0 = 0; // weak
char algn_673CC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_673CDC = 0; // weak
_UNKNOWN unk_673CE0; // weak
int dword_673CF8 = 0; // weak
_UNKNOWN unk_673CFC; // weak
int dword_673D14 = 0; // weak
_UNKNOWN unk_673D18; // weak
int dword_673D30 = 0; // weak
char algn_673D34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_673D4C = 0; // weak
_UNKNOWN unk_673D50; // weak
int dword_673D68 = 0; // weak
_UNKNOWN unk_673D6C; // weak
int dword_673D84 = 0; // weak
_UNKNOWN unk_673D88; // weak
int dword_673DA0 = 0; // weak
char algn_673DA4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_673DBC = 0; // weak
_UNKNOWN unk_673DC0; // weak
int dword_673DD8 = 0; // weak
_UNKNOWN unk_673DDC; // weak
int dword_673DF4 = 0; // weak
_UNKNOWN unk_673DF8; // weak
int dword_673E10 = 0; // weak
char algn_673E14[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_673E2C = 0; // weak
_UNKNOWN unk_673E30; // weak
int dword_673E48 = 0; // weak
_UNKNOWN unk_673E4C; // weak
int dword_673E64 = 0; // weak
_UNKNOWN unk_673E68; // weak
int dword_673E80 = 0; // weak
char algn_673E84[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_673E9C = 0; // weak
_UNKNOWN unk_673EA0; // weak
int dword_673EB8 = 0; // weak
_UNKNOWN unk_673EBC; // weak
int dword_673ED4 = 0; // weak
_UNKNOWN unk_673ED8; // weak
int dword_673EF0 = 0; // weak
char algn_673EF4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_673F0C = 0; // weak
_UNKNOWN unk_673F10; // weak
int dword_673F28 = 0; // weak
_UNKNOWN unk_673F2C; // weak
int dword_673F44 = 0; // weak
_UNKNOWN unk_673F48; // weak
int dword_673F60 = 0; // weak
char algn_673F64[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_673F7C = 0; // weak
_UNKNOWN unk_673F80; // weak
int dword_673F98 = 0; // weak
_UNKNOWN unk_673F9C; // weak
int dword_673FB4 = 0; // weak
int dword_673FB8 = 0; // weak
int dword_673FD0 = 0; // weak
char algn_673FD4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_673FEC = 0; // weak
int dword_673FF0 = 0; // weak
int dword_674008 = 0; // weak
_UNKNOWN unk_67400C; // weak
int dword_674024 = 0; // weak
int dword_674028 = 0; // weak
int dword_674040 = 0; // weak
char algn_674044[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67405C = 0; // weak
int dword_674060 = 0; // weak
int dword_674078 = 0; // weak
_UNKNOWN unk_67407C; // weak
int dword_674094 = 0; // weak
int dword_674098 = 0; // weak
int dword_6740B0 = 0; // weak
char algn_6740B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6740CC = 0; // weak
int dword_6740D0 = 0; // weak
int dword_6740E8 = 0; // weak
_UNKNOWN unk_6740EC; // weak
int dword_674104 = 0; // weak
int dword_674108 = 0; // weak
int dword_674120 = 0; // weak
char algn_674124[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67413C = 0; // weak
int dword_674140 = 0; // weak
int dword_674158 = 0; // weak
_UNKNOWN unk_67415C; // weak
int dword_674174 = 0; // weak
_UNKNOWN unk_674178; // weak
int dword_674190 = 0; // weak
char algn_674194[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6741AC = 0; // weak
_UNKNOWN unk_6741B0; // weak
int dword_6741C8 = 0; // weak
_UNKNOWN unk_6741CC; // weak
int dword_6741E4 = 0; // weak
_UNKNOWN unk_6741E8; // weak
int dword_674200 = 0; // weak
char algn_674204[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67421C = 0; // weak
_UNKNOWN unk_674220; // weak
int dword_674238 = 0; // weak
_UNKNOWN unk_67423C; // weak
_DWORD dword_674254[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_674270[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_67428C[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_6742A8[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_6742C4[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_6742E0[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_6742FC[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_674318[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_674334[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_674350[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_67436C[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_674388[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_6743A4[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_6743C0[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_6743DC[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_6743F8[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_674414[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_674430[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_67444C[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_674468[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_674484[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_6744A0[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_6744BC = 0; // weak
_UNKNOWN unk_6744C0; // weak
_DWORD dword_6744D8[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_6744F4[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
_DWORD dword_674510 = 0; // idb
int dword_674514 = 0; // weak
int dword_67452C = 0; // weak
int dword_674530 = 0; // weak
int dword_674548 = 0; // weak
int dword_67454C = 0; // weak
int dword_674564 = 0; // weak
int dword_674568 = 0; // weak
_DWORD dword_674580 = 0; // idb
int dword_674584 = 0; // weak
_DWORD dword_67459C = 0; // idb
int dword_6745A0 = 0; // weak
_DWORD dword_6745B8 = 0; // idb
int dword_6745BC = 0; // weak
_DWORD dword_6745D4 = 0; // idb
int dword_6745D8 = 0; // weak
_DWORD dword_6745F0 = 0; // idb
int dword_6745F4 = 0; // weak
int dword_67460C = 0; // weak
int dword_674610 = 0; // weak
int dword_674628 = 0; // weak
int dword_67462C = 0; // weak
int dword_674644 = 0; // weak
int dword_674648 = 0; // weak
int dword_674660 = 0; // weak
int dword_674664 = 0; // weak
int dword_67467C = 0; // weak
int dword_674680 = 0; // weak
int dword_674698 = 0; // weak
int dword_67469C = 0; // weak
int dword_6746B4 = 0; // weak
int dword_6746B8 = 0; // weak
int dword_6746D0 = 0; // weak
int dword_6746D4 = 0; // weak
int dword_6746EC = 0; // weak
_UNKNOWN unk_6746F0; // weak
int dword_674708 = 0; // weak
_UNKNOWN unk_67470C; // weak
int dword_674724 = 0; // weak
_UNKNOWN unk_674728; // weak
int dword_674740 = 0; // weak
char algn_674744[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67475C = 0; // weak
_UNKNOWN unk_674760; // weak
int dword_674778 = 0; // weak
_UNKNOWN unk_67477C; // weak
int dword_674794 = 0; // weak
_UNKNOWN unk_674798; // weak
int dword_6747B0 = 0; // weak
char algn_6747B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6747CC = 0; // weak
_UNKNOWN unk_6747D0; // weak
int dword_6747E8 = 0; // weak
_UNKNOWN unk_6747EC; // weak
int dword_674804 = 0; // weak
_UNKNOWN unk_674808; // weak
int dword_674820 = 0; // weak
char algn_674824[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67483C = 0; // weak
_UNKNOWN unk_674840; // weak
int dword_674858 = 0; // weak
_UNKNOWN unk_67485C; // weak
int dword_674874 = 0; // weak
_UNKNOWN unk_674878; // weak
int dword_674890 = 0; // weak
char algn_674894[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6748AC = 0; // weak
_UNKNOWN unk_6748B0; // weak
int dword_6748C8 = 0; // weak
_UNKNOWN unk_6748CC; // weak
int dword_6748E4 = 0; // weak
_UNKNOWN unk_6748E8; // weak
int dword_674900 = 0; // weak
char algn_674904[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67491C = 0; // weak
_UNKNOWN unk_674920; // weak
int dword_674938 = 0; // weak
_UNKNOWN unk_67493C; // weak
int dword_674954 = 0; // weak
_UNKNOWN unk_674958; // weak
int dword_674970 = 0; // weak
char algn_674974[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67498C = 0; // weak
_UNKNOWN unk_674990; // weak
int dword_6749A8 = 0; // weak
_UNKNOWN unk_6749AC; // weak
int dword_6749C4 = 0; // weak
_UNKNOWN unk_6749C8; // weak
int dword_6749E0 = 0; // weak
char algn_6749E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6749FC = 0; // weak
_UNKNOWN unk_674A00; // weak
int dword_674A18 = 0; // weak
_UNKNOWN unk_674A1C; // weak
int dword_674A34 = 0; // weak
int dword_674A38 = 0; // weak
int dword_674A50 = 0; // weak
char algn_674A54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_674A6C = 0; // weak
int dword_674A70 = 0; // weak
int dword_674A88 = 0; // weak
_UNKNOWN unk_674A8C; // weak
int dword_674AA4 = 0; // weak
int dword_674AA8 = 0; // weak
int dword_674AC0 = 0; // weak
char algn_674AC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_674ADC = 0; // weak
int dword_674AE0 = 0; // weak
int dword_674AF8 = 0; // weak
_UNKNOWN unk_674AFC; // weak
int dword_674B14 = 0; // weak
int dword_674B18 = 0; // weak
int dword_674B30 = 0; // weak
char algn_674B34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_674B4C = 0; // weak
int dword_674B50 = 0; // weak
int dword_674B68 = 0; // weak
_UNKNOWN unk_674B6C; // weak
int dword_674B84 = 0; // weak
int dword_674B88 = 0; // weak
int dword_674BA0 = 0; // weak
char algn_674BA4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_674BBC = 0; // weak
int dword_674BC0 = 0; // weak
int dword_674BD8 = 0; // weak
_UNKNOWN unk_674BDC; // weak
int dword_674BF4 = 0; // weak
_UNKNOWN unk_674BF8; // weak
int dword_674C10 = 0; // weak
char algn_674C14[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_674C2C = 0; // weak
_UNKNOWN unk_674C30; // weak
int dword_674C48 = 0; // weak
_UNKNOWN unk_674C4C; // weak
int dword_674C64 = 0; // weak
_UNKNOWN unk_674C68; // weak
int dword_674C80 = 0; // weak
char algn_674C84[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_674C9C = 0; // weak
_UNKNOWN unk_674CA0; // weak
int dword_674CB8 = 0; // weak
_UNKNOWN unk_674CBC; // weak
_DWORD dword_674CD4[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_674CF0[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_674D0C[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_674D28[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_674D44[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_674D60[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_674D7C[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_674D98[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_674DB4[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_674DD0[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_674DEC[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_674E08[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_674E24[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_674E40[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_674E5C[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_674E78[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_674E94[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_674EB0[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_674ECC[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_674EE8[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_674F04[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_674F20[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_674F3C = 0; // weak
_UNKNOWN unk_674F40; // weak
_DWORD dword_674F58[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_674F74[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
_DWORD dword_674F90 = 0; // idb
int dword_674F94 = 0; // weak
int dword_674FAC = 0; // weak
int dword_674FB0 = 0; // weak
int dword_674FC8 = 0; // weak
int dword_674FCC = 0; // weak
int dword_674FE4 = 0; // weak
int dword_674FE8 = 0; // weak
_DWORD dword_675000 = 0; // idb
int dword_675004 = 0; // weak
_DWORD dword_67501C = 0; // idb
int dword_675020 = 0; // weak
_DWORD dword_675038 = 0; // idb
int dword_67503C = 0; // weak
_DWORD dword_675054 = 0; // idb
int dword_675058 = 0; // weak
_DWORD dword_675070 = 0; // idb
int dword_675074 = 0; // weak
int dword_67508C = 0; // weak
int dword_675090 = 0; // weak
int dword_6750A8 = 0; // weak
int dword_6750AC = 0; // weak
int dword_6750C4 = 0; // weak
int dword_6750C8 = 0; // weak
int dword_6750E0 = 0; // weak
int dword_6750E4 = 0; // weak
int dword_6750FC = 0; // weak
int dword_675100 = 0; // weak
int dword_675118 = 0; // weak
int dword_67511C = 0; // weak
int dword_675134 = 0; // weak
int dword_675138 = 0; // weak
int dword_675150 = 0; // weak
char algn_675154[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67516C = 0; // weak
_UNKNOWN unk_675170; // weak
int dword_675188 = 0; // weak
_UNKNOWN unk_67518C; // weak
int dword_6751A4 = 0; // weak
_UNKNOWN unk_6751A8; // weak
int dword_6751C0 = 0; // weak
char algn_6751C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6751DC = 0; // weak
_UNKNOWN unk_6751E0; // weak
int dword_6751F8 = 0; // weak
_UNKNOWN unk_6751FC; // weak
int dword_675214 = 0; // weak
_UNKNOWN unk_675218; // weak
int dword_675230 = 0; // weak
char algn_675234[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67524C = 0; // weak
_UNKNOWN unk_675250; // weak
int dword_675268 = 0; // weak
_UNKNOWN unk_67526C; // weak
int dword_675284 = 0; // weak
_UNKNOWN unk_675288; // weak
int dword_6752A0 = 0; // weak
char algn_6752A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6752BC = 0; // weak
_UNKNOWN unk_6752C0; // weak
int dword_6752D8 = 0; // weak
_UNKNOWN unk_6752DC; // weak
int dword_6752F4 = 0; // weak
_UNKNOWN unk_6752F8; // weak
int dword_675310 = 0; // weak
char algn_675314[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67532C = 0; // weak
_UNKNOWN unk_675330; // weak
int dword_675348 = 0; // weak
_UNKNOWN unk_67534C; // weak
int dword_675364 = 0; // weak
_UNKNOWN unk_675368; // weak
int dword_675380 = 0; // weak
char algn_675384[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67539C = 0; // weak
_UNKNOWN unk_6753A0; // weak
int dword_6753B8 = 0; // weak
_UNKNOWN unk_6753BC; // weak
int dword_6753D4 = 0; // weak
_UNKNOWN unk_6753D8; // weak
int dword_6753F0 = 0; // weak
char algn_6753F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67540C = 0; // weak
_UNKNOWN unk_675410; // weak
int dword_675428 = 0; // weak
_UNKNOWN unk_67542C; // weak
int dword_675444 = 0; // weak
_UNKNOWN unk_675448; // weak
int dword_675460 = 0; // weak
char algn_675464[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67547C = 0; // weak
_UNKNOWN unk_675480; // weak
int dword_675498 = 0; // weak
int dword_67549C = 0; // weak
int dword_6754B4 = 0; // weak
_UNKNOWN unk_6754B8; // weak
int dword_6754D0 = 0; // weak
int dword_6754D4 = 0; // weak
int dword_6754EC = 0; // weak
_UNKNOWN unk_6754F0; // weak
int dword_675508 = 0; // weak
int dword_67550C = 0; // weak
int dword_675524 = 0; // weak
_UNKNOWN unk_675528; // weak
int dword_675540 = 0; // weak
int dword_675544 = 0; // weak
int dword_67555C = 0; // weak
_UNKNOWN unk_675560; // weak
int dword_675578 = 0; // weak
int dword_67557C = 0; // weak
int dword_675594 = 0; // weak
_UNKNOWN unk_675598; // weak
int dword_6755B0 = 0; // weak
int dword_6755B4 = 0; // weak
int dword_6755CC = 0; // weak
_UNKNOWN unk_6755D0; // weak
int dword_6755E8 = 0; // weak
int dword_6755EC = 0; // weak
int dword_675604 = 0; // weak
_UNKNOWN unk_675608; // weak
int dword_675620 = 0; // weak
int dword_675624 = 0; // weak
int dword_67563C = 0; // weak
_UNKNOWN unk_675640; // weak
int dword_675658 = 0; // weak
_UNKNOWN unk_67565C; // weak
int dword_675674 = 0; // weak
_UNKNOWN unk_675678; // weak
int dword_675690 = 0; // weak
char algn_675694[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6756AC = 0; // weak
_UNKNOWN unk_6756B0; // weak
int dword_6756C8 = 0; // weak
_UNKNOWN unk_6756CC; // weak
int dword_6756E4 = 0; // weak
_UNKNOWN unk_6756E8; // weak
int dword_675700 = 0; // weak
char algn_675704[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67571C = 0; // weak
_UNKNOWN unk_675720; // weak
_DWORD dword_675738[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_675754[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_675770[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_67578C[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_6757A8[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_6757C4[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_6757E0[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_6757FC[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_675818[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_675834[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_675850[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_67586C[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_675888[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_6758A4[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_6758C0[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_6758DC[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_6758F8[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_675914[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_675930[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_67594C[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_675968[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_675984[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_6759A0 = 0; // weak
char algn_6759A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_6759BC[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_6759D8[10] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0, 0 }; // idb
int dword_675A00 = 0; // weak
int dword_675A04 = 0; // weak
int dword_675A1C = 0; // weak
int dword_675A20 = 0; // weak
int dword_675A38 = 0; // weak
int dword_675A3C = 0; // weak
int dword_675A60 = 0; // weak
int dword_675A64 = 0; // weak
int dword_675A7C = 0; // weak
_UNKNOWN unk_675A80; // weak
int dword_675A98 = 0; // weak
_UNKNOWN unk_675A9C; // weak
int dword_675AB4 = 0; // weak
_UNKNOWN unk_675AB8; // weak
int dword_675AD0 = 0; // weak
char algn_675AD4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675AEC = 0; // weak
_UNKNOWN unk_675AF0; // weak
int dword_675B08 = 0; // weak
_UNKNOWN unk_675B0C; // weak
int dword_675B24 = 0; // weak
_UNKNOWN unk_675B28; // weak
int dword_675B40 = 0; // weak
char algn_675B44[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675B5C = 0; // weak
_UNKNOWN unk_675B60; // weak
int dword_675B78 = 0; // weak
_UNKNOWN unk_675B7C; // weak
int dword_675B94 = 0; // weak
_UNKNOWN unk_675B98; // weak
int dword_675BB0 = 0; // weak
char algn_675BB4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675BCC = 0; // weak
_UNKNOWN unk_675BD0; // weak
int dword_675BE8 = 0; // weak
_UNKNOWN unk_675BEC; // weak
int dword_675C04 = 0; // weak
_UNKNOWN unk_675C08; // weak
int dword_675C20 = 0; // weak
char algn_675C24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675C3C = 0; // weak
_UNKNOWN unk_675C40; // weak
int dword_675C58 = 0; // weak
_UNKNOWN unk_675C5C; // weak
int dword_675C74 = 0; // weak
_UNKNOWN unk_675C78; // weak
int dword_675C90 = 0; // weak
char algn_675C94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675CAC = 0; // weak
_UNKNOWN unk_675CB0; // weak
int dword_675CC8 = 0; // weak
_UNKNOWN unk_675CCC; // weak
int dword_675CE4 = 0; // weak
_UNKNOWN unk_675CE8; // weak
int dword_675D00 = 0; // weak
char algn_675D04[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675D1C = 0; // weak
_UNKNOWN unk_675D20; // weak
int dword_675D38 = 0; // weak
_UNKNOWN unk_675D3C; // weak
int dword_675D54 = 0; // weak
_UNKNOWN unk_675D58; // weak
int dword_675D70 = 0; // weak
char algn_675D74[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675D8C = 0; // weak
_UNKNOWN unk_675D90; // weak
int dword_675DA8 = 0; // weak
_UNKNOWN unk_675DAC; // weak
int dword_675DC4 = 0; // weak
int dword_675DC8 = 0; // weak
int dword_675DE0 = 0; // weak
char algn_675DE4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675DFC = 0; // weak
int dword_675E00 = 0; // weak
int dword_675E18 = 0; // weak
_UNKNOWN unk_675E1C; // weak
int dword_675E34 = 0; // weak
int dword_675E38 = 0; // weak
int dword_675E50 = 0; // weak
char algn_675E54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675E6C = 0; // weak
int dword_675E70 = 0; // weak
int dword_675E88 = 0; // weak
_UNKNOWN unk_675E8C; // weak
int dword_675EA4 = 0; // weak
int dword_675EA8 = 0; // weak
int dword_675EC0 = 0; // weak
char algn_675EC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675EDC = 0; // weak
int dword_675EE0 = 0; // weak
int dword_675EF8 = 0; // weak
_UNKNOWN unk_675EFC; // weak
int dword_675F14 = 0; // weak
int dword_675F18 = 0; // weak
int dword_675F30 = 0; // weak
char algn_675F34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675F4C = 0; // weak
int dword_675F50 = 0; // weak
int dword_675F68 = 0; // weak
_UNKNOWN unk_675F6C; // weak
int dword_675F84 = 0; // weak
_UNKNOWN unk_675F88; // weak
int dword_675FA0 = 0; // weak
char algn_675FA4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_675FBC = 0; // weak
_UNKNOWN unk_675FC0; // weak
int dword_675FD8 = 0; // weak
_UNKNOWN unk_675FDC; // weak
int dword_675FF4 = 0; // weak
_UNKNOWN unk_675FF8; // weak
int dword_676010 = 0; // weak
char algn_676014[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67602C = 0; // weak
_UNKNOWN unk_676030; // weak
int dword_676048 = 0; // weak
_UNKNOWN unk_67604C; // weak
_DWORD dword_676064[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_676080[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_67609C[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_6760B8[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_6760D4[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_6760F0[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_67610C[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_676128[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_676144[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_676160[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_67617C[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_676198[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_6761B4[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_6761D0[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_6761EC[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_676208[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_676224[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_676240[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_67625C[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_676278[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_676294[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_6762B0[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_6762CC = 0; // weak
_UNKNOWN unk_6762D0; // weak
_DWORD dword_6762E8[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_676304[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
_DWORD dword_676320 = 0; // idb
int dword_676324 = 0; // weak
int dword_67633C = 0; // weak
int dword_676340 = 0; // weak
int dword_676358 = 0; // weak
int dword_67635C = 0; // weak
int dword_676374 = 0; // weak
int dword_676378 = 0; // weak
_DWORD dword_676390 = 0; // idb
int dword_676394 = 0; // weak
_DWORD dword_6763AC = 0; // idb
int dword_6763B0 = 0; // weak
_DWORD dword_6763C8 = 0; // idb
int dword_6763CC = 0; // weak
_DWORD dword_6763E4 = 0; // idb
int dword_6763E8 = 0; // weak
_DWORD dword_676400 = 0; // idb
int dword_676404 = 0; // weak
int dword_67641C = 0; // weak
int dword_676420 = 0; // weak
int dword_676438 = 0; // weak
int dword_67643C = 0; // weak
int dword_676454 = 0; // weak
int dword_676458 = 0; // weak
int dword_676470 = 0; // weak
int dword_676474 = 0; // weak
int dword_67648C = 0; // weak
int dword_676490 = 0; // weak
int dword_6764A8 = 0; // weak
int dword_6764AC = 0; // weak
int dword_6764C4 = 0; // weak
int dword_6764C8 = 0; // weak
int dword_6764E0 = 0; // weak
int dword_6764E4 = 0; // weak
int dword_6764FC = 0; // weak
_UNKNOWN unk_676500; // weak
int dword_676518 = 0; // weak
_UNKNOWN unk_67651C; // weak
int dword_676534 = 0; // weak
_UNKNOWN unk_676538; // weak
int dword_676550 = 0; // weak
char algn_676554[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67656C = 0; // weak
_UNKNOWN unk_676570; // weak
int dword_676588 = 0; // weak
_UNKNOWN unk_67658C; // weak
int dword_6765A4 = 0; // weak
_UNKNOWN unk_6765A8; // weak
int dword_6765C0 = 0; // weak
char algn_6765C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6765DC = 0; // weak
_UNKNOWN unk_6765E0; // weak
int dword_6765F8 = 0; // weak
_UNKNOWN unk_6765FC; // weak
int dword_676614 = 0; // weak
_UNKNOWN unk_676618; // weak
int dword_676630 = 0; // weak
char algn_676634[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67664C = 0; // weak
_UNKNOWN unk_676650; // weak
int dword_676668 = 0; // weak
_UNKNOWN unk_67666C; // weak
int dword_676684 = 0; // weak
_UNKNOWN unk_676688; // weak
int dword_6766A0 = 0; // weak
char algn_6766A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6766BC = 0; // weak
_UNKNOWN unk_6766C0; // weak
int dword_6766D8 = 0; // weak
_UNKNOWN unk_6766DC; // weak
int dword_6766F4 = 0; // weak
_UNKNOWN unk_6766F8; // weak
int dword_676710 = 0; // weak
char algn_676714[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67672C = 0; // weak
_UNKNOWN unk_676730; // weak
int dword_676748 = 0; // weak
_UNKNOWN unk_67674C; // weak
int dword_676764 = 0; // weak
_UNKNOWN unk_676768; // weak
int dword_676780 = 0; // weak
char algn_676784[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67679C = 0; // weak
_UNKNOWN unk_6767A0; // weak
int dword_6767B8 = 0; // weak
_UNKNOWN unk_6767BC; // weak
int dword_6767D4 = 0; // weak
_UNKNOWN unk_6767D8; // weak
int dword_6767F0 = 0; // weak
char algn_6767F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67680C = 0; // weak
_UNKNOWN unk_676810; // weak
int dword_676828 = 0; // weak
_UNKNOWN unk_67682C; // weak
int dword_676844 = 0; // weak
int dword_676848 = 0; // weak
int dword_676860 = 0; // weak
char algn_676864[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67687C = 0; // weak
int dword_676880 = 0; // weak
int dword_676898 = 0; // weak
_UNKNOWN unk_67689C; // weak
int dword_6768B4 = 0; // weak
int dword_6768B8 = 0; // weak
int dword_6768D0 = 0; // weak
char algn_6768D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6768EC = 0; // weak
int dword_6768F0 = 0; // weak
int dword_676908 = 0; // weak
_UNKNOWN unk_67690C; // weak
int dword_676924 = 0; // weak
int dword_676928 = 0; // weak
int dword_676940 = 0; // weak
char algn_676944[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67695C = 0; // weak
int dword_676960 = 0; // weak
int dword_676978 = 0; // weak
_UNKNOWN unk_67697C; // weak
int dword_676994 = 0; // weak
int dword_676998 = 0; // weak
int dword_6769B0 = 0; // weak
char algn_6769B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6769CC = 0; // weak
int dword_6769D0 = 0; // weak
int dword_6769E8 = 0; // weak
_UNKNOWN unk_6769EC; // weak
int dword_676A04 = 0; // weak
_UNKNOWN unk_676A08; // weak
int dword_676A20 = 0; // weak
char algn_676A24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_676A3C = 0; // weak
_UNKNOWN unk_676A40; // weak
int dword_676A58 = 0; // weak
_UNKNOWN unk_676A5C; // weak
int dword_676A74 = 0; // weak
_UNKNOWN unk_676A78; // weak
int dword_676A90 = 0; // weak
char algn_676A94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_676AAC = 0; // weak
_UNKNOWN unk_676AB0; // weak
int dword_676AC8 = 0; // weak
_UNKNOWN unk_676ACC; // weak
_DWORD dword_676AE4[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_676B00[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_676B1C[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_676B38[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_676B54[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_676B70[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_676B8C[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_676BA8[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_676BC4[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_676BE0[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_676BFC[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_676C18[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_676C34[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_676C50[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_676C6C = 0; // idb
_UNKNOWN unk_676C70; // weak
_DWORD dword_676C88[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_676CA4[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_676CC0[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_676CDC[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_676CF8[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_676D14[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_676D30[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_676D4C = 0; // weak
_UNKNOWN unk_676D50; // weak
_UNKNOWN unk_676D68; // weak
_UNKNOWN unk_676D6C; // weak
_DWORD dword_676D84[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
_UNKNOWN unk_676DA0; // weak
_UNKNOWN unk_676E10; // weak
int dword_676E20 = 0; // weak
int dword_676E24 = 0; // weak
int dword_676E3C = 0; // weak
int dword_676E40 = 0; // weak
_DWORD dword_676E58[7] = { 0, 0, 0, 0, 1, 6552912, 4926964 }; // idb
int dword_676E74 = 0; // weak
int dword_676E78 = 0; // weak
int dword_676E90 = 0; // weak
int dword_676E94 = 0; // weak
int dword_676EAC = 0; // weak
int dword_676EB0 = 0; // weak
int dword_676EC8 = 0; // weak
int dword_676ECC = 0; // weak
int dword_676EE4 = 0; // weak
int dword_676EE8 = 0; // weak
int dword_676F00 = 0; // weak
int dword_676F04 = 0; // weak
int dword_676F1C = 0; // weak
int dword_676F20 = 0; // weak
int dword_676F38 = 0; // weak
int dword_676F3C = 0; // weak
_DWORD dword_676F54 = 0; // idb
int dword_676F58 = 0; // weak
_DWORD dword_676F70 = 0; // idb
int dword_676F74 = 0; // weak
_DWORD dword_676F8C = 0; // idb
int dword_676F90 = 0; // weak
_DWORD dword_676FA8 = 0; // idb
int dword_676FAC = 0; // weak
_DWORD dword_676FC4 = 0; // idb
int dword_676FC8 = 0; // weak
_DWORD dword_676FE0 = 0; // idb
int dword_676FE4 = 0; // weak
_DWORD dword_676FFC = 0; // idb
int dword_677000 = 0; // weak
_DWORD dword_677018 = 0; // idb
int dword_67701C = 0; // weak
_DWORD dword_677034 = 0; // idb
int dword_677038 = 0; // weak
_DWORD dword_677050 = 0; // idb
int dword_677054 = 0; // weak
int dword_67706C = 0; // weak
int dword_677070 = 0; // weak
int dword_677088 = 0; // weak
int dword_67708C = 0; // weak
int dword_6770A4 = 0; // weak
int dword_6770A8 = 0; // weak
int dword_6770C0 = 0; // weak
char algn_6770C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6770DC = 0; // weak
_UNKNOWN unk_6770E0; // weak
int dword_6770F8 = 0; // weak
_UNKNOWN unk_6770FC; // weak
int dword_677114 = 0; // weak
_UNKNOWN unk_677118; // weak
int dword_677130 = 0; // weak
char algn_677134[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67714C = 0; // weak
_UNKNOWN unk_677150; // weak
int dword_677168 = 0; // weak
_UNKNOWN unk_67716C; // weak
int dword_677184 = 0; // weak
_UNKNOWN unk_677188; // weak
int dword_6771A0 = 0; // weak
char algn_6771A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6771BC = 0; // weak
_UNKNOWN unk_6771C0; // weak
int dword_6771D8 = 0; // weak
_UNKNOWN unk_6771DC; // weak
int dword_6771F4 = 0; // weak
_UNKNOWN unk_6771F8; // weak
int dword_677210 = 0; // weak
char algn_677214[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67722C = 0; // weak
_UNKNOWN unk_677230; // weak
int dword_677248 = 0; // weak
_UNKNOWN unk_67724C; // weak
int dword_677264 = 0; // weak
_UNKNOWN unk_677268; // weak
int dword_677280 = 0; // weak
char algn_677284[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67729C = 0; // weak
_UNKNOWN unk_6772A0; // weak
int dword_6772B8 = 0; // weak
_UNKNOWN unk_6772BC; // weak
int dword_6772D4 = 0; // weak
_UNKNOWN unk_6772D8; // weak
int dword_6772F0 = 0; // weak
char algn_6772F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67730C = 0; // weak
_UNKNOWN unk_677310; // weak
int dword_677328 = 0; // weak
_UNKNOWN unk_67732C; // weak
int dword_677344 = 0; // weak
_UNKNOWN unk_677348; // weak
int dword_677360 = 0; // weak
_UNKNOWN unk_677364; // weak
int dword_67737C = 0; // weak
_UNKNOWN unk_677380; // weak
int dword_677398 = 0; // weak
_UNKNOWN unk_67739C; // weak
int dword_6773B4 = 0; // weak
_UNKNOWN unk_6773B8; // weak
int dword_6773D0 = 0; // weak
char algn_6773D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6773EC = 0; // weak
_UNKNOWN unk_6773F0; // weak
int dword_677408 = 0; // weak
int dword_67740C = 0; // weak
int dword_677424 = 0; // weak
_UNKNOWN unk_677428; // weak
int dword_677440 = 0; // weak
int dword_677444 = 0; // weak
int dword_67745C = 0; // weak
_UNKNOWN unk_677460; // weak
int dword_677478 = 0; // weak
int dword_67747C = 0; // weak
int dword_677494 = 0; // weak
_UNKNOWN unk_677498; // weak
int dword_6774B0 = 0; // weak
int dword_6774B4 = 0; // weak
int dword_6774CC = 0; // weak
_UNKNOWN unk_6774D0; // weak
int dword_6774E8 = 0; // weak
int dword_6774EC = 0; // weak
int dword_677504 = 0; // weak
_UNKNOWN unk_677508; // weak
int dword_677520 = 0; // weak
int dword_677524 = 0; // weak
int dword_67753C = 0; // weak
_UNKNOWN unk_677540; // weak
int dword_677558 = 0; // weak
int dword_67755C = 0; // weak
int dword_677574 = 0; // weak
_UNKNOWN unk_677578; // weak
int dword_677590 = 0; // weak
int dword_677594 = 0; // weak
int dword_6775AC = 0; // weak
_UNKNOWN unk_6775B0; // weak
int dword_6775C8 = 0; // weak
_UNKNOWN unk_6775CC; // weak
int dword_6775E4 = 0; // weak
_UNKNOWN unk_6775E8; // weak
int dword_677600 = 0; // weak
char algn_677604[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67761C = 0; // weak
_UNKNOWN unk_677620; // weak
int dword_677638 = 0; // weak
_UNKNOWN unk_67763C; // weak
int dword_677654 = 0; // weak
_UNKNOWN unk_677658; // weak
int dword_677670 = 0; // weak
char algn_677674[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67768C = 0; // weak
_UNKNOWN unk_677690; // weak
_DWORD dword_6776A8[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_6776C4[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_6776E0[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_6776FC[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_677718[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_677734[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_677750[5] = { 0, 0, 0, 0, 4 }; // idb
_DWORD dword_67776C[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_677788[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_6777A4[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_6777C0[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_6777DC[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_6777F8[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_677814[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_677830[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_67784C[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_677868[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_677884[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_6778A0[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_6778BC[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_6778D8[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_6778F4[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_677910 = 0; // weak
char algn_677914[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_67792C[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_677948[10] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0, 0 }; // idb
int dword_677970 = 0; // weak
char algn_677974[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67798C = 0; // weak
_UNKNOWN unk_677990; // weak
int dword_6779A8 = 0; // weak
_UNKNOWN unk_6779AC; // weak
int dword_6779C4 = 0; // weak
_UNKNOWN unk_6779C8; // weak
int dword_6779E0 = 0; // weak
char algn_6779E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6779FC = 0; // weak
_UNKNOWN unk_677A00; // weak
int dword_677A18 = 0; // weak
_UNKNOWN unk_677A1C; // weak
int dword_677A34 = 0; // weak
_UNKNOWN unk_677A38; // weak
int dword_677A50 = 0; // weak
char algn_677A54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_677A6C = 0; // weak
_UNKNOWN unk_677A70; // weak
int dword_677A88 = 0; // weak
_UNKNOWN unk_677A8C; // weak
int dword_677AA4 = 0; // weak
_UNKNOWN unk_677AA8; // weak
int dword_677AC0 = 0; // weak
char algn_677AC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_677ADC = 0; // weak
_UNKNOWN unk_677AE0; // weak
int dword_677AF8 = 0; // weak
_UNKNOWN unk_677AFC; // weak
int dword_677B14 = 0; // weak
_UNKNOWN unk_677B18; // weak
int dword_677B30 = 0; // weak
char algn_677B34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_677B4C = 0; // weak
_UNKNOWN unk_677B50; // weak
int dword_677B68 = 0; // weak
_UNKNOWN unk_677B6C; // weak
int dword_677B84 = 0; // weak
_UNKNOWN unk_677B88; // weak
int dword_677BA0 = 0; // weak
char algn_677BA4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_677BBC = 0; // weak
_UNKNOWN unk_677BC0; // weak
int dword_677BD8 = 0; // weak
_UNKNOWN unk_677BDC; // weak
int dword_677BF4 = 0; // weak
_UNKNOWN unk_677BF8; // weak
int dword_677C10 = 0; // weak
char algn_677C14[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_677C2C = 0; // weak
_UNKNOWN unk_677C30; // weak
int dword_677C48 = 0; // weak
_UNKNOWN unk_677C4C; // weak
int dword_677C64 = 0; // weak
_UNKNOWN unk_677C68; // weak
int dword_677C80 = 0; // weak
char algn_677C84[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_677C9C = 0; // weak
_UNKNOWN unk_677CA0; // weak
int dword_677CB8 = 0; // weak
int dword_677CBC = 0; // weak
int dword_677CD4 = 0; // weak
_UNKNOWN unk_677CD8; // weak
int dword_677CF0 = 0; // weak
int dword_677CF4 = 0; // weak
int dword_677D0C = 0; // weak
_UNKNOWN unk_677D10; // weak
int dword_677D28 = 0; // weak
int dword_677D2C = 0; // weak
int dword_677D44 = 0; // weak
_UNKNOWN unk_677D48; // weak
int dword_677D60 = 0; // weak
int dword_677D64 = 0; // weak
int dword_677D7C = 0; // weak
_UNKNOWN unk_677D80; // weak
int dword_677D98 = 0; // weak
int dword_677D9C = 0; // weak
int dword_677DB4 = 0; // weak
_UNKNOWN unk_677DB8; // weak
int dword_677DD0 = 0; // weak
int dword_677DD4 = 0; // weak
int dword_677DEC = 0; // weak
_UNKNOWN unk_677DF0; // weak
int dword_677E08 = 0; // weak
int dword_677E0C = 0; // weak
int dword_677E24 = 0; // weak
_UNKNOWN unk_677E28; // weak
int dword_677E40 = 0; // weak
int dword_677E44 = 0; // weak
int dword_677E5C = 0; // weak
_UNKNOWN unk_677E60; // weak
int dword_677E78 = 0; // weak
_UNKNOWN unk_677E7C; // weak
int dword_677E94 = 0; // weak
_UNKNOWN unk_677E98; // weak
int dword_677EB0 = 0; // weak
char algn_677EB4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_677ECC = 0; // weak
_UNKNOWN unk_677ED0; // weak
int dword_677EE8 = 0; // weak
_UNKNOWN unk_677EEC; // weak
int dword_677F04 = 0; // weak
_UNKNOWN unk_677F08; // weak
int dword_677F20 = 0; // weak
char algn_677F24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_677F3C = 0; // weak
_UNKNOWN unk_677F40; // weak
_DWORD dword_677F58[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_677F74[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_677F90[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_677FAC[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_677FC8[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_677FE4[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_678000[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_67801C[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_678038[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_678054[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_678070[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_67808C[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_6780A8[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_6780C4[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_6780E0[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_6780FC[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_678118[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_678134[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_678150[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_67816C[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_678188[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_6781A4[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_6781C0 = 0; // weak
char algn_6781C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_6781DC[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_6781F8[10] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0, 0 }; // idb
int dword_678220 = 0; // weak
int dword_678224 = 0; // weak
int dword_678240 = 0; // weak
char algn_678244[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67825C = 0; // weak
_UNKNOWN unk_678260; // weak
int dword_678278 = 0; // weak
_UNKNOWN unk_67827C; // weak
int dword_678294 = 0; // weak
_UNKNOWN unk_678298; // weak
int dword_6782B0 = 0; // weak
char algn_6782B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6782CC = 0; // weak
_UNKNOWN unk_6782D0; // weak
int dword_6782E8 = 0; // weak
_UNKNOWN unk_6782EC; // weak
int dword_678304 = 0; // weak
_UNKNOWN unk_678308; // weak
int dword_678320 = 0; // weak
char algn_678324[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67833C = 0; // weak
_UNKNOWN unk_678340; // weak
int dword_678358 = 0; // weak
_UNKNOWN unk_67835C; // weak
int dword_678374 = 0; // weak
_UNKNOWN unk_678378; // weak
int dword_678390 = 0; // weak
char algn_678394[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6783AC = 0; // weak
_UNKNOWN unk_6783B0; // weak
int dword_6783C8 = 0; // weak
_UNKNOWN unk_6783CC; // weak
int dword_6783E4 = 0; // weak
_UNKNOWN unk_6783E8; // weak
int dword_678400 = 0; // weak
char algn_678404[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67841C = 0; // weak
_UNKNOWN unk_678420; // weak
int dword_678438 = 0; // weak
_UNKNOWN unk_67843C; // weak
int dword_678454 = 0; // weak
_UNKNOWN unk_678458; // weak
int dword_678470 = 0; // weak
char algn_678474[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67848C = 0; // weak
_UNKNOWN unk_678490; // weak
int dword_6784A8 = 0; // weak
_UNKNOWN unk_6784AC; // weak
int dword_6784C4 = 0; // weak
_UNKNOWN unk_6784C8; // weak
int dword_6784E0 = 0; // weak
char algn_6784E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6784FC = 0; // weak
_UNKNOWN unk_678500; // weak
int dword_678518 = 0; // weak
_UNKNOWN unk_67851C; // weak
int dword_678534 = 0; // weak
_UNKNOWN unk_678538; // weak
int dword_678550 = 0; // weak
char algn_678554[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67856C = 0; // weak
_UNKNOWN unk_678570; // weak
int dword_678588 = 0; // weak
int dword_67858C = 0; // weak
int dword_6785A4 = 0; // weak
_UNKNOWN unk_6785A8; // weak
int dword_6785C0 = 0; // weak
int dword_6785C4 = 0; // weak
int dword_6785DC = 0; // weak
_UNKNOWN unk_6785E0; // weak
int dword_6785F8 = 0; // weak
int dword_6785FC = 0; // weak
int dword_678614 = 0; // weak
_UNKNOWN unk_678618; // weak
int dword_678630 = 0; // weak
int dword_678634 = 0; // weak
int dword_67864C = 0; // weak
_UNKNOWN unk_678650; // weak
int dword_678668 = 0; // weak
int dword_67866C = 0; // weak
int dword_678684 = 0; // weak
_UNKNOWN unk_678688; // weak
int dword_6786A0 = 0; // weak
int dword_6786A4 = 0; // weak
int dword_6786BC = 0; // weak
_UNKNOWN unk_6786C0; // weak
int dword_6786D8 = 0; // weak
int dword_6786DC = 0; // weak
int dword_6786F4 = 0; // weak
_UNKNOWN unk_6786F8; // weak
int dword_678710 = 0; // weak
int dword_678714 = 0; // weak
int dword_67872C = 0; // weak
_UNKNOWN unk_678730; // weak
int dword_678748 = 0; // weak
_UNKNOWN unk_67874C; // weak
int dword_678764 = 0; // weak
_UNKNOWN unk_678768; // weak
int dword_678780 = 0; // weak
char algn_678784[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67879C = 0; // weak
_UNKNOWN unk_6787A0; // weak
int dword_6787B8 = 0; // weak
_UNKNOWN unk_6787BC; // weak
int dword_6787D4 = 0; // weak
_UNKNOWN unk_6787D8; // weak
int dword_6787F0 = 0; // weak
char algn_6787F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67880C = 0; // weak
_UNKNOWN unk_678810; // weak
_DWORD dword_678828[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_678844[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_678860[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_67887C[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_678898[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_6788B4[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_6788D0[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_6788EC[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_678908[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_678924[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_678940[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_67895C[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_678978[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_678994[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_6789B0[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_6789CC[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_6789E8[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_678A04[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_678A20[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_678A3C[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_678A58[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_678A74[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_678A90 = 0; // weak
char algn_678A94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_678AAC[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_678AC8[10] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0, 0 }; // idb
char *off_678AF0[8] =
{
  "mrcl_1_en",
  "mrcl_2_en",
  "mrcl_3_en",
  "mrcl_4_en",
  "mrcl_5_en",
  "mrcl_6_en",
  "mrcl_7_en",
  "mrcl_10_en"
}; // weak
void *off_678B10 = (void *)0x4CF9EC; // weak
_DWORD dword_678B20 = 0; // idb
int dword_678B24 = 0; // weak
int dword_678B3C = 0; // weak
int dword_678B40 = 0; // weak
int dword_678B58 = 0; // weak
int dword_678B5C = 0; // weak
int dword_678B74 = 0; // weak
int dword_678B78 = 0; // weak
_DWORD dword_678B90 = 0; // idb
int dword_678B94 = 0; // weak
_DWORD dword_678BAC = 0; // idb
int dword_678BB0 = 0; // weak
_DWORD dword_678BC8 = 0; // idb
int dword_678BCC = 0; // weak
_DWORD dword_678BE4 = 0; // idb
int dword_678BE8 = 0; // weak
_DWORD dword_678C00 = 0; // idb
int dword_678C04 = 0; // weak
int dword_678C1C = 0; // weak
int dword_678C20 = 0; // weak
int dword_678C38 = 0; // weak
int dword_678C3C = 0; // weak
int dword_678C54 = 0; // weak
int dword_678C58 = 0; // weak
int dword_678C70 = 0; // weak
int dword_678C74 = 0; // weak
int dword_678C8C = 0; // weak
int dword_678C90 = 0; // weak
int dword_678CA8 = 0; // weak
int dword_678CAC = 0; // weak
int dword_678CC4 = 0; // weak
int dword_678CC8 = 0; // weak
_DWORD dword_678CE0[7] = { 0, 0, 0, 0, 2, 5054556, 4849348 }; // idb
int dword_678CFC = 0; // weak
int dword_678D00 = 0; // weak
int dword_678D18 = 0; // weak
int dword_678D1C = 0; // weak
int dword_678D34 = 0; // weak
int dword_678D38 = 0; // weak
int dword_678D50 = 0; // weak
char algn_678D54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_678D6C = 0; // weak
_UNKNOWN unk_678D70; // weak
int dword_678D88 = 0; // weak
int dword_678D8C = 0; // weak
int dword_678DA4 = 0; // weak
int dword_678DA8 = 0; // weak
int dword_678DC0 = 0; // weak
int dword_678DC4 = 0; // weak
int dword_678DDC = 0; // weak
int dword_678DE0 = 0; // weak
_DWORD dword_678DF8 = 0; // idb
int dword_678DFC = 0; // weak
_DWORD dword_678E14 = 0; // idb
int dword_678E18 = 0; // weak
_DWORD dword_678E30 = 0; // idb
int dword_678E34 = 0; // weak
_DWORD dword_678E4C = 0; // idb
int dword_678E50 = 0; // weak
_DWORD dword_678E68 = 0; // idb
int dword_678E6C = 0; // weak
_DWORD dword_678E84 = 0; // idb
int dword_678E88 = 0; // weak
_DWORD dword_678EA0 = 0; // idb
int dword_678EA4 = 0; // weak
_DWORD dword_678EBC = 0; // idb
int dword_678EC0 = 0; // weak
_DWORD dword_678ED8 = 0; // idb
int dword_678EDC = 0; // weak
_DWORD dword_678EF4 = 0; // idb
int dword_678EF8 = 0; // weak
_DWORD dword_678F10 = 0; // idb
int dword_678F14 = 0; // weak
int dword_678F2C = 0; // weak
int dword_678F30 = 0; // weak
int dword_678F48 = 0; // weak
int dword_678F4C = 0; // weak
int dword_678F64 = 0; // weak
_UNKNOWN unk_678F68; // weak
int dword_678F80 = 0; // weak
char algn_678F84[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_678F9C = 0; // weak
_UNKNOWN unk_678FA0; // weak
int dword_678FB8 = 0; // weak
_UNKNOWN unk_678FBC; // weak
int dword_678FD4 = 0; // weak
_UNKNOWN unk_678FD8; // weak
int dword_678FF0 = 0; // weak
char algn_678FF4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67900C = 0; // weak
_UNKNOWN unk_679010; // weak
int dword_679028 = 0; // weak
_UNKNOWN unk_67902C; // weak
int dword_679044 = 0; // weak
_UNKNOWN unk_679048; // weak
int dword_679060 = 0; // weak
char algn_679064[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67907C = 0; // weak
_UNKNOWN unk_679080; // weak
int dword_679098 = 0; // weak
_UNKNOWN unk_67909C; // weak
int dword_6790B4 = 0; // weak
_UNKNOWN unk_6790B8; // weak
int dword_6790D0 = 0; // weak
char algn_6790D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6790EC = 0; // weak
_UNKNOWN unk_6790F0; // weak
int dword_679108 = 0; // weak
_UNKNOWN unk_67910C; // weak
int dword_679124 = 0; // weak
_UNKNOWN unk_679128; // weak
int dword_679140 = 0; // weak
char algn_679144[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67915C = 0; // weak
_UNKNOWN unk_679160; // weak
int dword_679178 = 0; // weak
_UNKNOWN unk_67917C; // weak
int dword_679194 = 0; // weak
_UNKNOWN unk_679198; // weak
int dword_6791B0 = 0; // weak
char algn_6791B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6791CC = 0; // weak
_UNKNOWN unk_6791D0; // weak
int dword_6791E8 = 0; // weak
_UNKNOWN unk_6791EC; // weak
int dword_679204 = 0; // weak
_UNKNOWN unk_679208; // weak
int dword_679220 = 0; // weak
char algn_679224[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67923C = 0; // weak
_UNKNOWN unk_679240; // weak
int dword_679258 = 0; // weak
_UNKNOWN unk_67925C; // weak
int dword_679274 = 0; // weak
_UNKNOWN unk_679278; // weak
int dword_679290 = 0; // weak
char algn_679294[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6792AC = 0; // weak
int dword_6792B0 = 0; // weak
int dword_6792C8 = 0; // weak
_UNKNOWN unk_6792CC; // weak
int dword_6792E4 = 0; // weak
int dword_6792E8 = 0; // weak
int dword_679300 = 0; // weak
char algn_679304[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67931C = 0; // weak
int dword_679320 = 0; // weak
int dword_679338 = 0; // weak
_UNKNOWN unk_67933C; // weak
int dword_679354 = 0; // weak
int dword_679358 = 0; // weak
int dword_679370 = 0; // weak
char algn_679374[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67938C = 0; // weak
int dword_679390 = 0; // weak
int dword_6793A8 = 0; // weak
_UNKNOWN unk_6793AC; // weak
int dword_6793C4 = 0; // weak
int dword_6793C8 = 0; // weak
int dword_6793E0 = 0; // weak
char algn_6793E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6793FC = 0; // weak
int dword_679400 = 0; // weak
int dword_679418 = 0; // weak
_UNKNOWN unk_67941C; // weak
int dword_679434 = 0; // weak
int dword_679438 = 0; // weak
int dword_679450 = 0; // weak
char algn_679454[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67946C = 0; // weak
_UNKNOWN unk_679470; // weak
int dword_679488 = 0; // weak
_UNKNOWN unk_67948C; // weak
int dword_6794A4 = 0; // weak
_UNKNOWN unk_6794A8; // weak
int dword_6794C0 = 0; // weak
char algn_6794C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_6794DC = 0; // weak
_UNKNOWN unk_6794E0; // weak
int dword_6794F8 = 0; // weak
_UNKNOWN unk_6794FC; // weak
int dword_679514 = 0; // weak
_UNKNOWN unk_679518; // weak
int dword_679530 = 0; // weak
char algn_679534[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_67954C[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_679568[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_679584[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_6795A0[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_6795BC[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_6795D8[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_6795F4[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_679610[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_67962C[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_679648[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_679664[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_679680[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_67969C[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_6796B8[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_6796D4[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_6796F0[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_67970C[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_679728[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_679744[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_679760[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_67977C[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_679798[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_6797B4 = 0; // weak
_UNKNOWN unk_6797B8; // weak
_DWORD dword_6797D0[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_6797EC[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
char *ll_ssstt = "dianxin"; // weak
char *off_679810 = "wangtong"; // weak
_UNKNOWN cl_ips_types; // weak
char *off_679864 = "dianxin"; // weak
_DWORD dword_6798C0 = 0; // idb
int dword_6798C4 = 0; // weak
int dword_6798DC = 0; // weak
int dword_6798E0 = 0; // weak
int dword_6798F8 = 0; // weak
int dword_6798FC = 0; // weak
int dword_679914 = 0; // weak
int dword_679918 = 0; // weak
_DWORD dword_679930 = 0; // idb
int dword_679934 = 0; // weak
_DWORD dword_67994C = 0; // idb
int dword_679950 = 0; // weak
_DWORD dword_679968 = 0; // idb
int dword_67996C = 0; // weak
_DWORD dword_679984 = 0; // idb
int dword_679988 = 0; // weak
_DWORD dword_6799A0 = 0; // idb
int dword_6799A4 = 0; // weak
int dword_6799BC = 0; // weak
int dword_6799C0 = 0; // weak
int dword_6799D8 = 0; // weak
int dword_6799DC = 0; // weak
int dword_6799F4 = 0; // weak
int dword_6799F8 = 0; // weak
int dword_679A10 = 0; // weak
int dword_679A14 = 0; // weak
int dword_679A2C = 0; // weak
int dword_679A30 = 0; // weak
int dword_679A48 = 0; // weak
int dword_679A4C = 0; // weak
int dword_679A64 = 0; // weak
int dword_679A68 = 0; // weak
_DWORD dword_679A80[7] = { 0, 0, 0, 0, 2, 5054556, 4849348 }; // idb
int dword_679A9C = 0; // weak
int dword_679AA0 = 0; // weak
int dword_679AB8 = 0; // weak
int dword_679ABC = 0; // weak
int dword_679AD4 = 0; // weak
int dword_679AD8 = 0; // weak
int dword_679AF0 = 0; // weak
char algn_679AF4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_679B0C = 0; // weak
_UNKNOWN unk_679B10; // weak
int dword_679B28 = 0; // weak
int dword_679B2C = 0; // weak
int dword_679B44 = 0; // weak
int dword_679B48 = 0; // weak
int dword_679B60 = 0; // weak
int dword_679B64 = 0; // weak
int dword_679B7C = 0; // weak
int dword_679B80 = 0; // weak
_DWORD dword_679B98 = 0; // idb
int dword_679B9C = 0; // weak
_DWORD dword_679BB4 = 0; // idb
int dword_679BB8 = 0; // weak
_DWORD dword_679BD0 = 0; // idb
int dword_679BD4 = 0; // weak
_DWORD dword_679BEC = 0; // idb
int dword_679BF0 = 0; // weak
_DWORD dword_679C08 = 0; // idb
int dword_679C0C = 0; // weak
_DWORD dword_679C24 = 0; // idb
int dword_679C28 = 0; // weak
_DWORD dword_679C40 = 0; // idb
int dword_679C44 = 0; // weak
_DWORD dword_679C5C = 0; // idb
int dword_679C60 = 0; // weak
_DWORD dword_679C78 = 0; // idb
int dword_679C7C = 0; // weak
_DWORD dword_679C94 = 0; // idb
int dword_679C98 = 0; // weak
_DWORD dword_679CB0 = 0; // idb
int dword_679CB4 = 0; // weak
int dword_679CCC = 0; // weak
int dword_679CD0 = 0; // weak
int dword_679CE8 = 0; // weak
int dword_679CEC = 0; // weak
int dword_679D04 = 0; // weak
_UNKNOWN unk_679D08; // weak
int dword_679D20 = 0; // weak
char algn_679D24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_679D3C = 0; // weak
_UNKNOWN unk_679D40; // weak
int dword_679D58 = 0; // weak
_UNKNOWN unk_679D5C; // weak
int dword_679D74 = 0; // weak
_UNKNOWN unk_679D78; // weak
int dword_679D90 = 0; // weak
char algn_679D94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_679DAC = 0; // weak
_UNKNOWN unk_679DB0; // weak
int dword_679DC8 = 0; // weak
_UNKNOWN unk_679DCC; // weak
int dword_679DE4 = 0; // weak
_UNKNOWN unk_679DE8; // weak
int dword_679E00 = 0; // weak
char algn_679E04[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_679E1C = 0; // weak
_UNKNOWN unk_679E20; // weak
int dword_679E38 = 0; // weak
_UNKNOWN unk_679E3C; // weak
int dword_679E54 = 0; // weak
_UNKNOWN unk_679E58; // weak
int dword_679E70 = 0; // weak
char algn_679E74[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_679E8C = 0; // weak
_UNKNOWN unk_679E90; // weak
int dword_679EA8 = 0; // weak
_UNKNOWN unk_679EAC; // weak
int dword_679EC4 = 0; // weak
_UNKNOWN unk_679EC8; // weak
int dword_679EE0 = 0; // weak
char algn_679EE4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_679EFC = 0; // weak
_UNKNOWN unk_679F00; // weak
int dword_679F18 = 0; // weak
_UNKNOWN unk_679F1C; // weak
int dword_679F34 = 0; // weak
_UNKNOWN unk_679F38; // weak
int dword_679F50 = 0; // weak
char algn_679F54[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_679F6C = 0; // weak
_UNKNOWN unk_679F70; // weak
int dword_679F88 = 0; // weak
_UNKNOWN unk_679F8C; // weak
int dword_679FA4 = 0; // weak
_UNKNOWN unk_679FA8; // weak
int dword_679FC0 = 0; // weak
char algn_679FC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_679FDC = 0; // weak
_UNKNOWN unk_679FE0; // weak
int dword_679FF8 = 0; // weak
_UNKNOWN unk_679FFC; // weak
int dword_67A014 = 0; // weak
_UNKNOWN unk_67A018; // weak
int dword_67A030 = 0; // weak
char algn_67A034[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A04C = 0; // weak
int dword_67A050 = 0; // weak
int dword_67A068 = 0; // weak
_UNKNOWN unk_67A06C; // weak
int dword_67A084 = 0; // weak
int dword_67A088 = 0; // weak
int dword_67A0A0 = 0; // weak
char algn_67A0A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A0BC = 0; // weak
int dword_67A0C0 = 0; // weak
int dword_67A0D8 = 0; // weak
_UNKNOWN unk_67A0DC; // weak
int dword_67A0F4 = 0; // weak
int dword_67A0F8 = 0; // weak
int dword_67A110 = 0; // weak
char algn_67A114[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A12C = 0; // weak
int dword_67A130 = 0; // weak
int dword_67A148 = 0; // weak
_UNKNOWN unk_67A14C; // weak
int dword_67A164 = 0; // weak
int dword_67A168 = 0; // weak
int dword_67A180 = 0; // weak
char algn_67A184[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A19C = 0; // weak
int dword_67A1A0 = 0; // weak
int dword_67A1B8 = 0; // weak
_UNKNOWN unk_67A1BC; // weak
int dword_67A1D4 = 0; // weak
int dword_67A1D8 = 0; // weak
int dword_67A1F0 = 0; // weak
char algn_67A1F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A20C = 0; // weak
_UNKNOWN unk_67A210; // weak
int dword_67A228 = 0; // weak
_UNKNOWN unk_67A22C; // weak
int dword_67A244 = 0; // weak
_UNKNOWN unk_67A248; // weak
int dword_67A260 = 0; // weak
char algn_67A264[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A27C = 0; // weak
_UNKNOWN unk_67A280; // weak
int dword_67A298 = 0; // weak
_UNKNOWN unk_67A29C; // weak
int dword_67A2B4 = 0; // weak
_UNKNOWN unk_67A2B8; // weak
int dword_67A2D0 = 0; // weak
char algn_67A2D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_67A2EC[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_67A308[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_67A324[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_67A340[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_67A35C[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_67A378[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_67A394[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_67A3B0[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_67A3CC[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_67A3E8[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_67A404[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_67A420[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_67A43C[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_67A458[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_67A474[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_67A490[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_67A4AC[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_67A4C8[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_67A4E4[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_67A500[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_67A51C[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_67A538[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_67A554 = 0; // weak
_UNKNOWN unk_67A558; // weak
_DWORD dword_67A570[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_67A58C[9] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0 }; // idb
int dword_67A5B0 = 0; // weak
int dword_67A5B4 = 0; // weak
int dword_67A5D0 = -1; // weak
int dword_67A5E0 = 0; // weak
int dword_67A5E4 = 0; // weak
int dword_67A5FC = 0; // weak
int dword_67A600 = 0; // weak
int dword_67A618 = 0; // weak
int dword_67A61C = 0; // weak
_DWORD dword_67A634[7] = { 0, 0, 0, 0, 3, 6555232, 4516572 }; // idb
int dword_67A650 = 0; // weak
int dword_67A654 = 0; // weak
int dword_67A66C = 0; // weak
int dword_67A670 = 0; // weak
int dword_67A688 = 0; // weak
int dword_67A68C = 0; // weak
int dword_67A6A4 = 0; // weak
int dword_67A6A8 = 0; // weak
int dword_67A6C0 = 0; // weak
int dword_67A6C4 = 0; // weak
int dword_67A6DC = 0; // weak
int dword_67A6E0 = 0; // weak
int dword_67A6F8 = 0; // weak
int dword_67A6FC = 0; // weak
int dword_67A714 = 0; // weak
int dword_67A718 = 0; // weak
_DWORD dword_67A730 = 0; // idb
int dword_67A734 = 0; // weak
_DWORD dword_67A74C = 0; // idb
int dword_67A750 = 0; // weak
_DWORD dword_67A768 = 0; // idb
int dword_67A76C = 0; // weak
_DWORD dword_67A784 = 0; // idb
int dword_67A788 = 0; // weak
_DWORD dword_67A7A0 = 0; // idb
int dword_67A7A4 = 0; // weak
_DWORD dword_67A7BC = 0; // idb
int dword_67A7C0 = 0; // weak
_DWORD dword_67A7D8 = 0; // idb
int dword_67A7DC = 0; // weak
_DWORD dword_67A7F4 = 0; // idb
int dword_67A7F8 = 0; // weak
_DWORD dword_67A810 = 0; // idb
int dword_67A814 = 0; // weak
_DWORD dword_67A82C = 0; // idb
int dword_67A830 = 0; // weak
int dword_67A848 = 0; // weak
int dword_67A84C = 0; // weak
int dword_67A864 = 0; // weak
int dword_67A868 = 0; // weak
int dword_67A880 = 0; // weak
char algn_67A884[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A89C = 0; // weak
_UNKNOWN unk_67A8A0; // weak
int dword_67A8B8 = 0; // weak
_UNKNOWN unk_67A8BC; // weak
int dword_67A8D4 = 0; // weak
_UNKNOWN unk_67A8D8; // weak
int dword_67A8F0 = 0; // weak
char algn_67A8F4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A90C = 0; // weak
_UNKNOWN unk_67A910; // weak
int dword_67A928 = 0; // weak
_UNKNOWN unk_67A92C; // weak
int dword_67A944 = 0; // weak
_UNKNOWN unk_67A948; // weak
int dword_67A960 = 0; // weak
char algn_67A964[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A97C = 0; // weak
_UNKNOWN unk_67A980; // weak
int dword_67A998 = 0; // weak
_UNKNOWN unk_67A99C; // weak
int dword_67A9B4 = 0; // weak
_UNKNOWN unk_67A9B8; // weak
int dword_67A9D0 = 0; // weak
char algn_67A9D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67A9EC = 0; // weak
_UNKNOWN unk_67A9F0; // weak
int dword_67AA08 = 0; // weak
_UNKNOWN unk_67AA0C; // weak
int dword_67AA24 = 0; // weak
_UNKNOWN unk_67AA28; // weak
int dword_67AA40 = 0; // weak
char algn_67AA44[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67AA5C = 0; // weak
_UNKNOWN unk_67AA60; // weak
int dword_67AA78 = 0; // weak
_UNKNOWN unk_67AA7C; // weak
int dword_67AA94 = 0; // weak
_UNKNOWN unk_67AA98; // weak
int dword_67AAB0 = 0; // weak
char algn_67AAB4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67AACC = 0; // weak
_UNKNOWN unk_67AAD0; // weak
int dword_67AAE8 = 0; // weak
_UNKNOWN unk_67AAEC; // weak
int dword_67AB04 = 0; // weak
_UNKNOWN unk_67AB08; // weak
int dword_67AB20 = 0; // weak
char algn_67AB24[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67AB3C = 0; // weak
_UNKNOWN unk_67AB40; // weak
int dword_67AB58 = 0; // weak
_UNKNOWN unk_67AB5C; // weak
int dword_67AB74 = 0; // weak
_UNKNOWN unk_67AB78; // weak
int dword_67AB90 = 0; // weak
char algn_67AB94[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67ABAC = 0; // weak
_UNKNOWN unk_67ABB0; // weak
int dword_67ABC8 = 0; // weak
int dword_67ABCC = 0; // weak
int dword_67ABE4 = 0; // weak
_UNKNOWN unk_67ABE8; // weak
int dword_67AC00 = 0; // weak
int dword_67AC04 = 0; // weak
int dword_67AC1C = 0; // weak
_UNKNOWN unk_67AC20; // weak
int dword_67AC38 = 0; // weak
int dword_67AC3C = 0; // weak
int dword_67AC54 = 0; // weak
_UNKNOWN unk_67AC58; // weak
int dword_67AC70 = 0; // weak
int dword_67AC74 = 0; // weak
int dword_67AC8C = 0; // weak
_UNKNOWN unk_67AC90; // weak
int dword_67ACA8 = 0; // weak
int dword_67ACAC = 0; // weak
int dword_67ACC4 = 0; // weak
_UNKNOWN unk_67ACC8; // weak
int dword_67ACE0 = 0; // weak
int dword_67ACE4 = 0; // weak
int dword_67ACFC = 0; // weak
_UNKNOWN unk_67AD00; // weak
int dword_67AD18 = 0; // weak
int dword_67AD1C = 0; // weak
int dword_67AD34 = 0; // weak
_UNKNOWN unk_67AD38; // weak
int dword_67AD50 = 0; // weak
int dword_67AD54 = 0; // weak
int dword_67AD6C = 0; // weak
_UNKNOWN unk_67AD70; // weak
int dword_67AD88 = 0; // weak
_UNKNOWN unk_67AD8C; // weak
int dword_67ADA4 = 0; // weak
_UNKNOWN unk_67ADA8; // weak
int dword_67ADC0 = 0; // weak
char algn_67ADC4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67ADDC = 0; // weak
_UNKNOWN unk_67ADE0; // weak
int dword_67ADF8 = 0; // weak
_UNKNOWN unk_67ADFC; // weak
int dword_67AE14 = 0; // weak
_UNKNOWN unk_67AE18; // weak
int dword_67AE30 = 0; // weak
char algn_67AE34[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67AE4C = 0; // weak
_UNKNOWN unk_67AE50; // weak
_DWORD dword_67AE68[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_67AE84[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_67AEA0[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_67AEBC[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_67AED8[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_67AEF4[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_67AF10[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_67AF2C[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_67AF48[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_67AF64[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_67AF80[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_67AF9C[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_67AFB8[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_67AFD4[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_67AFF0[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_67B00C[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_67B028[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_67B044[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_67B060[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_67B07C[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_67B098[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_67B0B4[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_67B0D0 = 0; // weak
char algn_67B0D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
_DWORD dword_67B0EC[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_67B108[10] = { 0, 0, 0, 0, 3, 6558800, 4448540, 0, 0, 0 }; // idb
int dword_67B130 = 0; // weak
int dword_67B134 = 0; // weak
_DWORD dword_67B14C = 0; // idb
int dword_67B150 = 0; // weak
int dword_67B168 = 0; // weak
int dword_67B16C = 0; // weak
int dword_67B184 = 0; // weak
int dword_67B188 = 0; // weak
int dword_67B1A0 = 0; // weak
int dword_67B1A4 = 0; // weak
_DWORD dword_67B1BC = 0; // idb
int dword_67B1C0 = 0; // weak
_DWORD dword_67B1D8 = 0; // idb
int dword_67B1DC = 0; // weak
_DWORD dword_67B1F4 = 0; // idb
int dword_67B1F8 = 0; // weak
_DWORD dword_67B210 = 0; // idb
int dword_67B214 = 0; // weak
_DWORD dword_67B22C = 0; // idb
int dword_67B230 = 0; // weak
int dword_67B248 = 0; // weak
int dword_67B24C = 0; // weak
int dword_67B264 = 0; // weak
int dword_67B268 = 0; // weak
int dword_67B280 = 0; // weak
int dword_67B284 = 0; // weak
int dword_67B29C = 0; // weak
int dword_67B2A0 = 0; // weak
int dword_67B2B8 = 0; // weak
int dword_67B2BC = 0; // weak
int dword_67B2D4 = 0; // weak
int dword_67B2D8 = 0; // weak
int dword_67B2F0 = 0; // weak
int dword_67B2F4 = 0; // weak
int dword_67B30C = 0; // weak
_UNKNOWN unk_67B310; // weak
int dword_67B328 = 0; // weak
_UNKNOWN unk_67B32C; // weak
int dword_67B344 = 0; // weak
_UNKNOWN unk_67B348; // weak
int dword_67B360 = 0; // weak
char algn_67B364[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B37C = 0; // weak
_UNKNOWN unk_67B380; // weak
int dword_67B398 = 0; // weak
_UNKNOWN unk_67B39C; // weak
int dword_67B3B4 = 0; // weak
_UNKNOWN unk_67B3B8; // weak
int dword_67B3D0 = 0; // weak
char algn_67B3D4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B3EC = 0; // weak
_UNKNOWN unk_67B3F0; // weak
int dword_67B408 = 0; // weak
_UNKNOWN unk_67B40C; // weak
int dword_67B424 = 0; // weak
_UNKNOWN unk_67B428; // weak
int dword_67B440 = 0; // weak
char algn_67B444[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B45C = 0; // weak
_UNKNOWN unk_67B460; // weak
int dword_67B478 = 0; // weak
_UNKNOWN unk_67B47C; // weak
int dword_67B494 = 0; // weak
_UNKNOWN unk_67B498; // weak
int dword_67B4B0 = 0; // weak
char algn_67B4B4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B4CC = 0; // weak
_UNKNOWN unk_67B4D0; // weak
int dword_67B4E8 = 0; // weak
_UNKNOWN unk_67B4EC; // weak
int dword_67B504 = 0; // weak
_UNKNOWN unk_67B508; // weak
int dword_67B520 = 0; // weak
char algn_67B524[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B53C = 0; // weak
_UNKNOWN unk_67B540; // weak
int dword_67B558 = 0; // weak
_UNKNOWN unk_67B55C; // weak
int dword_67B574 = 0; // weak
_UNKNOWN unk_67B578; // weak
int dword_67B590 = 0; // weak
char algn_67B594[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B5AC = 0; // weak
_UNKNOWN unk_67B5B0; // weak
int dword_67B5C8 = 0; // weak
_UNKNOWN unk_67B5CC; // weak
int dword_67B5E4 = 0; // weak
_UNKNOWN unk_67B5E8; // weak
int dword_67B600 = 0; // weak
char algn_67B604[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B61C = 0; // weak
_UNKNOWN unk_67B620; // weak
int dword_67B638 = 0; // weak
_UNKNOWN unk_67B63C; // weak
int dword_67B654 = 0; // weak
int dword_67B658 = 0; // weak
int dword_67B670 = 0; // weak
char algn_67B674[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B68C = 0; // weak
int dword_67B690 = 0; // weak
int dword_67B6A8 = 0; // weak
_UNKNOWN unk_67B6AC; // weak
int dword_67B6C4 = 0; // weak
int dword_67B6C8 = 0; // weak
int dword_67B6E0 = 0; // weak
char algn_67B6E4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B6FC = 0; // weak
int dword_67B700 = 0; // weak
int dword_67B718 = 0; // weak
_UNKNOWN unk_67B71C; // weak
int dword_67B734 = 0; // weak
int dword_67B738 = 0; // weak
int dword_67B750 = 0; // weak
char algn_67B754[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B76C = 0; // weak
int dword_67B770 = 0; // weak
int dword_67B788 = 0; // weak
_UNKNOWN unk_67B78C; // weak
int dword_67B7A4 = 0; // weak
int dword_67B7A8 = 0; // weak
int dword_67B7C0 = 0; // weak
char algn_67B7C4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B7DC = 0; // weak
int dword_67B7E0 = 0; // weak
int dword_67B7F8 = 0; // weak
_UNKNOWN unk_67B7FC; // weak
int dword_67B814 = 0; // weak
_UNKNOWN unk_67B818; // weak
int dword_67B830 = 0; // weak
char algn_67B834[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B84C = 0; // weak
_UNKNOWN unk_67B850; // weak
int dword_67B868 = 0; // weak
_UNKNOWN unk_67B86C; // weak
int dword_67B884 = 0; // weak
_UNKNOWN unk_67B888; // weak
int dword_67B8A0 = 0; // weak
char algn_67B8A4[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // weak
int dword_67B8BC = 0; // weak
_UNKNOWN unk_67B8C0; // weak
int dword_67B8D8 = 0; // weak
_UNKNOWN unk_67B8DC; // weak
_DWORD dword_67B8F4[7] = { 0, 0, 0, 0, 4, 6558444, 4989208 }; // idb
_DWORD dword_67B910[7] = { 0, 0, 0, 0, 3, 6558452, 4985696 }; // idb
_DWORD dword_67B92C[7] = { 0, 0, 0, 0, 3, 6558460, 4459668 }; // idb
_DWORD dword_67B948[7] = { 0, 0, 0, 0, 3, 6558476, 4472744 }; // idb
_DWORD dword_67B964[7] = { 0, 0, 0, 0, 4, 6558492, 4491324 }; // idb
_DWORD dword_67B980[7] = { 0, 0, 0, 0, 3, 6558508, 4490512 }; // idb
_DWORD dword_67B99C[7] = { 0, 0, 0, 0, 4, 6558524, 4487892 }; // idb
_DWORD dword_67B9B8[7] = { 0, 0, 0, 0, 3, 6558540, 4478116 }; // idb
_DWORD dword_67B9D4[7] = { 0, 0, 0, 0, 4, 6558556, 4479004 }; // idb
_DWORD dword_67B9F0[7] = { 0, 0, 0, 0, 3, 6558568, 4473928 }; // idb
_DWORD dword_67BA0C[7] = { 0, 0, 0, 0, 4, 6558580, 4444620 }; // idb
_DWORD dword_67BA28[7] = { 0, 0, 0, 0, 3, 6558600, 4446508 }; // idb
_DWORD dword_67BA44[7] = { 0, 0, 0, 0, 4, 6558620, 4446292 }; // idb
_DWORD dword_67BA60[7] = { 0, 0, 0, 0, 3, 6558636, 4445984 }; // idb
_DWORD dword_67BA7C[7] = { 0, 0, 0, 0, 4, 6558652, 4490936 }; // idb
_DWORD dword_67BA98[7] = { 0, 0, 0, 0, 3, 6558664, 4489436 }; // idb
_DWORD dword_67BAB4[7] = { 0, 0, 0, 0, 4, 6558676, 4441380 }; // idb
_DWORD dword_67BAD0[7] = { 0, 0, 0, 0, 3, 6558692, 4440812 }; // idb
_DWORD dword_67BAEC[7] = { 0, 0, 0, 0, 4, 6558708, 4442260 }; // idb
_DWORD dword_67BB08[7] = { 0, 0, 0, 0, 3, 6558724, 4443768 }; // idb
_DWORD dword_67BB24[7] = { 0, 0, 0, 0, 3, 6558740, 4461488 }; // idb
_DWORD dword_67BB40[7] = { 0, 0, 0, 0, 3, 6558760, 4463344 }; // idb
int dword_67BB5C = 0; // weak
_UNKNOWN unk_67BB60; // weak
_DWORD dword_67BB78[7] = { 0, 0, 0, 0, 4, 6558792, 4451692 }; // idb
_DWORD dword_67BB94[7] = { 0, 0, 0, 0, 3, 6558800, 4448540 }; // idb
_DWORD dword_67BBB0 = 0; // idb
int dword_67BBB4 = 0; // weak
int dword_67BBCC = 0; // weak
int dword_67BBD0 = 0; // weak
_DWORD dword_67BBE8 = 0; // idb
int dword_67BBEC = 0; // weak
_DWORD dword_67BC04 = 0; // idb
int dword_67BC08 = 0; // weak
_DWORD dword_67BC20 = 0; // idb
int dword_67BC24 = 0; // weak
int dword_67BC3C = 0; // weak
int dword_67BC40 = 0; // weak
int dword_67BC58 = 0; // weak
int dword_67BC5C = 0; // weak
int dword_67BC74 = 0; // weak
int dword_67BC78 = 0; // weak
int dword_67BC90 = 0; // weak
int dword_67BC94 = 0; // weak
int dword_67BCAC = 0; // weak
int dword_67BCB0 = 0; // weak
int dword_67BCC8 = 0; // weak
int dword_67BCCC = 0; // weak
int dword_67BCE4 = 0; // weak
int dword_67BCE8 = 0; // weak
int dword_67BD00 = 0; // weak
int dword_67BD04 = 0; // weak
int dword_67BD1C = 0; // weak
int dword_67BD20 = 0; // weak
int https_init = 1; // weak
int https_fd = -1; // weak
_DWORD dword_67BD50 = 0; // idb
int dword_67BD54 = 0; // weak
_DWORD dword_67BD6C = 0; // idb
int dword_67BD70 = 0; // weak
_DWORD dword_67BD88 = 0; // idb
int dword_67BD8C = 0; // weak
int dword_67BDA4 = 0; // weak
int dword_67BDA8 = 0; // weak
int dword_67BDC0 = 0; // weak
int dword_67BDC4 = 0; // weak
int dword_67BDDC = 0; // weak
int dword_67BDE0 = 0; // weak
int dword_67BDF8 = 0; // weak
int dword_67BDFC = 0; // weak
int dword_67BE14 = 0; // weak
int dword_67BE18 = 0; // weak
int dword_67BE30 = 0; // weak
int dword_67BE34 = 0; // weak
int dword_67BE4C = 0; // weak
int dword_67BE50 = 0; // weak
int dword_67BE68 = 0; // weak
int dword_67BE6C = 0; // weak
int dword_67BE84 = 0; // weak
int dword_67BE88 = 0; // weak
int dword_67BEA0 = 0; // weak
int dword_67BEA4 = 0; // weak
void *iptv_token_list_head = &iptv_token_list_head; // weak
void **off_67BEC0 = &iptv_token_list_head; // weak
int dword_67BED0 = 0; // weak
int dword_67BED4 = 0; // weak
int dword_67BEEC = 0; // weak
int dword_67BEF0 = 0; // weak
int dword_67BF08 = 0; // weak
int dword_67BF0C = 0; // weak
char *menu_js_router_str = "{\"showRoutes\":[{\"name\":\"overview\",\"component\":\"Layout\",\"children\":[{\"name\":\"networkOverview\",\"meta\":{\"title\":\"[TEXT:1]\",\"icon\":\"el-icon-tuoputu\"},\"component\":\"overview/index\"}]},{\"name\":\"host\",\"component\":\"Layout\",\"children\":[{\"name\":\"hostMonitoring\",\"meta\":{\"title\":\"[TEXT:2]\",\"icon\":\"el-icon-user\"},\"children\":[{\"name\":\"onlineUserIndex\",\"meta\":{\"title\":\"[TEXT:3]\"},\"component\":\"host/online/index\"},{\"name\":\"onlineUserCtList\",\"hidden\":true,\"meta\":{\"sameMenu\":\"/onlineUserIndex\"},\"component\":\"host/online/ctList\"},{\"name\":\"onlineUserDetails\",\"hidden\":true,\"meta\":{\"sameMenu\":\"/onlineUserIndex\"},\"component\":\"host/online/details\"},{\"name\":\"webUserIndex\",\"meta\":{\"title\":\"[TEXT:4]\"},\"component\":\"host/web/index\"},{\"name\":\"pppoeUserIndex\",\"meta\":{\"title\":\"[TEXT:5]\"},\"component\":\"host/pppoe/index\"},{\"name\":\"dhcpUserIndex\",\"meta\":{\"title\":\"[TEXT:6]\"},\"component\":\"host/dhcp/index\"}]}]},{\"name\":\"interface\",\"component\":\"Layout\",\"children\":[{\"name\":\"interfaceManage\",\"meta\":{\"title\":\"[TEXT:191]\",\"icon\":\"el-icon-interface\"},\"children\":[{\"name\":\"wanSet\",\"meta\":{\"title\":\"[TEXT:17]\"},\"children\":[{\"name\":\"wanSetIndex\",\"meta\":{\"title\":\"[TEXT:17]\"},\"component\":\"router/basic/wan/index\"},{\"name\":\"wanExtend\",\"meta\":{\"title\":\"[TEXT:19]\"},\"component\":\"router/basic/wanExtend/extend\"},{\"name\":\"multiDial\",\"meta\":{\"title\":\"[TEXT:20]\"},\"component\":\"router/basic/multiDial/dial\"},{\"name\":\"wanGroup\",\"meta\":{\"title\":\"[TEXT:182]\"},\"component\":\"router/basic/wanGroup/index\"}]},{\"name\":\"lanSet\",\"meta\":{\"title\":\"[TEXT:14]\"},\"children\":[{\"name\":\"lanSetIndex\",\"hidden\":[HIDDEN:BRIDGE:1],\"meta\":{\"title\":\"[TEXT:14]\"},\"component\":\"router/basic/lan/lanSet\"},{\"name\":\"dnsProxy\",\"meta\":{\"title\":\"[TEXT:16]\"},\"component\":\"router/basic/lan/dnsProxy\"}]},{\"name\":\"strategyRouter\",\"meta\":{\"title\":\"[TEXT:28]\"},\"children\":[{\"name\":\"strategyRouterIndex\",\"meta\":{\"title\":\"[TEXT:28]\"},\"component\":\"router/basic/strategyRouter/strategy\"},{\"name\":\"loadBalancing\",\"meta\":{\"title\":\"[TEXT:29]\"},\"component\":\"router/basic/strategyRouter/balancing\"},{\"name\":\"addressRange\",\"meta\":{\"title\":\"[TEXT:30]\"},\"component\":\"router/basic/strategyRouter/addressRange\"},{\"name\":\"lineStatus\",\"meta\":{\"title\":\"[TEXT:31]\"},\"component\":\"router/basic/strategyRouter/lineStatus\"},{\"name\":\"strategyRouterLog\",\"meta\":{\"title\":\"[TEXT:32]\"},\"component\":\"router/basic/strategyRouter/log\"}]},{\"name\":\"ipv6\",\"meta\":{\"title\":\"[TEXT:37]\"},\"children\":[{\"name\":\"lanSetIpv6\",\"meta\":{\"title\":\"[TEXT:38]\"},\"component\":\"router/basic/ipv6/lan\"},{\"name\":\"wanSetIpv6\",\"meta\":{\"title\":\"[TEXT:39]\"},\"component\":\"router/basic/ipv6/wan\"}]},{\"name\":\"lanWanBond\",\"meta\":{\"title\":\"[TEXT:22]\"},\"component\":\"router/basic/lanWanBond/index\"},{\"name\":\"portMode\",\"meta\":{\"title\":\"[TEXT:117]\"},\"component\":\"router/advanced/portMode/index\"},{\"name\":\"iptvSet\",\"meta\":{\"title\":\"[TEXT:26]\"},\"component\":\"router/basic/iptv/index\"},{\"name\":\"4gServices\",\"meta\":{\"title\":\"[TEXT:124]\"},\"component\":\"router/more/usb/4g\"}]}]},{\"name\":\"router\",\"component\":\"Layout\",\"children\":[{\"name\":\"routerManage\",\"meta\":{\"title\":\"[TEXT:7]\",\"icon\":\"el-icon-gateway\"},\"children\":[{\"name\":\"routerStatus\",\"meta\":{\"title\":\"[TEXT:8]\"},\"children\":[{\"name\":\"deviceOverviewIndex\",\"meta\":{\"title\":\"[TEXT:9]\"},\"component\":\"router/status/overview/index\"},{\"name\":\"deviceNetIndex\",\"meta\":{\"title\":\"[TEXT:10]\"},\"component\":\"router/status/net/index\"},{\"name\":\"webLogin\",\"meta\":{\"title\":\"[TEXT:12]\"},\"component\":\"router/system/login\"},{\"name\":\"routerLog\",\"meta\":{\"title\":\"[TEXT:11]\"},\"component\":\"network/log/router\"}]},{\"name\":\"flowControl\",\"meta\":{\"title\":\"[TEXT:40]\"},\"children\":[{\"name\":\"prioritySet\",\"meta\":{\"title\":\"[TEXT:41]\"},\"component\":\"router/flowCtrl/priority\"},{\"name\":\"bandwidthLimit\",\"meta\":{\"title\":\"[TEXT:42]\"},\"component\":\"router/flowCtrl/limit\"},{\"name\":\"bandwidthEnsure\",\"meta\":{\"title\":\"[TEXT:43]\"},\"component\":\"router/flowCtrl/ensure\"},{\"name\":\"controlException\",\"meta\":{\"title\":\"[TEXT:44]\"},\"component\":\"router/flowCtrl/exception\"}]},{\"name\":\"safetyManage\",\"meta\":{\"title\":\"[TEXT:53]\"},\"children\":[{\"name\":\"arpList\",\"meta\":{\"title\":\"[TEXT:54]\"},\"component\":\"router/safety/arp/index\"},{\"name\":\"accessControl\",\"meta\":{\"title\":\"[TEXT:63]\"},\"component\":\"router/behavior/acl/index\"},{\"name\":\"arpDefense\",\"meta\":{\"title\":\"[TEXT:55]\"},\"component\":\"router/safety/arpDefense/index\"},{\"name\":\"macFilter\",\"meta\":{\"title\":\"[TEXT:56]\"},\"component\":\"router/safety/mac/index\"},{\"name\":\"linksLimit\",\"meta\":{\"title\":\"[TEXT:57]\"},\"component\":\"router/safety/links/limit\"},{\"name\":\"ddosDefense\",\"meta\":{\"title\":\"[TEXT:59]\"},\"children\":[{\"name\":\"ddosDefenseIndex\",\"meta\":{\"title\":\"[TEXT:59]\"},\"component\":\"router/safety/ddos/ddos\"},{\"name\":\"ddosDefenseAuto\",\"meta\":{\"title\":\"[TEXT:60]\"},\"component\":\"router/safety/ddos/ddosFy\"}]},{\"name\":\"pingWan\",\"meta\":{\"title\":\"[TEXT:61]\"},\"component\":\"router/safety/pingWAN/index\"},{\"name\":\"linksSetIndex\",\"meta\":{\"title\":\"[TEXT:58]\"},\"component\":\"router/safety/links/set\"}]},{\"name\":\"behaviorManage\",\"meta\":{\"title\":\"[TEXT:62]\"},\"children\":[{\"name\":\"timeManage\",\"meta\":{\"title\":\"[TEXT:73]\"},\"component\":\"router/behavior/time/index\"},{\"name\":\"addressManage\",\"meta\":{\"title\":\"[TEXT:72]\"},\"component\":\"router/behavior/ips/index\"},{\"name\":\"behaviorRecognition\",\"meta\":{\"title\":\"[TEXT:202]\"},\"component\":\"router/behavior/behavior/index\"},{\"name\":\"siteManage\",\"meta\":{\"title\":\"[TEXT:64]\"},\"children\":[{\"name\":\"siteFilter\",\"meta\":{\"title\":\"[TEXT:65]\"},\"component\":\"router/behavior/site/filter\"},{\"name\":\"siteGroup\",\"meta\":{\"title\":\"[TEXT:66]\"},\"component\":\"router/behavior/site/group\"},{\"name\":\"siteDataBase\",\"meta\":{\"title\":\"[TEXT:67]\"},\"component\":\"router/behavior/site/dataBase\"},{\"name\":\"behaviorLog\",\"meta\":{\"title\":\"[TEXT:32]\"},\"component\":\"router/behavior/site/log\"}]},{\"name\":\"dnsManage\",\"meta\":{\"title\":\"[TEXT:68]\"},\"children\":[{\"name\":\"dnsFilter\",\"meta\":{\"title\":\"[TEXT:69]\"},\"component\":\"router/behavior/dns/filter\"},{\"name\":\"dnsRedirect\",\"meta\":{\"title\":\"[TEXT:70]\"},\"component\":\"router/behavior/dns/redirect\"}]},{\"name\":\"qqManage\",\"meta\":{\"title\":\"[TEXT:71]\"},\"component\":\"router/behavior/qq/index\"}]},{\"name\":\"vpnManage\",\"meta\":{\"title\":\"[TEXT:74]\"},\"children\":[{\"name\":\"ipsecSet\",\"meta\":{\"title\":\"[TEXT:75]\"},\"children\":[{\"name\":\"ipsecNet\",\"meta\":{\"title\":\"[TEXT:76]\"},\"component\":\"router/vpn/ipsec/ipsecNet\"},{\"name\":\"ipsecRoad\",\"meta\":{\"title\":\"[TEXT:77]\"},\"component\":\"router/vpn/ipsec/ipsecRoad\"}]},{\"name\":\"l2tp\",\"meta\":{\"title\":\"L2TP IPSEC\"},\"children\":[{\"name\":\"l2tpService\",\"meta\":{\"title\":\" L2TP IPSec\"},\"component\":\"router/vpn/l2tp/l2tpService\"},{\"name\":\"l2tpUser\",\"meta\":{\"title\":\"[TEXT:79]\"},\"component\":\"router/vpn/l2tp/l2tpUser\"},{\"name\":\"l2tpClient\",\"meta\":{\"title\":\"[TEXT:80]\"},\"component\":\"router/vpn/l2tp/l2tpClient\"}]},{\"name\":\"pptp\",\"meta\":{\"title\":\"[TEXT:81]\"},\"children\":[{\"name\":\"pptpService\",\"meta\":{\"title\":\"[TEXT:82]\"},\"component\":\"router/vpn/pptp/pptpService\"},{\"name\":\"pptpUser\",\"meta\":{\"title\":\"[TEXT:83]\"},\"component\":\"router/vpn/pptp/pptpUser\"},{\"name\":\"pptpClient\",\"meta\":{\"title\":\"[TEXT:84]\"},\"component\":\"router/vpn/pptp/pptpClient\"}]}]},{\"name\":\"advancedManage\",\"meta\":{\"title\":\"[TEXT:180]\"},\"children\":[{\"name\":\"portMapping\",\"meta\":{\"title\":\"[TEXT:103]\"},\"component\":\"router/advanced/mapping/mapping\"},{\"name\":\"upnpSet\",\"meta\":{\"title\":\"[TEXT:104]\"},\"children\":[{\"name\":\"upnpSetIndex\",\"meta\":{\"title\":\"[TEXT:104]\"},\"component\":\"router/advanced/upnp/config\"},{\"name\":\"upnpStatus\",\"meta\":{\"title\":\"[TEXT:198]\"},\"component\":\"router/advanced/upnp/status\"}]},{\"name\":\"dmzSet\",\"meta\":{\"title\":\"[TEXT:105]\"},\"component\":\"router/advanced/mapping/dmz\"},{\"name\":\"natSwitch\",\"meta\":{\"title\":\"[TEXT:106]\"},\"children\":[{\"name\":\"natOneOnOne\",\"meta\":{\"title\":\"[TEXT:107]\"},\"component\":\"router/advanced/nat/oneOnOne\"},{\"name\":\"natMoreOnMore\",\"meta\":{\"title\":\"[TEXT:108]\"},\"component\":\"router/advanced/nat/moreOnMore\"}]},{\"name\":\"routerSet\",\"meta\":{\"title\":\"[TEXT:109]\"},\"children\":[{\"name\":\"routerTable\",\"meta\":{\"title\":\"[TEXT:110]\"},\"component\":\"router/advanced/router/table\"},{\"name\":\"routerStatic\",\"meta\":{\"title\":\"[TEXT:111]\"},\"component\":\"router/advanced/router/static\"},{\"name\":\"routerTableIpv6\",\"meta\":{\"title\":\"[TEXT:112]\"},\"component\":\"router/advanced/router/table_ipv6\"},{\"name\":\"routerStaticIpv6\",\"meta\":{\"title\":\"[TEXT:113]\"},\"component\":\"router/advanced/router/static_ipv6\"}]},{\"name\":\"dnsStrategy\",\"meta\":{\"title\":\"[TEXT:33]\"},\"children\":[{\"name\":\"dnsRule\",\"meta\":{\"title\":\"[TEXT:34]\"},\"component\":\"router/basic/dnsStrategy/rule\"},{\"name\":\"dnsGroup\",\"meta\":{\"title\":\"[TEXT:35]\"},\"component\":\"router/basic/dnsStrategy/dnsGroup\"},{\"name\":\"dnsExportGroup\",\"meta\":{\"title\":\"[TEXT:36]\"},\"component\":\"router/basic/dnsStrategy/dnsExportGroup\"}]},{\"name\":\"ddns\",\"meta\":{\"title\":\"[TEXT:115]\"},\"component\":\"router/advanced/ddns/index\"},{\"name\":\"portImage\",\"meta\":{\"title\":\"[TEXT:114]\"},\"component\":\"router/advanced/image/index\"},{\"name\":\"natFast\",\"meta\":{\"title\":\"[TEXT:116]\"},\"component\":\"router/advanced/natFast/index\"},{\"name\":\"wakeup\",\"meta\":{\"title\":\"[TEXT:197]\"},\"component\":\"router/advanced/wakeup/index\"}]},{\"name\":\"moreFeatures\",\"meta\":{\"title\":\"[TEXT:118]\"},\"children\":[{\"name\":\"usbStorage\",\"meta\":{\"title\":\"[TEXT:119]\"},\"children\":[{\"name\":\"deviceStatus\",\"meta\":{\"title\":\"[TEXT:120]\"},\"component\":\"router/more/usb/status\"},{\"name\":\"sharedServices\",\"meta\":{\"title\":\"[TEXT:121]\"},\"component\":\"router/more/usb/service\"},{\"name\":\"usbPrinter\",\"meta\":{\"title\":\"[TEXT:122]\"},\"component\":\"router/more/usb/printer\"},{\"name\":\"usbLog\",\"meta\":{\"title\":\"[TEXT:123]\"},\"component\":\"router/more/usb/log\"}]}]},{\"name\":\"faultDiagnosis\",\"meta\":{\"title\":\"[TEXT:125]\"},\"children\":[{\"name\":\"healthIndex\",\"meta\":{\"title\":\"[TEXT:126]\"},\"component\":\"router/diagnose/network/index\"},{\"name\":\"diagnoseAlarm\",\"meta\":{\"title\":\"[TEXT:127]\"},\"component\":\"router/diagnose/alarm/index\"},{\"name\":\"netTool\",\"meta\":{\"title\":\"[TEXT:128]\"},\"children\":[{\"name\":\"pingCheck\",\"meta\":{\"title\":\"[TEXT:129]\"},\"component\":\"router/diagnose/nettool/ping\"},{\"name\":\"tracert\",\"meta\":{\"title\":\"[TEXT:130]\"},\"component\":\"router/diagnose/nettool/tracert\"},{\"name\":\"speedTool\",\"meta\":{\"title\":\"[TEXT:132]\"},\"component\":\"router/diagnose/nettool/velocity\"},{\"name\":\"dhcpDetect\",\"meta\":{\"title\":\"[TEXT:133]\"},\"component\":\"router/diagnose/nettool/dhcp\"}]}]}]}]},{\"name\":\"auth\",\"component\":\"Layout\",\"children\":[{\"name\":\"authenticationSet\",\"meta\":{\"title\":\"[TEXT:183]\",\"icon\":\"el-icon-auth\"},\"children\":[{\"name\":\"authenticationUser\",\"meta\":{\"title\":\"[TEXT:91]\"},\"component\":\"router/advanced/user\"},{\"name\":\"wisdomWifi\",\"meta\":{\"title\":\"[TEXT:99]\"},\"component\":\"router/advanced/auth/wisdom\"},{\"name\":\"billSystem\",\"meta\":{\"title\":\"[TEXT:100]\"},\"component\":\"router/advanced/auth/bill\"},{\"name\":\"authSet\",\"meta\":{\"title\":\"[TEXT:96]\"},\"children\":[{\"name\":\"baseSet\",\"meta\":{\"title\":\"[TEXT:48]\"},\"component\":\"router/advanced/auth/base\"},{\"name\":\"authenticationFree\",\"meta\":{\"title\":\"[TEXT:98]\"},\"component\":\"router/advanced/auth/free\"},{\"name\":\"authPage\",\"meta\":{\"title\":\"[TEXT:102]\"},\"component\":\"router/advanced/auth/page\"}]},{\"name\":\"pppoeSet\",\"meta\":{\"title\":\"[TEXT:93]\"},\"component\":\"router/advanced/pppoe/setting\"},{\"name\":\"pppoeExtend\",\"meta\":{\"title\":\"[TEXT:95]\"},\"component\":\"router/advanced/pppoe/extend\"},{\"name\":\"radiusSet\",\"meta\":{\"title\":\"[TEXT:101]\"},\"component\":\"router/advanced/auth/radius\"}]}]},{\"name\":\"wifi\",\"component\":\"Layout\",\"hidden\":false,\"children\":[{\"name\":\"wifiManage\",\"meta\":{\"title\":\"[TEXT:146]\",\"icon\":\"el-icon-wifi\"},\"children\":[{\"name\":\"apList\",\"meta\":{\"title\":\"[TEXT:147]\"},\"component\":\"wifi/ap\"},{\"name\":\"apUserList\",\"meta\":{\"title\":\"[TEXT:148]\"},\"component\":\"wifi/user\"},{\"name\":\"apRoam\",\"meta\":{\"title\":\"[TEXT:149]\"},\"component\":\"wifi/roam\"},{\"name\":\"apGroup\",\"meta\":{\"title\":\"[TEXT:150]\"},\"component\":\"wifi/group\"},{\"name\":\"apTemplate\",\"meta\":{\"title\":\"[TEXT:151]\"},\"children\":[{\"name\":\"tp24G\",\"meta\":{\"title\":\"[TEXT:153]\"},\"component\":\"wifi/template/tp24G\"},{\"name\":\"tp58G\",\"meta\":{\"title\":\"[TEXT:154]\"},\"component\":\"wifi/template/tp58G\"}]},{\"name\":\"apDevice\",\"meta\":{\"title\":\"[TEXT:155]\"},\"children\":[{\"name\":\"device24G\",\"meta\":{\"title\":\"[TEXT:156]\"},\"component\":\"wifi/device/device24G\"},{\"name\":\"device58G\",\"meta\":{\"title\":\"[TEXT:157]\"},\"component\":\"wifi/device/device58G\"}]},{\"name\":\"apUserManage\",\"meta\":{\"title\":\"[TEXT:91]\"},\"children\":[{\"name\":\"userLink\",\"meta\":{\"title\":\"[TEXT:159]\"},\"component\":\"wifi/userManage/userLink\"},{\"name\":\"blackWhiteList\",\"meta\":{\"title\":\"[TEXT:160]\"},\"component\":\"wifi/userManage/userBWList\"},{\"name\":\"userLinkLog\",\"meta\":{\"title\":\"[TEXT:161]\"},\"component\":\"wifi/userManage/linkLog\"}]},{\"name\":\"networkSystemManage\",\"meta\":{\"title\":\"[TEXT:164]\"},\"component\":\"network/systemManage\"},{\"name\":\"dhcpDefense\",\"meta\":{\"title\":\"[TEXT:167]\"},\"component\":\"network/dhcpDefense\"},{\"name\":\"wifiLog\",\"meta\":{\"title\":\"[TEXT:169]\"},\"component\":\"network/log/wifi\"}]}]},{\"name\":\"switch\",\"component\":\"Layout\",\"children\":[{\"name\":\"switchManage\",\"meta\":{\"title\":\"[TEXT:162]\",\"icon\":\"el-icon-core-switch\"},\"component\":\"switch/index\"}]},{\"name\":\"aiFriend\",\"component\":\"Layout\",\"children\":[{\"name\":\"aiFriendManage\",\"meta\":{\"title\":\"[TEXT:170]\",\"icon\":\"el-icon-ai\"},\"component\":\"ai/index\"}]},{\"name\":\"system\",\"component\":\"Layout\",\"children\":[{\"name\":\"systemManage\",\"meta\":{\"title\":\"[TEXT:134]\",\"icon\":\"el-icon-s-operation\"},\"children\":[{\"name\":\"remoteMaintain\",\"meta\":{\"title\":\"[TEXT:166]\"},\"component\":\"router/system/remote\"},{\"name\":\"loginManager\",\"meta\":{\"title\":\"[TEXT:165]\"},\"children\":[{\"name\":\"loginManage\",\"meta\":{\"title\":\"[TEXT:165]\"},\"component\":\"router/system/web/index\"},{\"name\":\"huserSet\",\"hidden\":[HIDDEN:AUTHXX:5],\"meta\":{\"title\":\"[TEXT:201]\"},\"component\":\"router/system/huser\"}]},{\"name\":\"configManage\",\"meta\":{\"title\":\"[TEXT:135]\"},\"children\":[{\"name\":\"backup\",\"meta\":{\"title\":\"[TEXT:136]\"},\"component\":\"router/system/config/backup\"},{\"name\":\"restore\",\"meta\":{\"title\":\"[TEXT:137]\"},\"component\":\"router/system/config/reset\"},{\"name\":\"timingBackup\",\"meta\":{\"title\":\"[TEXT:138]\"},\"component\":\"router/system/config/timingBackup\"}]},{\"name\":\"deviceReboot\",\"meta\":{\"title\":\"[TEXT:143]\"},\"children\":[{\"name\":\"systemReboot\",\"meta\":{\"title\":\"[TEXT:143]\"},\"component\":\"router/system/reboot/sysReboot\"},{\"name\":\"timingReboot\",\"meta\":{\"title\":\"[TEXT:144]\"},\"component\":\"router/system/reboot/timingReboot\"}]},{\"name\":\"systemUpgrade\",\"meta\":{\"title\":\"[TEXT:139]\"},\"children\":[{\"name\":\"upgradeLocal\",\"meta\":{\"title\":\"[TEXT:140]\"},\"component\":\"router/system/upgrade/local\"},{\"name\":\"upgradeOnline\",\"meta\":{\"title\":\"[TEXT:141]\"},\"component\":\"router/system/upgrade/online\"},{\"name\":\"upgradeApp\",\"meta\":{\"title\":\"[TEXT:142]\"},\"component\":\"router/system/upgrade/app\"}]},{\"name\":\"networkDate\",\"meta\":{\"title\":\"[TEXT:168]\"},\"component\":\"network/date\"}]}]}]}"; // weak
int fbss; // weak
int dword_67D054; // weak
int ll_httpd_conn_used; // weak
int dword_67D05C; // weak
int ll_mem_debug_list; // weak
int dword_67D064; // weak
int ll_httpd_conn_pty; // weak
int dword_67D06C; // weak
char byte_67D070; // weak
int dword_67D074; // weak
_UNKNOWN unk_67D078; // weak
int gl_httpd_guest_user_en; // weak
int gl_httpd_high_admin_en; // weak
int gl_httpd_user_en; // weak
int gl_hs_speed; // weak
int curfds; // weak
int all_mem_malloc_num; // weak
int ll_httpd_conn_all_num; // weak
int ll_httpd_conn_dd_num; // weak
int g_Raix_wsc_configured; // weak
int g_wsc_configured; // weak
int debug_level; // weak
int dword_67D0C4; // weak
int dword_67D0C8; // weak
int dword_67D0CC; // weak
int dword_67D0D0; // weak
char cookie_realm[512]; // idb
int jhl_realm_init; // weak
int user_login_init; // weak
int user_login_num; // weak
int dword_67D2EC; // weak
_UNKNOWN unk_67D2F0; // weak
int dword_67D4E0; // weak
int dword_67D4E4; // weak
int dword_67D4F0; // weak
_DWORD dword_67D500[2752]; // idb
_UNKNOWN unk_680000; // weak
int https_accept_num; // weak
int https_ssl_ctx; // weak
int dword_681510; // weak
char gl_httpd_high_adminpwd[32]; // idb
_DWORD gl_file_hash[4096]; // idb
_UNKNOWN gl_cgi_ext_hash; // weak
char gl_httpd_user[32]; // idb
char gl_httpd_guest_user[32]; // idb
char gl_httpd_high_admin[32]; // idb
char gl_httpd_admin[32]; // idb
_DWORD file_type2_str_hash[677]; // idb
char gl_httpd_high_adminpwd_md5[64]; // idb
_DWORD gl_vfile_ext_hash[4096]; // idb
char gl_httpd_adminpwd[32]; // idb
char gl_httpd_password_md5[64]; // idb
char gl_httpd_guest_pwd_md5[64]; // idb
char gl_usb_hpassword_md5[64]; // idb
char gl_httpd_guest_pwd[32]; // idb
char gl_httpd_adminpwd_md5[64]; // idb
char gl_httpd_password[32]; // idb
char gl_httpd_pppoe_br_md5[64]; // idb
char gl_usb_password_md5[64]; // idb
_DWORD ll_httpd_conn_hash[4096]; // idb
_UNKNOWN ll_mem_debug_hash; // weak
struct pollfd array_conn; // idb
int dword_6997E8; // weak
__int16 word_6997EC; // weak
char httpd_set_cookie[256]; // idb
int jhl_realm_str; // weak
char byte_6A38E4; // weak
char byte_6A38E8; // weak
int dword_6A38EC; // weak
int lan_restart_timer; // weak
int dword_6A3908; // weak
int dword_6A390C; // weak
int dword_6A3910; // weak
char gl_exec_service_name[256]; // idb
int net_restart_timer; // weak
int dword_6A3A1C; // weak
int dword_6A3A20; // weak
int dword_6A3A24; // weak
int gl_reset_timer; // weak
int dword_6A3A30; // weak
int dword_6A3A34; // weak
int dword_6A3A38; // weak
char msg_buf[512]; // idb
_UNKNOWN gl_auto_diagnosis_timer; // weak
int dword_6A3C44; // weak
int dword_6A3C48; // weak
int dword_6A3C4C; // weak
char ipsec_info[16640]; // idb
_UNKNOWN switch_reboot_timer; // weak
int dword_6A7D58; // weak
int dword_6A7D5C; // weak
int dword_6A7D60; // weak
_DWORD iptv_token_hlist_head[256]; // idb
_UNKNOWN end; // weak
// extern const struct in6_addr in6addr_any;
// extern _UNKNOWN wys_svn_info; weak
// extern _DWORD jhlret_err_str[1]; idb
// extern struct _IO_FILE *stderr;
// extern _UNKNOWN cJSON_DetachItemFromObject; weak
// extern _UNKNOWN tomato_buildtime; weak
// extern _UNKNOWN cJSON_SetValuestring; weak
// extern _UNKNOWN wayos_version; weak


//----- (0040B1B4) --------------------------------------------------------
void init_proc(void)
{
  sub_41FF2C();
  sub_4CC640();
}

//----- (0040B1F0) --------------------------------------------------------
int *ftext()
{
  int *result; // $v0

  result = &dword_667998;
  dword_6679B8 = (int)off_66B584;
  *off_66B584 = &dword_6679B4;
  off_66B584 = (void **)&dword_667998;
  dword_667998 = (int)&_httpd_cgi_all_fun;
  dword_66799C = (int)&dword_6679B4;
  dword_6679B4 = (int)&dword_667998;
  return result;
}
// 667998: using guessed type int dword_667998;
// 66799C: using guessed type int dword_66799C;
// 6679B4: using guessed type int dword_6679B4;
// 6679B8: using guessed type int dword_6679B8;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040B230) --------------------------------------------------------
_DWORD *ctor_002()
{
  _DWORD *result; // $v0

  result = dword_667730;
  dword_667980 = (int)off_66B584;
  *off_66B584 = &dword_66797C;
  dword_667964 = (int)&dword_66797C;
  dword_66797C = (int)&dword_667960;
  dword_667948 = (int)&dword_667960;
  dword_667960 = &dword_667944;
  dword_66792C = (int)&dword_667944;
  dword_667944 = &dword_667928;
  dword_667910 = (int)&dword_667928;
  dword_6678F4 = (int)&dword_66790C;
  dword_667928 = &dword_66790C;
  dword_6678D8 = (int)&dword_6678F0;
  dword_66790C = &dword_6678F0;
  dword_6678BC = (int)&dword_6678D4;
  dword_6678F0 = &dword_6678D4;
  dword_6678A0 = (int)&dword_6678B8;
  dword_6678D4 = &dword_6678B8;
  dword_6678B8 = &dword_66789C;
  dword_667884 = (int)&dword_66789C;
  dword_667868 = (int)&dword_667880;
  dword_66789C = &dword_667880;
  dword_66784C = (int)&dword_667864;
  dword_667880 = &dword_667864;
  dword_667864 = &dword_667848;
  dword_667830 = (int)&dword_667848;
  dword_667848 = &dword_66782C;
  dword_667814 = (int)&dword_66782C;
  dword_66782C = (int)&dword_667810;
  dword_6677F8 = (int)&dword_667810;
  dword_667810 = (int)&dword_6677F4;
  dword_66776C = (int)&dword_667784;
  dword_667784 = (int)&dword_667768;
  dword_667750 = (int)&dword_667768;
  dword_6677DC = (int)&dword_6677F4;
  unk_6677C0 = &dword_6677D8;
  *(_DWORD *)algn_6677A4 = &dword_6677BC;
  dword_667788 = (int)&dword_6677A0;
  dword_6677A0 = (int)&dword_667784;
  off_66B584 = (void **)dword_667730;
  dword_667730[0] = &_httpd_cgi_all_fun;
  dword_667730[1] = &dword_66774C;
  dword_66774C = (int)dword_667730;
  dword_6677F4 = (int)&dword_6677D8;
  dword_6677D8 = (int)&dword_6677BC;
  dword_6677BC = (int)&dword_6677A0;
  dword_667768 = (int)&dword_66774C;
  return result;
}
// 66774C: using guessed type int dword_66774C;
// 667750: using guessed type int dword_667750;
// 667768: using guessed type int dword_667768;
// 66776C: using guessed type int dword_66776C;
// 667784: using guessed type int dword_667784;
// 667788: using guessed type int dword_667788;
// 6677A0: using guessed type int dword_6677A0;
// 6677BC: using guessed type int dword_6677BC;
// 6677D8: using guessed type int dword_6677D8;
// 6677DC: using guessed type int dword_6677DC;
// 6677F4: using guessed type int dword_6677F4;
// 6677F8: using guessed type int dword_6677F8;
// 667810: using guessed type int dword_667810;
// 667814: using guessed type int dword_667814;
// 66782C: using guessed type int dword_66782C;
// 667830: using guessed type int dword_667830;
// 66784C: using guessed type int dword_66784C;
// 667868: using guessed type int dword_667868;
// 667884: using guessed type int dword_667884;
// 6678A0: using guessed type int dword_6678A0;
// 6678BC: using guessed type int dword_6678BC;
// 6678D8: using guessed type int dword_6678D8;
// 6678F4: using guessed type int dword_6678F4;
// 667910: using guessed type int dword_667910;
// 66792C: using guessed type int dword_66792C;
// 667948: using guessed type int dword_667948;
// 667964: using guessed type int dword_667964;
// 66797C: using guessed type int dword_66797C;
// 667980: using guessed type int dword_667980;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040B48C) --------------------------------------------------------
int __fastcall main(int a1, char **a2, char **a3)
{
  unsigned int v4; // $v0
  const char *v6; // $s2
  unsigned int v7; // $a0
  int v8; // $a0
  int v9; // $a1
  int v10; // $a2
  const char *v11; // $v0
  const char *v12; // $v0
  int v14; // $s1
  int v15; // [sp+28h] [-8h] BYREF

  v15 = 0;
  v4 = get_random_seed(a1, a2, a3);
  srand(v4);
  gl_hs_speed = nvram_get_int("jhttpd_hs_speed");
  nvram_unset("wan_webset_run");
  if ( a1 >= 2 )
  {
    v6 = a2[1];
    if ( !strcmp(v6, "wait") )
    {
      if ( a1 == 2 )
        v7 = 15;
      else
        v7 = J_atoi(a2[2]);
      sleep(v7);
    }
    else
    {
      debug_level = atoi(v6);
    }
  }
  register_signal();
  _get_cpu_uptime(&dword_67D0C8);
  jhl_httpd_reset_user();
  httpd_cgi_user_check_admin(v8, v9, v10);
  if ( debug_level > 0 )
    printf(
      "%s:%d user %s pwd %s port %u https port %u\n",
      "main",
      1817,
      gl_httpd_user,
      gl_httpd_password,
      (unsigned __int16)gl_httpd_port,
      (unsigned __int16)gl_httpd_https_port);
  v11 = (const char *)jhl_nv_get_def("usb_passwd");
  usb_httpd_passwd_md5(gl_usb_password_md5, v11);
  v12 = (const char *)jhl_nv_get_def("usb_hpasswd");
  usb_httpd_passwd_md5(gl_usb_hpassword_md5, v12);
  mem_init_fun();
  httpd_find_type2_init();
  if ( !httpd_sever_init(0, gl_httpd_port, 10000)
    && !https_ssl_init()
    && !https_sever_init(0, gl_httpd_https_port, 10000) )
  {
    if ( gl_httpd_tggl_port && gl_httpd_port != gl_httpd_tggl_port )
      httpd_tggl_init(0, gl_httpd_tggl_port, 10000);
    if ( !httpd_unix_init() && !httpd_poll_init() )
    {
      init_diagnosis_timer();
      switch_reboot_auto_timer_init();
      g_wsc_configured = nvram_getdef_int("WscConfigured", "1");
      v14 = 0;
      g_Raix_wsc_configured = nvram_getdef_int("WscConfigured_5g", "1");
      while ( !dword_67D0C4 && !httpd_poll(30) )
      {
        run_timers();
        get_uptime2(&v15);
        if ( (unsigned int)(v15 - v14) >= 4 )
        {
          cpu_rate_set();
          v14 = v15;
        }
      }
    }
  }
  exit_clean();
  return 0;
}
// 40B5C8: variable 'v8' is possibly undefined
// 40B5C8: variable 'v9' is possibly undefined
// 40B5C8: variable 'v10' is possibly undefined
// 666174: using guessed type __int16 gl_httpd_https_port;
// 666176: using guessed type __int16 gl_httpd_tggl_port;
// 666178: using guessed type __int16 gl_httpd_port;
// 67D0A0: using guessed type int gl_hs_speed;
// 67D0B4: using guessed type int g_Raix_wsc_configured;
// 67D0B8: using guessed type int g_wsc_configured;
// 67D0BC: using guessed type int debug_level;
// 67D0C4: using guessed type int dword_67D0C4;
// 67D0C8: using guessed type int dword_67D0C8;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A8344: using guessed type int run_timers(void);
// 6A8400: using guessed type int __fastcall _get_cpu_uptime(_DWORD);
// 6A845C: using guessed type int __fastcall get_random_seed(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A8804: using guessed type int __fastcall get_uptime2(_DWORD);
// 6A8828: using guessed type int __fastcall nvram_getdef_int(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0040B904) --------------------------------------------------------
_DWORD *ctor_003()
{
  _DWORD *result; // $v0

  result = &dword_66B3C0;
  dword_66B568 = (int)off_66B584;
  *off_66B584 = &dword_66B564;
  dword_66B54C = (int)&dword_66B564;
  dword_66B564 = (int)&dword_66B548;
  dword_66B548 = (int)&dword_66B52C;
  dword_66B52C = (int)&dword_66B510;
  dword_66B510 = (int)&dword_66B4F4;
  dword_66B4F4 = (int)&dword_66B4D8;
  dword_66B530 = (int)&dword_66B548;
  dword_66B514 = (int)&dword_66B52C;
  dword_66B4F8 = (int)&dword_66B510;
  dword_66B4DC = (int)&dword_66B4F4;
  dword_66B4C0 = (int)&dword_66B4D8;
  dword_66B4D8 = (int)&dword_66B4BC;
  dword_66B4A4 = (int)&dword_66B4BC;
  dword_66B488 = (int)&dword_66B4A0;
  dword_66B4BC = (int)&dword_66B4A0;
  dword_66B46C = (int)&dword_66B484;
  dword_66B4A0 = &dword_66B484;
  dword_66B450 = (int)&dword_66B468;
  dword_66B484 = &dword_66B468;
  dword_66B434 = (int)&dword_66B44C;
  dword_66B468 = &dword_66B44C;
  dword_66B418 = (int)&dword_66B430;
  dword_66B44C = &dword_66B430;
  dword_66B430 = &dword_66B414;
  dword_66B3FC = (int)&dword_66B414;
  dword_66B414 = (int)&dword_66B3F8;
  dword_66B3E0 = (int)&dword_66B3F8;
  dword_66B3F8 = (int)&dword_66B3DC;
  off_66B584 = (void **)&dword_66B3C0;
  dword_66B3C0 = &_httpd_cgi_all_fun;
  dword_66B3C4 = (int)&dword_66B3DC;
  dword_66B3DC = (int)&dword_66B3C0;
  return result;
}
// 66B3C4: using guessed type int dword_66B3C4;
// 66B3DC: using guessed type int dword_66B3DC;
// 66B3E0: using guessed type int dword_66B3E0;
// 66B3F8: using guessed type int dword_66B3F8;
// 66B3FC: using guessed type int dword_66B3FC;
// 66B414: using guessed type int dword_66B414;
// 66B418: using guessed type int dword_66B418;
// 66B434: using guessed type int dword_66B434;
// 66B450: using guessed type int dword_66B450;
// 66B46C: using guessed type int dword_66B46C;
// 66B488: using guessed type int dword_66B488;
// 66B4A4: using guessed type int dword_66B4A4;
// 66B4BC: using guessed type int dword_66B4BC;
// 66B4C0: using guessed type int dword_66B4C0;
// 66B4D8: using guessed type int dword_66B4D8;
// 66B4DC: using guessed type int dword_66B4DC;
// 66B4F4: using guessed type int dword_66B4F4;
// 66B4F8: using guessed type int dword_66B4F8;
// 66B510: using guessed type int dword_66B510;
// 66B514: using guessed type int dword_66B514;
// 66B52C: using guessed type int dword_66B52C;
// 66B530: using guessed type int dword_66B530;
// 66B548: using guessed type int dword_66B548;
// 66B54C: using guessed type int dword_66B54C;
// 66B564: using guessed type int dword_66B564;
// 66B568: using guessed type int dword_66B568;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040BAB8) --------------------------------------------------------
int *ctor_004()
{
  int *result; // $v0

  dword_66B3A4[1] = off_66B584;
  *off_66B584 = dword_66B3A4;
  dword_66B388[1] = dword_66B3A4;
  dword_66B3A4[0] = dword_66B388;
  unk_66B370 = dword_66B388;
  dword_66B388[0] = &dword_66B36C;
  dword_66B350[1] = &dword_66B36C;
  dword_66B36C = (int)dword_66B350;
  dword_66B334[1] = dword_66B350;
  dword_66B350[0] = dword_66B334;
  dword_66B318[1] = dword_66B334;
  dword_66B334[0] = dword_66B318;
  dword_66B2FC[1] = dword_66B318;
  dword_66B318[0] = dword_66B2FC;
  dword_66B2E0[1] = dword_66B2FC;
  dword_66B2FC[0] = dword_66B2E0;
  dword_66B2C4[1] = dword_66B2E0;
  dword_66B2E0[0] = dword_66B2C4;
  dword_66B2A8[1] = dword_66B2C4;
  dword_66B2C4[0] = dword_66B2A8;
  dword_66B28C[1] = dword_66B2A8;
  dword_66B2A8[0] = dword_66B28C;
  dword_66B270[1] = dword_66B28C;
  dword_66B28C[0] = dword_66B270;
  dword_66B254[1] = dword_66B270;
  dword_66B270[0] = dword_66B254;
  dword_66B238[1] = dword_66B254;
  dword_66B254[0] = dword_66B238;
  dword_66B21C[1] = dword_66B238;
  dword_66B238[0] = dword_66B21C;
  dword_66B200[1] = dword_66B21C;
  dword_66B21C[0] = dword_66B200;
  dword_66B1E4[1] = dword_66B200;
  dword_66B200[0] = dword_66B1E4;
  dword_66B1C8[1] = dword_66B1E4;
  dword_66B1E4[0] = dword_66B1C8;
  dword_66B1AC[1] = dword_66B1C8;
  dword_66B1C8[0] = dword_66B1AC;
  dword_66B190[1] = dword_66B1AC;
  dword_66B1AC[0] = dword_66B190;
  dword_66B174[1] = dword_66B190;
  dword_66B190[0] = dword_66B174;
  dword_66B158[1] = dword_66B174;
  dword_66B174[0] = dword_66B158;
  dword_66B13C[1] = dword_66B158;
  dword_66B158[0] = dword_66B13C;
  dword_66B13C[0] = dword_66B120;
  dword_66B120[1] = dword_66B13C;
  dword_66B104[1] = dword_66B120;
  unk_66B0EC = dword_66B104;
  dword_66B120[0] = dword_66B104;
  unk_66B0D0 = &dword_66B0E8;
  dword_66B104[0] = &dword_66B0E8;
  *(_DWORD *)algn_66B0B4 = &dword_66B0CC;
  dword_66B0E8 = (int)&dword_66B0CC;
  dword_66B0CC = (int)&dword_66B0B0;
  dword_66B0B0 = (int)&dword_66B094;
  dword_66B094 = (int)&dword_66B078;
  dword_66B078 = (int)&dword_66B05C;
  dword_66B05C = (int)&dword_66B040;
  dword_66B040 = (int)&dword_66B024;
  dword_66B024 = (int)&dword_66B008;
  *(_DWORD *)algn_66AF64 = &dword_66AF7C;
  dword_66B008 = (int)&dword_66AFEC;
  dword_66AF48 = (int)&dword_66AF60;
  dword_66AFEC = (int)&dword_66AFD0;
  unk_66B098 = &dword_66B0B0;
  dword_66AFD0 = (int)&dword_66AFB4;
  unk_66B07C = &dword_66B094;
  dword_66AFB4 = (int)&dword_66AF98;
  unk_66B060 = &dword_66B078;
  dword_66AF98 = (int)&dword_66AF7C;
  *(_DWORD *)algn_66B044 = &dword_66B05C;
  dword_66AF7C = (int)&dword_66AF60;
  unk_66B028 = &dword_66B040;
  dword_66AF60 = (int)&dword_66AF44;
  unk_66B00C = &dword_66B024;
  dword_66AFF0 = (int)&dword_66B008;
  *(_DWORD *)algn_66AFD4 = &dword_66AFEC;
  dword_66AFB8 = (int)&dword_66AFD0;
  unk_66AF9C = &dword_66AFB4;
  dword_66AF80 = (int)&dword_66AF98;
  unk_66AF2C = &dword_66AF44;
  dword_66AF44 = (int)&dword_66AF28;
  dword_66AF28 = (int)&dword_66AF0C;
  dword_66AF0C = (int)&dword_66AEF0;
  dword_66AEF0 = (int)&dword_66AED4;
  dword_66AED4 = (int)&dword_66AEB8;
  dword_66AEA0 = (int)&dword_66AEB8;
  dword_66AEB8 = (int)&dword_66AE9C;
  *(_DWORD *)algn_66AE84 = &dword_66AE9C;
  dword_66AE68 = (int)&dword_66AE80;
  unk_66AE4C = &dword_66AE64;
  dword_66AE9C = (int)&dword_66AE80;
  dword_66AE80 = (int)&dword_66AE64;
  unk_66AE30 = &dword_66AE48;
  dword_66AE64 = (int)&dword_66AE48;
  dword_66AE48 = (int)&dword_66AE2C;
  *(_DWORD *)algn_66AE14 = &dword_66AE2C;
  dword_66AE2C = (int)&dword_66AE10;
  unk_66ADF8 = &dword_66AE10;
  dword_66AE10 = (int)&dword_66ADF4;
  unk_66ADDC = &dword_66ADF4;
  dword_66ADF4 = (int)&dword_66ADD8;
  dword_66AF10 = (int)&dword_66AF28;
  *(_DWORD *)algn_66AEF4 = &dword_66AF0C;
  dword_66AED8 = (int)&dword_66AEF0;
  unk_66AEBC = &dword_66AED4;
  unk_66ADC0 = &dword_66ADD8;
  dword_66ADD8 = (int)&dword_66ADBC;
  *(_DWORD *)algn_66ADA4 = &dword_66ADBC;
  dword_66ADBC = (int)&dword_66ADA0;
  unk_66AD88 = &dword_66ADA0;
  dword_66ADA0 = (int)&dword_66AD84;
  unk_66AD6C = &dword_66AD84;
  dword_66AD84 = (int)&dword_66AD68;
  unk_66AD50 = &dword_66AD68;
  dword_66AD68 = (int)&dword_66AD4C;
  *(_DWORD *)algn_66AD34 = &dword_66AD4C;
  dword_66AD4C = (int)&dword_66AD30;
  unk_66AD18 = &dword_66AD30;
  dword_66AD30 = (int)&dword_66AD14;
  unk_66ACFC = &dword_66AD14;
  dword_66AD14 = (int)&dword_66ACF8;
  unk_66ACE0 = &dword_66ACF8;
  dword_66ACF8 = (int)&dword_66ACDC;
  *(_DWORD *)algn_66ACC4 = &dword_66ACDC;
  dword_66ACDC = (int)&dword_66ACC0;
  unk_66ACA8 = &dword_66ACC0;
  dword_66ACC0 = (int)&dword_66ACA4;
  unk_66AC8C = &dword_66ACA4;
  dword_66ACA4 = (int)&dword_66AC88;
  unk_66AC70 = &dword_66AC88;
  dword_66AC88 = (int)&dword_66AC6C;
  *(_DWORD *)algn_66AC54 = &dword_66AC6C;
  dword_66AC6C = (int)&dword_66AC50;
  unk_66AC38 = &dword_66AC50;
  dword_66AC50 = (int)&dword_66AC34;
  unk_66AC1C = &dword_66AC34;
  dword_66AC34 = (int)&dword_66AC18;
  unk_66AC00 = &dword_66AC18;
  dword_66AC18 = (int)&dword_66ABFC;
  *(_DWORD *)algn_66ABE4 = &dword_66ABFC;
  dword_66ABFC = (int)&dword_66ABE0;
  unk_66ABC8 = &dword_66ABE0;
  dword_66ABE0 = (int)&dword_66ABC4;
  unk_66ABAC = &dword_66ABC4;
  dword_66ABC4 = (int)&dword_66ABA8;
  unk_66AB90 = &dword_66ABA8;
  dword_66ABA8 = (int)&dword_66AB8C;
  *(_DWORD *)algn_66AB74 = &dword_66AB8C;
  dword_66AB8C = (int)&dword_66AB70;
  unk_66AB58 = &dword_66AB70;
  dword_66AB70 = (int)&dword_66AB54;
  unk_66AB3C = &dword_66AB54;
  dword_66AB54 = (int)&dword_66AB38;
  result = &dword_66AB1C;
  off_66B584 = (void **)&dword_66AB1C;
  unk_66AB20 = &dword_66AB38;
  dword_66AB38 = (int)&dword_66AB1C;
  dword_66AB1C = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66AB1C: using guessed type int dword_66AB1C;
// 66AB38: using guessed type int dword_66AB38;
// 66AB54: using guessed type int dword_66AB54;
// 66AB70: using guessed type int dword_66AB70;
// 66AB8C: using guessed type int dword_66AB8C;
// 66ABA8: using guessed type int dword_66ABA8;
// 66ABC4: using guessed type int dword_66ABC4;
// 66ABE0: using guessed type int dword_66ABE0;
// 66ABFC: using guessed type int dword_66ABFC;
// 66AC18: using guessed type int dword_66AC18;
// 66AC34: using guessed type int dword_66AC34;
// 66AC50: using guessed type int dword_66AC50;
// 66AC6C: using guessed type int dword_66AC6C;
// 66AC88: using guessed type int dword_66AC88;
// 66ACA4: using guessed type int dword_66ACA4;
// 66ACC0: using guessed type int dword_66ACC0;
// 66ACDC: using guessed type int dword_66ACDC;
// 66ACF8: using guessed type int dword_66ACF8;
// 66AD14: using guessed type int dword_66AD14;
// 66AD30: using guessed type int dword_66AD30;
// 66AD4C: using guessed type int dword_66AD4C;
// 66AD68: using guessed type int dword_66AD68;
// 66AD84: using guessed type int dword_66AD84;
// 66ADA0: using guessed type int dword_66ADA0;
// 66ADBC: using guessed type int dword_66ADBC;
// 66ADD8: using guessed type int dword_66ADD8;
// 66ADF4: using guessed type int dword_66ADF4;
// 66AE10: using guessed type int dword_66AE10;
// 66AE2C: using guessed type int dword_66AE2C;
// 66AE48: using guessed type int dword_66AE48;
// 66AE64: using guessed type int dword_66AE64;
// 66AE68: using guessed type int dword_66AE68;
// 66AE80: using guessed type int dword_66AE80;
// 66AE9C: using guessed type int dword_66AE9C;
// 66AEA0: using guessed type int dword_66AEA0;
// 66AEB8: using guessed type int dword_66AEB8;
// 66AED4: using guessed type int dword_66AED4;
// 66AED8: using guessed type int dword_66AED8;
// 66AEF0: using guessed type int dword_66AEF0;
// 66AF0C: using guessed type int dword_66AF0C;
// 66AF10: using guessed type int dword_66AF10;
// 66AF28: using guessed type int dword_66AF28;
// 66AF44: using guessed type int dword_66AF44;
// 66AF48: using guessed type int dword_66AF48;
// 66AF60: using guessed type int dword_66AF60;
// 66AF7C: using guessed type int dword_66AF7C;
// 66AF80: using guessed type int dword_66AF80;
// 66AF98: using guessed type int dword_66AF98;
// 66AFB4: using guessed type int dword_66AFB4;
// 66AFB8: using guessed type int dword_66AFB8;
// 66AFD0: using guessed type int dword_66AFD0;
// 66AFEC: using guessed type int dword_66AFEC;
// 66AFF0: using guessed type int dword_66AFF0;
// 66B008: using guessed type int dword_66B008;
// 66B024: using guessed type int dword_66B024;
// 66B040: using guessed type int dword_66B040;
// 66B05C: using guessed type int dword_66B05C;
// 66B078: using guessed type int dword_66B078;
// 66B094: using guessed type int dword_66B094;
// 66B0B0: using guessed type int dword_66B0B0;
// 66B0CC: using guessed type int dword_66B0CC;
// 66B0E8: using guessed type int dword_66B0E8;
// 66B36C: using guessed type int dword_66B36C;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040C40C) --------------------------------------------------------
int *ctor_005()
{
  int *result; // $v0

  result = &dword_66AAE4;
  dword_66AB04 = (int)off_66B584;
  *off_66B584 = &dword_66AB00;
  off_66B584 = (void **)&dword_66AAE4;
  dword_66AAE4 = (int)&_httpd_cgi_all_fun;
  dword_66AAE8 = (int)&dword_66AB00;
  dword_66AB00 = (int)&dword_66AAE4;
  return result;
}
// 66AAE4: using guessed type int dword_66AAE4;
// 66AAE8: using guessed type int dword_66AAE8;
// 66AB00: using guessed type int dword_66AB00;
// 66AB04: using guessed type int dword_66AB04;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040C44C) --------------------------------------------------------
int *ctor_006()
{
  int *result; // $v0

  result = &dword_66AA90;
  dword_66AACC = (int)off_66B584;
  *off_66B584 = &dword_66AAC8;
  dword_66AAB0 = (int)&dword_66AAC8;
  dword_66AAC8 = (int)&dword_66AAAC;
  off_66B584 = (void **)&dword_66AA90;
  dword_66AA90 = (int)&_httpd_cgi_all_fun;
  dword_66AA94 = (int)&dword_66AAAC;
  dword_66AAAC = (int)&dword_66AA90;
  return result;
}
// 66AA90: using guessed type int dword_66AA90;
// 66AA94: using guessed type int dword_66AA94;
// 66AAAC: using guessed type int dword_66AAAC;
// 66AAB0: using guessed type int dword_66AAB0;
// 66AAC8: using guessed type int dword_66AAC8;
// 66AACC: using guessed type int dword_66AACC;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040C49C) --------------------------------------------------------
int *ctor_007()
{
  int *result; // $v0

  result = &dword_66AA58;
  dword_66AA78 = (int)off_66B584;
  *off_66B584 = &dword_66AA74;
  off_66B584 = (void **)&dword_66AA58;
  dword_66AA58 = (int)&_httpd_cgi_all_fun;
  dword_66AA5C = (int)&dword_66AA74;
  dword_66AA74 = (int)&dword_66AA58;
  return result;
}
// 66AA58: using guessed type int dword_66AA58;
// 66AA5C: using guessed type int dword_66AA5C;
// 66AA74: using guessed type int dword_66AA74;
// 66AA78: using guessed type int dword_66AA78;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040C4DC) --------------------------------------------------------
_DWORD *ctor_008()
{
  _DWORD *result; // $v0

  result = dword_66A828;
  dword_66AA40 = (int)off_66B584;
  *off_66B584 = &dword_66AA3C;
  dword_66AA24 = (int)&dword_66AA3C;
  dword_66AA3C = (int)&dword_66AA20;
  dword_66AA08 = (int)&dword_66AA20;
  dword_66AA20 = (int)&dword_66AA04;
  dword_66A9EC = (int)&dword_66AA04;
  dword_66AA04 = (int)&dword_66A9E8;
  dword_66A9D0 = (int)&dword_66A9E8;
  dword_66A9B4 = (int)&dword_66A9CC;
  dword_66A9E8 = &dword_66A9CC;
  dword_66A998 = (int)&dword_66A9B0;
  dword_66A9CC = &dword_66A9B0;
  dword_66A97C = (int)&dword_66A994;
  dword_66A9B0 = &dword_66A994;
  dword_66A960 = (int)&dword_66A978;
  dword_66A994 = &dword_66A978;
  dword_66A944 = (int)&dword_66A95C;
  dword_66A978 = &dword_66A95C;
  dword_66A928 = (int)&dword_66A940;
  dword_66A95C = &dword_66A940;
  dword_66A90C = (int)&dword_66A924;
  dword_66A940 = &dword_66A924;
  dword_66A8F0 = (int)&dword_66A908;
  dword_66A924 = &dword_66A908;
  dword_66A908 = &dword_66A8EC;
  dword_66A8D4 = (int)&dword_66A8EC;
  dword_66A8EC = (int)&dword_66A8D0;
  dword_66A8B8 = (int)&dword_66A8D0;
  dword_66A8D0 = (int)&dword_66A8B4;
  dword_66A89C = (int)&dword_66A8B4;
  dword_66A8B4 = (int)&dword_66A898;
  dword_66A880 = (int)&dword_66A898;
  dword_66A864 = (int)&dword_66A87C;
  dword_66A848 = (int)&dword_66A860;
  off_66B584 = (void **)dword_66A828;
  dword_66A828[0] = &_httpd_cgi_all_fun;
  dword_66A828[1] = &dword_66A844;
  dword_66A898 = (int)&dword_66A87C;
  dword_66A87C = (int)&dword_66A860;
  dword_66A860 = (int)&dword_66A844;
  dword_66A844 = (int)dword_66A828;
  return result;
}
// 66A844: using guessed type int dword_66A844;
// 66A848: using guessed type int dword_66A848;
// 66A860: using guessed type int dword_66A860;
// 66A864: using guessed type int dword_66A864;
// 66A87C: using guessed type int dword_66A87C;
// 66A880: using guessed type int dword_66A880;
// 66A898: using guessed type int dword_66A898;
// 66A89C: using guessed type int dword_66A89C;
// 66A8B4: using guessed type int dword_66A8B4;
// 66A8B8: using guessed type int dword_66A8B8;
// 66A8D0: using guessed type int dword_66A8D0;
// 66A8D4: using guessed type int dword_66A8D4;
// 66A8EC: using guessed type int dword_66A8EC;
// 66A8F0: using guessed type int dword_66A8F0;
// 66A90C: using guessed type int dword_66A90C;
// 66A928: using guessed type int dword_66A928;
// 66A944: using guessed type int dword_66A944;
// 66A960: using guessed type int dword_66A960;
// 66A97C: using guessed type int dword_66A97C;
// 66A998: using guessed type int dword_66A998;
// 66A9B4: using guessed type int dword_66A9B4;
// 66A9D0: using guessed type int dword_66A9D0;
// 66A9EC: using guessed type int dword_66A9EC;
// 66AA04: using guessed type int dword_66AA04;
// 66AA08: using guessed type int dword_66AA08;
// 66AA20: using guessed type int dword_66AA20;
// 66AA24: using guessed type int dword_66AA24;
// 66AA3C: using guessed type int dword_66AA3C;
// 66AA40: using guessed type int dword_66AA40;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040C700) --------------------------------------------------------
_DWORD *ctor_009()
{
  _DWORD *result; // $v0

  result = dword_66A630;
  dword_66A810 = (int)off_66B584;
  *off_66B584 = &dword_66A80C;
  dword_66A7F4 = (int)&dword_66A80C;
  dword_66A80C = (int)&dword_66A7F0;
  dword_66A7D8 = (int)&dword_66A7F0;
  dword_66A7F0 = (int)&dword_66A7D4;
  dword_66A7BC = (int)&dword_66A7D4;
  dword_66A7D4 = (int)&dword_66A7B8;
  dword_66A7B8 = (int)&dword_66A79C;
  dword_66A784 = (int)&dword_66A79C;
  dword_66A7A0 = (int)&dword_66A7B8;
  dword_66A79C = (int)&dword_66A780;
  dword_66A768 = (int)&dword_66A780;
  dword_66A780 = &dword_66A764;
  dword_66A74C = (int)&dword_66A764;
  dword_66A730 = (int)&dword_66A748;
  dword_66A764 = &dword_66A748;
  dword_66A714 = (int)&dword_66A72C;
  dword_66A748 = &dword_66A72C;
  dword_66A72C = &dword_66A710;
  dword_66A6F8 = (int)&dword_66A710;
  dword_66A6DC = (int)&dword_66A6F4;
  dword_66A710 = &dword_66A6F4;
  dword_66A6F4 = &dword_66A6D8;
  dword_66A6C0 = (int)&dword_66A6D8;
  dword_66A6D8 = &dword_66A6BC;
  dword_66A650 = (int)&dword_66A668;
  dword_66A668 = (int)&dword_66A64C;
  dword_66A6A4 = (int)&dword_66A6BC;
  dword_66A6BC = (int)&dword_66A6A0;
  dword_66A688 = (int)&dword_66A6A0;
  dword_66A6A0 = (int)&dword_66A684;
  dword_66A66C = (int)&dword_66A684;
  dword_66A684 = (int)&dword_66A668;
  off_66B584 = (void **)dword_66A630;
  dword_66A630[0] = &_httpd_cgi_all_fun;
  dword_66A630[1] = &dword_66A64C;
  dword_66A64C = (int)dword_66A630;
  return result;
}
// 66A64C: using guessed type int dword_66A64C;
// 66A650: using guessed type int dword_66A650;
// 66A668: using guessed type int dword_66A668;
// 66A66C: using guessed type int dword_66A66C;
// 66A684: using guessed type int dword_66A684;
// 66A688: using guessed type int dword_66A688;
// 66A6A0: using guessed type int dword_66A6A0;
// 66A6A4: using guessed type int dword_66A6A4;
// 66A6BC: using guessed type int dword_66A6BC;
// 66A6C0: using guessed type int dword_66A6C0;
// 66A6DC: using guessed type int dword_66A6DC;
// 66A6F8: using guessed type int dword_66A6F8;
// 66A714: using guessed type int dword_66A714;
// 66A730: using guessed type int dword_66A730;
// 66A74C: using guessed type int dword_66A74C;
// 66A768: using guessed type int dword_66A768;
// 66A784: using guessed type int dword_66A784;
// 66A79C: using guessed type int dword_66A79C;
// 66A7A0: using guessed type int dword_66A7A0;
// 66A7B8: using guessed type int dword_66A7B8;
// 66A7BC: using guessed type int dword_66A7BC;
// 66A7D4: using guessed type int dword_66A7D4;
// 66A7D8: using guessed type int dword_66A7D8;
// 66A7F0: using guessed type int dword_66A7F0;
// 66A7F4: using guessed type int dword_66A7F4;
// 66A80C: using guessed type int dword_66A80C;
// 66A810: using guessed type int dword_66A810;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040C8EC) --------------------------------------------------------
_DWORD *ctor_010()
{
  _DWORD *result; // $v0

  result = dword_66A3AC;
  dword_66A618 = (int)off_66B584;
  *off_66B584 = &dword_66A614;
  dword_66A5FC = (int)&dword_66A614;
  dword_66A614 = &dword_66A5F8;
  dword_66A5E0 = (int)&dword_66A5F8;
  dword_66A5F8 = &dword_66A5DC;
  dword_66A5C4 = (int)&dword_66A5DC;
  dword_66A5A8 = (int)&dword_66A5C0;
  dword_66A5DC = &dword_66A5C0;
  dword_66A58C = (int)&dword_66A5A4;
  dword_66A5C0 = &dword_66A5A4;
  dword_66A5A4 = &dword_66A588;
  dword_66A570 = (int)&dword_66A588;
  dword_66A554 = (int)&dword_66A56C;
  dword_66A588 = &dword_66A56C;
  dword_66A538 = (int)&dword_66A550;
  dword_66A56C = &dword_66A550;
  dword_66A550 = &dword_66A534;
  dword_66A51C = (int)&dword_66A534;
  dword_66A500 = (int)&dword_66A518;
  dword_66A534 = &dword_66A518;
  dword_66A518 = &dword_66A4FC;
  dword_66A4E4 = (int)&dword_66A4FC;
  dword_66A4FC = &dword_66A4E0;
  dword_66A4C8 = (int)&dword_66A4E0;
  dword_66A4E0 = &dword_66A4C4;
  dword_66A4AC = (int)&dword_66A4C4;
  dword_66A43C = (int)&dword_66A454;
  dword_66A454 = (int)&dword_66A438;
  dword_66A420 = (int)&dword_66A438;
  dword_66A3E8 = (int)&dword_66A400;
  dword_66A400 = (int)&dword_66A3E4;
  dword_66A3CC = (int)&dword_66A3E4;
  dword_66A490 = (int)&dword_66A4A8;
  dword_66A474 = (int)&dword_66A48C;
  unk_66A458 = &dword_66A470;
  dword_66A404 = (int)&dword_66A41C;
  dword_66A41C = (int)&dword_66A400;
  off_66B584 = (void **)dword_66A3AC;
  dword_66A3AC[0] = &_httpd_cgi_all_fun;
  dword_66A3AC[1] = &dword_66A3C8;
  dword_66A3C8 = (int)dword_66A3AC;
  dword_66A4C4 = (int)&dword_66A4A8;
  dword_66A4A8 = (int)&dword_66A48C;
  dword_66A48C = (int)&dword_66A470;
  dword_66A470 = (int)&dword_66A454;
  dword_66A438 = (int)&dword_66A41C;
  dword_66A3E4 = (int)&dword_66A3C8;
  return result;
}
// 66A3C8: using guessed type int dword_66A3C8;
// 66A3CC: using guessed type int dword_66A3CC;
// 66A3E4: using guessed type int dword_66A3E4;
// 66A3E8: using guessed type int dword_66A3E8;
// 66A400: using guessed type int dword_66A400;
// 66A404: using guessed type int dword_66A404;
// 66A41C: using guessed type int dword_66A41C;
// 66A420: using guessed type int dword_66A420;
// 66A438: using guessed type int dword_66A438;
// 66A43C: using guessed type int dword_66A43C;
// 66A454: using guessed type int dword_66A454;
// 66A470: using guessed type int dword_66A470;
// 66A474: using guessed type int dword_66A474;
// 66A48C: using guessed type int dword_66A48C;
// 66A490: using guessed type int dword_66A490;
// 66A4A8: using guessed type int dword_66A4A8;
// 66A4AC: using guessed type int dword_66A4AC;
// 66A4C4: using guessed type int dword_66A4C4;
// 66A4C8: using guessed type int dword_66A4C8;
// 66A4E4: using guessed type int dword_66A4E4;
// 66A500: using guessed type int dword_66A500;
// 66A51C: using guessed type int dword_66A51C;
// 66A538: using guessed type int dword_66A538;
// 66A554: using guessed type int dword_66A554;
// 66A570: using guessed type int dword_66A570;
// 66A58C: using guessed type int dword_66A58C;
// 66A5A8: using guessed type int dword_66A5A8;
// 66A5C4: using guessed type int dword_66A5C4;
// 66A5E0: using guessed type int dword_66A5E0;
// 66A5FC: using guessed type int dword_66A5FC;
// 66A618: using guessed type int dword_66A618;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040CB64) --------------------------------------------------------
int *ctor_011()
{
  int *result; // $v0

  dword_66A390[1] = off_66B584;
  *off_66B584 = dword_66A390;
  dword_66A374[1] = dword_66A390;
  dword_66A390[0] = dword_66A374;
  unk_66A35C = dword_66A374;
  dword_66A374[0] = &dword_66A358;
  dword_66A33C[1] = &dword_66A358;
  dword_66A358 = (int)dword_66A33C;
  dword_66A320[1] = dword_66A33C;
  dword_66A33C[0] = dword_66A320;
  dword_66A304[1] = dword_66A320;
  dword_66A320[0] = dword_66A304;
  dword_66A2E8[1] = dword_66A304;
  dword_66A304[0] = dword_66A2E8;
  dword_66A2CC[1] = dword_66A2E8;
  dword_66A2E8[0] = dword_66A2CC;
  dword_66A2B0[1] = dword_66A2CC;
  dword_66A2CC[0] = dword_66A2B0;
  off_66A294[1] = dword_66A2B0;
  dword_66A2B0[0] = off_66A294;
  off_66A278[1] = off_66A294;
  off_66A294[0] = off_66A278;
  dword_66A25C[1] = off_66A278;
  off_66A278[0] = dword_66A25C;
  dword_66A240[1] = dword_66A25C;
  dword_66A25C[0] = dword_66A240;
  dword_66A224[1] = dword_66A240;
  dword_66A240[0] = dword_66A224;
  dword_66A208[1] = dword_66A224;
  dword_66A224[0] = dword_66A208;
  off_66A1EC[1] = dword_66A208;
  dword_66A208[0] = off_66A1EC;
  off_66A1D0[1] = off_66A1EC;
  off_66A1EC[0] = off_66A1D0;
  dword_66A1B4[1] = off_66A1D0;
  off_66A1D0[0] = dword_66A1B4;
  dword_66A198[1] = dword_66A1B4;
  dword_66A1B4[0] = dword_66A198;
  dword_66A17C[1] = dword_66A198;
  dword_66A198[0] = dword_66A17C;
  dword_66A160[1] = dword_66A17C;
  dword_66A17C[0] = dword_66A160;
  dword_66A144[1] = dword_66A160;
  dword_66A160[0] = dword_66A144;
  dword_66A128[1] = dword_66A144;
  dword_66A144[0] = dword_66A128;
  unk_66A0A0 = &dword_66A0B8;
  dword_66A128[0] = dword_66A10C;
  dword_66A10C[1] = dword_66A128;
  dword_66A0F0[1] = dword_66A10C;
  dword_66A10C[0] = dword_66A0F0;
  unk_66A0D8 = dword_66A0F0;
  dword_66A0F0[0] = &dword_66A0D4;
  unk_66A0BC = &dword_66A0D4;
  *(_DWORD *)algn_66A084 = &dword_66A09C;
  dword_66A0D4 = (int)&dword_66A0B8;
  unk_66A068 = &dword_66A080;
  dword_66A0B8 = (int)&dword_66A09C;
  dword_66A04C = (int)&dword_66A064;
  dword_66A09C = (int)&dword_66A080;
  unk_66A030 = &dword_66A048;
  dword_66A080 = (int)&dword_66A064;
  dword_66A064 = (int)&dword_66A048;
  dword_66A048 = (int)&dword_66A02C;
  dword_66A014 = (int)&dword_66A02C;
  dword_66A02C = (int)&dword_66A010;
  dword_66A010 = (int)&dword_669FF4;
  dword_669FF4 = (int)&dword_669FD8;
  dword_669FD8 = (int)&dword_669FBC;
  dword_669FBC = (int)&dword_669FA0;
  dword_669FA0 = (int)&dword_669F84;
  dword_669F84 = (int)&dword_669F68;
  dword_669F68 = (int)&dword_669F4C;
  dword_669F4C = (int)&dword_669F30;
  dword_669F30 = (int)&dword_669F14;
  dword_669F14 = (int)&dword_669EF8;
  dword_669EF8 = (int)&dword_669EDC;
  dword_669EDC = (int)&dword_669EC0;
  dword_669E8C = (int)&dword_669EA4;
  dword_669EC0 = (int)&dword_669EA4;
  unk_669E70 = &dword_669E88;
  dword_669EA4 = (int)&dword_669E88;
  unk_669F50 = &dword_669F68;
  dword_669F34 = (int)&dword_669F4C;
  unk_669F18 = &dword_669F30;
  dword_669EFC = (int)&dword_669F14;
  unk_669EE0 = &dword_669EF8;
  dword_669EC4 = (int)&dword_669EDC;
  unk_669EA8 = &dword_669EC0;
  dword_669E88 = (int)&dword_669E6C;
  unk_669FF8 = &dword_66A010;
  unk_669FDC = &dword_669FF4;
  unk_669FC0 = &dword_669FD8;
  dword_669FA4 = (int)&dword_669FBC;
  unk_669F88 = &dword_669FA0;
  dword_669F6C = (int)&dword_669F84;
  dword_669E54 = (int)&dword_669E6C;
  dword_669E6C = (int)&dword_669E50;
  unk_669E38 = &dword_669E50;
  unk_669E1C = &dword_669E34;
  dword_669E50 = (int)&dword_669E34;
  dword_669E34 = (int)&dword_669E18;
  unk_669E00 = &dword_669E18;
  dword_669E18 = (int)&dword_669DFC;
  *(_DWORD *)algn_669DE4 = &dword_669DFC;
  dword_669DFC = (int)&dword_669DE0;
  unk_669DC8 = &dword_669DE0;
  dword_669DE0 = (int)&dword_669DC4;
  unk_669DAC = &dword_669DC4;
  dword_669DC4 = (int)&dword_669DA8;
  *(_DWORD *)algn_669D90 = &dword_669DA8;
  dword_669DA8 = (int)&dword_669D8C;
  unk_669D74 = &dword_669D8C;
  dword_669D8C = (int)&dword_669D70;
  unk_669D58 = &dword_669D70;
  dword_669D70 = (int)&dword_669D54;
  unk_669D3C = &dword_669D54;
  dword_669D54 = (int)&dword_669D38;
  unk_669D20 = &dword_669D38;
  dword_669D38 = (int)&dword_669D1C;
  unk_669D04 = &dword_669D1C;
  dword_669D1C = (int)&dword_669D00;
  unk_669CE8 = &dword_669D00;
  dword_669D00 = (int)&dword_669CE4;
  result = &dword_669CC8;
  unk_669CCC = &dword_669CE4;
  dword_669CE4 = (int)&dword_669CC8;
  off_66B584 = (void **)&dword_669CAC;
  *(_DWORD *)algn_669CB0 = &dword_669CC8;
  dword_669CC8 = (int)&dword_669CAC;
  dword_669CAC = (int)&_httpd_cgi_all_fun;
  return result;
}
// 669CAC: using guessed type int dword_669CAC;
// 669CC8: using guessed type int dword_669CC8;
// 669CE4: using guessed type int dword_669CE4;
// 669D00: using guessed type int dword_669D00;
// 669D1C: using guessed type int dword_669D1C;
// 669D38: using guessed type int dword_669D38;
// 669D54: using guessed type int dword_669D54;
// 669D70: using guessed type int dword_669D70;
// 669D8C: using guessed type int dword_669D8C;
// 669DA8: using guessed type int dword_669DA8;
// 669DC4: using guessed type int dword_669DC4;
// 669DE0: using guessed type int dword_669DE0;
// 669DFC: using guessed type int dword_669DFC;
// 669E18: using guessed type int dword_669E18;
// 669E34: using guessed type int dword_669E34;
// 669E50: using guessed type int dword_669E50;
// 669E54: using guessed type int dword_669E54;
// 669E6C: using guessed type int dword_669E6C;
// 669E88: using guessed type int dword_669E88;
// 669E8C: using guessed type int dword_669E8C;
// 669EA4: using guessed type int dword_669EA4;
// 669EC0: using guessed type int dword_669EC0;
// 669EC4: using guessed type int dword_669EC4;
// 669EDC: using guessed type int dword_669EDC;
// 669EF8: using guessed type int dword_669EF8;
// 669EFC: using guessed type int dword_669EFC;
// 669F14: using guessed type int dword_669F14;
// 669F30: using guessed type int dword_669F30;
// 669F34: using guessed type int dword_669F34;
// 669F4C: using guessed type int dword_669F4C;
// 669F68: using guessed type int dword_669F68;
// 669F6C: using guessed type int dword_669F6C;
// 669F84: using guessed type int dword_669F84;
// 669FA0: using guessed type int dword_669FA0;
// 669FA4: using guessed type int dword_669FA4;
// 669FBC: using guessed type int dword_669FBC;
// 669FD8: using guessed type int dword_669FD8;
// 669FF4: using guessed type int dword_669FF4;
// 66A010: using guessed type int dword_66A010;
// 66A014: using guessed type int dword_66A014;
// 66A02C: using guessed type int dword_66A02C;
// 66A048: using guessed type int dword_66A048;
// 66A04C: using guessed type int dword_66A04C;
// 66A064: using guessed type int dword_66A064;
// 66A080: using guessed type int dword_66A080;
// 66A09C: using guessed type int dword_66A09C;
// 66A0B8: using guessed type int dword_66A0B8;
// 66A0D4: using guessed type int dword_66A0D4;
// 66A358: using guessed type int dword_66A358;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040D314) --------------------------------------------------------
_DWORD *ctor_012()
{
  _DWORD *result; // $v0

  result = dword_669A60;
  dword_669C94 = (int)off_66B584;
  *off_66B584 = &dword_669C90;
  dword_669C5C = (int)&dword_669C74;
  dword_669C74 = (int)&dword_669C58;
  dword_669C40 = (int)&dword_669C58;
  dword_669C78 = (int)&dword_669C90;
  dword_669C90 = (int)&dword_669C74;
  dword_669C58 = &dword_669C3C;
  dword_669C24 = (int)&dword_669C3C;
  dword_669C08 = (int)&dword_669C20;
  dword_669C3C = &dword_669C20;
  dword_669BEC = (int)&dword_669C04;
  dword_669C20 = &dword_669C04;
  dword_669C04 = &dword_669BE8;
  dword_669BD0 = (int)&dword_669BE8;
  dword_669BB4 = (int)&dword_669BCC;
  dword_669BE8 = &dword_669BCC;
  dword_669B98 = (int)&dword_669BB0;
  dword_669BCC = &dword_669BB0;
  dword_669B7C = (int)&dword_669B94;
  dword_669BB0 = &dword_669B94;
  dword_669B60 = (int)&dword_669B78;
  dword_669B94 = &dword_669B78;
  dword_669B44 = (int)&dword_669B5C;
  dword_669B78 = &dword_669B5C;
  dword_669B5C = &dword_669B40;
  dword_669B28 = (int)&dword_669B40;
  dword_669B40 = (int)&dword_669B24;
  dword_669B0C = (int)&dword_669B24;
  dword_669B24 = (int)&dword_669B08;
  dword_669AF0 = (int)&dword_669B08;
  dword_669B08 = (int)&dword_669AEC;
  dword_669AD4 = (int)&dword_669AEC;
  dword_669AB8 = (int)&dword_669AD0;
  dword_669AEC = (int)&dword_669AD0;
  dword_669A9C = (int)&dword_669AB4;
  dword_669A80 = (int)&dword_669A98;
  dword_669A98 = (int)&dword_669A7C;
  off_66B584 = (void **)dword_669A60;
  dword_669A60[0] = &_httpd_cgi_all_fun;
  dword_669A60[1] = &dword_669A7C;
  dword_669A7C = (int)dword_669A60;
  dword_669AD0 = (int)&dword_669AB4;
  dword_669AB4 = (int)&dword_669A98;
  return result;
}
// 669A7C: using guessed type int dword_669A7C;
// 669A80: using guessed type int dword_669A80;
// 669A98: using guessed type int dword_669A98;
// 669A9C: using guessed type int dword_669A9C;
// 669AB4: using guessed type int dword_669AB4;
// 669AB8: using guessed type int dword_669AB8;
// 669AD0: using guessed type int dword_669AD0;
// 669AD4: using guessed type int dword_669AD4;
// 669AEC: using guessed type int dword_669AEC;
// 669AF0: using guessed type int dword_669AF0;
// 669B08: using guessed type int dword_669B08;
// 669B0C: using guessed type int dword_669B0C;
// 669B24: using guessed type int dword_669B24;
// 669B28: using guessed type int dword_669B28;
// 669B40: using guessed type int dword_669B40;
// 669B44: using guessed type int dword_669B44;
// 669B60: using guessed type int dword_669B60;
// 669B7C: using guessed type int dword_669B7C;
// 669B98: using guessed type int dword_669B98;
// 669BB4: using guessed type int dword_669BB4;
// 669BD0: using guessed type int dword_669BD0;
// 669BEC: using guessed type int dword_669BEC;
// 669C08: using guessed type int dword_669C08;
// 669C24: using guessed type int dword_669C24;
// 669C40: using guessed type int dword_669C40;
// 669C5C: using guessed type int dword_669C5C;
// 669C74: using guessed type int dword_669C74;
// 669C78: using guessed type int dword_669C78;
// 669C90: using guessed type int dword_669C90;
// 669C94: using guessed type int dword_669C94;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040D554) --------------------------------------------------------
_DWORD *ctor_013()
{
  _DWORD *result; // $v0

  result = &dword_6698F4;
  dword_669A48 = (int)off_66B584;
  *off_66B584 = &dword_669A44;
  dword_669A44 = (int)&dword_669A28;
  dword_669A28 = (int)&dword_669A0C;
  dword_669A0C = (int)&dword_6699F0;
  dword_6699F0 = (int)&dword_6699D4;
  dword_6699D4 = (int)&dword_6699B8;
  dword_6699B8 = (int)&dword_66999C;
  dword_66999C = (int)&dword_669980;
  dword_669A2C = (int)&dword_669A44;
  dword_669A10 = (int)&dword_669A28;
  dword_6699F4 = (int)&dword_669A0C;
  dword_6699D8 = (int)&dword_6699F0;
  dword_6699BC = (int)&dword_6699D4;
  dword_6699A0 = (int)&dword_6699B8;
  dword_669984 = (int)&dword_66999C;
  dword_669968 = (int)&dword_669980;
  dword_669914 = (int)&dword_66992C;
  dword_669930 = (int)&dword_669948;
  dword_669948 = (int)&dword_66992C;
  dword_6698F8 = (int)&dword_669910;
  dword_66992C = &dword_669910;
  dword_669980 = (int)&dword_669964;
  dword_66994C = (int)&dword_669964;
  dword_669964 = (int)&dword_669948;
  off_66B584 = (void **)&dword_6698F4;
  dword_6698F4 = &_httpd_cgi_all_fun;
  dword_669910 = &dword_6698F4;
  return result;
}
// 6698F8: using guessed type int dword_6698F8;
// 669914: using guessed type int dword_669914;
// 669930: using guessed type int dword_669930;
// 669948: using guessed type int dword_669948;
// 66994C: using guessed type int dword_66994C;
// 669964: using guessed type int dword_669964;
// 669968: using guessed type int dword_669968;
// 669980: using guessed type int dword_669980;
// 669984: using guessed type int dword_669984;
// 66999C: using guessed type int dword_66999C;
// 6699A0: using guessed type int dword_6699A0;
// 6699B8: using guessed type int dword_6699B8;
// 6699BC: using guessed type int dword_6699BC;
// 6699D4: using guessed type int dword_6699D4;
// 6699D8: using guessed type int dword_6699D8;
// 6699F0: using guessed type int dword_6699F0;
// 6699F4: using guessed type int dword_6699F4;
// 669A0C: using guessed type int dword_669A0C;
// 669A10: using guessed type int dword_669A10;
// 669A28: using guessed type int dword_669A28;
// 669A2C: using guessed type int dword_669A2C;
// 669A44: using guessed type int dword_669A44;
// 669A48: using guessed type int dword_669A48;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040D6B4) --------------------------------------------------------
int *ctor_014()
{
  int *result; // $v0

  result = &dword_6697A4;
  dword_6698DC = (int)off_66B584;
  *off_66B584 = &dword_6698D8;
  dword_6698D8 = (int)&dword_6698BC;
  dword_6698BC = (int)&dword_6698A0;
  dword_6698A0 = (int)&dword_669884;
  dword_669884 = (int)&dword_669868;
  dword_669868 = (int)&dword_66984C;
  dword_66984C = (int)&dword_669830;
  dword_669830 = (int)&dword_669814;
  dword_669814 = (int)&dword_6697F8;
  dword_6698C0 = (int)&dword_6698D8;
  dword_6698A4 = (int)&dword_6698BC;
  dword_669888 = (int)&dword_6698A0;
  dword_66986C = (int)&dword_669884;
  dword_669850 = (int)&dword_669868;
  dword_669834 = (int)&dword_66984C;
  dword_669818 = (int)&dword_669830;
  dword_6697FC = (int)&dword_669814;
  dword_6697E0 = (int)&dword_6697F8;
  dword_6697C4 = (int)&dword_6697DC;
  dword_6697DC = (int)&dword_6697C0;
  dword_6697A8 = (int)&dword_6697C0;
  dword_6697F8 = (int)&dword_6697DC;
  off_66B584 = (void **)&dword_6697A4;
  dword_6697A4 = (int)&_httpd_cgi_all_fun;
  dword_6697C0 = &dword_6697A4;
  return result;
}
// 6697A4: using guessed type int dword_6697A4;
// 6697A8: using guessed type int dword_6697A8;
// 6697C4: using guessed type int dword_6697C4;
// 6697DC: using guessed type int dword_6697DC;
// 6697E0: using guessed type int dword_6697E0;
// 6697F8: using guessed type int dword_6697F8;
// 6697FC: using guessed type int dword_6697FC;
// 669814: using guessed type int dword_669814;
// 669818: using guessed type int dword_669818;
// 669830: using guessed type int dword_669830;
// 669834: using guessed type int dword_669834;
// 66984C: using guessed type int dword_66984C;
// 669850: using guessed type int dword_669850;
// 669868: using guessed type int dword_669868;
// 66986C: using guessed type int dword_66986C;
// 669884: using guessed type int dword_669884;
// 669888: using guessed type int dword_669888;
// 6698A0: using guessed type int dword_6698A0;
// 6698A4: using guessed type int dword_6698A4;
// 6698BC: using guessed type int dword_6698BC;
// 6698C0: using guessed type int dword_6698C0;
// 6698D8: using guessed type int dword_6698D8;
// 6698DC: using guessed type int dword_6698DC;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040D7F0) --------------------------------------------------------
_DWORD *ctor_015()
{
  _DWORD *result; // $v0

  result = &dword_6695E4;
  dword_66978C = (int)off_66B584;
  *off_66B584 = &dword_669788;
  dword_669770 = (int)&dword_669788;
  dword_669788 = (int)&dword_66976C;
  dword_66976C = (int)&dword_669750;
  dword_669750 = (int)&dword_669734;
  dword_669734 = (int)&dword_669718;
  dword_669718 = (int)&dword_6696FC;
  dword_669754 = (int)&dword_66976C;
  dword_669738 = (int)&dword_669750;
  dword_66971C = (int)&dword_669734;
  dword_669700 = (int)&dword_669718;
  dword_6696E4 = (int)&dword_6696FC;
  dword_6696FC = (int)&dword_6696E0;
  dword_6696C8 = (int)&dword_6696E0;
  dword_6696AC = (int)&dword_6696C4;
  dword_6696E0 = (int)&dword_6696C4;
  dword_669690 = (int)&dword_6696A8;
  dword_6696C4 = &dword_6696A8;
  dword_669674 = (int)&dword_66968C;
  dword_6696A8 = &dword_66968C;
  dword_669658 = (int)&dword_669670;
  dword_66968C = &dword_669670;
  dword_66963C = (int)&dword_669654;
  dword_669670 = &dword_669654;
  dword_669654 = &dword_669638;
  dword_669620 = (int)&dword_669638;
  dword_669638 = (int)&dword_66961C;
  dword_669604 = (int)&dword_66961C;
  dword_66961C = (int)&dword_669600;
  off_66B584 = (void **)&dword_6695E4;
  dword_6695E4 = &_httpd_cgi_all_fun;
  dword_6695E8 = (int)&dword_669600;
  dword_669600 = (int)&dword_6695E4;
  return result;
}
// 6695E8: using guessed type int dword_6695E8;
// 669600: using guessed type int dword_669600;
// 669604: using guessed type int dword_669604;
// 66961C: using guessed type int dword_66961C;
// 669620: using guessed type int dword_669620;
// 669638: using guessed type int dword_669638;
// 66963C: using guessed type int dword_66963C;
// 669658: using guessed type int dword_669658;
// 669674: using guessed type int dword_669674;
// 669690: using guessed type int dword_669690;
// 6696AC: using guessed type int dword_6696AC;
// 6696C8: using guessed type int dword_6696C8;
// 6696E0: using guessed type int dword_6696E0;
// 6696E4: using guessed type int dword_6696E4;
// 6696FC: using guessed type int dword_6696FC;
// 669700: using guessed type int dword_669700;
// 669718: using guessed type int dword_669718;
// 66971C: using guessed type int dword_66971C;
// 669734: using guessed type int dword_669734;
// 669738: using guessed type int dword_669738;
// 669750: using guessed type int dword_669750;
// 669754: using guessed type int dword_669754;
// 66976C: using guessed type int dword_66976C;
// 669770: using guessed type int dword_669770;
// 669788: using guessed type int dword_669788;
// 66978C: using guessed type int dword_66978C;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040D9A4) --------------------------------------------------------
_DWORD *ctor_016()
{
  _DWORD *result; // $v0

  result = &dword_66945C;
  dword_6695CC = (int)off_66B584;
  *off_66B584 = &dword_6695C8;
  dword_6695C8 = (int)&dword_6695AC;
  dword_6695AC = (int)&dword_669590;
  dword_669590 = (int)&dword_669574;
  dword_669574 = (int)&dword_669558;
  dword_669558 = (int)&dword_66953C;
  dword_66953C = (int)&dword_669520;
  dword_6695B0 = (int)&dword_6695C8;
  dword_669594 = (int)&dword_6695AC;
  dword_669578 = (int)&dword_669590;
  dword_66955C = (int)&dword_669574;
  dword_669540 = (int)&dword_669558;
  dword_669524 = (int)&dword_66953C;
  dword_669508 = (int)&dword_669520;
  dword_669520 = (int)&dword_669504;
  dword_6694B4 = (int)&dword_6694CC;
  dword_6694D0 = (int)&dword_6694E8;
  dword_6694E8 = (int)&dword_6694CC;
  dword_669498 = (int)&dword_6694B0;
  dword_6694CC = &dword_6694B0;
  dword_66947C = (int)&dword_669494;
  dword_6694B0 = &dword_669494;
  dword_669494 = &dword_669478;
  dword_669504 = (int)&dword_6694E8;
  off_66B584 = (void **)&dword_66945C;
  dword_669460 = (int)&dword_669478;
  dword_6694EC = (int)&dword_669504;
  dword_66945C = &_httpd_cgi_all_fun;
  dword_669478 = (int)&dword_66945C;
  return result;
}
// 669460: using guessed type int dword_669460;
// 669478: using guessed type int dword_669478;
// 66947C: using guessed type int dword_66947C;
// 669498: using guessed type int dword_669498;
// 6694B4: using guessed type int dword_6694B4;
// 6694D0: using guessed type int dword_6694D0;
// 6694E8: using guessed type int dword_6694E8;
// 6694EC: using guessed type int dword_6694EC;
// 669504: using guessed type int dword_669504;
// 669508: using guessed type int dword_669508;
// 669520: using guessed type int dword_669520;
// 669524: using guessed type int dword_669524;
// 66953C: using guessed type int dword_66953C;
// 669540: using guessed type int dword_669540;
// 669558: using guessed type int dword_669558;
// 66955C: using guessed type int dword_66955C;
// 669574: using guessed type int dword_669574;
// 669578: using guessed type int dword_669578;
// 669590: using guessed type int dword_669590;
// 669594: using guessed type int dword_669594;
// 6695AC: using guessed type int dword_6695AC;
// 6695B0: using guessed type int dword_6695B0;
// 6695C8: using guessed type int dword_6695C8;
// 6695CC: using guessed type int dword_6695CC;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040DB20) --------------------------------------------------------
int *ctor_017()
{
  int *result; // $v0

  result = &dword_669424;
  dword_669444 = (int)off_66B584;
  *off_66B584 = &dword_669440;
  off_66B584 = (void **)&dword_669424;
  dword_669424 = (int)&_httpd_cgi_all_fun;
  dword_669428 = (int)&dword_669440;
  dword_669440 = (int)&dword_669424;
  return result;
}
// 669424: using guessed type int dword_669424;
// 669428: using guessed type int dword_669428;
// 669440: using guessed type int dword_669440;
// 669444: using guessed type int dword_669444;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040DB60) --------------------------------------------------------
_DWORD *ctor_018()
{
  _DWORD *result; // $v0

  result = &dword_66929C;
  dword_66940C = (int)off_66B584;
  *off_66B584 = &dword_669408;
  dword_669408 = (int)&dword_6693EC;
  dword_6693EC = (int)&dword_6693D0;
  dword_6693D0 = (int)&dword_6693B4;
  dword_6693B4 = (int)&dword_669398;
  dword_669398 = (int)&dword_66937C;
  dword_66937C = (int)&dword_669360;
  dword_6693F0 = (int)&dword_669408;
  dword_6693D4 = (int)&dword_6693EC;
  dword_6693B8 = (int)&dword_6693D0;
  dword_66939C = (int)&dword_6693B4;
  dword_669380 = (int)&dword_669398;
  dword_669364 = (int)&dword_66937C;
  dword_669348 = (int)&dword_669360;
  dword_669360 = (int)&dword_669344;
  dword_6692F4 = (int)&dword_66930C;
  dword_669310 = (int)&dword_669328;
  dword_669328 = (int)&dword_66930C;
  dword_6692D8 = (int)&dword_6692F0;
  dword_66930C = &dword_6692F0;
  dword_6692BC = (int)&dword_6692D4;
  dword_6692F0 = &dword_6692D4;
  dword_6692D4 = &dword_6692B8;
  dword_669344 = (int)&dword_669328;
  off_66B584 = (void **)&dword_66929C;
  dword_6692A0 = (int)&dword_6692B8;
  dword_66932C = (int)&dword_669344;
  dword_66929C = &_httpd_cgi_all_fun;
  dword_6692B8 = (int)&dword_66929C;
  return result;
}
// 6692A0: using guessed type int dword_6692A0;
// 6692B8: using guessed type int dword_6692B8;
// 6692BC: using guessed type int dword_6692BC;
// 6692D8: using guessed type int dword_6692D8;
// 6692F4: using guessed type int dword_6692F4;
// 669310: using guessed type int dword_669310;
// 669328: using guessed type int dword_669328;
// 66932C: using guessed type int dword_66932C;
// 669344: using guessed type int dword_669344;
// 669348: using guessed type int dword_669348;
// 669360: using guessed type int dword_669360;
// 669364: using guessed type int dword_669364;
// 66937C: using guessed type int dword_66937C;
// 669380: using guessed type int dword_669380;
// 669398: using guessed type int dword_669398;
// 66939C: using guessed type int dword_66939C;
// 6693B4: using guessed type int dword_6693B4;
// 6693B8: using guessed type int dword_6693B8;
// 6693D0: using guessed type int dword_6693D0;
// 6693D4: using guessed type int dword_6693D4;
// 6693EC: using guessed type int dword_6693EC;
// 6693F0: using guessed type int dword_6693F0;
// 669408: using guessed type int dword_669408;
// 66940C: using guessed type int dword_66940C;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040DCDC) --------------------------------------------------------
_DWORD *ctor_019()
{
  _DWORD *result; // $v0

  result = dword_669034;
  dword_669284 = (int)off_66B584;
  *off_66B584 = &dword_669280;
  dword_669268 = (int)&dword_669280;
  dword_669280 = (int)&dword_669264;
  dword_66924C = (int)&dword_669264;
  dword_669264 = &dword_669248;
  dword_669230 = (int)&dword_669248;
  dword_669248 = &dword_66922C;
  dword_669214 = (int)&dword_66922C;
  dword_6691F8 = (int)&dword_669210;
  dword_66922C = &dword_669210;
  dword_6691DC = (int)&dword_6691F4;
  dword_669210 = &dword_6691F4;
  dword_6691C0 = (int)&dword_6691D8;
  dword_6691F4 = &dword_6691D8;
  dword_6691A4 = (int)&dword_6691BC;
  dword_6691D8 = &dword_6691BC;
  dword_6691BC = &dword_6691A0;
  dword_669188 = (int)&dword_6691A0;
  dword_66916C = (int)&dword_669184;
  dword_6691A0 = &dword_669184;
  dword_669150 = (int)&dword_669168;
  dword_669184 = &dword_669168;
  dword_669168 = &dword_66914C;
  dword_669134 = (int)&dword_66914C;
  dword_66914C = &dword_669130;
  dword_669118 = (int)&dword_669130;
  dword_669130 = (int)&dword_669114;
  dword_6690FC = (int)&dword_669114;
  dword_669114 = (int)&dword_6690F8;
  dword_669070 = (int)&dword_669088;
  dword_669088 = (int)&dword_66906C;
  dword_669054 = (int)&dword_66906C;
  dword_6690E0 = (int)&dword_6690F8;
  *(_DWORD *)algn_6690C4 = &dword_6690DC;
  unk_6690A8 = &dword_6690C0;
  dword_66908C = (int)&dword_6690A4;
  dword_6690A4 = (int)&dword_669088;
  off_66B584 = (void **)dword_669034;
  dword_669034[0] = &_httpd_cgi_all_fun;
  dword_669034[1] = &dword_669050;
  dword_669050 = (int)dword_669034;
  dword_6690F8 = (int)&dword_6690DC;
  dword_6690DC = (int)&dword_6690C0;
  dword_6690C0 = (int)&dword_6690A4;
  dword_66906C = (int)&dword_669050;
  return result;
}
// 669050: using guessed type int dword_669050;
// 669054: using guessed type int dword_669054;
// 66906C: using guessed type int dword_66906C;
// 669070: using guessed type int dword_669070;
// 669088: using guessed type int dword_669088;
// 66908C: using guessed type int dword_66908C;
// 6690A4: using guessed type int dword_6690A4;
// 6690C0: using guessed type int dword_6690C0;
// 6690DC: using guessed type int dword_6690DC;
// 6690E0: using guessed type int dword_6690E0;
// 6690F8: using guessed type int dword_6690F8;
// 6690FC: using guessed type int dword_6690FC;
// 669114: using guessed type int dword_669114;
// 669118: using guessed type int dword_669118;
// 669130: using guessed type int dword_669130;
// 669134: using guessed type int dword_669134;
// 669150: using guessed type int dword_669150;
// 66916C: using guessed type int dword_66916C;
// 669188: using guessed type int dword_669188;
// 6691A4: using guessed type int dword_6691A4;
// 6691C0: using guessed type int dword_6691C0;
// 6691DC: using guessed type int dword_6691DC;
// 6691F8: using guessed type int dword_6691F8;
// 669214: using guessed type int dword_669214;
// 669230: using guessed type int dword_669230;
// 66924C: using guessed type int dword_66924C;
// 669268: using guessed type int dword_669268;
// 669280: using guessed type int dword_669280;
// 669284: using guessed type int dword_669284;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040DF38) --------------------------------------------------------
int *ctor_020()
{
  int *result; // $v0

  result = &dword_668F00;
  dword_66901C = (int)off_66B584;
  *off_66B584 = &dword_669018;
  dword_669018 = (int)&dword_668FFC;
  dword_668FFC = (int)&dword_668FE0;
  dword_668FE0 = (int)&dword_668FC4;
  dword_668FC4 = (int)&dword_668FA8;
  dword_668FA8 = (int)&dword_668F8C;
  dword_668F8C = (int)&dword_668F70;
  dword_668F70 = (int)&dword_668F54;
  dword_669000 = (int)&dword_669018;
  dword_668FE4 = (int)&dword_668FFC;
  dword_668FC8 = (int)&dword_668FE0;
  dword_668FAC = (int)&dword_668FC4;
  dword_668F90 = (int)&dword_668FA8;
  dword_668F74 = (int)&dword_668F8C;
  dword_668F58 = (int)&dword_668F70;
  dword_668F3C = (int)&dword_668F54;
  dword_668F54 = (int)&dword_668F38;
  dword_668F20 = (int)&dword_668F38;
  dword_668F38 = (int)&dword_668F1C;
  off_66B584 = (void **)&dword_668F00;
  dword_668F00 = (int)&_httpd_cgi_all_fun;
  dword_668F04 = (int)&dword_668F1C;
  dword_668F1C = (int)&dword_668F00;
  return result;
}
// 668F00: using guessed type int dword_668F00;
// 668F04: using guessed type int dword_668F04;
// 668F1C: using guessed type int dword_668F1C;
// 668F20: using guessed type int dword_668F20;
// 668F38: using guessed type int dword_668F38;
// 668F3C: using guessed type int dword_668F3C;
// 668F54: using guessed type int dword_668F54;
// 668F58: using guessed type int dword_668F58;
// 668F70: using guessed type int dword_668F70;
// 668F74: using guessed type int dword_668F74;
// 668F8C: using guessed type int dword_668F8C;
// 668F90: using guessed type int dword_668F90;
// 668FA8: using guessed type int dword_668FA8;
// 668FAC: using guessed type int dword_668FAC;
// 668FC4: using guessed type int dword_668FC4;
// 668FC8: using guessed type int dword_668FC8;
// 668FE0: using guessed type int dword_668FE0;
// 668FE4: using guessed type int dword_668FE4;
// 668FFC: using guessed type int dword_668FFC;
// 669000: using guessed type int dword_669000;
// 669018: using guessed type int dword_669018;
// 66901C: using guessed type int dword_66901C;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E050) --------------------------------------------------------
int *ctor_021()
{
  int *result; // $v0

  result = &dword_668EAC;
  dword_668EE8 = (int)off_66B584;
  *off_66B584 = &dword_668EE4;
  dword_668ECC = (int)&dword_668EE4;
  dword_668EE4 = (int)&dword_668EC8;
  off_66B584 = (void **)&dword_668EAC;
  dword_668EAC = (int)&_httpd_cgi_all_fun;
  dword_668EB0 = (int)&dword_668EC8;
  dword_668EC8 = (int)&dword_668EAC;
  return result;
}
// 668EAC: using guessed type int dword_668EAC;
// 668EB0: using guessed type int dword_668EB0;
// 668EC8: using guessed type int dword_668EC8;
// 668ECC: using guessed type int dword_668ECC;
// 668EE4: using guessed type int dword_668EE4;
// 668EE8: using guessed type int dword_668EE8;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E0A0) --------------------------------------------------------
_DWORD *ctor_022()
{
  _DWORD *result; // $v0

  result = dword_668C60;
  dword_668E94 = (int)off_66B584;
  *off_66B584 = &dword_668E90;
  dword_668E5C = (int)&dword_668E74;
  dword_668E74 = (int)&dword_668E58;
  dword_668E40 = (int)&dword_668E58;
  dword_668E78 = (int)&dword_668E90;
  dword_668E90 = (int)&dword_668E74;
  dword_668E58 = &dword_668E3C;
  dword_668E24 = (int)&dword_668E3C;
  dword_668E08 = (int)&dword_668E20;
  dword_668E3C = &dword_668E20;
  dword_668DEC = (int)&dword_668E04;
  dword_668E20 = &dword_668E04;
  dword_668E04 = &dword_668DE8;
  dword_668DD0 = (int)&dword_668DE8;
  dword_668DB4 = (int)&dword_668DCC;
  dword_668DE8 = &dword_668DCC;
  dword_668D98 = (int)&dword_668DB0;
  dword_668DCC = &dword_668DB0;
  dword_668D7C = (int)&dword_668D94;
  dword_668DB0 = &dword_668D94;
  dword_668D60 = (int)&dword_668D78;
  dword_668D94 = &dword_668D78;
  dword_668D44 = (int)&dword_668D5C;
  dword_668D78 = &dword_668D5C;
  dword_668D5C = &dword_668D40;
  dword_668D28 = (int)&dword_668D40;
  dword_668D40 = (int)&dword_668D24;
  dword_668D0C = (int)&dword_668D24;
  dword_668D24 = (int)&dword_668D08;
  dword_668CF0 = (int)&dword_668D08;
  dword_668D08 = (int)&dword_668CEC;
  dword_668CD4 = (int)&dword_668CEC;
  dword_668CB8 = (int)&dword_668CD0;
  dword_668CEC = (int)&dword_668CD0;
  dword_668C9C = (int)&dword_668CB4;
  dword_668C80 = (int)&dword_668C98;
  dword_668C98 = (int)&dword_668C7C;
  off_66B584 = (void **)dword_668C60;
  dword_668C60[0] = &_httpd_cgi_all_fun;
  dword_668C60[1] = &dword_668C7C;
  dword_668C7C = (int)dword_668C60;
  dword_668CD0 = (int)&dword_668CB4;
  dword_668CB4 = (int)&dword_668C98;
  return result;
}
// 668C7C: using guessed type int dword_668C7C;
// 668C80: using guessed type int dword_668C80;
// 668C98: using guessed type int dword_668C98;
// 668C9C: using guessed type int dword_668C9C;
// 668CB4: using guessed type int dword_668CB4;
// 668CB8: using guessed type int dword_668CB8;
// 668CD0: using guessed type int dword_668CD0;
// 668CD4: using guessed type int dword_668CD4;
// 668CEC: using guessed type int dword_668CEC;
// 668CF0: using guessed type int dword_668CF0;
// 668D08: using guessed type int dword_668D08;
// 668D0C: using guessed type int dword_668D0C;
// 668D24: using guessed type int dword_668D24;
// 668D28: using guessed type int dword_668D28;
// 668D40: using guessed type int dword_668D40;
// 668D44: using guessed type int dword_668D44;
// 668D60: using guessed type int dword_668D60;
// 668D7C: using guessed type int dword_668D7C;
// 668D98: using guessed type int dword_668D98;
// 668DB4: using guessed type int dword_668DB4;
// 668DD0: using guessed type int dword_668DD0;
// 668DEC: using guessed type int dword_668DEC;
// 668E08: using guessed type int dword_668E08;
// 668E24: using guessed type int dword_668E24;
// 668E40: using guessed type int dword_668E40;
// 668E5C: using guessed type int dword_668E5C;
// 668E74: using guessed type int dword_668E74;
// 668E78: using guessed type int dword_668E78;
// 668E90: using guessed type int dword_668E90;
// 668E94: using guessed type int dword_668E94;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E2E0) --------------------------------------------------------
_DWORD *ctor_023()
{
  _DWORD *result; // $v0

  result = &dword_668AD8;
  dword_668C48 = (int)off_66B584;
  *off_66B584 = &dword_668C44;
  dword_668C44 = (int)&dword_668C28;
  dword_668C28 = (int)&dword_668C0C;
  dword_668C0C = (int)&dword_668BF0;
  dword_668BF0 = (int)&dword_668BD4;
  dword_668BD4 = (int)&dword_668BB8;
  dword_668BB8 = (int)&dword_668B9C;
  dword_668C2C = (int)&dword_668C44;
  dword_668C10 = (int)&dword_668C28;
  dword_668BF4 = (int)&dword_668C0C;
  dword_668BD8 = (int)&dword_668BF0;
  dword_668BBC = (int)&dword_668BD4;
  dword_668BA0 = (int)&dword_668BB8;
  dword_668B84 = (int)&dword_668B9C;
  dword_668B9C = (int)&dword_668B80;
  dword_668B30 = (int)&dword_668B48;
  dword_668B4C = (int)&dword_668B64;
  dword_668B64 = (int)&dword_668B48;
  dword_668B14 = (int)&dword_668B2C;
  dword_668B48 = &dword_668B2C;
  dword_668AF8 = (int)&dword_668B10;
  dword_668B2C = &dword_668B10;
  dword_668B10 = &dword_668AF4;
  dword_668B80 = (int)&dword_668B64;
  off_66B584 = (void **)&dword_668AD8;
  dword_668ADC = (int)&dword_668AF4;
  dword_668B68 = (int)&dword_668B80;
  dword_668AD8 = &_httpd_cgi_all_fun;
  dword_668AF4 = (int)&dword_668AD8;
  return result;
}
// 668ADC: using guessed type int dword_668ADC;
// 668AF4: using guessed type int dword_668AF4;
// 668AF8: using guessed type int dword_668AF8;
// 668B14: using guessed type int dword_668B14;
// 668B30: using guessed type int dword_668B30;
// 668B4C: using guessed type int dword_668B4C;
// 668B64: using guessed type int dword_668B64;
// 668B68: using guessed type int dword_668B68;
// 668B80: using guessed type int dword_668B80;
// 668B84: using guessed type int dword_668B84;
// 668B9C: using guessed type int dword_668B9C;
// 668BA0: using guessed type int dword_668BA0;
// 668BB8: using guessed type int dword_668BB8;
// 668BBC: using guessed type int dword_668BBC;
// 668BD4: using guessed type int dword_668BD4;
// 668BD8: using guessed type int dword_668BD8;
// 668BF0: using guessed type int dword_668BF0;
// 668BF4: using guessed type int dword_668BF4;
// 668C0C: using guessed type int dword_668C0C;
// 668C10: using guessed type int dword_668C10;
// 668C28: using guessed type int dword_668C28;
// 668C2C: using guessed type int dword_668C2C;
// 668C44: using guessed type int dword_668C44;
// 668C48: using guessed type int dword_668C48;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E45C) --------------------------------------------------------
_DWORD *ctor_024()
{
  _DWORD *result; // $v0

  result = dword_66888C;
  dword_668AC0 = (int)off_66B584;
  *off_66B584 = &dword_668ABC;
  dword_668A88 = (int)&dword_668AA0;
  dword_668AA0 = (int)&dword_668A84;
  dword_668A6C = (int)&dword_668A84;
  dword_668AA4 = (int)&dword_668ABC;
  dword_668ABC = (int)&dword_668AA0;
  dword_668A84 = &dword_668A68;
  dword_668A50 = (int)&dword_668A68;
  dword_668A34 = (int)&dword_668A4C;
  dword_668A68 = &dword_668A4C;
  dword_668A18 = (int)&dword_668A30;
  dword_668A4C = &dword_668A30;
  dword_668A30 = &dword_668A14;
  dword_6689FC = (int)&dword_668A14;
  dword_6689E0 = (int)&dword_6689F8;
  dword_668A14 = &dword_6689F8;
  dword_6689C4 = (int)&dword_6689DC;
  dword_6689F8 = &dword_6689DC;
  dword_6689A8 = (int)&dword_6689C0;
  dword_6689DC = &dword_6689C0;
  dword_66898C = (int)&dword_6689A4;
  dword_6689C0 = &dword_6689A4;
  dword_668970 = (int)&dword_668988;
  dword_6689A4 = &dword_668988;
  dword_668988 = &dword_66896C;
  dword_668954 = (int)&dword_66896C;
  dword_66896C = (int)&dword_668950;
  dword_668938 = (int)&dword_668950;
  dword_668950 = (int)&dword_668934;
  dword_66891C = (int)&dword_668934;
  dword_668934 = (int)&dword_668918;
  dword_668900 = (int)&dword_668918;
  dword_6688E4 = (int)&dword_6688FC;
  dword_668918 = (int)&dword_6688FC;
  dword_6688C8 = (int)&dword_6688E0;
  dword_6688AC = (int)&dword_6688C4;
  dword_6688C4 = (int)&dword_6688A8;
  off_66B584 = (void **)dword_66888C;
  dword_66888C[0] = &_httpd_cgi_all_fun;
  dword_66888C[1] = &dword_6688A8;
  dword_6688A8 = (int)dword_66888C;
  dword_6688FC = (int)&dword_6688E0;
  dword_6688E0 = (int)&dword_6688C4;
  return result;
}
// 6688A8: using guessed type int dword_6688A8;
// 6688AC: using guessed type int dword_6688AC;
// 6688C4: using guessed type int dword_6688C4;
// 6688C8: using guessed type int dword_6688C8;
// 6688E0: using guessed type int dword_6688E0;
// 6688E4: using guessed type int dword_6688E4;
// 6688FC: using guessed type int dword_6688FC;
// 668900: using guessed type int dword_668900;
// 668918: using guessed type int dword_668918;
// 66891C: using guessed type int dword_66891C;
// 668934: using guessed type int dword_668934;
// 668938: using guessed type int dword_668938;
// 668950: using guessed type int dword_668950;
// 668954: using guessed type int dword_668954;
// 66896C: using guessed type int dword_66896C;
// 668970: using guessed type int dword_668970;
// 66898C: using guessed type int dword_66898C;
// 6689A8: using guessed type int dword_6689A8;
// 6689C4: using guessed type int dword_6689C4;
// 6689E0: using guessed type int dword_6689E0;
// 6689FC: using guessed type int dword_6689FC;
// 668A18: using guessed type int dword_668A18;
// 668A34: using guessed type int dword_668A34;
// 668A50: using guessed type int dword_668A50;
// 668A6C: using guessed type int dword_668A6C;
// 668A88: using guessed type int dword_668A88;
// 668AA0: using guessed type int dword_668AA0;
// 668AA4: using guessed type int dword_668AA4;
// 668ABC: using guessed type int dword_668ABC;
// 668AC0: using guessed type int dword_668AC0;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E69C) --------------------------------------------------------
_DWORD *ctor_025()
{
  _DWORD *result; // $v0

  result = &dword_6686E8;
  dword_668874 = (int)off_66B584;
  *off_66B584 = &dword_668870;
  dword_668870 = (int)&dword_668854;
  dword_668854 = (int)&dword_668838;
  dword_668838 = (int)&dword_66881C;
  dword_66881C = (int)&dword_668800;
  dword_668800 = (int)&dword_6687E4;
  dword_6687E4 = (int)&dword_6687C8;
  dword_668858 = (int)&dword_668870;
  dword_66883C = (int)&dword_668854;
  dword_668820 = (int)&dword_668838;
  dword_668804 = (int)&dword_66881C;
  dword_6687E8 = (int)&dword_668800;
  dword_6687CC = (int)&dword_6687E4;
  dword_6687B0 = (int)&dword_6687C8;
  dword_668778 = (int)&dword_668790;
  dword_668794 = (int)&dword_6687AC;
  dword_6687AC = (int)&dword_668790;
  dword_66875C = (int)&dword_668774;
  dword_668790 = &dword_668774;
  dword_668740 = (int)&dword_668758;
  dword_668774 = &dword_668758;
  dword_668724 = (int)&dword_66873C;
  dword_668758 = &dword_66873C;
  dword_66873C = &dword_668720;
  dword_668708 = (int)&dword_668720;
  dword_6686EC = (int)&dword_668704;
  dword_668720 = (int)&dword_668704;
  dword_6687C8 = (int)&dword_6687AC;
  off_66B584 = (void **)&dword_6686E8;
  dword_6686E8 = &_httpd_cgi_all_fun;
  dword_668704 = (int)&dword_6686E8;
  return result;
}
// 6686EC: using guessed type int dword_6686EC;
// 668704: using guessed type int dword_668704;
// 668708: using guessed type int dword_668708;
// 668720: using guessed type int dword_668720;
// 668724: using guessed type int dword_668724;
// 668740: using guessed type int dword_668740;
// 66875C: using guessed type int dword_66875C;
// 668778: using guessed type int dword_668778;
// 668794: using guessed type int dword_668794;
// 6687AC: using guessed type int dword_6687AC;
// 6687B0: using guessed type int dword_6687B0;
// 6687C8: using guessed type int dword_6687C8;
// 6687CC: using guessed type int dword_6687CC;
// 6687E4: using guessed type int dword_6687E4;
// 6687E8: using guessed type int dword_6687E8;
// 668800: using guessed type int dword_668800;
// 668804: using guessed type int dword_668804;
// 66881C: using guessed type int dword_66881C;
// 668820: using guessed type int dword_668820;
// 668838: using guessed type int dword_668838;
// 66883C: using guessed type int dword_66883C;
// 668854: using guessed type int dword_668854;
// 668858: using guessed type int dword_668858;
// 668870: using guessed type int dword_668870;
// 668874: using guessed type int dword_668874;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E834) --------------------------------------------------------
int *ctor_026()
{
  int *result; // $v0

  result = &dword_6686B0;
  dword_6686D0 = (int)off_66B584;
  *off_66B584 = &dword_6686CC;
  off_66B584 = (void **)&dword_6686B0;
  dword_6686B0 = (int)&_httpd_cgi_all_fun;
  dword_6686B4 = (int)&dword_6686CC;
  dword_6686CC = (int)&dword_6686B0;
  return result;
}
// 6686B0: using guessed type int dword_6686B0;
// 6686B4: using guessed type int dword_6686B4;
// 6686CC: using guessed type int dword_6686CC;
// 6686D0: using guessed type int dword_6686D0;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E874) --------------------------------------------------------
int *ctor_027()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_668694;
  off_66B584 = (void **)&dword_668694;
  dword_668694 = (int)&_httpd_cgi_all_fun;
  dword_668698 = (int)v0;
  *v0 = &dword_668694;
  return result;
}
// 668694: using guessed type int dword_668694;
// 668698: using guessed type int dword_668698;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E8A4) --------------------------------------------------------
int *ctor_028()
{
  int *result; // $v0

  result = &dword_66865C;
  dword_66867C = (int)off_66B584;
  *off_66B584 = &dword_668678;
  off_66B584 = (void **)&dword_66865C;
  dword_66865C = (int)&_httpd_cgi_all_fun;
  dword_668660 = (int)&dword_668678;
  dword_668678 = (int)&dword_66865C;
  return result;
}
// 66865C: using guessed type int dword_66865C;
// 668660: using guessed type int dword_668660;
// 668678: using guessed type int dword_668678;
// 66867C: using guessed type int dword_66867C;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E8E4) --------------------------------------------------------
int *ctor_029()
{
  int *result; // $v0

  result = &dword_6685EC;
  dword_668644 = (int)off_66B584;
  *off_66B584 = &dword_668640;
  dword_668628 = (int)&dword_668640;
  dword_668640 = (int)&dword_668624;
  dword_66860C = (int)&dword_668624;
  dword_668624 = (int)&dword_668608;
  off_66B584 = (void **)&dword_6685EC;
  dword_6685EC = (int)&_httpd_cgi_all_fun;
  dword_6685F0 = (int)&dword_668608;
  dword_668608 = (int)&dword_6685EC;
  return result;
}
// 6685EC: using guessed type int dword_6685EC;
// 6685F0: using guessed type int dword_6685F0;
// 668608: using guessed type int dword_668608;
// 66860C: using guessed type int dword_66860C;
// 668624: using guessed type int dword_668624;
// 668628: using guessed type int dword_668628;
// 668640: using guessed type int dword_668640;
// 668644: using guessed type int dword_668644;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040E944) --------------------------------------------------------
_DWORD *ctor_030()
{
  _DWORD *result; // $v0

  result = &dword_668480;
  dword_6685D4 = (int)off_66B584;
  *off_66B584 = &dword_6685D0;
  dword_6685D0 = (int)&dword_6685B4;
  dword_6685B4 = (int)&dword_668598;
  dword_668598 = (int)&dword_66857C;
  dword_66857C = (int)&dword_668560;
  dword_668560 = (int)&dword_668544;
  dword_668544 = (int)&dword_668528;
  dword_668528 = (int)&dword_66850C;
  dword_6685B8 = (int)&dword_6685D0;
  dword_66859C = (int)&dword_6685B4;
  dword_668580 = (int)&dword_668598;
  dword_668564 = (int)&dword_66857C;
  dword_668548 = (int)&dword_668560;
  dword_66852C = (int)&dword_668544;
  dword_668510 = (int)&dword_668528;
  dword_6684F4 = (int)&dword_66850C;
  dword_6684A0 = (int)&dword_6684B8;
  dword_6684BC = (int)&dword_6684D4;
  dword_6684D4 = (int)&dword_6684B8;
  dword_668484 = (int)&dword_66849C;
  dword_6684B8 = &dword_66849C;
  dword_66850C = (int)&dword_6684F0;
  dword_6684D8 = (int)&dword_6684F0;
  dword_6684F0 = (int)&dword_6684D4;
  off_66B584 = (void **)&dword_668480;
  dword_668480 = &_httpd_cgi_all_fun;
  dword_66849C = &dword_668480;
  return result;
}
// 668484: using guessed type int dword_668484;
// 6684A0: using guessed type int dword_6684A0;
// 6684BC: using guessed type int dword_6684BC;
// 6684D4: using guessed type int dword_6684D4;
// 6684D8: using guessed type int dword_6684D8;
// 6684F0: using guessed type int dword_6684F0;
// 6684F4: using guessed type int dword_6684F4;
// 66850C: using guessed type int dword_66850C;
// 668510: using guessed type int dword_668510;
// 668528: using guessed type int dword_668528;
// 66852C: using guessed type int dword_66852C;
// 668544: using guessed type int dword_668544;
// 668548: using guessed type int dword_668548;
// 668560: using guessed type int dword_668560;
// 668564: using guessed type int dword_668564;
// 66857C: using guessed type int dword_66857C;
// 668580: using guessed type int dword_668580;
// 668598: using guessed type int dword_668598;
// 66859C: using guessed type int dword_66859C;
// 6685B4: using guessed type int dword_6685B4;
// 6685B8: using guessed type int dword_6685B8;
// 6685D0: using guessed type int dword_6685D0;
// 6685D4: using guessed type int dword_6685D4;
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;

//----- (0040EAA4) --------------------------------------------------------
_DWORD *ctor_031()
{
  _DWORD *result; // $v0

  result = &dword_66BEA4;
  dword_66C014 = (int)off_66B584;
  *off_66B584 = &dword_66C010;
  dword_66C010 = (int)&dword_66BFF4;
  dword_66BFF4 = (int)&dword_66BFD8;
  dword_66BFD8 = (int)&dword_66BFBC;
  dword_66BFBC = (int)&dword_66BFA0;
  dword_66BFA0 = (int)&dword_66BF84;
  dword_66BF84 = (int)&dword_66BF68;
  dword_66BFF8 = (int)&dword_66C010;
  dword_66BFDC = (int)&dword_66BFF4;
  dword_66BFC0 = (int)&dword_66BFD8;
  dword_66BFA4 = (int)&dword_66BFBC;
  dword_66BF88 = (int)&dword_66BFA0;
  dword_66BF6C = (int)&dword_66BF84;
  dword_66BF50 = (int)&dword_66BF68;
  dword_66BF68 = (int)&dword_66BF4C;
  dword_66BEFC = (int)&dword_66BF14;
  dword_66BF18 = (int)&dword_66BF30;
  dword_66BF30 = (int)&dword_66BF14;
  dword_66BEE0 = (int)&dword_66BEF8;
  dword_66BF14 = &dword_66BEF8;
  dword_66BEC4 = (int)&dword_66BEDC;
  dword_66BEF8 = &dword_66BEDC;
  dword_66BEDC = &dword_66BEC0;
  dword_66BF4C = (int)&dword_66BF30;
  off_66B584 = (void **)&dword_66BEA4;
  dword_66BEA8 = (int)&dword_66BEC0;
  dword_66BF34 = (int)&dword_66BF4C;
  dword_66BEA4 = &_httpd_cgi_all_fun;
  dword_66BEC0 = (int)&dword_66BEA4;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66BEA8: using guessed type int dword_66BEA8;
// 66BEC0: using guessed type int dword_66BEC0;
// 66BEC4: using guessed type int dword_66BEC4;
// 66BEE0: using guessed type int dword_66BEE0;
// 66BEFC: using guessed type int dword_66BEFC;
// 66BF18: using guessed type int dword_66BF18;
// 66BF30: using guessed type int dword_66BF30;
// 66BF34: using guessed type int dword_66BF34;
// 66BF4C: using guessed type int dword_66BF4C;
// 66BF50: using guessed type int dword_66BF50;
// 66BF68: using guessed type int dword_66BF68;
// 66BF6C: using guessed type int dword_66BF6C;
// 66BF84: using guessed type int dword_66BF84;
// 66BF88: using guessed type int dword_66BF88;
// 66BFA0: using guessed type int dword_66BFA0;
// 66BFA4: using guessed type int dword_66BFA4;
// 66BFBC: using guessed type int dword_66BFBC;
// 66BFC0: using guessed type int dword_66BFC0;
// 66BFD8: using guessed type int dword_66BFD8;
// 66BFDC: using guessed type int dword_66BFDC;
// 66BFF4: using guessed type int dword_66BFF4;
// 66BFF8: using guessed type int dword_66BFF8;
// 66C010: using guessed type int dword_66C010;
// 66C014: using guessed type int dword_66C014;

//----- (0040EC20) --------------------------------------------------------
int *ctor_032()
{
  int *result; // $v0

  dword_66BE88[1] = off_66B584;
  *off_66B584 = dword_66BE88;
  dword_66BE6C[1] = dword_66BE88;
  dword_66BE88[0] = dword_66BE6C;
  *(_DWORD *)algn_66BE54 = dword_66BE6C;
  dword_66BE6C[0] = &dword_66BE50;
  dword_66BE34[1] = &dword_66BE50;
  dword_66BE50 = (int)dword_66BE34;
  dword_66BE18[1] = dword_66BE34;
  dword_66BE34[0] = dword_66BE18;
  dword_66BDFC[1] = dword_66BE18;
  dword_66BE18[0] = dword_66BDFC;
  dword_66BDE0[1] = dword_66BDFC;
  dword_66BDFC[0] = dword_66BDE0;
  dword_66BDC4[1] = dword_66BDE0;
  dword_66BDE0[0] = dword_66BDC4;
  dword_66BDA8[1] = dword_66BDC4;
  dword_66BDC4[0] = dword_66BDA8;
  dword_66BD8C[1] = dword_66BDA8;
  dword_66BDA8[0] = dword_66BD8C;
  dword_66BD70[1] = dword_66BD8C;
  dword_66BD8C[0] = dword_66BD70;
  dword_66BD54[1] = dword_66BD70;
  dword_66BD70[0] = dword_66BD54;
  dword_66BD38[1] = dword_66BD54;
  dword_66BD54[0] = dword_66BD38;
  dword_66BD1C[1] = dword_66BD38;
  dword_66BD38[0] = dword_66BD1C;
  dword_66BD00[1] = dword_66BD1C;
  dword_66BD1C[0] = dword_66BD00;
  dword_66BCE4[1] = dword_66BD00;
  dword_66BD00[0] = dword_66BCE4;
  dword_66BCC8[1] = dword_66BCE4;
  dword_66BCE4[0] = dword_66BCC8;
  dword_66BCAC[1] = dword_66BCC8;
  dword_66BCC8[0] = dword_66BCAC;
  dword_66BC90[1] = dword_66BCAC;
  dword_66BCAC[0] = dword_66BC90;
  dword_66BC74[1] = dword_66BC90;
  dword_66BC90[0] = dword_66BC74;
  dword_66BC58[1] = dword_66BC74;
  dword_66BC74[0] = dword_66BC58;
  dword_66BC3C[1] = dword_66BC58;
  dword_66BC58[0] = dword_66BC3C;
  dword_66BC20[1] = dword_66BC3C;
  dword_66BC3C[0] = dword_66BC20;
  dword_66BC20[0] = dword_66BC04;
  dword_66BC04[1] = dword_66BC20;
  dword_66BBE8[1] = dword_66BC04;
  unk_66BBD0 = dword_66BBE8;
  dword_66BC04[0] = dword_66BBE8;
  *(_DWORD *)algn_66BBB4 = &dword_66BBCC;
  dword_66BBE8[0] = &dword_66BBCC;
  unk_66BB98 = &dword_66BBB0;
  dword_66BBCC = (int)&dword_66BBB0;
  dword_66BBB0 = (int)&dword_66BB94;
  dword_66BB94 = (int)&dword_66BB78;
  dword_66BB78 = (int)&dword_66BB5C;
  dword_66BB5C = (int)&dword_66BB40;
  dword_66BB40 = (int)&dword_66BB24;
  dword_66BB24 = (int)&dword_66BB08;
  dword_66BB08 = (int)&dword_66BAEC;
  unk_66BA48 = &dword_66BA60;
  dword_66BAEC = (int)&dword_66BAD0;
  dword_66BA2C = (int)&dword_66BA44;
  dword_66BAD0 = (int)&dword_66BAB4;
  unk_66BB7C = &dword_66BB94;
  dword_66BAB4 = (int)&dword_66BA98;
  unk_66BB60 = &dword_66BB78;
  dword_66BA98 = (int)&dword_66BA7C;
  *(_DWORD *)algn_66BB44 = &dword_66BB5C;
  dword_66BA7C = (int)&dword_66BA60;
  unk_66BB28 = &dword_66BB40;
  dword_66BA60 = (int)&dword_66BA44;
  unk_66BB0C = &dword_66BB24;
  dword_66BA44 = (int)&dword_66BA28;
  unk_66BAF0 = &dword_66BB08;
  dword_66BAD4 = (int)&dword_66BAEC;
  unk_66BAB8 = &dword_66BAD0;
  dword_66BA9C = (int)&dword_66BAB4;
  unk_66BA80 = &dword_66BA98;
  dword_66BA64 = (int)&dword_66BA7C;
  unk_66BA10 = &dword_66BA28;
  dword_66BA28 = (int)&dword_66BA0C;
  dword_66BA0C = (int)&dword_66B9F0;
  dword_66B9F0 = (int)&dword_66B9D4;
  dword_66B9D4 = (int)&dword_66B9B8;
  dword_66B9B8 = (int)&dword_66B99C;
  dword_66B984 = (int)&dword_66B99C;
  dword_66B99C = (int)&dword_66B980;
  unk_66B968 = &dword_66B980;
  dword_66B94C = (int)&dword_66B964;
  unk_66B930 = &dword_66B948;
  dword_66B980 = (int)&dword_66B964;
  dword_66B964 = (int)&dword_66B948;
  *(_DWORD *)algn_66B914 = &dword_66B92C;
  dword_66B948 = (int)&dword_66B92C;
  dword_66B92C = (int)&dword_66B910;
  unk_66B8F8 = &dword_66B910;
  dword_66B910 = (int)&dword_66B8F4;
  unk_66B8DC = &dword_66B8F4;
  dword_66B8F4 = (int)&dword_66B8D8;
  unk_66B8C0 = &dword_66B8D8;
  dword_66B8D8 = (int)&dword_66B8BC;
  dword_66B9F4 = (int)&dword_66BA0C;
  unk_66B9D8 = &dword_66B9F0;
  dword_66B9BC = (int)&dword_66B9D4;
  unk_66B9A0 = &dword_66B9B8;
  *(_DWORD *)algn_66B8A4 = &dword_66B8BC;
  dword_66B8BC = (int)&dword_66B8A0;
  unk_66B888 = &dword_66B8A0;
  dword_66B8A0 = (int)&dword_66B884;
  unk_66B86C = &dword_66B884;
  dword_66B884 = (int)&dword_66B868;
  unk_66B850 = &dword_66B868;
  dword_66B868 = (int)&dword_66B84C;
  *(_DWORD *)algn_66B834 = &dword_66B84C;
  dword_66B84C = (int)&dword_66B830;
  unk_66B818 = &dword_66B830;
  dword_66B830 = (int)&dword_66B814;
  unk_66B7FC = &dword_66B814;
  dword_66B814 = (int)&dword_66B7F8;
  unk_66B7E0 = &dword_66B7F8;
  dword_66B7F8 = (int)&dword_66B7DC;
  *(_DWORD *)algn_66B7C4 = &dword_66B7DC;
  dword_66B7DC = (int)&dword_66B7C0;
  unk_66B7A8 = &dword_66B7C0;
  dword_66B7C0 = (int)&dword_66B7A4;
  unk_66B78C = &dword_66B7A4;
  dword_66B7A4 = (int)&dword_66B788;
  unk_66B770 = &dword_66B788;
  dword_66B788 = (int)&dword_66B76C;
  *(_DWORD *)algn_66B754 = &dword_66B76C;
  dword_66B76C = (int)&dword_66B750;
  unk_66B738 = &dword_66B750;
  dword_66B750 = (int)&dword_66B734;
  unk_66B71C = &dword_66B734;
  dword_66B734 = (int)&dword_66B718;
  unk_66B700 = &dword_66B718;
  dword_66B718 = (int)&dword_66B6FC;
  *(_DWORD *)algn_66B6E4 = &dword_66B6FC;
  dword_66B6FC = (int)&dword_66B6E0;
  unk_66B6C8 = &dword_66B6E0;
  dword_66B6E0 = (int)&dword_66B6C4;
  unk_66B6AC = &dword_66B6C4;
  dword_66B6C4 = (int)&dword_66B6A8;
  unk_66B690 = &dword_66B6A8;
  dword_66B6A8 = (int)&dword_66B68C;
  *(_DWORD *)algn_66B674 = &dword_66B68C;
  dword_66B68C = (int)&dword_66B670;
  unk_66B658 = &dword_66B670;
  dword_66B670 = (int)&dword_66B654;
  unk_66B63C = &dword_66B654;
  dword_66B654 = (int)&dword_66B638;
  unk_66B620 = &dword_66B638;
  dword_66B638 = (int)&dword_66B61C;
  result = &dword_66B600;
  off_66B584 = (void **)&dword_66B600;
  *(_DWORD *)algn_66B604 = &dword_66B61C;
  dword_66B61C = (int)&dword_66B600;
  dword_66B600 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66B600: using guessed type int dword_66B600;
// 66B61C: using guessed type int dword_66B61C;
// 66B638: using guessed type int dword_66B638;
// 66B654: using guessed type int dword_66B654;
// 66B670: using guessed type int dword_66B670;
// 66B68C: using guessed type int dword_66B68C;
// 66B6A8: using guessed type int dword_66B6A8;
// 66B6C4: using guessed type int dword_66B6C4;
// 66B6E0: using guessed type int dword_66B6E0;
// 66B6FC: using guessed type int dword_66B6FC;
// 66B718: using guessed type int dword_66B718;
// 66B734: using guessed type int dword_66B734;
// 66B750: using guessed type int dword_66B750;
// 66B76C: using guessed type int dword_66B76C;
// 66B788: using guessed type int dword_66B788;
// 66B7A4: using guessed type int dword_66B7A4;
// 66B7C0: using guessed type int dword_66B7C0;
// 66B7DC: using guessed type int dword_66B7DC;
// 66B7F8: using guessed type int dword_66B7F8;
// 66B814: using guessed type int dword_66B814;
// 66B830: using guessed type int dword_66B830;
// 66B84C: using guessed type int dword_66B84C;
// 66B868: using guessed type int dword_66B868;
// 66B884: using guessed type int dword_66B884;
// 66B8A0: using guessed type int dword_66B8A0;
// 66B8BC: using guessed type int dword_66B8BC;
// 66B8D8: using guessed type int dword_66B8D8;
// 66B8F4: using guessed type int dword_66B8F4;
// 66B910: using guessed type int dword_66B910;
// 66B92C: using guessed type int dword_66B92C;
// 66B948: using guessed type int dword_66B948;
// 66B94C: using guessed type int dword_66B94C;
// 66B964: using guessed type int dword_66B964;
// 66B980: using guessed type int dword_66B980;
// 66B984: using guessed type int dword_66B984;
// 66B99C: using guessed type int dword_66B99C;
// 66B9B8: using guessed type int dword_66B9B8;
// 66B9BC: using guessed type int dword_66B9BC;
// 66B9D4: using guessed type int dword_66B9D4;
// 66B9F0: using guessed type int dword_66B9F0;
// 66B9F4: using guessed type int dword_66B9F4;
// 66BA0C: using guessed type int dword_66BA0C;
// 66BA28: using guessed type int dword_66BA28;
// 66BA2C: using guessed type int dword_66BA2C;
// 66BA44: using guessed type int dword_66BA44;
// 66BA60: using guessed type int dword_66BA60;
// 66BA64: using guessed type int dword_66BA64;
// 66BA7C: using guessed type int dword_66BA7C;
// 66BA98: using guessed type int dword_66BA98;
// 66BA9C: using guessed type int dword_66BA9C;
// 66BAB4: using guessed type int dword_66BAB4;
// 66BAD0: using guessed type int dword_66BAD0;
// 66BAD4: using guessed type int dword_66BAD4;
// 66BAEC: using guessed type int dword_66BAEC;
// 66BB08: using guessed type int dword_66BB08;
// 66BB24: using guessed type int dword_66BB24;
// 66BB40: using guessed type int dword_66BB40;
// 66BB5C: using guessed type int dword_66BB5C;
// 66BB78: using guessed type int dword_66BB78;
// 66BB94: using guessed type int dword_66BB94;
// 66BBB0: using guessed type int dword_66BBB0;
// 66BBCC: using guessed type int dword_66BBCC;
// 66BE50: using guessed type int dword_66BE50;

//----- (0040F574) --------------------------------------------------------
int *ctor_033()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_66C030;
  off_66B584 = (void **)&dword_66C030;
  dword_66C030 = (int)&_httpd_cgi_all_fun;
  dword_66C034 = (int)v0;
  *v0 = &dword_66C030;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66C030: using guessed type int dword_66C030;
// 66C034: using guessed type int dword_66C034;

//----- (0040F5A4) --------------------------------------------------------
int *ctor_034()
{
  int *result; // $v0

  dword_66D224[1] = off_66B584;
  *off_66B584 = dword_66D224;
  dword_66D208[1] = dword_66D224;
  dword_66D224[0] = dword_66D208;
  unk_66D1F0 = dword_66D208;
  dword_66D208[0] = &dword_66D1EC;
  dword_66D1D0[1] = &dword_66D1EC;
  dword_66D1EC = (int)dword_66D1D0;
  dword_66D1B4[1] = dword_66D1D0;
  dword_66D1D0[0] = dword_66D1B4;
  dword_66D198[1] = dword_66D1B4;
  dword_66D1B4[0] = dword_66D198;
  dword_66D17C[1] = dword_66D198;
  dword_66D198[0] = dword_66D17C;
  dword_66D160[1] = dword_66D17C;
  dword_66D17C[0] = dword_66D160;
  dword_66D144[1] = dword_66D160;
  dword_66D160[0] = dword_66D144;
  dword_66D128[1] = dword_66D144;
  dword_66D144[0] = dword_66D128;
  dword_66D10C[1] = dword_66D128;
  dword_66D128[0] = dword_66D10C;
  dword_66D0F0[1] = dword_66D10C;
  dword_66D10C[0] = dword_66D0F0;
  dword_66D0D4[1] = dword_66D0F0;
  dword_66D0F0[0] = dword_66D0D4;
  dword_66D0B8[1] = dword_66D0D4;
  dword_66D0D4[0] = dword_66D0B8;
  dword_66D09C[1] = dword_66D0B8;
  dword_66D0B8[0] = dword_66D09C;
  dword_66D080[1] = dword_66D09C;
  dword_66D09C[0] = dword_66D080;
  dword_66D064[1] = dword_66D080;
  dword_66D080[0] = dword_66D064;
  dword_66D048[1] = dword_66D064;
  dword_66D064[0] = dword_66D048;
  dword_66D02C[1] = dword_66D048;
  dword_66D048[0] = dword_66D02C;
  dword_66D010[1] = dword_66D02C;
  dword_66D02C[0] = dword_66D010;
  dword_66CFF4[1] = dword_66D010;
  dword_66D010[0] = dword_66CFF4;
  dword_66CFD8[1] = dword_66CFF4;
  dword_66CFF4[0] = dword_66CFD8;
  dword_66CFBC[1] = dword_66CFD8;
  dword_66CFD8[0] = dword_66CFBC;
  dword_66CFBC[0] = dword_66CFA0;
  dword_66CFA0[1] = dword_66CFBC;
  dword_66CF84[1] = dword_66CFA0;
  unk_66CF6C = dword_66CF84;
  dword_66CFA0[0] = dword_66CF84;
  unk_66CF50 = &dword_66CF68;
  dword_66CF84[0] = &dword_66CF68;
  *(_DWORD *)algn_66CF34 = &dword_66CF4C;
  dword_66CF68 = (int)&dword_66CF4C;
  dword_66CF4C = (int)&dword_66CF30;
  dword_66CF30 = (int)&dword_66CF14;
  dword_66CF14 = (int)&dword_66CEF8;
  dword_66CEF8 = (int)&dword_66CEDC;
  dword_66CEDC = (int)&dword_66CEC0;
  dword_66CEC0 = (int)&dword_66CEA4;
  dword_66CEA4 = (int)&dword_66CE88;
  *(_DWORD *)algn_66CDE4 = &dword_66CDFC;
  dword_66CE88 = (int)&dword_66CE6C;
  dword_66CDC8 = (int)&dword_66CDE0;
  dword_66CE6C = (int)&dword_66CE50;
  unk_66CF18 = &dword_66CF30;
  dword_66CE50 = (int)&dword_66CE34;
  unk_66CEFC = &dword_66CF14;
  dword_66CE34 = (int)&dword_66CE18;
  unk_66CEE0 = &dword_66CEF8;
  dword_66CE18 = (int)&dword_66CDFC;
  *(_DWORD *)algn_66CEC4 = &dword_66CEDC;
  dword_66CDFC = (int)&dword_66CDE0;
  unk_66CEA8 = &dword_66CEC0;
  dword_66CDE0 = (int)&dword_66CDC4;
  unk_66CE8C = &dword_66CEA4;
  dword_66CE70 = (int)&dword_66CE88;
  *(_DWORD *)algn_66CE54 = &dword_66CE6C;
  dword_66CE38 = (int)&dword_66CE50;
  unk_66CE1C = &dword_66CE34;
  dword_66CE00 = (int)&dword_66CE18;
  unk_66CDAC = &dword_66CDC4;
  dword_66CDC4 = (int)&dword_66CDA8;
  dword_66CDA8 = (int)&dword_66CD8C;
  dword_66CD8C = (int)&dword_66CD70;
  dword_66CD70 = (int)&dword_66CD54;
  dword_66CD54 = (int)&dword_66CD38;
  dword_66CD20 = (int)&dword_66CD38;
  dword_66CD38 = (int)&dword_66CD1C;
  *(_DWORD *)algn_66CD04 = &dword_66CD1C;
  dword_66CCE8 = (int)&dword_66CD00;
  unk_66CCCC = &dword_66CCE4;
  dword_66CD1C = (int)&dword_66CD00;
  dword_66CD00 = (int)&dword_66CCE4;
  unk_66CCB0 = &dword_66CCC8;
  dword_66CCE4 = (int)&dword_66CCC8;
  dword_66CCC8 = (int)&dword_66CCAC;
  *(_DWORD *)algn_66CC94 = &dword_66CCAC;
  dword_66CCAC = (int)&dword_66CC90;
  unk_66CC78 = &dword_66CC90;
  dword_66CC90 = (int)&dword_66CC74;
  unk_66CC5C = &dword_66CC74;
  dword_66CC74 = (int)&dword_66CC58;
  dword_66CD90 = (int)&dword_66CDA8;
  *(_DWORD *)algn_66CD74 = &dword_66CD8C;
  dword_66CD58 = (int)&dword_66CD70;
  unk_66CD3C = &dword_66CD54;
  unk_66CC40 = &dword_66CC58;
  dword_66CC58 = (int)&dword_66CC3C;
  *(_DWORD *)algn_66CC24 = &dword_66CC3C;
  dword_66CC3C = (int)&dword_66CC20;
  unk_66CC08 = &dword_66CC20;
  dword_66CC20 = (int)&dword_66CC04;
  unk_66CBEC = &dword_66CC04;
  dword_66CC04 = (int)&dword_66CBE8;
  unk_66CBD0 = &dword_66CBE8;
  dword_66CBE8 = (int)&dword_66CBCC;
  *(_DWORD *)algn_66CBB4 = &dword_66CBCC;
  dword_66CBCC = (int)&dword_66CBB0;
  unk_66CB98 = &dword_66CBB0;
  dword_66CBB0 = (int)&dword_66CB94;
  unk_66CB7C = &dword_66CB94;
  dword_66CB94 = (int)&dword_66CB78;
  unk_66CB60 = &dword_66CB78;
  dword_66CB78 = (int)&dword_66CB5C;
  *(_DWORD *)algn_66CB44 = &dword_66CB5C;
  dword_66CB5C = (int)&dword_66CB40;
  unk_66CB28 = &dword_66CB40;
  dword_66CB40 = (int)&dword_66CB24;
  unk_66CB0C = &dword_66CB24;
  dword_66CB24 = (int)&dword_66CB08;
  unk_66CAF0 = &dword_66CB08;
  dword_66CB08 = (int)&dword_66CAEC;
  *(_DWORD *)algn_66CAD4 = &dword_66CAEC;
  dword_66CAEC = (int)&dword_66CAD0;
  unk_66CAB8 = &dword_66CAD0;
  dword_66CAD0 = (int)&dword_66CAB4;
  unk_66CA9C = &dword_66CAB4;
  dword_66CAB4 = (int)&dword_66CA98;
  unk_66CA80 = &dword_66CA98;
  dword_66CA98 = (int)&dword_66CA7C;
  *(_DWORD *)algn_66CA64 = &dword_66CA7C;
  dword_66CA7C = (int)&dword_66CA60;
  unk_66CA48 = &dword_66CA60;
  dword_66CA60 = (int)&dword_66CA44;
  unk_66CA2C = &dword_66CA44;
  dword_66CA44 = (int)&dword_66CA28;
  unk_66CA10 = &dword_66CA28;
  dword_66CA28 = (int)&dword_66CA0C;
  *(_DWORD *)algn_66C9F4 = &dword_66CA0C;
  dword_66CA0C = (int)&dword_66C9F0;
  unk_66C9D8 = &dword_66C9F0;
  dword_66C9F0 = (int)&dword_66C9D4;
  unk_66C9BC = &dword_66C9D4;
  dword_66C9D4 = (int)&dword_66C9B8;
  result = &dword_66C99C;
  off_66B584 = (void **)&dword_66C99C;
  unk_66C9A0 = &dword_66C9B8;
  dword_66C9B8 = (int)&dword_66C99C;
  dword_66C99C = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66C99C: using guessed type int dword_66C99C;
// 66C9B8: using guessed type int dword_66C9B8;
// 66C9D4: using guessed type int dword_66C9D4;
// 66C9F0: using guessed type int dword_66C9F0;
// 66CA0C: using guessed type int dword_66CA0C;
// 66CA28: using guessed type int dword_66CA28;
// 66CA44: using guessed type int dword_66CA44;
// 66CA60: using guessed type int dword_66CA60;
// 66CA7C: using guessed type int dword_66CA7C;
// 66CA98: using guessed type int dword_66CA98;
// 66CAB4: using guessed type int dword_66CAB4;
// 66CAD0: using guessed type int dword_66CAD0;
// 66CAEC: using guessed type int dword_66CAEC;
// 66CB08: using guessed type int dword_66CB08;
// 66CB24: using guessed type int dword_66CB24;
// 66CB40: using guessed type int dword_66CB40;
// 66CB5C: using guessed type int dword_66CB5C;
// 66CB78: using guessed type int dword_66CB78;
// 66CB94: using guessed type int dword_66CB94;
// 66CBB0: using guessed type int dword_66CBB0;
// 66CBCC: using guessed type int dword_66CBCC;
// 66CBE8: using guessed type int dword_66CBE8;
// 66CC04: using guessed type int dword_66CC04;
// 66CC20: using guessed type int dword_66CC20;
// 66CC3C: using guessed type int dword_66CC3C;
// 66CC58: using guessed type int dword_66CC58;
// 66CC74: using guessed type int dword_66CC74;
// 66CC90: using guessed type int dword_66CC90;
// 66CCAC: using guessed type int dword_66CCAC;
// 66CCC8: using guessed type int dword_66CCC8;
// 66CCE4: using guessed type int dword_66CCE4;
// 66CCE8: using guessed type int dword_66CCE8;
// 66CD00: using guessed type int dword_66CD00;
// 66CD1C: using guessed type int dword_66CD1C;
// 66CD20: using guessed type int dword_66CD20;
// 66CD38: using guessed type int dword_66CD38;
// 66CD54: using guessed type int dword_66CD54;
// 66CD58: using guessed type int dword_66CD58;
// 66CD70: using guessed type int dword_66CD70;
// 66CD8C: using guessed type int dword_66CD8C;
// 66CD90: using guessed type int dword_66CD90;
// 66CDA8: using guessed type int dword_66CDA8;
// 66CDC4: using guessed type int dword_66CDC4;
// 66CDC8: using guessed type int dword_66CDC8;
// 66CDE0: using guessed type int dword_66CDE0;
// 66CDFC: using guessed type int dword_66CDFC;
// 66CE00: using guessed type int dword_66CE00;
// 66CE18: using guessed type int dword_66CE18;
// 66CE34: using guessed type int dword_66CE34;
// 66CE38: using guessed type int dword_66CE38;
// 66CE50: using guessed type int dword_66CE50;
// 66CE6C: using guessed type int dword_66CE6C;
// 66CE70: using guessed type int dword_66CE70;
// 66CE88: using guessed type int dword_66CE88;
// 66CEA4: using guessed type int dword_66CEA4;
// 66CEC0: using guessed type int dword_66CEC0;
// 66CEDC: using guessed type int dword_66CEDC;
// 66CEF8: using guessed type int dword_66CEF8;
// 66CF14: using guessed type int dword_66CF14;
// 66CF30: using guessed type int dword_66CF30;
// 66CF4C: using guessed type int dword_66CF4C;
// 66CF68: using guessed type int dword_66CF68;
// 66D1EC: using guessed type int dword_66D1EC;

//----- (0040FEF8) --------------------------------------------------------
_DWORD *ctor_035()
{
  _DWORD *result; // $v0

  result = dword_66C750;
  dword_66C984 = (int)off_66B584;
  *off_66B584 = &dword_66C980;
  dword_66C94C = (int)&dword_66C964;
  dword_66C964 = (int)&dword_66C948;
  dword_66C930 = (int)&dword_66C948;
  dword_66C968 = (int)&dword_66C980;
  dword_66C980 = (int)&dword_66C964;
  dword_66C948 = &dword_66C92C;
  dword_66C914 = (int)&dword_66C92C;
  dword_66C8F8 = (int)&dword_66C910;
  dword_66C92C = &dword_66C910;
  dword_66C8DC = (int)&dword_66C8F4;
  dword_66C910 = &dword_66C8F4;
  dword_66C8F4 = &dword_66C8D8;
  dword_66C8C0 = (int)&dword_66C8D8;
  dword_66C8A4 = (int)&dword_66C8BC;
  dword_66C8D8 = &dword_66C8BC;
  dword_66C888 = (int)&dword_66C8A0;
  dword_66C8BC = &dword_66C8A0;
  dword_66C86C = (int)&dword_66C884;
  dword_66C8A0 = &dword_66C884;
  dword_66C850 = (int)&dword_66C868;
  dword_66C884 = &dword_66C868;
  dword_66C834 = (int)&dword_66C84C;
  dword_66C868 = &dword_66C84C;
  dword_66C84C = &dword_66C830;
  dword_66C818 = (int)&dword_66C830;
  dword_66C830 = (int)&dword_66C814;
  dword_66C7FC = (int)&dword_66C814;
  dword_66C814 = (int)&dword_66C7F8;
  dword_66C7E0 = (int)&dword_66C7F8;
  dword_66C7F8 = (int)&dword_66C7DC;
  dword_66C7C4 = (int)&dword_66C7DC;
  dword_66C7A8 = (int)&dword_66C7C0;
  dword_66C7DC = (int)&dword_66C7C0;
  dword_66C78C = (int)&dword_66C7A4;
  dword_66C770 = (int)&dword_66C788;
  dword_66C788 = (int)&dword_66C76C;
  off_66B584 = (void **)dword_66C750;
  dword_66C750[0] = &_httpd_cgi_all_fun;
  dword_66C750[1] = &dword_66C76C;
  dword_66C76C = (int)dword_66C750;
  dword_66C7C0 = (int)&dword_66C7A4;
  dword_66C7A4 = (int)&dword_66C788;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66C76C: using guessed type int dword_66C76C;
// 66C770: using guessed type int dword_66C770;
// 66C788: using guessed type int dword_66C788;
// 66C78C: using guessed type int dword_66C78C;
// 66C7A4: using guessed type int dword_66C7A4;
// 66C7A8: using guessed type int dword_66C7A8;
// 66C7C0: using guessed type int dword_66C7C0;
// 66C7C4: using guessed type int dword_66C7C4;
// 66C7DC: using guessed type int dword_66C7DC;
// 66C7E0: using guessed type int dword_66C7E0;
// 66C7F8: using guessed type int dword_66C7F8;
// 66C7FC: using guessed type int dword_66C7FC;
// 66C814: using guessed type int dword_66C814;
// 66C818: using guessed type int dword_66C818;
// 66C830: using guessed type int dword_66C830;
// 66C834: using guessed type int dword_66C834;
// 66C850: using guessed type int dword_66C850;
// 66C86C: using guessed type int dword_66C86C;
// 66C888: using guessed type int dword_66C888;
// 66C8A4: using guessed type int dword_66C8A4;
// 66C8C0: using guessed type int dword_66C8C0;
// 66C8DC: using guessed type int dword_66C8DC;
// 66C8F8: using guessed type int dword_66C8F8;
// 66C914: using guessed type int dword_66C914;
// 66C930: using guessed type int dword_66C930;
// 66C94C: using guessed type int dword_66C94C;
// 66C964: using guessed type int dword_66C964;
// 66C968: using guessed type int dword_66C968;
// 66C980: using guessed type int dword_66C980;
// 66C984: using guessed type int dword_66C984;

//----- (00410138) --------------------------------------------------------
int *ctor_036()
{
  int *result; // $v0

  dword_66C734[1] = off_66B584;
  *off_66B584 = dword_66C734;
  dword_66C718[1] = dword_66C734;
  dword_66C734[0] = dword_66C718;
  unk_66C700 = dword_66C718;
  dword_66C718[0] = &dword_66C6FC;
  dword_66C6E0[1] = &dword_66C6FC;
  dword_66C6FC = (int)dword_66C6E0;
  dword_66C6C4[1] = dword_66C6E0;
  dword_66C6E0[0] = dword_66C6C4;
  dword_66C6A8[1] = dword_66C6C4;
  dword_66C6C4[0] = dword_66C6A8;
  dword_66C68C[1] = dword_66C6A8;
  dword_66C6A8[0] = dword_66C68C;
  dword_66C670[1] = dword_66C68C;
  dword_66C68C[0] = dword_66C670;
  dword_66C654[1] = dword_66C670;
  dword_66C670[0] = dword_66C654;
  off_66C638[1] = dword_66C654;
  dword_66C654[0] = off_66C638;
  off_66C61C[1] = off_66C638;
  off_66C638[0] = off_66C61C;
  dword_66C600[1] = off_66C61C;
  off_66C61C[0] = dword_66C600;
  dword_66C5E4[1] = dword_66C600;
  dword_66C600[0] = dword_66C5E4;
  dword_66C5C8[1] = dword_66C5E4;
  dword_66C5E4[0] = dword_66C5C8;
  dword_66C5AC[1] = dword_66C5C8;
  dword_66C5C8[0] = dword_66C5AC;
  off_66C590[1] = dword_66C5AC;
  dword_66C5AC[0] = off_66C590;
  off_66C574[1] = off_66C590;
  off_66C590[0] = off_66C574;
  dword_66C558[1] = off_66C574;
  off_66C574[0] = dword_66C558;
  dword_66C53C[1] = dword_66C558;
  dword_66C558[0] = dword_66C53C;
  dword_66C520[1] = dword_66C53C;
  dword_66C53C[0] = dword_66C520;
  dword_66C504[1] = dword_66C520;
  dword_66C520[0] = dword_66C504;
  dword_66C4E8[1] = dword_66C504;
  dword_66C504[0] = dword_66C4E8;
  dword_66C4CC[1] = dword_66C4E8;
  dword_66C4E8[0] = dword_66C4CC;
  *(_DWORD *)algn_66C444 = &dword_66C45C;
  dword_66C4CC[0] = dword_66C4B0;
  dword_66C4B0[1] = dword_66C4CC;
  dword_66C494[1] = dword_66C4B0;
  dword_66C4B0[0] = dword_66C494;
  unk_66C47C = dword_66C494;
  dword_66C494[0] = &dword_66C478;
  unk_66C460 = &dword_66C478;
  unk_66C428 = &dword_66C440;
  dword_66C478 = (int)&dword_66C45C;
  unk_66C40C = &dword_66C424;
  dword_66C45C = (int)&dword_66C440;
  dword_66C3F0 = (int)&dword_66C408;
  dword_66C440 = (int)&dword_66C424;
  *(_DWORD *)algn_66C3D4 = &dword_66C3EC;
  dword_66C424 = (int)&dword_66C408;
  dword_66C408 = (int)&dword_66C3EC;
  dword_66C3EC = (int)&dword_66C3D0;
  dword_66C3B8 = (int)&dword_66C3D0;
  dword_66C3D0 = (int)&dword_66C3B4;
  dword_66C3B4 = (int)&dword_66C398;
  dword_66C398 = (int)&dword_66C37C;
  dword_66C37C = (int)&dword_66C360;
  dword_66C360 = (int)&dword_66C344;
  dword_66C344 = (int)&dword_66C328;
  dword_66C328 = (int)&dword_66C30C;
  dword_66C30C = (int)&dword_66C2F0;
  dword_66C2F0 = (int)&dword_66C2D4;
  dword_66C2D4 = (int)&dword_66C2B8;
  dword_66C2B8 = (int)&dword_66C29C;
  dword_66C29C = (int)&dword_66C280;
  dword_66C280 = (int)&dword_66C264;
  dword_66C230 = (int)&dword_66C248;
  dword_66C264 = (int)&dword_66C248;
  *(_DWORD *)algn_66C214 = &dword_66C22C;
  dword_66C248 = (int)&dword_66C22C;
  *(_DWORD *)algn_66C2F4 = &dword_66C30C;
  dword_66C2D8 = (int)&dword_66C2F0;
  unk_66C2BC = &dword_66C2D4;
  dword_66C2A0 = (int)&dword_66C2B8;
  *(_DWORD *)algn_66C284 = &dword_66C29C;
  dword_66C268 = (int)&dword_66C280;
  unk_66C24C = &dword_66C264;
  dword_66C22C = (int)&dword_66C210;
  unk_66C39C = &dword_66C3B4;
  unk_66C380 = &dword_66C398;
  *(_DWORD *)algn_66C364 = &dword_66C37C;
  dword_66C348 = (int)&dword_66C360;
  unk_66C32C = &dword_66C344;
  dword_66C310 = (int)&dword_66C328;
  dword_66C1F8 = (int)&dword_66C210;
  dword_66C210 = (int)&dword_66C1F4;
  unk_66C1DC = &dword_66C1F4;
  unk_66C1C0 = &dword_66C1D8;
  dword_66C1F4 = (int)&dword_66C1D8;
  dword_66C1D8 = (int)&dword_66C1BC;
  *(_DWORD *)algn_66C1A4 = &dword_66C1BC;
  dword_66C1BC = (int)&dword_66C1A0;
  unk_66C188 = &dword_66C1A0;
  dword_66C1A0 = (int)&dword_66C184;
  unk_66C16C = &dword_66C184;
  dword_66C184 = (int)&dword_66C168;
  *(_DWORD *)algn_66C150 = &dword_66C168;
  dword_66C168 = (int)&dword_66C14C;
  unk_66C134 = &dword_66C14C;
  dword_66C14C = (int)&dword_66C130;
  unk_66C118 = &dword_66C130;
  dword_66C130 = (int)&dword_66C114;
  unk_66C0FC = &dword_66C114;
  dword_66C114 = (int)&dword_66C0F8;
  unk_66C0E0 = &dword_66C0F8;
  dword_66C0F8 = (int)&dword_66C0DC;
  unk_66C0C4 = &dword_66C0DC;
  dword_66C0DC = (int)&dword_66C0C0;
  unk_66C0A8 = &dword_66C0C0;
  dword_66C0C0 = (int)&dword_66C0A4;
  unk_66C08C = &dword_66C0A4;
  dword_66C0A4 = (int)&dword_66C088;
  result = &dword_66C06C;
  *(_DWORD *)algn_66C070 = &dword_66C088;
  dword_66C088 = (int)&dword_66C06C;
  off_66B584 = (void **)&dword_66C050;
  unk_66C054 = &dword_66C06C;
  dword_66C06C = (int)&dword_66C050;
  dword_66C050 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66C050: using guessed type int dword_66C050;
// 66C06C: using guessed type int dword_66C06C;
// 66C088: using guessed type int dword_66C088;
// 66C0A4: using guessed type int dword_66C0A4;
// 66C0C0: using guessed type int dword_66C0C0;
// 66C0DC: using guessed type int dword_66C0DC;
// 66C0F8: using guessed type int dword_66C0F8;
// 66C114: using guessed type int dword_66C114;
// 66C130: using guessed type int dword_66C130;
// 66C14C: using guessed type int dword_66C14C;
// 66C168: using guessed type int dword_66C168;
// 66C184: using guessed type int dword_66C184;
// 66C1A0: using guessed type int dword_66C1A0;
// 66C1BC: using guessed type int dword_66C1BC;
// 66C1D8: using guessed type int dword_66C1D8;
// 66C1F4: using guessed type int dword_66C1F4;
// 66C1F8: using guessed type int dword_66C1F8;
// 66C210: using guessed type int dword_66C210;
// 66C22C: using guessed type int dword_66C22C;
// 66C230: using guessed type int dword_66C230;
// 66C248: using guessed type int dword_66C248;
// 66C264: using guessed type int dword_66C264;
// 66C268: using guessed type int dword_66C268;
// 66C280: using guessed type int dword_66C280;
// 66C29C: using guessed type int dword_66C29C;
// 66C2A0: using guessed type int dword_66C2A0;
// 66C2B8: using guessed type int dword_66C2B8;
// 66C2D4: using guessed type int dword_66C2D4;
// 66C2D8: using guessed type int dword_66C2D8;
// 66C2F0: using guessed type int dword_66C2F0;
// 66C30C: using guessed type int dword_66C30C;
// 66C310: using guessed type int dword_66C310;
// 66C328: using guessed type int dword_66C328;
// 66C344: using guessed type int dword_66C344;
// 66C348: using guessed type int dword_66C348;
// 66C360: using guessed type int dword_66C360;
// 66C37C: using guessed type int dword_66C37C;
// 66C398: using guessed type int dword_66C398;
// 66C3B4: using guessed type int dword_66C3B4;
// 66C3B8: using guessed type int dword_66C3B8;
// 66C3D0: using guessed type int dword_66C3D0;
// 66C3EC: using guessed type int dword_66C3EC;
// 66C3F0: using guessed type int dword_66C3F0;
// 66C408: using guessed type int dword_66C408;
// 66C424: using guessed type int dword_66C424;
// 66C440: using guessed type int dword_66C440;
// 66C45C: using guessed type int dword_66C45C;
// 66C478: using guessed type int dword_66C478;
// 66C6FC: using guessed type int dword_66C6FC;

//----- (004108E8) --------------------------------------------------------
int *ctor_037()
{
  int *result; // $v0

  dword_66E208[1] = off_66B584;
  *off_66B584 = dword_66E208;
  dword_66E1EC[1] = dword_66E208;
  dword_66E208[0] = dword_66E1EC;
  *(_DWORD *)algn_66E1D4 = dword_66E1EC;
  dword_66E1EC[0] = &dword_66E1D0;
  dword_66E1B4[1] = &dword_66E1D0;
  dword_66E1D0 = (int)dword_66E1B4;
  dword_66E198[1] = dword_66E1B4;
  dword_66E1B4[0] = dword_66E198;
  dword_66E17C[1] = dword_66E198;
  dword_66E198[0] = dword_66E17C;
  dword_66E160[1] = dword_66E17C;
  dword_66E17C[0] = dword_66E160;
  dword_66E144[1] = dword_66E160;
  dword_66E160[0] = dword_66E144;
  dword_66E128[1] = dword_66E144;
  dword_66E144[0] = dword_66E128;
  dword_66E10C[1] = dword_66E128;
  dword_66E128[0] = dword_66E10C;
  dword_66E0F0[1] = dword_66E10C;
  dword_66E10C[0] = dword_66E0F0;
  dword_66E0D4[1] = dword_66E0F0;
  dword_66E0F0[0] = dword_66E0D4;
  dword_66E0B8[1] = dword_66E0D4;
  dword_66E0D4[0] = dword_66E0B8;
  dword_66E09C[1] = dword_66E0B8;
  dword_66E0B8[0] = dword_66E09C;
  dword_66E080[1] = dword_66E09C;
  dword_66E09C[0] = dword_66E080;
  dword_66E064[1] = dword_66E080;
  dword_66E080[0] = dword_66E064;
  dword_66E048[1] = dword_66E064;
  dword_66E064[0] = dword_66E048;
  dword_66E02C[1] = dword_66E048;
  dword_66E048[0] = dword_66E02C;
  dword_66E010[1] = dword_66E02C;
  dword_66E02C[0] = dword_66E010;
  dword_66DFF4[1] = dword_66E010;
  dword_66E010[0] = dword_66DFF4;
  dword_66DFD8[1] = dword_66DFF4;
  dword_66DFF4[0] = dword_66DFD8;
  dword_66DFBC[1] = dword_66DFD8;
  dword_66DFD8[0] = dword_66DFBC;
  dword_66DFA0[1] = dword_66DFBC;
  dword_66DFBC[0] = dword_66DFA0;
  dword_66DFA0[0] = dword_66DF84;
  dword_66DF84[1] = dword_66DFA0;
  dword_66DF68[1] = dword_66DF84;
  unk_66DF50 = dword_66DF68;
  dword_66DF84[0] = dword_66DF68;
  *(_DWORD *)algn_66DF34 = &dword_66DF4C;
  dword_66DF68[0] = &dword_66DF4C;
  unk_66DF18 = &dword_66DF30;
  dword_66DF4C = (int)&dword_66DF30;
  dword_66DF30 = (int)&dword_66DF14;
  dword_66DF14 = (int)&dword_66DEF8;
  dword_66DEF8 = (int)&dword_66DEDC;
  dword_66DEDC = (int)&dword_66DEC0;
  dword_66DEC0 = (int)&dword_66DEA4;
  dword_66DEA4 = (int)&dword_66DE88;
  dword_66DE88 = (int)&dword_66DE6C;
  unk_66DDC8 = &dword_66DDE0;
  dword_66DE6C = (int)&dword_66DE50;
  dword_66DDAC = (int)&dword_66DDC4;
  dword_66DE50 = (int)&dword_66DE34;
  unk_66DEFC = &dword_66DF14;
  dword_66DE34 = (int)&dword_66DE18;
  unk_66DEE0 = &dword_66DEF8;
  dword_66DE18 = (int)&dword_66DDFC;
  *(_DWORD *)algn_66DEC4 = &dword_66DEDC;
  dword_66DDFC = (int)&dword_66DDE0;
  unk_66DEA8 = &dword_66DEC0;
  dword_66DDE0 = (int)&dword_66DDC4;
  unk_66DE8C = &dword_66DEA4;
  dword_66DDC4 = (int)&dword_66DDA8;
  unk_66DE70 = &dword_66DE88;
  dword_66DE54 = (int)&dword_66DE6C;
  unk_66DE38 = &dword_66DE50;
  dword_66DE1C = (int)&dword_66DE34;
  unk_66DE00 = &dword_66DE18;
  dword_66DDE4 = (int)&dword_66DDFC;
  unk_66DD90 = &dword_66DDA8;
  dword_66DDA8 = (int)&dword_66DD8C;
  dword_66DD8C = (int)&dword_66DD70;
  dword_66DD70 = (int)&dword_66DD54;
  dword_66DD54 = (int)&dword_66DD38;
  dword_66DD38 = (int)&dword_66DD1C;
  dword_66DD04 = (int)&dword_66DD1C;
  dword_66DD1C = (int)&dword_66DD00;
  unk_66DCE8 = &dword_66DD00;
  dword_66DCCC = (int)&dword_66DCE4;
  unk_66DCB0 = &dword_66DCC8;
  dword_66DD00 = (int)&dword_66DCE4;
  dword_66DCE4 = (int)&dword_66DCC8;
  *(_DWORD *)algn_66DC94 = &dword_66DCAC;
  dword_66DCC8 = (int)&dword_66DCAC;
  dword_66DCAC = (int)&dword_66DC90;
  unk_66DC78 = &dword_66DC90;
  dword_66DC90 = (int)&dword_66DC74;
  unk_66DC5C = &dword_66DC74;
  dword_66DC74 = (int)&dword_66DC58;
  unk_66DC40 = &dword_66DC58;
  dword_66DC58 = (int)&dword_66DC3C;
  dword_66DD74 = (int)&dword_66DD8C;
  unk_66DD58 = &dword_66DD70;
  dword_66DD3C = (int)&dword_66DD54;
  unk_66DD20 = &dword_66DD38;
  *(_DWORD *)algn_66DC24 = &dword_66DC3C;
  dword_66DC3C = (int)&dword_66DC20;
  unk_66DC08 = &dword_66DC20;
  dword_66DC20 = (int)&dword_66DC04;
  unk_66DBEC = &dword_66DC04;
  dword_66DC04 = (int)&dword_66DBE8;
  unk_66DBD0 = &dword_66DBE8;
  dword_66DBE8 = (int)&dword_66DBCC;
  *(_DWORD *)algn_66DBB4 = &dword_66DBCC;
  dword_66DBCC = (int)&dword_66DBB0;
  unk_66DB98 = &dword_66DBB0;
  dword_66DBB0 = (int)&dword_66DB94;
  unk_66DB7C = &dword_66DB94;
  dword_66DB94 = (int)&dword_66DB78;
  unk_66DB60 = &dword_66DB78;
  dword_66DB78 = (int)&dword_66DB5C;
  *(_DWORD *)algn_66DB44 = &dword_66DB5C;
  dword_66DB5C = (int)&dword_66DB40;
  unk_66DB28 = &dword_66DB40;
  dword_66DB40 = (int)&dword_66DB24;
  unk_66DB0C = &dword_66DB24;
  dword_66DB24 = (int)&dword_66DB08;
  unk_66DAF0 = &dword_66DB08;
  dword_66DB08 = (int)&dword_66DAEC;
  *(_DWORD *)algn_66DAD4 = &dword_66DAEC;
  dword_66DAEC = (int)&dword_66DAD0;
  unk_66DAB8 = &dword_66DAD0;
  dword_66DAD0 = (int)&dword_66DAB4;
  unk_66DA9C = &dword_66DAB4;
  dword_66DAB4 = (int)&dword_66DA98;
  unk_66DA80 = &dword_66DA98;
  dword_66DA98 = (int)&dword_66DA7C;
  *(_DWORD *)algn_66DA64 = &dword_66DA7C;
  dword_66DA7C = (int)&dword_66DA60;
  unk_66DA48 = &dword_66DA60;
  dword_66DA60 = (int)&dword_66DA44;
  unk_66DA2C = &dword_66DA44;
  dword_66DA44 = (int)&dword_66DA28;
  unk_66DA10 = &dword_66DA28;
  dword_66DA28 = (int)&dword_66DA0C;
  *(_DWORD *)algn_66D9F4 = &dword_66DA0C;
  dword_66DA0C = (int)&dword_66D9F0;
  unk_66D9D8 = &dword_66D9F0;
  dword_66D9F0 = (int)&dword_66D9D4;
  unk_66D9BC = &dword_66D9D4;
  dword_66D9D4 = (int)&dword_66D9B8;
  unk_66D9A0 = &dword_66D9B8;
  dword_66D9B8 = (int)&dword_66D99C;
  result = &dword_66D980;
  off_66B584 = (void **)&dword_66D980;
  *(_DWORD *)algn_66D984 = &dword_66D99C;
  dword_66D99C = (int)&dword_66D980;
  dword_66D980 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66D980: using guessed type int dword_66D980;
// 66D99C: using guessed type int dword_66D99C;
// 66D9B8: using guessed type int dword_66D9B8;
// 66D9D4: using guessed type int dword_66D9D4;
// 66D9F0: using guessed type int dword_66D9F0;
// 66DA0C: using guessed type int dword_66DA0C;
// 66DA28: using guessed type int dword_66DA28;
// 66DA44: using guessed type int dword_66DA44;
// 66DA60: using guessed type int dword_66DA60;
// 66DA7C: using guessed type int dword_66DA7C;
// 66DA98: using guessed type int dword_66DA98;
// 66DAB4: using guessed type int dword_66DAB4;
// 66DAD0: using guessed type int dword_66DAD0;
// 66DAEC: using guessed type int dword_66DAEC;
// 66DB08: using guessed type int dword_66DB08;
// 66DB24: using guessed type int dword_66DB24;
// 66DB40: using guessed type int dword_66DB40;
// 66DB5C: using guessed type int dword_66DB5C;
// 66DB78: using guessed type int dword_66DB78;
// 66DB94: using guessed type int dword_66DB94;
// 66DBB0: using guessed type int dword_66DBB0;
// 66DBCC: using guessed type int dword_66DBCC;
// 66DBE8: using guessed type int dword_66DBE8;
// 66DC04: using guessed type int dword_66DC04;
// 66DC20: using guessed type int dword_66DC20;
// 66DC3C: using guessed type int dword_66DC3C;
// 66DC58: using guessed type int dword_66DC58;
// 66DC74: using guessed type int dword_66DC74;
// 66DC90: using guessed type int dword_66DC90;
// 66DCAC: using guessed type int dword_66DCAC;
// 66DCC8: using guessed type int dword_66DCC8;
// 66DCCC: using guessed type int dword_66DCCC;
// 66DCE4: using guessed type int dword_66DCE4;
// 66DD00: using guessed type int dword_66DD00;
// 66DD04: using guessed type int dword_66DD04;
// 66DD1C: using guessed type int dword_66DD1C;
// 66DD38: using guessed type int dword_66DD38;
// 66DD3C: using guessed type int dword_66DD3C;
// 66DD54: using guessed type int dword_66DD54;
// 66DD70: using guessed type int dword_66DD70;
// 66DD74: using guessed type int dword_66DD74;
// 66DD8C: using guessed type int dword_66DD8C;
// 66DDA8: using guessed type int dword_66DDA8;
// 66DDAC: using guessed type int dword_66DDAC;
// 66DDC4: using guessed type int dword_66DDC4;
// 66DDE0: using guessed type int dword_66DDE0;
// 66DDE4: using guessed type int dword_66DDE4;
// 66DDFC: using guessed type int dword_66DDFC;
// 66DE18: using guessed type int dword_66DE18;
// 66DE1C: using guessed type int dword_66DE1C;
// 66DE34: using guessed type int dword_66DE34;
// 66DE50: using guessed type int dword_66DE50;
// 66DE54: using guessed type int dword_66DE54;
// 66DE6C: using guessed type int dword_66DE6C;
// 66DE88: using guessed type int dword_66DE88;
// 66DEA4: using guessed type int dword_66DEA4;
// 66DEC0: using guessed type int dword_66DEC0;
// 66DEDC: using guessed type int dword_66DEDC;
// 66DEF8: using guessed type int dword_66DEF8;
// 66DF14: using guessed type int dword_66DF14;
// 66DF30: using guessed type int dword_66DF30;
// 66DF4C: using guessed type int dword_66DF4C;
// 66E1D0: using guessed type int dword_66E1D0;

//----- (0041123C) --------------------------------------------------------
int *ctor_038()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_66D964;
  off_66B584 = (void **)&dword_66D964;
  dword_66D964 = (int)&_httpd_cgi_all_fun;
  dword_66D968 = (int)v0;
  *v0 = &dword_66D964;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66D964: using guessed type int dword_66D964;
// 66D968: using guessed type int dword_66D968;

//----- (0041126C) --------------------------------------------------------
_DWORD *ctor_039()
{
  _DWORD *result; // $v0

  result = dword_66D6FC;
  dword_66D94C = (int)off_66B584;
  *off_66B584 = &dword_66D948;
  dword_66D930 = (int)&dword_66D948;
  dword_66D948 = (int)&dword_66D92C;
  dword_66D914 = (int)&dword_66D92C;
  dword_66D92C = &dword_66D910;
  dword_66D8F8 = (int)&dword_66D910;
  dword_66D910 = &dword_66D8F4;
  dword_66D8DC = (int)&dword_66D8F4;
  dword_66D8C0 = (int)&dword_66D8D8;
  dword_66D8F4 = &dword_66D8D8;
  dword_66D8A4 = (int)&dword_66D8BC;
  dword_66D8D8 = &dword_66D8BC;
  dword_66D888 = (int)&dword_66D8A0;
  dword_66D8BC = &dword_66D8A0;
  dword_66D86C = (int)&dword_66D884;
  dword_66D8A0 = &dword_66D884;
  dword_66D884 = &dword_66D868;
  dword_66D850 = (int)&dword_66D868;
  dword_66D834 = (int)&dword_66D84C;
  dword_66D868 = &dword_66D84C;
  dword_66D818 = (int)&dword_66D830;
  dword_66D84C = &dword_66D830;
  dword_66D830 = &dword_66D814;
  dword_66D7FC = (int)&dword_66D814;
  dword_66D814 = &dword_66D7F8;
  dword_66D7E0 = (int)&dword_66D7F8;
  dword_66D7F8 = (int)&dword_66D7DC;
  dword_66D7C4 = (int)&dword_66D7DC;
  dword_66D7DC = (int)&dword_66D7C0;
  dword_66D738 = (int)&dword_66D750;
  dword_66D750 = (int)&dword_66D734;
  dword_66D71C = (int)&dword_66D734;
  dword_66D7A8 = (int)&dword_66D7C0;
  unk_66D78C = &dword_66D7A4;
  unk_66D770 = &dword_66D788;
  dword_66D754 = (int)&dword_66D76C;
  dword_66D76C = (int)&dword_66D750;
  off_66B584 = (void **)dword_66D6FC;
  dword_66D6FC[0] = &_httpd_cgi_all_fun;
  dword_66D6FC[1] = &dword_66D718;
  dword_66D718 = (int)dword_66D6FC;
  dword_66D7C0 = (int)&dword_66D7A4;
  dword_66D7A4 = (int)&dword_66D788;
  dword_66D788 = (int)&dword_66D76C;
  dword_66D734 = (int)&dword_66D718;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66D718: using guessed type int dword_66D718;
// 66D71C: using guessed type int dword_66D71C;
// 66D734: using guessed type int dword_66D734;
// 66D738: using guessed type int dword_66D738;
// 66D750: using guessed type int dword_66D750;
// 66D754: using guessed type int dword_66D754;
// 66D76C: using guessed type int dword_66D76C;
// 66D788: using guessed type int dword_66D788;
// 66D7A4: using guessed type int dword_66D7A4;
// 66D7A8: using guessed type int dword_66D7A8;
// 66D7C0: using guessed type int dword_66D7C0;
// 66D7C4: using guessed type int dword_66D7C4;
// 66D7DC: using guessed type int dword_66D7DC;
// 66D7E0: using guessed type int dword_66D7E0;
// 66D7F8: using guessed type int dword_66D7F8;
// 66D7FC: using guessed type int dword_66D7FC;
// 66D818: using guessed type int dword_66D818;
// 66D834: using guessed type int dword_66D834;
// 66D850: using guessed type int dword_66D850;
// 66D86C: using guessed type int dword_66D86C;
// 66D888: using guessed type int dword_66D888;
// 66D8A4: using guessed type int dword_66D8A4;
// 66D8C0: using guessed type int dword_66D8C0;
// 66D8DC: using guessed type int dword_66D8DC;
// 66D8F8: using guessed type int dword_66D8F8;
// 66D914: using guessed type int dword_66D914;
// 66D930: using guessed type int dword_66D930;
// 66D948: using guessed type int dword_66D948;
// 66D94C: using guessed type int dword_66D94C;

//----- (004114C8) --------------------------------------------------------
_DWORD *ctor_040()
{
  _DWORD *result; // $v0

  result = dword_66D4B0;
  dword_66D6E4 = (int)off_66B584;
  *off_66B584 = &dword_66D6E0;
  dword_66D6AC = (int)&dword_66D6C4;
  dword_66D6C4 = (int)&dword_66D6A8;
  dword_66D690 = (int)&dword_66D6A8;
  dword_66D6C8 = (int)&dword_66D6E0;
  dword_66D6E0 = (int)&dword_66D6C4;
  dword_66D6A8 = &dword_66D68C;
  dword_66D674 = (int)&dword_66D68C;
  dword_66D658 = (int)&dword_66D670;
  dword_66D68C = &dword_66D670;
  dword_66D63C = (int)&dword_66D654;
  dword_66D670 = &dword_66D654;
  dword_66D654 = &dword_66D638;
  dword_66D620 = (int)&dword_66D638;
  dword_66D604 = (int)&dword_66D61C;
  dword_66D638 = &dword_66D61C;
  dword_66D5E8 = (int)&dword_66D600;
  dword_66D61C = &dword_66D600;
  dword_66D5CC = (int)&dword_66D5E4;
  dword_66D600 = &dword_66D5E4;
  dword_66D5B0 = (int)&dword_66D5C8;
  dword_66D5E4 = &dword_66D5C8;
  dword_66D594 = (int)&dword_66D5AC;
  dword_66D5C8 = &dword_66D5AC;
  dword_66D5AC = &dword_66D590;
  dword_66D578 = (int)&dword_66D590;
  dword_66D590 = (int)&dword_66D574;
  dword_66D55C = (int)&dword_66D574;
  dword_66D574 = (int)&dword_66D558;
  dword_66D540 = (int)&dword_66D558;
  dword_66D558 = (int)&dword_66D53C;
  dword_66D524 = (int)&dword_66D53C;
  dword_66D508 = (int)&dword_66D520;
  dword_66D53C = (int)&dword_66D520;
  dword_66D4EC = (int)&dword_66D504;
  dword_66D4D0 = (int)&dword_66D4E8;
  dword_66D4E8 = (int)&dword_66D4CC;
  off_66B584 = (void **)dword_66D4B0;
  dword_66D4B0[0] = &_httpd_cgi_all_fun;
  dword_66D4B0[1] = &dword_66D4CC;
  dword_66D4CC = (int)dword_66D4B0;
  dword_66D520 = (int)&dword_66D504;
  dword_66D504 = (int)&dword_66D4E8;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66D4CC: using guessed type int dword_66D4CC;
// 66D4D0: using guessed type int dword_66D4D0;
// 66D4E8: using guessed type int dword_66D4E8;
// 66D4EC: using guessed type int dword_66D4EC;
// 66D504: using guessed type int dword_66D504;
// 66D508: using guessed type int dword_66D508;
// 66D520: using guessed type int dword_66D520;
// 66D524: using guessed type int dword_66D524;
// 66D53C: using guessed type int dword_66D53C;
// 66D540: using guessed type int dword_66D540;
// 66D558: using guessed type int dword_66D558;
// 66D55C: using guessed type int dword_66D55C;
// 66D574: using guessed type int dword_66D574;
// 66D578: using guessed type int dword_66D578;
// 66D590: using guessed type int dword_66D590;
// 66D594: using guessed type int dword_66D594;
// 66D5B0: using guessed type int dword_66D5B0;
// 66D5CC: using guessed type int dword_66D5CC;
// 66D5E8: using guessed type int dword_66D5E8;
// 66D604: using guessed type int dword_66D604;
// 66D620: using guessed type int dword_66D620;
// 66D63C: using guessed type int dword_66D63C;
// 66D658: using guessed type int dword_66D658;
// 66D674: using guessed type int dword_66D674;
// 66D690: using guessed type int dword_66D690;
// 66D6AC: using guessed type int dword_66D6AC;
// 66D6C4: using guessed type int dword_66D6C4;
// 66D6C8: using guessed type int dword_66D6C8;
// 66D6E0: using guessed type int dword_66D6E0;
// 66D6E4: using guessed type int dword_66D6E4;

//----- (00411708) --------------------------------------------------------
_DWORD *ctor_041()
{
  _DWORD *result; // $v0

  result = &dword_66D2F0;
  dword_66D498 = (int)off_66B584;
  *off_66B584 = &dword_66D494;
  dword_66D47C = (int)&dword_66D494;
  dword_66D494 = (int)&dword_66D478;
  dword_66D478 = (int)&dword_66D45C;
  dword_66D45C = (int)&dword_66D440;
  dword_66D440 = (int)&dword_66D424;
  dword_66D424 = (int)&dword_66D408;
  dword_66D460 = (int)&dword_66D478;
  dword_66D444 = (int)&dword_66D45C;
  dword_66D428 = (int)&dword_66D440;
  dword_66D40C = (int)&dword_66D424;
  dword_66D3F0 = (int)&dword_66D408;
  dword_66D408 = (int)&dword_66D3EC;
  dword_66D3D4 = (int)&dword_66D3EC;
  dword_66D3B8 = (int)&dword_66D3D0;
  dword_66D3EC = (int)&dword_66D3D0;
  dword_66D39C = (int)&dword_66D3B4;
  dword_66D3D0 = &dword_66D3B4;
  dword_66D380 = (int)&dword_66D398;
  dword_66D3B4 = &dword_66D398;
  dword_66D364 = (int)&dword_66D37C;
  dword_66D398 = &dword_66D37C;
  dword_66D348 = (int)&dword_66D360;
  dword_66D37C = &dword_66D360;
  dword_66D360 = &dword_66D344;
  dword_66D32C = (int)&dword_66D344;
  dword_66D344 = (int)&dword_66D328;
  dword_66D310 = (int)&dword_66D328;
  dword_66D328 = (int)&dword_66D30C;
  off_66B584 = (void **)&dword_66D2F0;
  dword_66D2F0 = &_httpd_cgi_all_fun;
  dword_66D2F4 = (int)&dword_66D30C;
  dword_66D30C = (int)&dword_66D2F0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66D2F4: using guessed type int dword_66D2F4;
// 66D30C: using guessed type int dword_66D30C;
// 66D310: using guessed type int dword_66D310;
// 66D328: using guessed type int dword_66D328;
// 66D32C: using guessed type int dword_66D32C;
// 66D344: using guessed type int dword_66D344;
// 66D348: using guessed type int dword_66D348;
// 66D364: using guessed type int dword_66D364;
// 66D380: using guessed type int dword_66D380;
// 66D39C: using guessed type int dword_66D39C;
// 66D3B8: using guessed type int dword_66D3B8;
// 66D3D4: using guessed type int dword_66D3D4;
// 66D3EC: using guessed type int dword_66D3EC;
// 66D3F0: using guessed type int dword_66D3F0;
// 66D408: using guessed type int dword_66D408;
// 66D40C: using guessed type int dword_66D40C;
// 66D424: using guessed type int dword_66D424;
// 66D428: using guessed type int dword_66D428;
// 66D440: using guessed type int dword_66D440;
// 66D444: using guessed type int dword_66D444;
// 66D45C: using guessed type int dword_66D45C;
// 66D460: using guessed type int dword_66D460;
// 66D478: using guessed type int dword_66D478;
// 66D47C: using guessed type int dword_66D47C;
// 66D494: using guessed type int dword_66D494;
// 66D498: using guessed type int dword_66D498;

//----- (004118BC) --------------------------------------------------------
int *ctor_042()
{
  int *result; // $v0

  dword_66EE58[1] = off_66B584;
  *off_66B584 = dword_66EE58;
  dword_66EE3C[1] = dword_66EE58;
  dword_66EE58[0] = dword_66EE3C;
  *(_DWORD *)algn_66EE24 = dword_66EE3C;
  dword_66EE3C[0] = &dword_66EE20;
  dword_66EE04[1] = &dword_66EE20;
  dword_66EE20 = (int)dword_66EE04;
  dword_66EDE8[1] = dword_66EE04;
  dword_66EE04[0] = dword_66EDE8;
  dword_66EDCC[1] = dword_66EDE8;
  dword_66EDE8[0] = dword_66EDCC;
  dword_66EDB0[1] = dword_66EDCC;
  dword_66EDCC[0] = dword_66EDB0;
  dword_66ED94[1] = dword_66EDB0;
  dword_66EDB0[0] = dword_66ED94;
  dword_66ED78[1] = dword_66ED94;
  dword_66ED94[0] = dword_66ED78;
  dword_66ED5C[1] = dword_66ED78;
  dword_66ED78[0] = dword_66ED5C;
  dword_66ED40[1] = dword_66ED5C;
  dword_66ED5C[0] = dword_66ED40;
  dword_66ED24[1] = dword_66ED40;
  dword_66ED40[0] = dword_66ED24;
  dword_66ED08[1] = dword_66ED24;
  dword_66ED24[0] = dword_66ED08;
  dword_66ECEC[1] = dword_66ED08;
  dword_66ED08[0] = dword_66ECEC;
  dword_66ECD0[1] = dword_66ECEC;
  dword_66ECEC[0] = dword_66ECD0;
  dword_66ECB4[1] = dword_66ECD0;
  dword_66ECD0[0] = dword_66ECB4;
  dword_66EC98[1] = dword_66ECB4;
  dword_66ECB4[0] = dword_66EC98;
  dword_66EC7C[1] = dword_66EC98;
  dword_66EC98[0] = dword_66EC7C;
  dword_66EC60[1] = dword_66EC7C;
  dword_66EC7C[0] = dword_66EC60;
  dword_66EC44[1] = dword_66EC60;
  dword_66EC60[0] = dword_66EC44;
  dword_66EC28[1] = dword_66EC44;
  dword_66EC44[0] = dword_66EC28;
  dword_66EC0C[1] = dword_66EC28;
  dword_66EC28[0] = dword_66EC0C;
  dword_66EBF0[1] = dword_66EC0C;
  dword_66EC0C[0] = dword_66EBF0;
  dword_66EBF0[0] = dword_66EBD4;
  dword_66EBD4[1] = dword_66EBF0;
  dword_66EBB8[1] = dword_66EBD4;
  unk_66EBA0 = dword_66EBB8;
  dword_66EBD4[0] = dword_66EBB8;
  *(_DWORD *)algn_66EB84 = &dword_66EB9C;
  dword_66EBB8[0] = &dword_66EB9C;
  unk_66EB68 = &dword_66EB80;
  dword_66EB9C = (int)&dword_66EB80;
  dword_66EB80 = (int)&dword_66EB64;
  dword_66EB64 = (int)&dword_66EB48;
  dword_66EB48 = (int)&dword_66EB2C;
  dword_66EB2C = (int)&dword_66EB10;
  dword_66EB10 = (int)&dword_66EAF4;
  dword_66EAF4 = (int)&dword_66EAD8;
  dword_66EAD8 = (int)&dword_66EABC;
  unk_66EA18 = &dword_66EA30;
  dword_66EABC = (int)&dword_66EAA0;
  dword_66E9FC = (int)&dword_66EA14;
  dword_66EAA0 = (int)&dword_66EA84;
  unk_66EB4C = &dword_66EB64;
  dword_66EA84 = (int)&dword_66EA68;
  unk_66EB30 = &dword_66EB48;
  dword_66EA68 = (int)&dword_66EA4C;
  *(_DWORD *)algn_66EB14 = &dword_66EB2C;
  dword_66EA4C = (int)&dword_66EA30;
  unk_66EAF8 = &dword_66EB10;
  dword_66EA30 = (int)&dword_66EA14;
  unk_66EADC = &dword_66EAF4;
  dword_66EA14 = (int)&dword_66E9F8;
  unk_66EAC0 = &dword_66EAD8;
  dword_66EAA4 = (int)&dword_66EABC;
  unk_66EA88 = &dword_66EAA0;
  dword_66EA6C = (int)&dword_66EA84;
  unk_66EA50 = &dword_66EA68;
  dword_66EA34 = (int)&dword_66EA4C;
  unk_66E9E0 = &dword_66E9F8;
  dword_66E9F8 = (int)&dword_66E9DC;
  dword_66E9DC = (int)&dword_66E9C0;
  dword_66E9C0 = (int)&dword_66E9A4;
  dword_66E9A4 = (int)&dword_66E988;
  dword_66E988 = (int)&dword_66E96C;
  dword_66E954 = (int)&dword_66E96C;
  dword_66E96C = (int)&dword_66E950;
  unk_66E938 = &dword_66E950;
  dword_66E91C = (int)&dword_66E934;
  unk_66E900 = &dword_66E918;
  dword_66E950 = (int)&dword_66E934;
  dword_66E934 = (int)&dword_66E918;
  *(_DWORD *)algn_66E8E4 = &dword_66E8FC;
  dword_66E918 = (int)&dword_66E8FC;
  dword_66E8FC = (int)&dword_66E8E0;
  unk_66E8C8 = &dword_66E8E0;
  dword_66E8E0 = (int)&dword_66E8C4;
  unk_66E8AC = &dword_66E8C4;
  dword_66E8C4 = (int)&dword_66E8A8;
  unk_66E890 = &dword_66E8A8;
  dword_66E8A8 = (int)&dword_66E88C;
  dword_66E9C4 = (int)&dword_66E9DC;
  unk_66E9A8 = &dword_66E9C0;
  dword_66E98C = (int)&dword_66E9A4;
  unk_66E970 = &dword_66E988;
  *(_DWORD *)algn_66E874 = &dword_66E88C;
  dword_66E88C = (int)&dword_66E870;
  unk_66E858 = &dword_66E870;
  dword_66E870 = (int)&dword_66E854;
  unk_66E83C = &dword_66E854;
  dword_66E854 = (int)&dword_66E838;
  unk_66E820 = &dword_66E838;
  dword_66E838 = (int)&dword_66E81C;
  *(_DWORD *)algn_66E804 = &dword_66E81C;
  dword_66E81C = (int)&dword_66E800;
  unk_66E7E8 = &dword_66E800;
  dword_66E800 = (int)&dword_66E7E4;
  unk_66E7CC = &dword_66E7E4;
  dword_66E7E4 = (int)&dword_66E7C8;
  unk_66E7B0 = &dword_66E7C8;
  dword_66E7C8 = (int)&dword_66E7AC;
  *(_DWORD *)algn_66E794 = &dword_66E7AC;
  dword_66E7AC = (int)&dword_66E790;
  unk_66E778 = &dword_66E790;
  dword_66E790 = (int)&dword_66E774;
  unk_66E75C = &dword_66E774;
  dword_66E774 = (int)&dword_66E758;
  unk_66E740 = &dword_66E758;
  dword_66E758 = (int)&dword_66E73C;
  *(_DWORD *)algn_66E724 = &dword_66E73C;
  dword_66E73C = (int)&dword_66E720;
  unk_66E708 = &dword_66E720;
  dword_66E720 = (int)&dword_66E704;
  unk_66E6EC = &dword_66E704;
  dword_66E704 = (int)&dword_66E6E8;
  unk_66E6D0 = &dword_66E6E8;
  dword_66E6E8 = (int)&dword_66E6CC;
  *(_DWORD *)algn_66E6B4 = &dword_66E6CC;
  dword_66E6CC = (int)&dword_66E6B0;
  unk_66E698 = &dword_66E6B0;
  dword_66E6B0 = (int)&dword_66E694;
  unk_66E67C = &dword_66E694;
  dword_66E694 = (int)&dword_66E678;
  unk_66E660 = &dword_66E678;
  dword_66E678 = (int)&dword_66E65C;
  *(_DWORD *)algn_66E644 = &dword_66E65C;
  dword_66E65C = (int)&dword_66E640;
  unk_66E628 = &dword_66E640;
  dword_66E640 = (int)&dword_66E624;
  unk_66E60C = &dword_66E624;
  dword_66E624 = (int)&dword_66E608;
  unk_66E5F0 = &dword_66E608;
  dword_66E608 = (int)&dword_66E5EC;
  result = &dword_66E5D0;
  off_66B584 = (void **)&dword_66E5D0;
  *(_DWORD *)algn_66E5D4 = &dword_66E5EC;
  dword_66E5EC = (int)&dword_66E5D0;
  dword_66E5D0 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66E5D0: using guessed type int dword_66E5D0;
// 66E5EC: using guessed type int dword_66E5EC;
// 66E608: using guessed type int dword_66E608;
// 66E624: using guessed type int dword_66E624;
// 66E640: using guessed type int dword_66E640;
// 66E65C: using guessed type int dword_66E65C;
// 66E678: using guessed type int dword_66E678;
// 66E694: using guessed type int dword_66E694;
// 66E6B0: using guessed type int dword_66E6B0;
// 66E6CC: using guessed type int dword_66E6CC;
// 66E6E8: using guessed type int dword_66E6E8;
// 66E704: using guessed type int dword_66E704;
// 66E720: using guessed type int dword_66E720;
// 66E73C: using guessed type int dword_66E73C;
// 66E758: using guessed type int dword_66E758;
// 66E774: using guessed type int dword_66E774;
// 66E790: using guessed type int dword_66E790;
// 66E7AC: using guessed type int dword_66E7AC;
// 66E7C8: using guessed type int dword_66E7C8;
// 66E7E4: using guessed type int dword_66E7E4;
// 66E800: using guessed type int dword_66E800;
// 66E81C: using guessed type int dword_66E81C;
// 66E838: using guessed type int dword_66E838;
// 66E854: using guessed type int dword_66E854;
// 66E870: using guessed type int dword_66E870;
// 66E88C: using guessed type int dword_66E88C;
// 66E8A8: using guessed type int dword_66E8A8;
// 66E8C4: using guessed type int dword_66E8C4;
// 66E8E0: using guessed type int dword_66E8E0;
// 66E8FC: using guessed type int dword_66E8FC;
// 66E918: using guessed type int dword_66E918;
// 66E91C: using guessed type int dword_66E91C;
// 66E934: using guessed type int dword_66E934;
// 66E950: using guessed type int dword_66E950;
// 66E954: using guessed type int dword_66E954;
// 66E96C: using guessed type int dword_66E96C;
// 66E988: using guessed type int dword_66E988;
// 66E98C: using guessed type int dword_66E98C;
// 66E9A4: using guessed type int dword_66E9A4;
// 66E9C0: using guessed type int dword_66E9C0;
// 66E9C4: using guessed type int dword_66E9C4;
// 66E9DC: using guessed type int dword_66E9DC;
// 66E9F8: using guessed type int dword_66E9F8;
// 66E9FC: using guessed type int dword_66E9FC;
// 66EA14: using guessed type int dword_66EA14;
// 66EA30: using guessed type int dword_66EA30;
// 66EA34: using guessed type int dword_66EA34;
// 66EA4C: using guessed type int dword_66EA4C;
// 66EA68: using guessed type int dword_66EA68;
// 66EA6C: using guessed type int dword_66EA6C;
// 66EA84: using guessed type int dword_66EA84;
// 66EAA0: using guessed type int dword_66EAA0;
// 66EAA4: using guessed type int dword_66EAA4;
// 66EABC: using guessed type int dword_66EABC;
// 66EAD8: using guessed type int dword_66EAD8;
// 66EAF4: using guessed type int dword_66EAF4;
// 66EB10: using guessed type int dword_66EB10;
// 66EB2C: using guessed type int dword_66EB2C;
// 66EB48: using guessed type int dword_66EB48;
// 66EB64: using guessed type int dword_66EB64;
// 66EB80: using guessed type int dword_66EB80;
// 66EB9C: using guessed type int dword_66EB9C;
// 66EE20: using guessed type int dword_66EE20;

//----- (00412210) --------------------------------------------------------
_DWORD *ctor_043()
{
  _DWORD *result; // $v0

  result = dword_66E384;
  dword_66E5B8 = (int)off_66B584;
  *off_66B584 = &dword_66E5B4;
  dword_66E580 = (int)&dword_66E598;
  dword_66E598 = (int)&dword_66E57C;
  dword_66E564 = (int)&dword_66E57C;
  dword_66E59C = (int)&dword_66E5B4;
  dword_66E5B4 = (int)&dword_66E598;
  dword_66E57C = &dword_66E560;
  dword_66E548 = (int)&dword_66E560;
  dword_66E52C = (int)&dword_66E544;
  dword_66E560 = &dword_66E544;
  dword_66E510 = (int)&dword_66E528;
  dword_66E544 = &dword_66E528;
  dword_66E528 = &dword_66E50C;
  dword_66E4F4 = (int)&dword_66E50C;
  dword_66E4D8 = (int)&dword_66E4F0;
  dword_66E50C = &dword_66E4F0;
  dword_66E4BC = (int)&dword_66E4D4;
  dword_66E4F0 = &dword_66E4D4;
  dword_66E4A0 = (int)&dword_66E4B8;
  dword_66E4D4 = &dword_66E4B8;
  dword_66E484 = (int)&dword_66E49C;
  dword_66E4B8 = &dword_66E49C;
  dword_66E468 = (int)&dword_66E480;
  dword_66E49C = &dword_66E480;
  dword_66E480 = &dword_66E464;
  dword_66E44C = (int)&dword_66E464;
  dword_66E464 = (int)&dword_66E448;
  dword_66E430 = (int)&dword_66E448;
  dword_66E448 = (int)&dword_66E42C;
  dword_66E414 = (int)&dword_66E42C;
  dword_66E42C = (int)&dword_66E410;
  dword_66E3F8 = (int)&dword_66E410;
  dword_66E3DC = (int)&dword_66E3F4;
  dword_66E410 = (int)&dword_66E3F4;
  dword_66E3C0 = (int)&dword_66E3D8;
  dword_66E3A4 = (int)&dword_66E3BC;
  dword_66E3BC = (int)&dword_66E3A0;
  off_66B584 = (void **)dword_66E384;
  dword_66E384[0] = &_httpd_cgi_all_fun;
  dword_66E384[1] = &dword_66E3A0;
  dword_66E3A0 = (int)dword_66E384;
  dword_66E3F4 = (int)&dword_66E3D8;
  dword_66E3D8 = (int)&dword_66E3BC;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66E3A0: using guessed type int dword_66E3A0;
// 66E3A4: using guessed type int dword_66E3A4;
// 66E3BC: using guessed type int dword_66E3BC;
// 66E3C0: using guessed type int dword_66E3C0;
// 66E3D8: using guessed type int dword_66E3D8;
// 66E3DC: using guessed type int dword_66E3DC;
// 66E3F4: using guessed type int dword_66E3F4;
// 66E3F8: using guessed type int dword_66E3F8;
// 66E410: using guessed type int dword_66E410;
// 66E414: using guessed type int dword_66E414;
// 66E42C: using guessed type int dword_66E42C;
// 66E430: using guessed type int dword_66E430;
// 66E448: using guessed type int dword_66E448;
// 66E44C: using guessed type int dword_66E44C;
// 66E464: using guessed type int dword_66E464;
// 66E468: using guessed type int dword_66E468;
// 66E484: using guessed type int dword_66E484;
// 66E4A0: using guessed type int dword_66E4A0;
// 66E4BC: using guessed type int dword_66E4BC;
// 66E4D8: using guessed type int dword_66E4D8;
// 66E4F4: using guessed type int dword_66E4F4;
// 66E510: using guessed type int dword_66E510;
// 66E52C: using guessed type int dword_66E52C;
// 66E548: using guessed type int dword_66E548;
// 66E564: using guessed type int dword_66E564;
// 66E580: using guessed type int dword_66E580;
// 66E598: using guessed type int dword_66E598;
// 66E59C: using guessed type int dword_66E59C;
// 66E5B4: using guessed type int dword_66E5B4;
// 66E5B8: using guessed type int dword_66E5B8;

//----- (00412450) --------------------------------------------------------
int *ctor_044()
{
  int *result; // $v0

  result = &dword_66E330;
  dword_66E36C = (int)off_66B584;
  *off_66B584 = &dword_66E368;
  dword_66E350 = (int)&dword_66E368;
  dword_66E368 = (int)&dword_66E34C;
  off_66B584 = (void **)&dword_66E330;
  dword_66E330 = (int)&_httpd_cgi_all_fun;
  dword_66E334 = (int)&dword_66E34C;
  dword_66E34C = (int)&dword_66E330;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66E330: using guessed type int dword_66E330;
// 66E334: using guessed type int dword_66E334;
// 66E34C: using guessed type int dword_66E34C;
// 66E350: using guessed type int dword_66E350;
// 66E368: using guessed type int dword_66E368;
// 66E36C: using guessed type int dword_66E36C;

//----- (004124A0) --------------------------------------------------------
int *ctor_045()
{
  int *result; // $v0

  result = &dword_66F0CC;
  dword_66F0EC = (int)off_66B584;
  *off_66B584 = &dword_66F0E8;
  off_66B584 = (void **)&dword_66F0CC;
  dword_66F0CC = (int)&_httpd_cgi_all_fun;
  dword_66F0D0 = (int)&dword_66F0E8;
  dword_66F0E8 = (int)&dword_66F0CC;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66F0CC: using guessed type int dword_66F0CC;
// 66F0D0: using guessed type int dword_66F0D0;
// 66F0E8: using guessed type int dword_66F0E8;
// 66F0EC: using guessed type int dword_66F0EC;

//----- (004124E0) --------------------------------------------------------
_DWORD *ctor_046()
{
  _DWORD *result; // $v0

  result = dword_66EE80;
  dword_66F0B4 = (int)off_66B584;
  *off_66B584 = &dword_66F0B0;
  dword_66F07C = (int)&dword_66F094;
  dword_66F094 = (int)&dword_66F078;
  dword_66F060 = (int)&dword_66F078;
  dword_66F098 = (int)&dword_66F0B0;
  dword_66F0B0 = (int)&dword_66F094;
  dword_66F078 = &dword_66F05C;
  dword_66F044 = (int)&dword_66F05C;
  dword_66F028 = (int)&dword_66F040;
  dword_66F05C = &dword_66F040;
  dword_66F00C = (int)&dword_66F024;
  dword_66F040 = &dword_66F024;
  dword_66F024 = &dword_66F008;
  dword_66EFF0 = (int)&dword_66F008;
  dword_66EFD4 = (int)&dword_66EFEC;
  dword_66F008 = &dword_66EFEC;
  dword_66EFB8 = (int)&dword_66EFD0;
  dword_66EFEC = &dword_66EFD0;
  dword_66EF9C = (int)&dword_66EFB4;
  dword_66EFD0 = &dword_66EFB4;
  dword_66EF80 = (int)&dword_66EF98;
  dword_66EFB4 = &dword_66EF98;
  dword_66EF64 = (int)&dword_66EF7C;
  dword_66EF98 = &dword_66EF7C;
  dword_66EF7C = &dword_66EF60;
  dword_66EF48 = (int)&dword_66EF60;
  dword_66EF60 = (int)&dword_66EF44;
  dword_66EF2C = (int)&dword_66EF44;
  dword_66EF44 = (int)&dword_66EF28;
  dword_66EF10 = (int)&dword_66EF28;
  dword_66EF28 = (int)&dword_66EF0C;
  dword_66EEF4 = (int)&dword_66EF0C;
  dword_66EED8 = (int)&dword_66EEF0;
  dword_66EF0C = (int)&dword_66EEF0;
  dword_66EEBC = (int)&dword_66EED4;
  dword_66EEA0 = (int)&dword_66EEB8;
  dword_66EEB8 = (int)&dword_66EE9C;
  off_66B584 = (void **)dword_66EE80;
  dword_66EE80[0] = &_httpd_cgi_all_fun;
  dword_66EE80[1] = &dword_66EE9C;
  dword_66EE9C = (int)dword_66EE80;
  dword_66EEF0 = (int)&dword_66EED4;
  dword_66EED4 = (int)&dword_66EEB8;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66EE9C: using guessed type int dword_66EE9C;
// 66EEA0: using guessed type int dword_66EEA0;
// 66EEB8: using guessed type int dword_66EEB8;
// 66EEBC: using guessed type int dword_66EEBC;
// 66EED4: using guessed type int dword_66EED4;
// 66EED8: using guessed type int dword_66EED8;
// 66EEF0: using guessed type int dword_66EEF0;
// 66EEF4: using guessed type int dword_66EEF4;
// 66EF0C: using guessed type int dword_66EF0C;
// 66EF10: using guessed type int dword_66EF10;
// 66EF28: using guessed type int dword_66EF28;
// 66EF2C: using guessed type int dword_66EF2C;
// 66EF44: using guessed type int dword_66EF44;
// 66EF48: using guessed type int dword_66EF48;
// 66EF60: using guessed type int dword_66EF60;
// 66EF64: using guessed type int dword_66EF64;
// 66EF80: using guessed type int dword_66EF80;
// 66EF9C: using guessed type int dword_66EF9C;
// 66EFB8: using guessed type int dword_66EFB8;
// 66EFD4: using guessed type int dword_66EFD4;
// 66EFF0: using guessed type int dword_66EFF0;
// 66F00C: using guessed type int dword_66F00C;
// 66F028: using guessed type int dword_66F028;
// 66F044: using guessed type int dword_66F044;
// 66F060: using guessed type int dword_66F060;
// 66F07C: using guessed type int dword_66F07C;
// 66F094: using guessed type int dword_66F094;
// 66F098: using guessed type int dword_66F098;
// 66F0B0: using guessed type int dword_66F0B0;
// 66F0B4: using guessed type int dword_66F0B4;

//----- (00412720) --------------------------------------------------------
int *ctor_047()
{
  int *result; // $v0

  dword_66FC84[1] = off_66B584;
  *off_66B584 = dword_66FC84;
  dword_66FC68[1] = dword_66FC84;
  dword_66FC84[0] = dword_66FC68;
  unk_66FC50 = dword_66FC68;
  dword_66FC68[0] = &dword_66FC4C;
  dword_66FC30[1] = &dword_66FC4C;
  dword_66FC4C = (int)dword_66FC30;
  dword_66FC14[1] = dword_66FC30;
  dword_66FC30[0] = dword_66FC14;
  dword_66FBF8[1] = dword_66FC14;
  dword_66FC14[0] = dword_66FBF8;
  dword_66FBDC[1] = dword_66FBF8;
  dword_66FBF8[0] = dword_66FBDC;
  dword_66FBC0[1] = dword_66FBDC;
  dword_66FBDC[0] = dword_66FBC0;
  dword_66FBA4[1] = dword_66FBC0;
  dword_66FBC0[0] = dword_66FBA4;
  dword_66FB88[1] = dword_66FBA4;
  dword_66FBA4[0] = dword_66FB88;
  dword_66FB6C[1] = dword_66FB88;
  dword_66FB88[0] = dword_66FB6C;
  dword_66FB50[1] = dword_66FB6C;
  dword_66FB6C[0] = dword_66FB50;
  dword_66FB34[1] = dword_66FB50;
  dword_66FB50[0] = dword_66FB34;
  dword_66FB18[1] = dword_66FB34;
  dword_66FB34[0] = dword_66FB18;
  dword_66FAFC[1] = dword_66FB18;
  dword_66FB18[0] = dword_66FAFC;
  dword_66FAE0[1] = dword_66FAFC;
  dword_66FAFC[0] = dword_66FAE0;
  dword_66FAC4[1] = dword_66FAE0;
  dword_66FAE0[0] = dword_66FAC4;
  dword_66FAA8[1] = dword_66FAC4;
  dword_66FAC4[0] = dword_66FAA8;
  dword_66FA8C[1] = dword_66FAA8;
  dword_66FAA8[0] = dword_66FA8C;
  dword_66FA70[1] = dword_66FA8C;
  dword_66FA8C[0] = dword_66FA70;
  dword_66FA54[1] = dword_66FA70;
  dword_66FA70[0] = dword_66FA54;
  dword_66FA38[1] = dword_66FA54;
  dword_66FA54[0] = dword_66FA38;
  dword_66FA1C[1] = dword_66FA38;
  dword_66FA38[0] = dword_66FA1C;
  dword_66FA1C[0] = dword_66FA00;
  dword_66FA00[1] = dword_66FA1C;
  dword_66F9E4[1] = dword_66FA00;
  unk_66F9CC = dword_66F9E4;
  dword_66FA00[0] = dword_66F9E4;
  unk_66F9B0 = &dword_66F9C8;
  dword_66F9E4[0] = &dword_66F9C8;
  *(_DWORD *)algn_66F994 = &dword_66F9AC;
  dword_66F9C8 = (int)&dword_66F9AC;
  dword_66F9AC = (int)&dword_66F990;
  dword_66F990 = (int)&dword_66F974;
  dword_66F974 = (int)&dword_66F958;
  dword_66F958 = (int)&dword_66F93C;
  dword_66F93C = (int)&dword_66F920;
  dword_66F920 = (int)&dword_66F904;
  dword_66F904 = (int)&dword_66F8E8;
  *(_DWORD *)algn_66F844 = &dword_66F85C;
  dword_66F8E8 = (int)&dword_66F8CC;
  dword_66F828 = (int)&dword_66F840;
  dword_66F8CC = (int)&dword_66F8B0;
  unk_66F978 = &dword_66F990;
  dword_66F8B0 = (int)&dword_66F894;
  unk_66F95C = &dword_66F974;
  dword_66F894 = (int)&dword_66F878;
  unk_66F940 = &dword_66F958;
  dword_66F878 = (int)&dword_66F85C;
  *(_DWORD *)algn_66F924 = &dword_66F93C;
  dword_66F85C = (int)&dword_66F840;
  unk_66F908 = &dword_66F920;
  dword_66F840 = (int)&dword_66F824;
  unk_66F8EC = &dword_66F904;
  dword_66F8D0 = (int)&dword_66F8E8;
  *(_DWORD *)algn_66F8B4 = &dword_66F8CC;
  dword_66F898 = (int)&dword_66F8B0;
  unk_66F87C = &dword_66F894;
  dword_66F860 = (int)&dword_66F878;
  unk_66F80C = &dword_66F824;
  dword_66F824 = (int)&dword_66F808;
  dword_66F808 = (int)&dword_66F7EC;
  dword_66F7EC = (int)&dword_66F7D0;
  dword_66F7D0 = (int)&dword_66F7B4;
  dword_66F7B4 = (int)&dword_66F798;
  dword_66F780 = (int)&dword_66F798;
  dword_66F798 = (int)&dword_66F77C;
  *(_DWORD *)algn_66F764 = &dword_66F77C;
  dword_66F748 = (int)&dword_66F760;
  unk_66F72C = &dword_66F744;
  dword_66F77C = (int)&dword_66F760;
  dword_66F760 = (int)&dword_66F744;
  unk_66F710 = &dword_66F728;
  dword_66F744 = (int)&dword_66F728;
  dword_66F728 = (int)&dword_66F70C;
  *(_DWORD *)algn_66F6F4 = &dword_66F70C;
  dword_66F70C = (int)&dword_66F6F0;
  unk_66F6D8 = &dword_66F6F0;
  dword_66F6F0 = (int)&dword_66F6D4;
  unk_66F6BC = &dword_66F6D4;
  dword_66F6D4 = (int)&dword_66F6B8;
  dword_66F7F0 = (int)&dword_66F808;
  *(_DWORD *)algn_66F7D4 = &dword_66F7EC;
  dword_66F7B8 = (int)&dword_66F7D0;
  unk_66F79C = &dword_66F7B4;
  unk_66F6A0 = &dword_66F6B8;
  dword_66F6B8 = (int)&dword_66F69C;
  *(_DWORD *)algn_66F684 = &dword_66F69C;
  dword_66F69C = (int)&dword_66F680;
  unk_66F668 = &dword_66F680;
  dword_66F680 = (int)&dword_66F664;
  unk_66F64C = &dword_66F664;
  dword_66F664 = (int)&dword_66F648;
  unk_66F630 = &dword_66F648;
  dword_66F648 = (int)&dword_66F62C;
  *(_DWORD *)algn_66F614 = &dword_66F62C;
  dword_66F62C = (int)&dword_66F610;
  unk_66F5F8 = &dword_66F610;
  dword_66F610 = (int)&dword_66F5F4;
  unk_66F5DC = &dword_66F5F4;
  dword_66F5F4 = (int)&dword_66F5D8;
  unk_66F5C0 = &dword_66F5D8;
  dword_66F5D8 = (int)&dword_66F5BC;
  *(_DWORD *)algn_66F5A4 = &dword_66F5BC;
  dword_66F5BC = (int)&dword_66F5A0;
  unk_66F588 = &dword_66F5A0;
  dword_66F5A0 = (int)&dword_66F584;
  unk_66F56C = &dword_66F584;
  dword_66F584 = (int)&dword_66F568;
  unk_66F550 = &dword_66F568;
  dword_66F568 = (int)&dword_66F54C;
  *(_DWORD *)algn_66F534 = &dword_66F54C;
  dword_66F54C = (int)&dword_66F530;
  unk_66F518 = &dword_66F530;
  dword_66F530 = (int)&dword_66F514;
  unk_66F4FC = &dword_66F514;
  dword_66F514 = (int)&dword_66F4F8;
  unk_66F4E0 = &dword_66F4F8;
  dword_66F4F8 = (int)&dword_66F4DC;
  *(_DWORD *)algn_66F4C4 = &dword_66F4DC;
  dword_66F4DC = (int)&dword_66F4C0;
  unk_66F4A8 = &dword_66F4C0;
  dword_66F4C0 = (int)&dword_66F4A4;
  unk_66F48C = &dword_66F4A4;
  dword_66F4A4 = (int)&dword_66F488;
  unk_66F470 = &dword_66F488;
  dword_66F488 = (int)&dword_66F46C;
  *(_DWORD *)algn_66F454 = &dword_66F46C;
  dword_66F46C = (int)&dword_66F450;
  unk_66F438 = &dword_66F450;
  dword_66F450 = (int)&dword_66F434;
  unk_66F41C = &dword_66F434;
  dword_66F434 = (int)&dword_66F418;
  result = &dword_66F3FC;
  off_66B584 = (void **)&dword_66F3FC;
  unk_66F400 = &dword_66F418;
  dword_66F418 = (int)&dword_66F3FC;
  dword_66F3FC = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66F3FC: using guessed type int dword_66F3FC;
// 66F418: using guessed type int dword_66F418;
// 66F434: using guessed type int dword_66F434;
// 66F450: using guessed type int dword_66F450;
// 66F46C: using guessed type int dword_66F46C;
// 66F488: using guessed type int dword_66F488;
// 66F4A4: using guessed type int dword_66F4A4;
// 66F4C0: using guessed type int dword_66F4C0;
// 66F4DC: using guessed type int dword_66F4DC;
// 66F4F8: using guessed type int dword_66F4F8;
// 66F514: using guessed type int dword_66F514;
// 66F530: using guessed type int dword_66F530;
// 66F54C: using guessed type int dword_66F54C;
// 66F568: using guessed type int dword_66F568;
// 66F584: using guessed type int dword_66F584;
// 66F5A0: using guessed type int dword_66F5A0;
// 66F5BC: using guessed type int dword_66F5BC;
// 66F5D8: using guessed type int dword_66F5D8;
// 66F5F4: using guessed type int dword_66F5F4;
// 66F610: using guessed type int dword_66F610;
// 66F62C: using guessed type int dword_66F62C;
// 66F648: using guessed type int dword_66F648;
// 66F664: using guessed type int dword_66F664;
// 66F680: using guessed type int dword_66F680;
// 66F69C: using guessed type int dword_66F69C;
// 66F6B8: using guessed type int dword_66F6B8;
// 66F6D4: using guessed type int dword_66F6D4;
// 66F6F0: using guessed type int dword_66F6F0;
// 66F70C: using guessed type int dword_66F70C;
// 66F728: using guessed type int dword_66F728;
// 66F744: using guessed type int dword_66F744;
// 66F748: using guessed type int dword_66F748;
// 66F760: using guessed type int dword_66F760;
// 66F77C: using guessed type int dword_66F77C;
// 66F780: using guessed type int dword_66F780;
// 66F798: using guessed type int dword_66F798;
// 66F7B4: using guessed type int dword_66F7B4;
// 66F7B8: using guessed type int dword_66F7B8;
// 66F7D0: using guessed type int dword_66F7D0;
// 66F7EC: using guessed type int dword_66F7EC;
// 66F7F0: using guessed type int dword_66F7F0;
// 66F808: using guessed type int dword_66F808;
// 66F824: using guessed type int dword_66F824;
// 66F828: using guessed type int dword_66F828;
// 66F840: using guessed type int dword_66F840;
// 66F85C: using guessed type int dword_66F85C;
// 66F860: using guessed type int dword_66F860;
// 66F878: using guessed type int dword_66F878;
// 66F894: using guessed type int dword_66F894;
// 66F898: using guessed type int dword_66F898;
// 66F8B0: using guessed type int dword_66F8B0;
// 66F8CC: using guessed type int dword_66F8CC;
// 66F8D0: using guessed type int dword_66F8D0;
// 66F8E8: using guessed type int dword_66F8E8;
// 66F904: using guessed type int dword_66F904;
// 66F920: using guessed type int dword_66F920;
// 66F93C: using guessed type int dword_66F93C;
// 66F958: using guessed type int dword_66F958;
// 66F974: using guessed type int dword_66F974;
// 66F990: using guessed type int dword_66F990;
// 66F9AC: using guessed type int dword_66F9AC;
// 66F9C8: using guessed type int dword_66F9C8;
// 66FC4C: using guessed type int dword_66FC4C;

//----- (00413074) --------------------------------------------------------
_DWORD *ctor_048()
{
  _DWORD *result; // $v0

  result = &dword_66F23C;
  dword_66F3E4 = (int)off_66B584;
  *off_66B584 = &dword_66F3E0;
  dword_66F3C8 = (int)&dword_66F3E0;
  dword_66F3E0 = (int)&dword_66F3C4;
  dword_66F3C4 = (int)&dword_66F3A8;
  dword_66F3A8 = (int)&dword_66F38C;
  dword_66F38C = (int)&dword_66F370;
  dword_66F370 = (int)&dword_66F354;
  dword_66F3AC = (int)&dword_66F3C4;
  dword_66F390 = (int)&dword_66F3A8;
  dword_66F374 = (int)&dword_66F38C;
  dword_66F358 = (int)&dword_66F370;
  dword_66F33C = (int)&dword_66F354;
  dword_66F354 = (int)&dword_66F338;
  dword_66F320 = (int)&dword_66F338;
  dword_66F304 = (int)&dword_66F31C;
  dword_66F338 = (int)&dword_66F31C;
  dword_66F2E8 = (int)&dword_66F300;
  dword_66F31C = &dword_66F300;
  dword_66F2CC = (int)&dword_66F2E4;
  dword_66F300 = &dword_66F2E4;
  dword_66F2B0 = (int)&dword_66F2C8;
  dword_66F2E4 = &dword_66F2C8;
  dword_66F294 = (int)&dword_66F2AC;
  dword_66F2C8 = &dword_66F2AC;
  dword_66F2AC = &dword_66F290;
  dword_66F278 = (int)&dword_66F290;
  dword_66F290 = (int)&dword_66F274;
  dword_66F25C = (int)&dword_66F274;
  dword_66F274 = (int)&dword_66F258;
  off_66B584 = (void **)&dword_66F23C;
  dword_66F23C = &_httpd_cgi_all_fun;
  dword_66F240 = (int)&dword_66F258;
  dword_66F258 = (int)&dword_66F23C;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66F240: using guessed type int dword_66F240;
// 66F258: using guessed type int dword_66F258;
// 66F25C: using guessed type int dword_66F25C;
// 66F274: using guessed type int dword_66F274;
// 66F278: using guessed type int dword_66F278;
// 66F290: using guessed type int dword_66F290;
// 66F294: using guessed type int dword_66F294;
// 66F2B0: using guessed type int dword_66F2B0;
// 66F2CC: using guessed type int dword_66F2CC;
// 66F2E8: using guessed type int dword_66F2E8;
// 66F304: using guessed type int dword_66F304;
// 66F320: using guessed type int dword_66F320;
// 66F338: using guessed type int dword_66F338;
// 66F33C: using guessed type int dword_66F33C;
// 66F354: using guessed type int dword_66F354;
// 66F358: using guessed type int dword_66F358;
// 66F370: using guessed type int dword_66F370;
// 66F374: using guessed type int dword_66F374;
// 66F38C: using guessed type int dword_66F38C;
// 66F390: using guessed type int dword_66F390;
// 66F3A8: using guessed type int dword_66F3A8;
// 66F3AC: using guessed type int dword_66F3AC;
// 66F3C4: using guessed type int dword_66F3C4;
// 66F3C8: using guessed type int dword_66F3C8;
// 66F3E0: using guessed type int dword_66F3E0;
// 66F3E4: using guessed type int dword_66F3E4;

//----- (00413228) --------------------------------------------------------
int *ctor_049()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_66F220;
  off_66B584 = (void **)&dword_66F220;
  dword_66F220 = (int)&_httpd_cgi_all_fun;
  dword_66F224 = (int)v0;
  *v0 = &dword_66F220;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66F220: using guessed type int dword_66F220;
// 66F224: using guessed type int dword_66F224;

//----- (00413258) --------------------------------------------------------
int *ctor_050()
{
  int *result; // $v0

  dword_6705E0[1] = off_66B584;
  *off_66B584 = dword_6705E0;
  dword_6705C4[1] = dword_6705E0;
  dword_6705E0[0] = dword_6705C4;
  unk_6705AC = dword_6705C4;
  dword_6705C4[0] = &dword_6705A8;
  dword_67058C[1] = &dword_6705A8;
  dword_6705A8 = (int)dword_67058C;
  dword_670570[1] = dword_67058C;
  dword_67058C[0] = dword_670570;
  dword_670554[1] = dword_670570;
  dword_670570[0] = dword_670554;
  dword_670538[1] = dword_670554;
  dword_670554[0] = dword_670538;
  dword_67051C[1] = dword_670538;
  dword_670538[0] = dword_67051C;
  dword_670500[1] = dword_67051C;
  dword_67051C[0] = dword_670500;
  dword_6704E4[1] = dword_670500;
  dword_670500[0] = dword_6704E4;
  dword_6704C8[1] = dword_6704E4;
  dword_6704E4[0] = dword_6704C8;
  dword_6704AC[1] = dword_6704C8;
  dword_6704C8[0] = dword_6704AC;
  dword_670490[1] = dword_6704AC;
  dword_6704AC[0] = dword_670490;
  dword_670474[1] = dword_670490;
  dword_670490[0] = dword_670474;
  dword_670458[1] = dword_670474;
  dword_670474[0] = dword_670458;
  dword_67043C[1] = dword_670458;
  dword_670458[0] = dword_67043C;
  dword_670420[1] = dword_67043C;
  dword_67043C[0] = dword_670420;
  dword_670404[1] = dword_670420;
  dword_670420[0] = dword_670404;
  dword_6703E8[1] = dword_670404;
  dword_670404[0] = dword_6703E8;
  dword_6703CC[1] = dword_6703E8;
  dword_6703E8[0] = dword_6703CC;
  dword_6703B0[1] = dword_6703CC;
  dword_6703CC[0] = dword_6703B0;
  dword_670394[1] = dword_6703B0;
  dword_6703B0[0] = dword_670394;
  dword_670378[1] = dword_670394;
  dword_670394[0] = dword_670378;
  dword_670378[0] = dword_67035C;
  dword_67035C[1] = dword_670378;
  dword_670340[1] = dword_67035C;
  unk_670328 = dword_670340;
  dword_67035C[0] = dword_670340;
  unk_67030C = &dword_670324;
  dword_670340[0] = &dword_670324;
  unk_6702F0 = &dword_670308;
  dword_670324 = (int)&dword_670308;
  dword_670308 = (int)&dword_6702EC;
  dword_6702EC = (int)&dword_6702D0;
  dword_6702D0 = (int)&dword_6702B4;
  dword_6702B4 = (int)&dword_670298;
  dword_670298 = (int)&dword_67027C;
  dword_67027C = (int)&dword_670260;
  dword_670260 = (int)&dword_670244;
  unk_6701A0 = &dword_6701B8;
  dword_670244 = (int)&dword_670228;
  dword_670184 = (int)&dword_67019C;
  dword_670228 = (int)&dword_67020C;
  *(_DWORD *)algn_6702D4 = &dword_6702EC;
  dword_67020C = (int)&dword_6701F0;
  unk_6702B8 = &dword_6702D0;
  dword_6701F0 = (int)&dword_6701D4;
  unk_67029C = &dword_6702B4;
  dword_6701D4 = (int)&dword_6701B8;
  unk_670280 = &dword_670298;
  dword_6701B8 = (int)&dword_67019C;
  *(_DWORD *)algn_670264 = &dword_67027C;
  dword_67019C = (int)&dword_670180;
  unk_670248 = &dword_670260;
  dword_67022C = (int)&dword_670244;
  unk_670210 = &dword_670228;
  dword_6701F4 = (int)&dword_67020C;
  unk_6701D8 = &dword_6701F0;
  dword_6701BC = (int)&dword_6701D4;
  unk_670168 = &dword_670180;
  dword_670180 = (int)&dword_670164;
  dword_670164 = (int)&dword_670148;
  dword_670148 = (int)&dword_67012C;
  dword_67012C = (int)&dword_670110;
  dword_670110 = (int)&dword_6700F4;
  dword_6700DC = (int)&dword_6700F4;
  dword_6700F4 = (int)&dword_6700D8;
  unk_6700C0 = &dword_6700D8;
  dword_6700A4 = (int)&dword_6700BC;
  unk_670088 = &dword_6700A0;
  dword_6700D8 = (int)&dword_6700BC;
  dword_6700BC = (int)&dword_6700A0;
  unk_67006C = &dword_670084;
  dword_6700A0 = (int)&dword_670084;
  dword_670084 = (int)&dword_670068;
  unk_670050 = &dword_670068;
  dword_670068 = (int)&dword_67004C;
  *(_DWORD *)algn_670034 = &dword_67004C;
  dword_67004C = (int)&dword_670030;
  unk_670018 = &dword_670030;
  dword_670030 = (int)&dword_670014;
  dword_67014C = (int)&dword_670164;
  unk_670130 = &dword_670148;
  dword_670114 = (int)&dword_67012C;
  unk_6700F8 = &dword_670110;
  *(_DWORD *)algn_66FFFC = &dword_670014;
  dword_670014 = (int)&dword_66FFF8;
  unk_66FFE0 = &dword_66FFF8;
  dword_66FFF8 = (int)&dword_66FFDC;
  *(_DWORD *)algn_66FFC4 = &dword_66FFDC;
  dword_66FFDC = (int)&dword_66FFC0;
  unk_66FFA8 = &dword_66FFC0;
  dword_66FFC0 = (int)&dword_66FFA4;
  unk_66FF8C = &dword_66FFA4;
  dword_66FFA4 = (int)&dword_66FF88;
  unk_66FF70 = &dword_66FF88;
  dword_66FF88 = (int)&dword_66FF6C;
  *(_DWORD *)algn_66FF54 = &dword_66FF6C;
  dword_66FF6C = (int)&dword_66FF50;
  unk_66FF38 = &dword_66FF50;
  dword_66FF50 = (int)&dword_66FF34;
  unk_66FF1C = &dword_66FF34;
  dword_66FF34 = (int)&dword_66FF18;
  unk_66FF00 = &dword_66FF18;
  dword_66FF18 = (int)&dword_66FEFC;
  *(_DWORD *)algn_66FEE4 = &dword_66FEFC;
  dword_66FEFC = (int)&dword_66FEE0;
  unk_66FEC8 = &dword_66FEE0;
  dword_66FEE0 = (int)&dword_66FEC4;
  unk_66FEAC = &dword_66FEC4;
  dword_66FEC4 = (int)&dword_66FEA8;
  unk_66FE90 = &dword_66FEA8;
  dword_66FEA8 = (int)&dword_66FE8C;
  *(_DWORD *)algn_66FE74 = &dword_66FE8C;
  dword_66FE8C = (int)&dword_66FE70;
  unk_66FE58 = &dword_66FE70;
  dword_66FE70 = (int)&dword_66FE54;
  unk_66FE3C = &dword_66FE54;
  dword_66FE54 = (int)&dword_66FE38;
  unk_66FE20 = &dword_66FE38;
  dword_66FE38 = (int)&dword_66FE1C;
  *(_DWORD *)algn_66FE04 = &dword_66FE1C;
  dword_66FE1C = (int)&dword_66FE00;
  unk_66FDE8 = &dword_66FE00;
  dword_66FE00 = (int)&dword_66FDE4;
  unk_66FDCC = &dword_66FDE4;
  dword_66FDE4 = (int)&dword_66FDC8;
  unk_66FDB0 = &dword_66FDC8;
  dword_66FDC8 = (int)&dword_66FDAC;
  *(_DWORD *)algn_66FD94 = &dword_66FDAC;
  dword_66FDAC = (int)&dword_66FD90;
  unk_66FD78 = &dword_66FD90;
  dword_66FD90 = (int)&dword_66FD74;
  result = &dword_66FD58;
  off_66B584 = (void **)&dword_66FD58;
  unk_66FD5C = &dword_66FD74;
  dword_66FD74 = (int)&dword_66FD58;
  dword_66FD58 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 66FD58: using guessed type int dword_66FD58;
// 66FD74: using guessed type int dword_66FD74;
// 66FD90: using guessed type int dword_66FD90;
// 66FDAC: using guessed type int dword_66FDAC;
// 66FDC8: using guessed type int dword_66FDC8;
// 66FDE4: using guessed type int dword_66FDE4;
// 66FE00: using guessed type int dword_66FE00;
// 66FE1C: using guessed type int dword_66FE1C;
// 66FE38: using guessed type int dword_66FE38;
// 66FE54: using guessed type int dword_66FE54;
// 66FE70: using guessed type int dword_66FE70;
// 66FE8C: using guessed type int dword_66FE8C;
// 66FEA8: using guessed type int dword_66FEA8;
// 66FEC4: using guessed type int dword_66FEC4;
// 66FEE0: using guessed type int dword_66FEE0;
// 66FEFC: using guessed type int dword_66FEFC;
// 66FF18: using guessed type int dword_66FF18;
// 66FF34: using guessed type int dword_66FF34;
// 66FF50: using guessed type int dword_66FF50;
// 66FF6C: using guessed type int dword_66FF6C;
// 66FF88: using guessed type int dword_66FF88;
// 66FFA4: using guessed type int dword_66FFA4;
// 66FFC0: using guessed type int dword_66FFC0;
// 66FFDC: using guessed type int dword_66FFDC;
// 66FFF8: using guessed type int dword_66FFF8;
// 670014: using guessed type int dword_670014;
// 670030: using guessed type int dword_670030;
// 67004C: using guessed type int dword_67004C;
// 670068: using guessed type int dword_670068;
// 670084: using guessed type int dword_670084;
// 6700A0: using guessed type int dword_6700A0;
// 6700A4: using guessed type int dword_6700A4;
// 6700BC: using guessed type int dword_6700BC;
// 6700D8: using guessed type int dword_6700D8;
// 6700DC: using guessed type int dword_6700DC;
// 6700F4: using guessed type int dword_6700F4;
// 670110: using guessed type int dword_670110;
// 670114: using guessed type int dword_670114;
// 67012C: using guessed type int dword_67012C;
// 670148: using guessed type int dword_670148;
// 67014C: using guessed type int dword_67014C;
// 670164: using guessed type int dword_670164;
// 670180: using guessed type int dword_670180;
// 670184: using guessed type int dword_670184;
// 67019C: using guessed type int dword_67019C;
// 6701B8: using guessed type int dword_6701B8;
// 6701BC: using guessed type int dword_6701BC;
// 6701D4: using guessed type int dword_6701D4;
// 6701F0: using guessed type int dword_6701F0;
// 6701F4: using guessed type int dword_6701F4;
// 67020C: using guessed type int dword_67020C;
// 670228: using guessed type int dword_670228;
// 67022C: using guessed type int dword_67022C;
// 670244: using guessed type int dword_670244;
// 670260: using guessed type int dword_670260;
// 67027C: using guessed type int dword_67027C;
// 670298: using guessed type int dword_670298;
// 6702B4: using guessed type int dword_6702B4;
// 6702D0: using guessed type int dword_6702D0;
// 6702EC: using guessed type int dword_6702EC;
// 670308: using guessed type int dword_670308;
// 670324: using guessed type int dword_670324;
// 6705A8: using guessed type int dword_6705A8;

//----- (00413BAC) --------------------------------------------------------
int *ctor_051()
{
  int *result; // $v0

  dword_6710CC[1] = off_66B584;
  *off_66B584 = dword_6710CC;
  dword_6710B0[1] = dword_6710CC;
  dword_6710CC[0] = dword_6710B0;
  unk_671098 = dword_6710B0;
  dword_6710B0[0] = &dword_671094;
  dword_671078[1] = &dword_671094;
  dword_671094 = (int)dword_671078;
  dword_67105C[1] = dword_671078;
  dword_671078[0] = dword_67105C;
  dword_671040[1] = dword_67105C;
  dword_67105C[0] = dword_671040;
  dword_671024[1] = dword_671040;
  dword_671040[0] = dword_671024;
  dword_671008[1] = dword_671024;
  dword_671024[0] = dword_671008;
  dword_670FEC[1] = dword_671008;
  dword_671008[0] = dword_670FEC;
  dword_670FD0[1] = dword_670FEC;
  dword_670FEC[0] = dword_670FD0;
  dword_670FB4[1] = dword_670FD0;
  dword_670FD0[0] = dword_670FB4;
  dword_670F98[1] = dword_670FB4;
  dword_670FB4[0] = dword_670F98;
  dword_670F7C[1] = dword_670F98;
  dword_670F98[0] = dword_670F7C;
  dword_670F60[1] = dword_670F7C;
  dword_670F7C[0] = dword_670F60;
  dword_670F44[1] = dword_670F60;
  dword_670F60[0] = dword_670F44;
  dword_670F28[1] = dword_670F44;
  dword_670F44[0] = dword_670F28;
  dword_670F0C[1] = dword_670F28;
  dword_670F28[0] = dword_670F0C;
  dword_670EF0[1] = dword_670F0C;
  dword_670F0C[0] = dword_670EF0;
  dword_670ED4[1] = dword_670EF0;
  dword_670EF0[0] = dword_670ED4;
  dword_670EB8[1] = dword_670ED4;
  dword_670ED4[0] = dword_670EB8;
  dword_670E9C[1] = dword_670EB8;
  dword_670EB8[0] = dword_670E9C;
  dword_670E80[1] = dword_670E9C;
  dword_670E9C[0] = dword_670E80;
  dword_670E64[1] = dword_670E80;
  dword_670E80[0] = dword_670E64;
  dword_670E64[0] = dword_670E48;
  dword_670E48[1] = dword_670E64;
  dword_670E2C[1] = dword_670E48;
  *(_DWORD *)algn_670E14 = dword_670E2C;
  dword_670E48[0] = dword_670E2C;
  unk_670DF8 = &dword_670E10;
  dword_670E2C[0] = &dword_670E10;
  unk_670DDC = &dword_670DF4;
  dword_670E10 = (int)&dword_670DF4;
  dword_670DF4 = (int)&dword_670DD8;
  dword_670DD8 = (int)&dword_670DBC;
  dword_670DBC = (int)&dword_670DA0;
  dword_670DA0 = (int)&dword_670D84;
  dword_670D84 = (int)&dword_670D68;
  dword_670D68 = (int)&dword_670D4C;
  dword_670D4C = (int)&dword_670D30;
  unk_670C8C = &dword_670CA4;
  dword_670D30 = (int)&dword_670D14;
  dword_670C70 = (int)&dword_670C88;
  dword_670D14 = (int)&dword_670CF8;
  unk_670DC0 = &dword_670DD8;
  dword_670CF8 = (int)&dword_670CDC;
  *(_DWORD *)algn_670DA4 = &dword_670DBC;
  dword_670CDC = (int)&dword_670CC0;
  unk_670D88 = &dword_670DA0;
  dword_670CC0 = (int)&dword_670CA4;
  unk_670D6C = &dword_670D84;
  dword_670CA4 = (int)&dword_670C88;
  unk_670D50 = &dword_670D68;
  dword_670C88 = (int)&dword_670C6C;
  *(_DWORD *)algn_670D34 = &dword_670D4C;
  dword_670D18 = (int)&dword_670D30;
  unk_670CFC = &dword_670D14;
  dword_670CE0 = (int)&dword_670CF8;
  *(_DWORD *)algn_670CC4 = &dword_670CDC;
  dword_670CA8 = (int)&dword_670CC0;
  *(_DWORD *)algn_670C54 = &dword_670C6C;
  dword_670C6C = (int)&dword_670C50;
  dword_670C50 = (int)&dword_670C34;
  dword_670C34 = (int)&dword_670C18;
  dword_670C18 = (int)&dword_670BFC;
  dword_670BFC = (int)&dword_670BE0;
  dword_670BC8 = (int)&dword_670BE0;
  dword_670BE0 = (int)&dword_670BC4;
  unk_670BAC = &dword_670BC4;
  dword_670B90 = (int)&dword_670BA8;
  *(_DWORD *)algn_670B74 = &dword_670B8C;
  dword_670BC4 = (int)&dword_670BA8;
  dword_670BA8 = (int)&dword_670B8C;
  unk_670B58 = &dword_670B70;
  dword_670B8C = (int)&dword_670B70;
  dword_670B70 = (int)&dword_670B54;
  unk_670B3C = &dword_670B54;
  dword_670B54 = (int)&dword_670B38;
  unk_670B20 = &dword_670B38;
  dword_670B38 = (int)&dword_670B1C;
  *(_DWORD *)algn_670B04 = &dword_670B1C;
  dword_670B1C = (int)&dword_670B00;
  dword_670C38 = (int)&dword_670C50;
  unk_670C1C = &dword_670C34;
  dword_670C00 = (int)&dword_670C18;
  *(_DWORD *)algn_670BE4 = &dword_670BFC;
  unk_670AE8 = &dword_670B00;
  dword_670B00 = (int)&dword_670AE4;
  unk_670ACC = &dword_670AE4;
  dword_670AE4 = (int)&dword_670AC8;
  unk_670AB0 = &dword_670AC8;
  dword_670AC8 = (int)&dword_670AAC;
  *(_DWORD *)algn_670A94 = &dword_670AAC;
  dword_670AAC = (int)&dword_670A90;
  unk_670A78 = &dword_670A90;
  dword_670A90 = (int)&dword_670A74;
  unk_670A5C = &dword_670A74;
  dword_670A74 = (int)&dword_670A58;
  unk_670A40 = &dword_670A58;
  dword_670A58 = (int)&dword_670A3C;
  *(_DWORD *)algn_670A24 = &dword_670A3C;
  dword_670A3C = (int)&dword_670A20;
  unk_670A08 = &dword_670A20;
  dword_670A20 = (int)&dword_670A04;
  unk_6709EC = &dword_670A04;
  dword_670A04 = (int)&dword_6709E8;
  unk_6709D0 = &dword_6709E8;
  dword_6709E8 = (int)&dword_6709CC;
  *(_DWORD *)algn_6709B4 = &dword_6709CC;
  dword_6709CC = (int)&dword_6709B0;
  unk_670998 = &dword_6709B0;
  dword_6709B0 = (int)&dword_670994;
  unk_67097C = &dword_670994;
  dword_670994 = (int)&dword_670978;
  unk_670960 = &dword_670978;
  dword_670978 = (int)&dword_67095C;
  *(_DWORD *)algn_670944 = &dword_67095C;
  dword_67095C = (int)&dword_670940;
  unk_670928 = &dword_670940;
  dword_670940 = (int)&dword_670924;
  unk_67090C = &dword_670924;
  dword_670924 = (int)&dword_670908;
  unk_6708F0 = &dword_670908;
  dword_670908 = (int)&dword_6708EC;
  *(_DWORD *)algn_6708D4 = &dword_6708EC;
  dword_6708EC = (int)&dword_6708D0;
  unk_6708B8 = &dword_6708D0;
  dword_6708D0 = (int)&dword_6708B4;
  unk_67089C = &dword_6708B4;
  dword_6708B4 = (int)&dword_670898;
  unk_670880 = &dword_670898;
  dword_670898 = (int)&dword_67087C;
  *(_DWORD *)algn_670864 = &dword_67087C;
  dword_67087C = (int)&dword_670860;
  result = &dword_670844;
  off_66B584 = (void **)&dword_670844;
  unk_670848 = &dword_670860;
  dword_670860 = (int)&dword_670844;
  dword_670844 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 670844: using guessed type int dword_670844;
// 670860: using guessed type int dword_670860;
// 67087C: using guessed type int dword_67087C;
// 670898: using guessed type int dword_670898;
// 6708B4: using guessed type int dword_6708B4;
// 6708D0: using guessed type int dword_6708D0;
// 6708EC: using guessed type int dword_6708EC;
// 670908: using guessed type int dword_670908;
// 670924: using guessed type int dword_670924;
// 670940: using guessed type int dword_670940;
// 67095C: using guessed type int dword_67095C;
// 670978: using guessed type int dword_670978;
// 670994: using guessed type int dword_670994;
// 6709B0: using guessed type int dword_6709B0;
// 6709CC: using guessed type int dword_6709CC;
// 6709E8: using guessed type int dword_6709E8;
// 670A04: using guessed type int dword_670A04;
// 670A20: using guessed type int dword_670A20;
// 670A3C: using guessed type int dword_670A3C;
// 670A58: using guessed type int dword_670A58;
// 670A74: using guessed type int dword_670A74;
// 670A90: using guessed type int dword_670A90;
// 670AAC: using guessed type int dword_670AAC;
// 670AC8: using guessed type int dword_670AC8;
// 670AE4: using guessed type int dword_670AE4;
// 670B00: using guessed type int dword_670B00;
// 670B1C: using guessed type int dword_670B1C;
// 670B38: using guessed type int dword_670B38;
// 670B54: using guessed type int dword_670B54;
// 670B70: using guessed type int dword_670B70;
// 670B8C: using guessed type int dword_670B8C;
// 670B90: using guessed type int dword_670B90;
// 670BA8: using guessed type int dword_670BA8;
// 670BC4: using guessed type int dword_670BC4;
// 670BC8: using guessed type int dword_670BC8;
// 670BE0: using guessed type int dword_670BE0;
// 670BFC: using guessed type int dword_670BFC;
// 670C00: using guessed type int dword_670C00;
// 670C18: using guessed type int dword_670C18;
// 670C34: using guessed type int dword_670C34;
// 670C38: using guessed type int dword_670C38;
// 670C50: using guessed type int dword_670C50;
// 670C6C: using guessed type int dword_670C6C;
// 670C70: using guessed type int dword_670C70;
// 670C88: using guessed type int dword_670C88;
// 670CA4: using guessed type int dword_670CA4;
// 670CA8: using guessed type int dword_670CA8;
// 670CC0: using guessed type int dword_670CC0;
// 670CDC: using guessed type int dword_670CDC;
// 670CE0: using guessed type int dword_670CE0;
// 670CF8: using guessed type int dword_670CF8;
// 670D14: using guessed type int dword_670D14;
// 670D18: using guessed type int dword_670D18;
// 670D30: using guessed type int dword_670D30;
// 670D4C: using guessed type int dword_670D4C;
// 670D68: using guessed type int dword_670D68;
// 670D84: using guessed type int dword_670D84;
// 670DA0: using guessed type int dword_670DA0;
// 670DBC: using guessed type int dword_670DBC;
// 670DD8: using guessed type int dword_670DD8;
// 670DF4: using guessed type int dword_670DF4;
// 670E10: using guessed type int dword_670E10;
// 671094: using guessed type int dword_671094;

//----- (00414500) --------------------------------------------------------
_DWORD *ctor_052()
{
  _DWORD *result; // $v0

  result = dword_67064C;
  dword_67082C = (int)off_66B584;
  *off_66B584 = &dword_670828;
  dword_670810 = (int)&dword_670828;
  dword_670828 = (int)&dword_67080C;
  dword_6707F4 = (int)&dword_67080C;
  dword_67080C = (int)&dword_6707F0;
  dword_6707D8 = (int)&dword_6707F0;
  dword_6707F0 = (int)&dword_6707D4;
  dword_6707D4 = (int)&dword_6707B8;
  dword_6707A0 = (int)&dword_6707B8;
  dword_6707BC = (int)&dword_6707D4;
  dword_6707B8 = (int)&dword_67079C;
  dword_670784 = (int)&dword_67079C;
  dword_67079C = &dword_670780;
  dword_670768 = (int)&dword_670780;
  dword_67074C = (int)&dword_670764;
  dword_670780 = &dword_670764;
  dword_670730 = (int)&dword_670748;
  dword_670764 = &dword_670748;
  dword_670748 = &dword_67072C;
  dword_670714 = (int)&dword_67072C;
  dword_6706F8 = (int)&dword_670710;
  dword_67072C = &dword_670710;
  dword_670710 = &dword_6706F4;
  dword_6706DC = (int)&dword_6706F4;
  dword_6706F4 = &dword_6706D8;
  dword_67066C = (int)&dword_670684;
  dword_670684 = (int)&dword_670668;
  dword_6706C0 = (int)&dword_6706D8;
  dword_6706D8 = (int)&dword_6706BC;
  dword_6706A4 = (int)&dword_6706BC;
  dword_6706BC = (int)&dword_6706A0;
  dword_670688 = (int)&dword_6706A0;
  dword_6706A0 = (int)&dword_670684;
  off_66B584 = (void **)dword_67064C;
  dword_67064C[0] = &_httpd_cgi_all_fun;
  dword_67064C[1] = &dword_670668;
  dword_670668 = (int)dword_67064C;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 670668: using guessed type int dword_670668;
// 67066C: using guessed type int dword_67066C;
// 670684: using guessed type int dword_670684;
// 670688: using guessed type int dword_670688;
// 6706A0: using guessed type int dword_6706A0;
// 6706A4: using guessed type int dword_6706A4;
// 6706BC: using guessed type int dword_6706BC;
// 6706C0: using guessed type int dword_6706C0;
// 6706D8: using guessed type int dword_6706D8;
// 6706DC: using guessed type int dword_6706DC;
// 6706F8: using guessed type int dword_6706F8;
// 670714: using guessed type int dword_670714;
// 670730: using guessed type int dword_670730;
// 67074C: using guessed type int dword_67074C;
// 670768: using guessed type int dword_670768;
// 670784: using guessed type int dword_670784;
// 6707A0: using guessed type int dword_6707A0;
// 6707B8: using guessed type int dword_6707B8;
// 6707BC: using guessed type int dword_6707BC;
// 6707D4: using guessed type int dword_6707D4;
// 6707D8: using guessed type int dword_6707D8;
// 6707F0: using guessed type int dword_6707F0;
// 6707F4: using guessed type int dword_6707F4;
// 67080C: using guessed type int dword_67080C;
// 670810: using guessed type int dword_670810;
// 670828: using guessed type int dword_670828;
// 67082C: using guessed type int dword_67082C;

//----- (004146EC) --------------------------------------------------------
int *ctor_053()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_670630;
  off_66B584 = (void **)&dword_670630;
  dword_670630 = (int)&_httpd_cgi_all_fun;
  dword_670634 = (int)v0;
  *v0 = &dword_670630;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 670630: using guessed type int dword_670630;
// 670634: using guessed type int dword_670634;

//----- (0041471C) --------------------------------------------------------
_DWORD *ctor_054()
{
  _DWORD *result; // $v0

  result = &dword_671B70;
  dword_671CE0 = (int)off_66B584;
  *off_66B584 = &dword_671CDC;
  dword_671CDC = (int)&dword_671CC0;
  dword_671CC0 = (int)&dword_671CA4;
  dword_671CA4 = (int)&dword_671C88;
  dword_671C88 = (int)&dword_671C6C;
  dword_671C6C = (int)&dword_671C50;
  dword_671C50 = (int)&dword_671C34;
  dword_671CC4 = (int)&dword_671CDC;
  dword_671CA8 = (int)&dword_671CC0;
  dword_671C8C = (int)&dword_671CA4;
  dword_671C70 = (int)&dword_671C88;
  dword_671C54 = (int)&dword_671C6C;
  dword_671C38 = (int)&dword_671C50;
  dword_671C1C = (int)&dword_671C34;
  dword_671C34 = (int)&dword_671C18;
  dword_671BC8 = (int)&dword_671BE0;
  dword_671BE4 = (int)&dword_671BFC;
  dword_671BFC = (int)&dword_671BE0;
  dword_671BAC = (int)&dword_671BC4;
  dword_671BE0 = &dword_671BC4;
  dword_671B90 = (int)&dword_671BA8;
  dword_671BC4 = &dword_671BA8;
  dword_671BA8 = &dword_671B8C;
  dword_671C18 = (int)&dword_671BFC;
  off_66B584 = (void **)&dword_671B70;
  dword_671B74 = (int)&dword_671B8C;
  dword_671C00 = (int)&dword_671C18;
  dword_671B70 = &_httpd_cgi_all_fun;
  dword_671B8C = (int)&dword_671B70;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 671B74: using guessed type int dword_671B74;
// 671B8C: using guessed type int dword_671B8C;
// 671B90: using guessed type int dword_671B90;
// 671BAC: using guessed type int dword_671BAC;
// 671BC8: using guessed type int dword_671BC8;
// 671BE4: using guessed type int dword_671BE4;
// 671BFC: using guessed type int dword_671BFC;
// 671C00: using guessed type int dword_671C00;
// 671C18: using guessed type int dword_671C18;
// 671C1C: using guessed type int dword_671C1C;
// 671C34: using guessed type int dword_671C34;
// 671C38: using guessed type int dword_671C38;
// 671C50: using guessed type int dword_671C50;
// 671C54: using guessed type int dword_671C54;
// 671C6C: using guessed type int dword_671C6C;
// 671C70: using guessed type int dword_671C70;
// 671C88: using guessed type int dword_671C88;
// 671C8C: using guessed type int dword_671C8C;
// 671CA4: using guessed type int dword_671CA4;
// 671CA8: using guessed type int dword_671CA8;
// 671CC0: using guessed type int dword_671CC0;
// 671CC4: using guessed type int dword_671CC4;
// 671CDC: using guessed type int dword_671CDC;
// 671CE0: using guessed type int dword_671CE0;

//----- (00414898) --------------------------------------------------------
int *ctor_055()
{
  int *result; // $v0

  dword_671B54[1] = off_66B584;
  *off_66B584 = dword_671B54;
  dword_671B38[1] = dword_671B54;
  dword_671B54[0] = dword_671B38;
  unk_671B20 = dword_671B38;
  dword_671B38[0] = &dword_671B1C;
  dword_671B00[1] = &dword_671B1C;
  dword_671B1C = (int)dword_671B00;
  dword_671AE4[1] = dword_671B00;
  dword_671B00[0] = dword_671AE4;
  dword_671AC8[1] = dword_671AE4;
  dword_671AE4[0] = dword_671AC8;
  dword_671AAC[1] = dword_671AC8;
  dword_671AC8[0] = dword_671AAC;
  dword_671A90[1] = dword_671AAC;
  dword_671AAC[0] = dword_671A90;
  dword_671A74[1] = dword_671A90;
  dword_671A90[0] = dword_671A74;
  dword_671A58[1] = dword_671A74;
  dword_671A74[0] = dword_671A58;
  dword_671A3C[1] = dword_671A58;
  dword_671A58[0] = dword_671A3C;
  dword_671A20[1] = dword_671A3C;
  dword_671A3C[0] = dword_671A20;
  dword_671A04[1] = dword_671A20;
  dword_671A20[0] = dword_671A04;
  dword_6719E8[1] = dword_671A04;
  dword_671A04[0] = dword_6719E8;
  dword_6719CC[1] = dword_6719E8;
  dword_6719E8[0] = dword_6719CC;
  dword_6719B0[1] = dword_6719CC;
  dword_6719CC[0] = dword_6719B0;
  dword_671994[1] = dword_6719B0;
  dword_6719B0[0] = dword_671994;
  dword_671978[1] = dword_671994;
  dword_671994[0] = dword_671978;
  dword_67195C[1] = dword_671978;
  dword_671978[0] = dword_67195C;
  dword_671940[1] = dword_67195C;
  dword_67195C[0] = dword_671940;
  dword_671924[1] = dword_671940;
  dword_671940[0] = dword_671924;
  dword_671908[1] = dword_671924;
  dword_671924[0] = dword_671908;
  dword_6718EC[1] = dword_671908;
  dword_671908[0] = dword_6718EC;
  dword_6718EC[0] = dword_6718D0;
  dword_6718D0[1] = dword_6718EC;
  dword_6718B4[1] = dword_6718D0;
  unk_67189C = dword_6718B4;
  dword_6718D0[0] = dword_6718B4;
  unk_671880 = &dword_671898;
  dword_6718B4[0] = &dword_671898;
  *(_DWORD *)algn_671864 = &dword_67187C;
  dword_671898 = (int)&dword_67187C;
  dword_67187C = (int)&dword_671860;
  dword_671860 = (int)&dword_671844;
  dword_671844 = (int)&dword_671828;
  dword_671828 = (int)&dword_67180C;
  dword_67180C = (int)&dword_6717F0;
  dword_6717F0 = (int)&dword_6717D4;
  dword_6717D4 = (int)&dword_6717B8;
  *(_DWORD *)algn_671714 = &dword_67172C;
  dword_6717B8 = (int)&dword_67179C;
  dword_6716F8 = (int)&dword_671710;
  dword_67179C = (int)&dword_671780;
  unk_671848 = &dword_671860;
  dword_671780 = (int)&dword_671764;
  unk_67182C = &dword_671844;
  dword_671764 = (int)&dword_671748;
  unk_671810 = &dword_671828;
  dword_671748 = (int)&dword_67172C;
  *(_DWORD *)algn_6717F4 = &dword_67180C;
  dword_67172C = (int)&dword_671710;
  unk_6717D8 = &dword_6717F0;
  dword_671710 = (int)&dword_6716F4;
  unk_6717BC = &dword_6717D4;
  dword_6717A0 = (int)&dword_6717B8;
  *(_DWORD *)algn_671784 = &dword_67179C;
  dword_671768 = (int)&dword_671780;
  unk_67174C = &dword_671764;
  dword_671730 = (int)&dword_671748;
  unk_6716DC = &dword_6716F4;
  dword_6716F4 = (int)&dword_6716D8;
  dword_6716D8 = (int)&dword_6716BC;
  dword_6716BC = (int)&dword_6716A0;
  dword_6716A0 = (int)&dword_671684;
  dword_671684 = (int)&dword_671668;
  dword_671650 = (int)&dword_671668;
  dword_671668 = (int)&dword_67164C;
  *(_DWORD *)algn_671634 = &dword_67164C;
  dword_671618 = (int)&dword_671630;
  unk_6715FC = &dword_671614;
  dword_67164C = (int)&dword_671630;
  dword_671630 = (int)&dword_671614;
  unk_6715E0 = &dword_6715F8;
  dword_671614 = (int)&dword_6715F8;
  dword_6715F8 = (int)&dword_6715DC;
  *(_DWORD *)algn_6715C4 = &dword_6715DC;
  dword_6715DC = (int)&dword_6715C0;
  unk_6715A8 = &dword_6715C0;
  dword_6715C0 = (int)&dword_6715A4;
  unk_67158C = &dword_6715A4;
  dword_6715A4 = (int)&dword_671588;
  dword_6716C0 = (int)&dword_6716D8;
  *(_DWORD *)algn_6716A4 = &dword_6716BC;
  dword_671688 = (int)&dword_6716A0;
  unk_67166C = &dword_671684;
  unk_671570 = &dword_671588;
  dword_671588 = (int)&dword_67156C;
  *(_DWORD *)algn_671554 = &dword_67156C;
  dword_67156C = (int)&dword_671550;
  unk_671538 = &dword_671550;
  dword_671550 = (int)&dword_671534;
  unk_67151C = &dword_671534;
  dword_671534 = (int)&dword_671518;
  unk_671500 = &dword_671518;
  dword_671518 = (int)&dword_6714FC;
  *(_DWORD *)algn_6714E4 = &dword_6714FC;
  dword_6714FC = (int)&dword_6714E0;
  unk_6714C8 = &dword_6714E0;
  dword_6714E0 = (int)&dword_6714C4;
  unk_6714AC = &dword_6714C4;
  dword_6714C4 = (int)&dword_6714A8;
  unk_671490 = &dword_6714A8;
  dword_6714A8 = (int)&dword_67148C;
  *(_DWORD *)algn_671474 = &dword_67148C;
  dword_67148C = (int)&dword_671470;
  unk_671458 = &dword_671470;
  dword_671470 = (int)&dword_671454;
  unk_67143C = &dword_671454;
  dword_671454 = (int)&dword_671438;
  unk_671420 = &dword_671438;
  dword_671438 = (int)&dword_67141C;
  *(_DWORD *)algn_671404 = &dword_67141C;
  dword_67141C = (int)&dword_671400;
  unk_6713E8 = &dword_671400;
  dword_671400 = (int)&dword_6713E4;
  unk_6713CC = &dword_6713E4;
  dword_6713E4 = (int)&dword_6713C8;
  unk_6713B0 = &dword_6713C8;
  dword_6713C8 = (int)&dword_6713AC;
  *(_DWORD *)algn_671394 = &dword_6713AC;
  dword_6713AC = (int)&dword_671390;
  unk_671378 = &dword_671390;
  dword_671390 = (int)&dword_671374;
  unk_67135C = &dword_671374;
  dword_671374 = (int)&dword_671358;
  unk_671340 = &dword_671358;
  dword_671358 = (int)&dword_67133C;
  *(_DWORD *)algn_671324 = &dword_67133C;
  dword_67133C = (int)&dword_671320;
  unk_671308 = &dword_671320;
  dword_671320 = (int)&dword_671304;
  unk_6712EC = &dword_671304;
  dword_671304 = (int)&dword_6712E8;
  result = &dword_6712CC;
  off_66B584 = (void **)&dword_6712CC;
  unk_6712D0 = &dword_6712E8;
  dword_6712E8 = (int)&dword_6712CC;
  dword_6712CC = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6712CC: using guessed type int dword_6712CC;
// 6712E8: using guessed type int dword_6712E8;
// 671304: using guessed type int dword_671304;
// 671320: using guessed type int dword_671320;
// 67133C: using guessed type int dword_67133C;
// 671358: using guessed type int dword_671358;
// 671374: using guessed type int dword_671374;
// 671390: using guessed type int dword_671390;
// 6713AC: using guessed type int dword_6713AC;
// 6713C8: using guessed type int dword_6713C8;
// 6713E4: using guessed type int dword_6713E4;
// 671400: using guessed type int dword_671400;
// 67141C: using guessed type int dword_67141C;
// 671438: using guessed type int dword_671438;
// 671454: using guessed type int dword_671454;
// 671470: using guessed type int dword_671470;
// 67148C: using guessed type int dword_67148C;
// 6714A8: using guessed type int dword_6714A8;
// 6714C4: using guessed type int dword_6714C4;
// 6714E0: using guessed type int dword_6714E0;
// 6714FC: using guessed type int dword_6714FC;
// 671518: using guessed type int dword_671518;
// 671534: using guessed type int dword_671534;
// 671550: using guessed type int dword_671550;
// 67156C: using guessed type int dword_67156C;
// 671588: using guessed type int dword_671588;
// 6715A4: using guessed type int dword_6715A4;
// 6715C0: using guessed type int dword_6715C0;
// 6715DC: using guessed type int dword_6715DC;
// 6715F8: using guessed type int dword_6715F8;
// 671614: using guessed type int dword_671614;
// 671618: using guessed type int dword_671618;
// 671630: using guessed type int dword_671630;
// 67164C: using guessed type int dword_67164C;
// 671650: using guessed type int dword_671650;
// 671668: using guessed type int dword_671668;
// 671684: using guessed type int dword_671684;
// 671688: using guessed type int dword_671688;
// 6716A0: using guessed type int dword_6716A0;
// 6716BC: using guessed type int dword_6716BC;
// 6716C0: using guessed type int dword_6716C0;
// 6716D8: using guessed type int dword_6716D8;
// 6716F4: using guessed type int dword_6716F4;
// 6716F8: using guessed type int dword_6716F8;
// 671710: using guessed type int dword_671710;
// 67172C: using guessed type int dword_67172C;
// 671730: using guessed type int dword_671730;
// 671748: using guessed type int dword_671748;
// 671764: using guessed type int dword_671764;
// 671768: using guessed type int dword_671768;
// 671780: using guessed type int dword_671780;
// 67179C: using guessed type int dword_67179C;
// 6717A0: using guessed type int dword_6717A0;
// 6717B8: using guessed type int dword_6717B8;
// 6717D4: using guessed type int dword_6717D4;
// 6717F0: using guessed type int dword_6717F0;
// 67180C: using guessed type int dword_67180C;
// 671828: using guessed type int dword_671828;
// 671844: using guessed type int dword_671844;
// 671860: using guessed type int dword_671860;
// 67187C: using guessed type int dword_67187C;
// 671898: using guessed type int dword_671898;
// 671B1C: using guessed type int dword_671B1C;

//----- (004151EC) --------------------------------------------------------
_DWORD *ctor_056()
{
  _DWORD *result; // $v0

  result = &dword_67110C;
  dword_6712B4 = (int)off_66B584;
  *off_66B584 = &dword_6712B0;
  dword_671298 = (int)&dword_6712B0;
  dword_6712B0 = (int)&dword_671294;
  dword_671294 = (int)&dword_671278;
  dword_671278 = (int)&dword_67125C;
  dword_67125C = (int)&dword_671240;
  dword_671240 = (int)&dword_671224;
  dword_67127C = (int)&dword_671294;
  dword_671260 = (int)&dword_671278;
  dword_671244 = (int)&dword_67125C;
  dword_671228 = (int)&dword_671240;
  dword_67120C = (int)&dword_671224;
  dword_671224 = (int)&dword_671208;
  dword_6711F0 = (int)&dword_671208;
  dword_6711D4 = (int)&dword_6711EC;
  dword_671208 = (int)&dword_6711EC;
  dword_6711B8 = (int)&dword_6711D0;
  dword_6711EC = &dword_6711D0;
  dword_67119C = (int)&dword_6711B4;
  dword_6711D0 = &dword_6711B4;
  dword_671180 = (int)&dword_671198;
  dword_6711B4 = &dword_671198;
  dword_671164 = (int)&dword_67117C;
  dword_671198 = &dword_67117C;
  dword_67117C = &dword_671160;
  dword_671148 = (int)&dword_671160;
  dword_671160 = (int)&dword_671144;
  dword_67112C = (int)&dword_671144;
  dword_671144 = (int)&dword_671128;
  off_66B584 = (void **)&dword_67110C;
  dword_67110C = &_httpd_cgi_all_fun;
  dword_671110 = (int)&dword_671128;
  dword_671128 = (int)&dword_67110C;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 671110: using guessed type int dword_671110;
// 671128: using guessed type int dword_671128;
// 67112C: using guessed type int dword_67112C;
// 671144: using guessed type int dword_671144;
// 671148: using guessed type int dword_671148;
// 671160: using guessed type int dword_671160;
// 671164: using guessed type int dword_671164;
// 671180: using guessed type int dword_671180;
// 67119C: using guessed type int dword_67119C;
// 6711B8: using guessed type int dword_6711B8;
// 6711D4: using guessed type int dword_6711D4;
// 6711F0: using guessed type int dword_6711F0;
// 671208: using guessed type int dword_671208;
// 67120C: using guessed type int dword_67120C;
// 671224: using guessed type int dword_671224;
// 671228: using guessed type int dword_671228;
// 671240: using guessed type int dword_671240;
// 671244: using guessed type int dword_671244;
// 67125C: using guessed type int dword_67125C;
// 671260: using guessed type int dword_671260;
// 671278: using guessed type int dword_671278;
// 67127C: using guessed type int dword_67127C;
// 671294: using guessed type int dword_671294;
// 671298: using guessed type int dword_671298;
// 6712B0: using guessed type int dword_6712B0;
// 6712B4: using guessed type int dword_6712B4;

//----- (004153A0) --------------------------------------------------------
int *ctor_057()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_6710F0;
  off_66B584 = (void **)&dword_6710F0;
  dword_6710F0 = (int)&_httpd_cgi_all_fun;
  dword_6710F4 = (int)v0;
  *v0 = &dword_6710F0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6710F0: using guessed type int dword_6710F0;
// 6710F4: using guessed type int dword_6710F4;

//----- (004153D0) --------------------------------------------------------
_DWORD *ctor_058()
{
  _DWORD *result; // $v0

  result = &dword_672400;
  dword_6725A8 = (int)off_66B584;
  *off_66B584 = &dword_6725A4;
  dword_67258C = (int)&dword_6725A4;
  dword_6725A4 = (int)&dword_672588;
  dword_672588 = (int)&dword_67256C;
  dword_67256C = (int)&dword_672550;
  dword_672550 = (int)&dword_672534;
  dword_672534 = (int)&dword_672518;
  dword_672570 = (int)&dword_672588;
  dword_672554 = (int)&dword_67256C;
  dword_672538 = (int)&dword_672550;
  dword_67251C = (int)&dword_672534;
  dword_672500 = (int)&dword_672518;
  dword_672518 = (int)&dword_6724FC;
  dword_6724E4 = (int)&dword_6724FC;
  dword_6724C8 = (int)&dword_6724E0;
  dword_6724FC = (int)&dword_6724E0;
  dword_6724AC = (int)&dword_6724C4;
  dword_6724E0 = &dword_6724C4;
  dword_672490 = (int)&dword_6724A8;
  dword_6724C4 = &dword_6724A8;
  dword_672474 = (int)&dword_67248C;
  dword_6724A8 = &dword_67248C;
  dword_672458 = (int)&dword_672470;
  dword_67248C = &dword_672470;
  dword_672470 = &dword_672454;
  dword_67243C = (int)&dword_672454;
  dword_672454 = (int)&dword_672438;
  dword_672420 = (int)&dword_672438;
  dword_672438 = (int)&dword_67241C;
  off_66B584 = (void **)&dword_672400;
  dword_672400 = &_httpd_cgi_all_fun;
  dword_672404 = (int)&dword_67241C;
  dword_67241C = (int)&dword_672400;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 672404: using guessed type int dword_672404;
// 67241C: using guessed type int dword_67241C;
// 672420: using guessed type int dword_672420;
// 672438: using guessed type int dword_672438;
// 67243C: using guessed type int dword_67243C;
// 672454: using guessed type int dword_672454;
// 672458: using guessed type int dword_672458;
// 672474: using guessed type int dword_672474;
// 672490: using guessed type int dword_672490;
// 6724AC: using guessed type int dword_6724AC;
// 6724C8: using guessed type int dword_6724C8;
// 6724E4: using guessed type int dword_6724E4;
// 6724FC: using guessed type int dword_6724FC;
// 672500: using guessed type int dword_672500;
// 672518: using guessed type int dword_672518;
// 67251C: using guessed type int dword_67251C;
// 672534: using guessed type int dword_672534;
// 672538: using guessed type int dword_672538;
// 672550: using guessed type int dword_672550;
// 672554: using guessed type int dword_672554;
// 67256C: using guessed type int dword_67256C;
// 672570: using guessed type int dword_672570;
// 672588: using guessed type int dword_672588;
// 67258C: using guessed type int dword_67258C;
// 6725A4: using guessed type int dword_6725A4;
// 6725A8: using guessed type int dword_6725A8;

//----- (00415584) --------------------------------------------------------
int *ctor_059()
{
  int *result; // $v0

  dword_6723E4[1] = off_66B584;
  *off_66B584 = dword_6723E4;
  dword_6723C8[1] = dword_6723E4;
  dword_6723E4[0] = dword_6723C8;
  unk_6723B0 = dword_6723C8;
  dword_6723C8[0] = &dword_6723AC;
  dword_672390[1] = &dword_6723AC;
  dword_6723AC = (int)dword_672390;
  dword_672374[1] = dword_672390;
  dword_672390[0] = dword_672374;
  dword_672358[1] = dword_672374;
  dword_672374[0] = dword_672358;
  dword_67233C[1] = dword_672358;
  dword_672358[0] = dword_67233C;
  dword_672320[1] = dword_67233C;
  dword_67233C[0] = dword_672320;
  dword_672304[1] = dword_672320;
  dword_672320[0] = dword_672304;
  off_6722E8[1] = dword_672304;
  dword_672304[0] = off_6722E8;
  off_6722CC[1] = off_6722E8;
  off_6722E8[0] = off_6722CC;
  dword_6722B0[1] = off_6722CC;
  off_6722CC[0] = dword_6722B0;
  dword_672294[1] = dword_6722B0;
  dword_6722B0[0] = dword_672294;
  dword_672278[1] = dword_672294;
  dword_672294[0] = dword_672278;
  dword_67225C[1] = dword_672278;
  dword_672278[0] = dword_67225C;
  off_672240[1] = dword_67225C;
  dword_67225C[0] = off_672240;
  off_672224[1] = off_672240;
  off_672240[0] = off_672224;
  dword_672208[1] = off_672224;
  off_672224[0] = dword_672208;
  dword_6721EC[1] = dword_672208;
  dword_672208[0] = dword_6721EC;
  dword_6721D0[1] = dword_6721EC;
  dword_6721EC[0] = dword_6721D0;
  dword_6721B4[1] = dword_6721D0;
  dword_6721D0[0] = dword_6721B4;
  dword_672198[1] = dword_6721B4;
  dword_6721B4[0] = dword_672198;
  dword_67217C[1] = dword_672198;
  dword_672198[0] = dword_67217C;
  *(_DWORD *)algn_6720F4 = &dword_67210C;
  dword_67217C[0] = dword_672160;
  dword_672160[1] = dword_67217C;
  dword_672144[1] = dword_672160;
  dword_672160[0] = dword_672144;
  unk_67212C = dword_672144;
  dword_672144[0] = &dword_672128;
  unk_672110 = &dword_672128;
  unk_6720D8 = &dword_6720F0;
  dword_672128 = (int)&dword_67210C;
  unk_6720BC = &dword_6720D4;
  dword_67210C = (int)&dword_6720F0;
  dword_6720A0 = (int)&dword_6720B8;
  dword_6720F0 = (int)&dword_6720D4;
  *(_DWORD *)algn_672084 = &dword_67209C;
  dword_6720D4 = (int)&dword_6720B8;
  dword_6720B8 = (int)&dword_67209C;
  dword_67209C = (int)&dword_672080;
  dword_672068 = (int)&dword_672080;
  dword_672080 = (int)&dword_672064;
  dword_672064 = (int)&dword_672048;
  dword_672048 = (int)&dword_67202C;
  dword_67202C = (int)&dword_672010;
  dword_672010 = (int)&dword_671FF4;
  dword_671FF4 = (int)&dword_671FD8;
  dword_671FD8 = (int)&dword_671FBC;
  dword_671FBC = (int)&dword_671FA0;
  dword_671FA0 = (int)&dword_671F84;
  dword_671F84 = (int)&dword_671F68;
  dword_671F68 = (int)&dword_671F4C;
  dword_671F4C = (int)&dword_671F30;
  dword_671F30 = (int)&dword_671F14;
  dword_671EE0 = (int)&dword_671EF8;
  dword_671F14 = (int)&dword_671EF8;
  *(_DWORD *)algn_671EC4 = &dword_671EDC;
  dword_671EF8 = (int)&dword_671EDC;
  *(_DWORD *)algn_671FA4 = &dword_671FBC;
  dword_671F88 = (int)&dword_671FA0;
  unk_671F6C = &dword_671F84;
  dword_671F50 = (int)&dword_671F68;
  *(_DWORD *)algn_671F34 = &dword_671F4C;
  dword_671F18 = (int)&dword_671F30;
  unk_671EFC = &dword_671F14;
  dword_671EDC = (int)&dword_671EC0;
  unk_67204C = &dword_672064;
  unk_672030 = &dword_672048;
  *(_DWORD *)algn_672014 = &dword_67202C;
  dword_671FF8 = (int)&dword_672010;
  unk_671FDC = &dword_671FF4;
  dword_671FC0 = (int)&dword_671FD8;
  dword_671EA8 = (int)&dword_671EC0;
  dword_671EC0 = (int)&dword_671EA4;
  unk_671E8C = &dword_671EA4;
  unk_671E70 = &dword_671E88;
  dword_671EA4 = (int)&dword_671E88;
  dword_671E88 = (int)&dword_671E6C;
  *(_DWORD *)algn_671E54 = &dword_671E6C;
  dword_671E6C = (int)&dword_671E50;
  unk_671E38 = &dword_671E50;
  dword_671E50 = (int)&dword_671E34;
  unk_671E1C = &dword_671E34;
  dword_671E34 = (int)&dword_671E18;
  unk_671E00 = &dword_671E18;
  dword_671E18 = (int)&dword_671DFC;
  unk_671DE4 = &dword_671DFC;
  dword_671DFC = (int)&dword_671DE0;
  unk_671DC8 = &dword_671DE0;
  dword_671DE0 = (int)&dword_671DC4;
  unk_671DAC = &dword_671DC4;
  dword_671DC4 = (int)&dword_671DA8;
  *(_DWORD *)algn_671D90 = &dword_671DA8;
  dword_671DA8 = (int)&dword_671D8C;
  unk_671D74 = &dword_671D8C;
  dword_671D8C = (int)&dword_671D70;
  unk_671D58 = &dword_671D70;
  dword_671D70 = (int)&dword_671D54;
  unk_671D3C = &dword_671D54;
  dword_671D54 = (int)&dword_671D38;
  result = &dword_671D1C;
  unk_671D20 = &dword_671D38;
  dword_671D38 = (int)&dword_671D1C;
  off_66B584 = (void **)&dword_671D00;
  unk_671D04 = &dword_671D1C;
  dword_671D1C = (int)&dword_671D00;
  dword_671D00 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 671D00: using guessed type int dword_671D00;
// 671D1C: using guessed type int dword_671D1C;
// 671D38: using guessed type int dword_671D38;
// 671D54: using guessed type int dword_671D54;
// 671D70: using guessed type int dword_671D70;
// 671D8C: using guessed type int dword_671D8C;
// 671DA8: using guessed type int dword_671DA8;
// 671DC4: using guessed type int dword_671DC4;
// 671DE0: using guessed type int dword_671DE0;
// 671DFC: using guessed type int dword_671DFC;
// 671E18: using guessed type int dword_671E18;
// 671E34: using guessed type int dword_671E34;
// 671E50: using guessed type int dword_671E50;
// 671E6C: using guessed type int dword_671E6C;
// 671E88: using guessed type int dword_671E88;
// 671EA4: using guessed type int dword_671EA4;
// 671EA8: using guessed type int dword_671EA8;
// 671EC0: using guessed type int dword_671EC0;
// 671EDC: using guessed type int dword_671EDC;
// 671EE0: using guessed type int dword_671EE0;
// 671EF8: using guessed type int dword_671EF8;
// 671F14: using guessed type int dword_671F14;
// 671F18: using guessed type int dword_671F18;
// 671F30: using guessed type int dword_671F30;
// 671F4C: using guessed type int dword_671F4C;
// 671F50: using guessed type int dword_671F50;
// 671F68: using guessed type int dword_671F68;
// 671F84: using guessed type int dword_671F84;
// 671F88: using guessed type int dword_671F88;
// 671FA0: using guessed type int dword_671FA0;
// 671FBC: using guessed type int dword_671FBC;
// 671FC0: using guessed type int dword_671FC0;
// 671FD8: using guessed type int dword_671FD8;
// 671FF4: using guessed type int dword_671FF4;
// 671FF8: using guessed type int dword_671FF8;
// 672010: using guessed type int dword_672010;
// 67202C: using guessed type int dword_67202C;
// 672048: using guessed type int dword_672048;
// 672064: using guessed type int dword_672064;
// 672068: using guessed type int dword_672068;
// 672080: using guessed type int dword_672080;
// 67209C: using guessed type int dword_67209C;
// 6720A0: using guessed type int dword_6720A0;
// 6720B8: using guessed type int dword_6720B8;
// 6720D4: using guessed type int dword_6720D4;
// 6720F0: using guessed type int dword_6720F0;
// 67210C: using guessed type int dword_67210C;
// 672128: using guessed type int dword_672128;
// 6723AC: using guessed type int dword_6723AC;

//----- (00415D34) --------------------------------------------------------
int *ctor_060()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_6725C0;
  off_66B584 = (void **)&dword_6725C0;
  dword_6725C0 = (int)&_httpd_cgi_all_fun;
  dword_6725C4 = (int)v0;
  *v0 = &dword_6725C0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6725C0: using guessed type int dword_6725C0;
// 6725C4: using guessed type int dword_6725C4;

//----- (00415D64) --------------------------------------------------------
int *ctor_061()
{
  int *result; // $v0

  dword_672E84[1] = off_66B584;
  *off_66B584 = dword_672E84;
  dword_672E68[1] = dword_672E84;
  dword_672E84[0] = dword_672E68;
  unk_672E50 = dword_672E68;
  dword_672E68[0] = &dword_672E4C;
  dword_672E30[1] = &dword_672E4C;
  dword_672E4C = (int)dword_672E30;
  dword_672E14[1] = dword_672E30;
  dword_672E30[0] = dword_672E14;
  dword_672DF8[1] = dword_672E14;
  dword_672E14[0] = dword_672DF8;
  dword_672DDC[1] = dword_672DF8;
  dword_672DF8[0] = dword_672DDC;
  dword_672DC0[1] = dword_672DDC;
  dword_672DDC[0] = dword_672DC0;
  dword_672DA4[1] = dword_672DC0;
  dword_672DC0[0] = dword_672DA4;
  dword_672D88[1] = dword_672DA4;
  dword_672DA4[0] = dword_672D88;
  dword_672D6C[1] = dword_672D88;
  dword_672D88[0] = dword_672D6C;
  dword_672D50[1] = dword_672D6C;
  dword_672D6C[0] = dword_672D50;
  dword_672D34[1] = dword_672D50;
  dword_672D50[0] = dword_672D34;
  dword_672D18[1] = dword_672D34;
  dword_672D34[0] = dword_672D18;
  dword_672CFC[1] = dword_672D18;
  dword_672D18[0] = dword_672CFC;
  dword_672CE0[1] = dword_672CFC;
  dword_672CFC[0] = dword_672CE0;
  dword_672CC4[1] = dword_672CE0;
  dword_672CE0[0] = dword_672CC4;
  dword_672CA8[1] = dword_672CC4;
  dword_672CC4[0] = dword_672CA8;
  dword_672C8C[1] = dword_672CA8;
  dword_672CA8[0] = dword_672C8C;
  dword_672C70[1] = dword_672C8C;
  dword_672C8C[0] = dword_672C70;
  dword_672C54[1] = dword_672C70;
  dword_672C70[0] = dword_672C54;
  dword_672C38[1] = dword_672C54;
  dword_672C54[0] = dword_672C38;
  dword_672C1C[1] = dword_672C38;
  dword_672C38[0] = dword_672C1C;
  dword_672C1C[0] = dword_672C00;
  dword_672C00[1] = dword_672C1C;
  dword_672BE4[1] = dword_672C00;
  unk_672BCC = dword_672BE4;
  dword_672C00[0] = dword_672BE4;
  unk_672BB0 = &dword_672BC8;
  dword_672BE4[0] = &dword_672BC8;
  *(_DWORD *)algn_672B94 = &dword_672BAC;
  dword_672BC8 = (int)&dword_672BAC;
  dword_672BAC = (int)&dword_672B90;
  dword_672B90 = (int)&dword_672B74;
  dword_672B74 = (int)&dword_672B58;
  dword_672B58 = (int)&dword_672B3C;
  dword_672B3C = (int)&dword_672B20;
  dword_672B20 = (int)&dword_672B04;
  dword_672B04 = (int)&dword_672AE8;
  *(_DWORD *)algn_672A44 = &dword_672A5C;
  dword_672AE8 = (int)&dword_672ACC;
  dword_672A28 = (int)&dword_672A40;
  dword_672ACC = (int)&dword_672AB0;
  unk_672B78 = &dword_672B90;
  dword_672AB0 = (int)&dword_672A94;
  unk_672B5C = &dword_672B74;
  dword_672A94 = (int)&dword_672A78;
  unk_672B40 = &dword_672B58;
  dword_672A78 = (int)&dword_672A5C;
  *(_DWORD *)algn_672B24 = &dword_672B3C;
  dword_672A5C = (int)&dword_672A40;
  unk_672B08 = &dword_672B20;
  dword_672A40 = (int)&dword_672A24;
  unk_672AEC = &dword_672B04;
  dword_672AD0 = (int)&dword_672AE8;
  *(_DWORD *)algn_672AB4 = &dword_672ACC;
  dword_672A98 = (int)&dword_672AB0;
  unk_672A7C = &dword_672A94;
  dword_672A60 = (int)&dword_672A78;
  unk_672A0C = &dword_672A24;
  dword_672A24 = (int)&dword_672A08;
  dword_672A08 = (int)&dword_6729EC;
  dword_6729EC = (int)&dword_6729D0;
  dword_6729D0 = (int)&dword_6729B4;
  dword_6729B4 = (int)&dword_672998;
  dword_672980 = (int)&dword_672998;
  dword_672998 = (int)&dword_67297C;
  *(_DWORD *)algn_672964 = &dword_67297C;
  dword_672948 = (int)&dword_672960;
  unk_67292C = &dword_672944;
  dword_67297C = (int)&dword_672960;
  dword_672960 = (int)&dword_672944;
  unk_672910 = &dword_672928;
  dword_672944 = (int)&dword_672928;
  dword_672928 = (int)&dword_67290C;
  *(_DWORD *)algn_6728F4 = &dword_67290C;
  dword_67290C = (int)&dword_6728F0;
  unk_6728D8 = &dword_6728F0;
  dword_6728F0 = (int)&dword_6728D4;
  unk_6728BC = &dword_6728D4;
  dword_6728D4 = (int)&dword_6728B8;
  dword_6729F0 = (int)&dword_672A08;
  *(_DWORD *)algn_6729D4 = &dword_6729EC;
  dword_6729B8 = (int)&dword_6729D0;
  unk_67299C = &dword_6729B4;
  unk_6728A0 = &dword_6728B8;
  dword_6728B8 = (int)&dword_67289C;
  *(_DWORD *)algn_672884 = &dword_67289C;
  dword_67289C = (int)&dword_672880;
  unk_672868 = &dword_672880;
  dword_672880 = (int)&dword_672864;
  unk_67284C = &dword_672864;
  dword_672864 = (int)&dword_672848;
  unk_672830 = &dword_672848;
  dword_672848 = (int)&dword_67282C;
  *(_DWORD *)algn_672814 = &dword_67282C;
  dword_67282C = (int)&dword_672810;
  unk_6727F8 = &dword_672810;
  dword_672810 = (int)&dword_6727F4;
  unk_6727DC = &dword_6727F4;
  dword_6727F4 = (int)&dword_6727D8;
  unk_6727C0 = &dword_6727D8;
  dword_6727D8 = (int)&dword_6727BC;
  *(_DWORD *)algn_6727A4 = &dword_6727BC;
  dword_6727BC = (int)&dword_6727A0;
  unk_672788 = &dword_6727A0;
  dword_6727A0 = (int)&dword_672784;
  unk_67276C = &dword_672784;
  dword_672784 = (int)&dword_672768;
  unk_672750 = &dword_672768;
  dword_672768 = (int)&dword_67274C;
  *(_DWORD *)algn_672734 = &dword_67274C;
  dword_67274C = (int)&dword_672730;
  unk_672718 = &dword_672730;
  dword_672730 = (int)&dword_672714;
  unk_6726FC = &dword_672714;
  dword_672714 = (int)&dword_6726F8;
  unk_6726E0 = &dword_6726F8;
  dword_6726F8 = (int)&dword_6726DC;
  *(_DWORD *)algn_6726C4 = &dword_6726DC;
  dword_6726DC = (int)&dword_6726C0;
  unk_6726A8 = &dword_6726C0;
  dword_6726C0 = (int)&dword_6726A4;
  unk_67268C = &dword_6726A4;
  dword_6726A4 = (int)&dword_672688;
  unk_672670 = &dword_672688;
  dword_672688 = (int)&dword_67266C;
  *(_DWORD *)algn_672654 = &dword_67266C;
  dword_67266C = (int)&dword_672650;
  unk_672638 = &dword_672650;
  dword_672650 = (int)&dword_672634;
  unk_67261C = &dword_672634;
  dword_672634 = (int)&dword_672618;
  result = &dword_6725FC;
  off_66B584 = (void **)&dword_6725FC;
  unk_672600 = &dword_672618;
  dword_672618 = (int)&dword_6725FC;
  dword_6725FC = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6725FC: using guessed type int dword_6725FC;
// 672618: using guessed type int dword_672618;
// 672634: using guessed type int dword_672634;
// 672650: using guessed type int dword_672650;
// 67266C: using guessed type int dword_67266C;
// 672688: using guessed type int dword_672688;
// 6726A4: using guessed type int dword_6726A4;
// 6726C0: using guessed type int dword_6726C0;
// 6726DC: using guessed type int dword_6726DC;
// 6726F8: using guessed type int dword_6726F8;
// 672714: using guessed type int dword_672714;
// 672730: using guessed type int dword_672730;
// 67274C: using guessed type int dword_67274C;
// 672768: using guessed type int dword_672768;
// 672784: using guessed type int dword_672784;
// 6727A0: using guessed type int dword_6727A0;
// 6727BC: using guessed type int dword_6727BC;
// 6727D8: using guessed type int dword_6727D8;
// 6727F4: using guessed type int dword_6727F4;
// 672810: using guessed type int dword_672810;
// 67282C: using guessed type int dword_67282C;
// 672848: using guessed type int dword_672848;
// 672864: using guessed type int dword_672864;
// 672880: using guessed type int dword_672880;
// 67289C: using guessed type int dword_67289C;
// 6728B8: using guessed type int dword_6728B8;
// 6728D4: using guessed type int dword_6728D4;
// 6728F0: using guessed type int dword_6728F0;
// 67290C: using guessed type int dword_67290C;
// 672928: using guessed type int dword_672928;
// 672944: using guessed type int dword_672944;
// 672948: using guessed type int dword_672948;
// 672960: using guessed type int dword_672960;
// 67297C: using guessed type int dword_67297C;
// 672980: using guessed type int dword_672980;
// 672998: using guessed type int dword_672998;
// 6729B4: using guessed type int dword_6729B4;
// 6729B8: using guessed type int dword_6729B8;
// 6729D0: using guessed type int dword_6729D0;
// 6729EC: using guessed type int dword_6729EC;
// 6729F0: using guessed type int dword_6729F0;
// 672A08: using guessed type int dword_672A08;
// 672A24: using guessed type int dword_672A24;
// 672A28: using guessed type int dword_672A28;
// 672A40: using guessed type int dword_672A40;
// 672A5C: using guessed type int dword_672A5C;
// 672A60: using guessed type int dword_672A60;
// 672A78: using guessed type int dword_672A78;
// 672A94: using guessed type int dword_672A94;
// 672A98: using guessed type int dword_672A98;
// 672AB0: using guessed type int dword_672AB0;
// 672ACC: using guessed type int dword_672ACC;
// 672AD0: using guessed type int dword_672AD0;
// 672AE8: using guessed type int dword_672AE8;
// 672B04: using guessed type int dword_672B04;
// 672B20: using guessed type int dword_672B20;
// 672B3C: using guessed type int dword_672B3C;
// 672B58: using guessed type int dword_672B58;
// 672B74: using guessed type int dword_672B74;
// 672B90: using guessed type int dword_672B90;
// 672BAC: using guessed type int dword_672BAC;
// 672BC8: using guessed type int dword_672BC8;
// 672E4C: using guessed type int dword_672E4C;

//----- (004166B8) --------------------------------------------------------
int *ctor_062()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_6725E0;
  off_66B584 = (void **)&dword_6725E0;
  dword_6725E0 = (int)&_httpd_cgi_all_fun;
  dword_6725E4 = (int)v0;
  *v0 = &dword_6725E0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6725E0: using guessed type int dword_6725E0;
// 6725E4: using guessed type int dword_6725E4;

//----- (004166E8) --------------------------------------------------------
int *ctor_063()
{
  int *result; // $v0

  dword_673C28[1] = off_66B584;
  *off_66B584 = dword_673C28;
  dword_673C0C[1] = dword_673C28;
  dword_673C28[0] = dword_673C0C;
  *(_DWORD *)algn_673BF4 = dword_673C0C;
  dword_673C0C[0] = &dword_673BF0;
  dword_673BD4[1] = &dword_673BF0;
  dword_673BF0 = (int)dword_673BD4;
  dword_673BB8[1] = dword_673BD4;
  dword_673BD4[0] = dword_673BB8;
  dword_673B9C[1] = dword_673BB8;
  dword_673BB8[0] = dword_673B9C;
  dword_673B80[1] = dword_673B9C;
  dword_673B9C[0] = dword_673B80;
  dword_673B64[1] = dword_673B80;
  dword_673B80[0] = dword_673B64;
  dword_673B48[1] = dword_673B64;
  dword_673B64[0] = dword_673B48;
  dword_673B2C[1] = dword_673B48;
  dword_673B48[0] = dword_673B2C;
  dword_673B10[1] = dword_673B2C;
  dword_673B2C[0] = dword_673B10;
  dword_673AF4[1] = dword_673B10;
  dword_673B10[0] = dword_673AF4;
  dword_673AD8[1] = dword_673AF4;
  dword_673AF4[0] = dword_673AD8;
  dword_673ABC[1] = dword_673AD8;
  dword_673AD8[0] = dword_673ABC;
  dword_673AA0[1] = dword_673ABC;
  dword_673ABC[0] = dword_673AA0;
  dword_673A84[1] = dword_673AA0;
  dword_673AA0[0] = dword_673A84;
  dword_673A68[1] = dword_673A84;
  dword_673A84[0] = dword_673A68;
  dword_673A4C[1] = dword_673A68;
  dword_673A68[0] = dword_673A4C;
  dword_673A30[1] = dword_673A4C;
  dword_673A4C[0] = dword_673A30;
  dword_673A14[1] = dword_673A30;
  dword_673A30[0] = dword_673A14;
  dword_6739F8[1] = dword_673A14;
  dword_673A14[0] = dword_6739F8;
  dword_6739DC[1] = dword_6739F8;
  dword_6739F8[0] = dword_6739DC;
  dword_6739C0[1] = dword_6739DC;
  dword_6739DC[0] = dword_6739C0;
  dword_6739C0[0] = dword_6739A4;
  dword_6739A4[1] = dword_6739C0;
  dword_673988[1] = dword_6739A4;
  unk_673970 = dword_673988;
  dword_6739A4[0] = dword_673988;
  *(_DWORD *)algn_673954 = &dword_67396C;
  dword_673988[0] = &dword_67396C;
  unk_673938 = &dword_673950;
  dword_67396C = (int)&dword_673950;
  dword_673950 = (int)&dword_673934;
  dword_673934 = (int)&dword_673918;
  dword_673918 = (int)&dword_6738FC;
  dword_6738FC = (int)&dword_6738E0;
  dword_6738E0 = (int)&dword_6738C4;
  dword_6738C4 = (int)&dword_6738A8;
  dword_6738A8 = (int)&dword_67388C;
  unk_6737E8 = &dword_673800;
  dword_67388C = (int)&dword_673870;
  dword_6737CC = (int)&dword_6737E4;
  dword_673870 = (int)&dword_673854;
  unk_67391C = &dword_673934;
  dword_673854 = (int)&dword_673838;
  unk_673900 = &dword_673918;
  dword_673838 = (int)&dword_67381C;
  *(_DWORD *)algn_6738E4 = &dword_6738FC;
  dword_67381C = (int)&dword_673800;
  unk_6738C8 = &dword_6738E0;
  dword_673800 = (int)&dword_6737E4;
  unk_6738AC = &dword_6738C4;
  dword_6737E4 = (int)&dword_6737C8;
  unk_673890 = &dword_6738A8;
  dword_673874 = (int)&dword_67388C;
  unk_673858 = &dword_673870;
  dword_67383C = (int)&dword_673854;
  unk_673820 = &dword_673838;
  dword_673804 = (int)&dword_67381C;
  unk_6737B0 = &dword_6737C8;
  dword_6737C8 = (int)&dword_6737AC;
  dword_6737AC = (int)&dword_673790;
  dword_673790 = (int)&dword_673774;
  dword_673774 = (int)&dword_673758;
  dword_673758 = (int)&dword_67373C;
  dword_673724 = (int)&dword_67373C;
  dword_67373C = (int)&dword_673720;
  unk_673708 = &dword_673720;
  dword_6736EC = (int)&dword_673704;
  unk_6736D0 = &dword_6736E8;
  dword_673720 = (int)&dword_673704;
  dword_673704 = (int)&dword_6736E8;
  *(_DWORD *)algn_6736B4 = &dword_6736CC;
  dword_6736E8 = (int)&dword_6736CC;
  dword_6736CC = (int)&dword_6736B0;
  unk_673698 = &dword_6736B0;
  dword_6736B0 = (int)&dword_673694;
  unk_67367C = &dword_673694;
  dword_673694 = (int)&dword_673678;
  unk_673660 = &dword_673678;
  dword_673678 = (int)&dword_67365C;
  dword_673794 = (int)&dword_6737AC;
  unk_673778 = &dword_673790;
  dword_67375C = (int)&dword_673774;
  unk_673740 = &dword_673758;
  *(_DWORD *)algn_673644 = &dword_67365C;
  dword_67365C = (int)&dword_673640;
  unk_673628 = &dword_673640;
  dword_673640 = (int)&dword_673624;
  unk_67360C = &dword_673624;
  dword_673624 = (int)&dword_673608;
  unk_6735F0 = &dword_673608;
  dword_673608 = (int)&dword_6735EC;
  *(_DWORD *)algn_6735D4 = &dword_6735EC;
  dword_6735EC = (int)&dword_6735D0;
  unk_6735B8 = &dword_6735D0;
  dword_6735D0 = (int)&dword_6735B4;
  unk_67359C = &dword_6735B4;
  dword_6735B4 = (int)&dword_673598;
  unk_673580 = &dword_673598;
  dword_673598 = (int)&dword_67357C;
  *(_DWORD *)algn_673564 = &dword_67357C;
  dword_67357C = (int)&dword_673560;
  unk_673548 = &dword_673560;
  dword_673560 = (int)&dword_673544;
  unk_67352C = &dword_673544;
  dword_673544 = (int)&dword_673528;
  unk_673510 = &dword_673528;
  dword_673528 = (int)&dword_67350C;
  *(_DWORD *)algn_6734F4 = &dword_67350C;
  dword_67350C = (int)&dword_6734F0;
  unk_6734D8 = &dword_6734F0;
  dword_6734F0 = (int)&dword_6734D4;
  unk_6734BC = &dword_6734D4;
  dword_6734D4 = (int)&dword_6734B8;
  unk_6734A0 = &dword_6734B8;
  dword_6734B8 = (int)&dword_67349C;
  *(_DWORD *)algn_673484 = &dword_67349C;
  dword_67349C = (int)&dword_673480;
  unk_673468 = &dword_673480;
  dword_673480 = (int)&dword_673464;
  unk_67344C = &dword_673464;
  dword_673464 = (int)&dword_673448;
  unk_673430 = &dword_673448;
  dword_673448 = (int)&dword_67342C;
  *(_DWORD *)algn_673414 = &dword_67342C;
  dword_67342C = (int)&dword_673410;
  unk_6733F8 = &dword_673410;
  dword_673410 = (int)&dword_6733F4;
  unk_6733DC = &dword_6733F4;
  dword_6733F4 = (int)&dword_6733D8;
  unk_6733C0 = &dword_6733D8;
  dword_6733D8 = (int)&dword_6733BC;
  result = &dword_6733A0;
  off_66B584 = (void **)&dword_6733A0;
  *(_DWORD *)algn_6733A4 = &dword_6733BC;
  dword_6733BC = (int)&dword_6733A0;
  dword_6733A0 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6733A0: using guessed type int dword_6733A0;
// 6733BC: using guessed type int dword_6733BC;
// 6733D8: using guessed type int dword_6733D8;
// 6733F4: using guessed type int dword_6733F4;
// 673410: using guessed type int dword_673410;
// 67342C: using guessed type int dword_67342C;
// 673448: using guessed type int dword_673448;
// 673464: using guessed type int dword_673464;
// 673480: using guessed type int dword_673480;
// 67349C: using guessed type int dword_67349C;
// 6734B8: using guessed type int dword_6734B8;
// 6734D4: using guessed type int dword_6734D4;
// 6734F0: using guessed type int dword_6734F0;
// 67350C: using guessed type int dword_67350C;
// 673528: using guessed type int dword_673528;
// 673544: using guessed type int dword_673544;
// 673560: using guessed type int dword_673560;
// 67357C: using guessed type int dword_67357C;
// 673598: using guessed type int dword_673598;
// 6735B4: using guessed type int dword_6735B4;
// 6735D0: using guessed type int dword_6735D0;
// 6735EC: using guessed type int dword_6735EC;
// 673608: using guessed type int dword_673608;
// 673624: using guessed type int dword_673624;
// 673640: using guessed type int dword_673640;
// 67365C: using guessed type int dword_67365C;
// 673678: using guessed type int dword_673678;
// 673694: using guessed type int dword_673694;
// 6736B0: using guessed type int dword_6736B0;
// 6736CC: using guessed type int dword_6736CC;
// 6736E8: using guessed type int dword_6736E8;
// 6736EC: using guessed type int dword_6736EC;
// 673704: using guessed type int dword_673704;
// 673720: using guessed type int dword_673720;
// 673724: using guessed type int dword_673724;
// 67373C: using guessed type int dword_67373C;
// 673758: using guessed type int dword_673758;
// 67375C: using guessed type int dword_67375C;
// 673774: using guessed type int dword_673774;
// 673790: using guessed type int dword_673790;
// 673794: using guessed type int dword_673794;
// 6737AC: using guessed type int dword_6737AC;
// 6737C8: using guessed type int dword_6737C8;
// 6737CC: using guessed type int dword_6737CC;
// 6737E4: using guessed type int dword_6737E4;
// 673800: using guessed type int dword_673800;
// 673804: using guessed type int dword_673804;
// 67381C: using guessed type int dword_67381C;
// 673838: using guessed type int dword_673838;
// 67383C: using guessed type int dword_67383C;
// 673854: using guessed type int dword_673854;
// 673870: using guessed type int dword_673870;
// 673874: using guessed type int dword_673874;
// 67388C: using guessed type int dword_67388C;
// 6738A8: using guessed type int dword_6738A8;
// 6738C4: using guessed type int dword_6738C4;
// 6738E0: using guessed type int dword_6738E0;
// 6738FC: using guessed type int dword_6738FC;
// 673918: using guessed type int dword_673918;
// 673934: using guessed type int dword_673934;
// 673950: using guessed type int dword_673950;
// 67396C: using guessed type int dword_67396C;
// 673BF0: using guessed type int dword_673BF0;

//----- (0041703C) --------------------------------------------------------
_DWORD *ctor_064()
{
  _DWORD *result; // $v0

  result = dword_67311C;
  dword_673388 = (int)off_66B584;
  *off_66B584 = &dword_673384;
  dword_67336C = (int)&dword_673384;
  dword_673384 = &dword_673368;
  dword_673350 = (int)&dword_673368;
  dword_673368 = &dword_67334C;
  dword_673334 = (int)&dword_67334C;
  dword_673318 = (int)&dword_673330;
  dword_67334C = &dword_673330;
  dword_6732FC = (int)&dword_673314;
  dword_673330 = &dword_673314;
  dword_673314 = &dword_6732F8;
  dword_6732E0 = (int)&dword_6732F8;
  dword_6732C4 = (int)&dword_6732DC;
  dword_6732F8 = &dword_6732DC;
  dword_6732A8 = (int)&dword_6732C0;
  dword_6732DC = &dword_6732C0;
  dword_6732C0 = &dword_6732A4;
  dword_67328C = (int)&dword_6732A4;
  dword_673270 = (int)&dword_673288;
  dword_6732A4 = &dword_673288;
  dword_673288 = &dword_67326C;
  dword_673254 = (int)&dword_67326C;
  dword_67326C = &dword_673250;
  dword_673238 = (int)&dword_673250;
  dword_673250 = &dword_673234;
  dword_67321C = (int)&dword_673234;
  dword_6731AC = (int)&dword_6731C4;
  dword_6731C4 = (int)&dword_6731A8;
  dword_673190 = (int)&dword_6731A8;
  dword_673158 = (int)&dword_673170;
  dword_673170 = (int)&dword_673154;
  dword_67313C = (int)&dword_673154;
  dword_673200 = (int)&dword_673218;
  dword_6731E4 = (int)&dword_6731FC;
  unk_6731C8 = &dword_6731E0;
  dword_673174 = (int)&dword_67318C;
  dword_67318C = (int)&dword_673170;
  off_66B584 = (void **)dword_67311C;
  dword_67311C[0] = &_httpd_cgi_all_fun;
  dword_67311C[1] = &dword_673138;
  dword_673138 = (int)dword_67311C;
  dword_673234 = (int)&dword_673218;
  dword_673218 = (int)&dword_6731FC;
  dword_6731FC = (int)&dword_6731E0;
  dword_6731E0 = (int)&dword_6731C4;
  dword_6731A8 = (int)&dword_67318C;
  dword_673154 = (int)&dword_673138;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 673138: using guessed type int dword_673138;
// 67313C: using guessed type int dword_67313C;
// 673154: using guessed type int dword_673154;
// 673158: using guessed type int dword_673158;
// 673170: using guessed type int dword_673170;
// 673174: using guessed type int dword_673174;
// 67318C: using guessed type int dword_67318C;
// 673190: using guessed type int dword_673190;
// 6731A8: using guessed type int dword_6731A8;
// 6731AC: using guessed type int dword_6731AC;
// 6731C4: using guessed type int dword_6731C4;
// 6731E0: using guessed type int dword_6731E0;
// 6731E4: using guessed type int dword_6731E4;
// 6731FC: using guessed type int dword_6731FC;
// 673200: using guessed type int dword_673200;
// 673218: using guessed type int dword_673218;
// 67321C: using guessed type int dword_67321C;
// 673234: using guessed type int dword_673234;
// 673238: using guessed type int dword_673238;
// 673254: using guessed type int dword_673254;
// 673270: using guessed type int dword_673270;
// 67328C: using guessed type int dword_67328C;
// 6732A8: using guessed type int dword_6732A8;
// 6732C4: using guessed type int dword_6732C4;
// 6732E0: using guessed type int dword_6732E0;
// 6732FC: using guessed type int dword_6732FC;
// 673318: using guessed type int dword_673318;
// 673334: using guessed type int dword_673334;
// 673350: using guessed type int dword_673350;
// 67336C: using guessed type int dword_67336C;
// 673388: using guessed type int dword_673388;

//----- (004172B4) --------------------------------------------------------
_DWORD *ctor_065()
{
  _DWORD *result; // $v0

  result = &dword_672F5C;
  dword_673104 = (int)off_66B584;
  *off_66B584 = &dword_673100;
  dword_6730E8 = (int)&dword_673100;
  dword_673100 = (int)&dword_6730E4;
  dword_6730E4 = (int)&dword_6730C8;
  dword_6730C8 = (int)&dword_6730AC;
  dword_6730AC = (int)&dword_673090;
  dword_673090 = (int)&dword_673074;
  dword_6730CC = (int)&dword_6730E4;
  dword_6730B0 = (int)&dword_6730C8;
  dword_673094 = (int)&dword_6730AC;
  dword_673078 = (int)&dword_673090;
  dword_67305C = (int)&dword_673074;
  dword_673074 = (int)&dword_673058;
  dword_673040 = (int)&dword_673058;
  dword_673024 = (int)&dword_67303C;
  dword_673058 = (int)&dword_67303C;
  dword_673008 = (int)&dword_673020;
  dword_67303C = &dword_673020;
  dword_672FEC = (int)&dword_673004;
  dword_673020 = &dword_673004;
  dword_672FD0 = (int)&dword_672FE8;
  dword_673004 = &dword_672FE8;
  dword_672FB4 = (int)&dword_672FCC;
  dword_672FE8 = &dword_672FCC;
  dword_672FCC = &dword_672FB0;
  dword_672F98 = (int)&dword_672FB0;
  dword_672FB0 = (int)&dword_672F94;
  dword_672F7C = (int)&dword_672F94;
  dword_672F94 = (int)&dword_672F78;
  off_66B584 = (void **)&dword_672F5C;
  dword_672F5C = &_httpd_cgi_all_fun;
  dword_672F60 = (int)&dword_672F78;
  dword_672F78 = (int)&dword_672F5C;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 672F60: using guessed type int dword_672F60;
// 672F78: using guessed type int dword_672F78;
// 672F7C: using guessed type int dword_672F7C;
// 672F94: using guessed type int dword_672F94;
// 672F98: using guessed type int dword_672F98;
// 672FB0: using guessed type int dword_672FB0;
// 672FB4: using guessed type int dword_672FB4;
// 672FD0: using guessed type int dword_672FD0;
// 672FEC: using guessed type int dword_672FEC;
// 673008: using guessed type int dword_673008;
// 673024: using guessed type int dword_673024;
// 673040: using guessed type int dword_673040;
// 673058: using guessed type int dword_673058;
// 67305C: using guessed type int dword_67305C;
// 673074: using guessed type int dword_673074;
// 673078: using guessed type int dword_673078;
// 673090: using guessed type int dword_673090;
// 673094: using guessed type int dword_673094;
// 6730AC: using guessed type int dword_6730AC;
// 6730B0: using guessed type int dword_6730B0;
// 6730C8: using guessed type int dword_6730C8;
// 6730CC: using guessed type int dword_6730CC;
// 6730E4: using guessed type int dword_6730E4;
// 6730E8: using guessed type int dword_6730E8;
// 673100: using guessed type int dword_673100;
// 673104: using guessed type int dword_673104;

//----- (00417468) --------------------------------------------------------
int *ctor_066()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_672F40;
  off_66B584 = (void **)&dword_672F40;
  dword_672F40 = (int)&_httpd_cgi_all_fun;
  dword_672F44 = (int)v0;
  *v0 = &dword_672F40;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 672F40: using guessed type int dword_672F40;
// 672F44: using guessed type int dword_672F44;

//----- (00417498) --------------------------------------------------------
_DWORD *ctor_067()
{
  _DWORD *result; // $v0

  result = &dword_674510;
  dword_6746B8 = (int)off_66B584;
  *off_66B584 = &dword_6746B4;
  dword_67469C = (int)&dword_6746B4;
  dword_6746B4 = (int)&dword_674698;
  dword_674698 = (int)&dword_67467C;
  dword_67467C = (int)&dword_674660;
  dword_674660 = (int)&dword_674644;
  dword_674644 = (int)&dword_674628;
  dword_674680 = (int)&dword_674698;
  dword_674664 = (int)&dword_67467C;
  dword_674648 = (int)&dword_674660;
  dword_67462C = (int)&dword_674644;
  dword_674610 = (int)&dword_674628;
  dword_674628 = (int)&dword_67460C;
  dword_6745F4 = (int)&dword_67460C;
  dword_6745D8 = (int)&dword_6745F0;
  dword_67460C = (int)&dword_6745F0;
  dword_6745BC = (int)&dword_6745D4;
  dword_6745F0 = &dword_6745D4;
  dword_6745A0 = (int)&dword_6745B8;
  dword_6745D4 = &dword_6745B8;
  dword_674584 = (int)&dword_67459C;
  dword_6745B8 = &dword_67459C;
  dword_674568 = (int)&dword_674580;
  dword_67459C = &dword_674580;
  dword_674580 = &dword_674564;
  dword_67454C = (int)&dword_674564;
  dword_674564 = (int)&dword_674548;
  dword_674530 = (int)&dword_674548;
  dword_674548 = (int)&dword_67452C;
  off_66B584 = (void **)&dword_674510;
  dword_674510 = &_httpd_cgi_all_fun;
  dword_674514 = (int)&dword_67452C;
  dword_67452C = (int)&dword_674510;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 674514: using guessed type int dword_674514;
// 67452C: using guessed type int dword_67452C;
// 674530: using guessed type int dword_674530;
// 674548: using guessed type int dword_674548;
// 67454C: using guessed type int dword_67454C;
// 674564: using guessed type int dword_674564;
// 674568: using guessed type int dword_674568;
// 674584: using guessed type int dword_674584;
// 6745A0: using guessed type int dword_6745A0;
// 6745BC: using guessed type int dword_6745BC;
// 6745D8: using guessed type int dword_6745D8;
// 6745F4: using guessed type int dword_6745F4;
// 67460C: using guessed type int dword_67460C;
// 674610: using guessed type int dword_674610;
// 674628: using guessed type int dword_674628;
// 67462C: using guessed type int dword_67462C;
// 674644: using guessed type int dword_674644;
// 674648: using guessed type int dword_674648;
// 674660: using guessed type int dword_674660;
// 674664: using guessed type int dword_674664;
// 67467C: using guessed type int dword_67467C;
// 674680: using guessed type int dword_674680;
// 674698: using guessed type int dword_674698;
// 67469C: using guessed type int dword_67469C;
// 6746B4: using guessed type int dword_6746B4;
// 6746B8: using guessed type int dword_6746B8;

//----- (0041764C) --------------------------------------------------------
int *ctor_068()
{
  int *result; // $v0

  dword_6744F4[1] = off_66B584;
  *off_66B584 = dword_6744F4;
  dword_6744D8[1] = dword_6744F4;
  dword_6744F4[0] = dword_6744D8;
  unk_6744C0 = dword_6744D8;
  dword_6744D8[0] = &dword_6744BC;
  dword_6744A0[1] = &dword_6744BC;
  dword_6744BC = (int)dword_6744A0;
  dword_674484[1] = dword_6744A0;
  dword_6744A0[0] = dword_674484;
  dword_674468[1] = dword_674484;
  dword_674484[0] = dword_674468;
  dword_67444C[1] = dword_674468;
  dword_674468[0] = dword_67444C;
  dword_674430[1] = dword_67444C;
  dword_67444C[0] = dword_674430;
  dword_674414[1] = dword_674430;
  dword_674430[0] = dword_674414;
  dword_6743F8[1] = dword_674414;
  dword_674414[0] = dword_6743F8;
  dword_6743DC[1] = dword_6743F8;
  dword_6743F8[0] = dword_6743DC;
  dword_6743C0[1] = dword_6743DC;
  dword_6743DC[0] = dword_6743C0;
  dword_6743A4[1] = dword_6743C0;
  dword_6743C0[0] = dword_6743A4;
  dword_674388[1] = dword_6743A4;
  dword_6743A4[0] = dword_674388;
  dword_67436C[1] = dword_674388;
  dword_674388[0] = dword_67436C;
  dword_674350[1] = dword_67436C;
  dword_67436C[0] = dword_674350;
  dword_674334[1] = dword_674350;
  dword_674350[0] = dword_674334;
  dword_674318[1] = dword_674334;
  dword_674334[0] = dword_674318;
  dword_6742FC[1] = dword_674318;
  dword_674318[0] = dword_6742FC;
  dword_6742E0[1] = dword_6742FC;
  dword_6742FC[0] = dword_6742E0;
  dword_6742C4[1] = dword_6742E0;
  dword_6742E0[0] = dword_6742C4;
  dword_6742A8[1] = dword_6742C4;
  dword_6742C4[0] = dword_6742A8;
  dword_67428C[1] = dword_6742A8;
  dword_6742A8[0] = dword_67428C;
  dword_67428C[0] = dword_674270;
  dword_674270[1] = dword_67428C;
  dword_674254[1] = dword_674270;
  unk_67423C = dword_674254;
  dword_674270[0] = dword_674254;
  unk_674220 = &dword_674238;
  dword_674254[0] = &dword_674238;
  *(_DWORD *)algn_674204 = &dword_67421C;
  dword_674238 = (int)&dword_67421C;
  dword_67421C = (int)&dword_674200;
  dword_674200 = (int)&dword_6741E4;
  dword_6741E4 = (int)&dword_6741C8;
  dword_6741C8 = (int)&dword_6741AC;
  dword_6741AC = (int)&dword_674190;
  dword_674190 = (int)&dword_674174;
  dword_674174 = (int)&dword_674158;
  *(_DWORD *)algn_6740B4 = &dword_6740CC;
  dword_674158 = (int)&dword_67413C;
  dword_674098 = (int)&dword_6740B0;
  dword_67413C = (int)&dword_674120;
  unk_6741E8 = &dword_674200;
  dword_674120 = (int)&dword_674104;
  unk_6741CC = &dword_6741E4;
  dword_674104 = (int)&dword_6740E8;
  unk_6741B0 = &dword_6741C8;
  dword_6740E8 = (int)&dword_6740CC;
  *(_DWORD *)algn_674194 = &dword_6741AC;
  dword_6740CC = (int)&dword_6740B0;
  unk_674178 = &dword_674190;
  dword_6740B0 = (int)&dword_674094;
  unk_67415C = &dword_674174;
  dword_674140 = (int)&dword_674158;
  *(_DWORD *)algn_674124 = &dword_67413C;
  dword_674108 = (int)&dword_674120;
  unk_6740EC = &dword_674104;
  dword_6740D0 = (int)&dword_6740E8;
  unk_67407C = &dword_674094;
  dword_674094 = (int)&dword_674078;
  dword_674078 = (int)&dword_67405C;
  dword_67405C = (int)&dword_674040;
  dword_674040 = (int)&dword_674024;
  dword_674024 = (int)&dword_674008;
  dword_673FF0 = (int)&dword_674008;
  dword_674008 = (int)&dword_673FEC;
  *(_DWORD *)algn_673FD4 = &dword_673FEC;
  dword_673FB8 = (int)&dword_673FD0;
  unk_673F9C = &dword_673FB4;
  dword_673FEC = (int)&dword_673FD0;
  dword_673FD0 = (int)&dword_673FB4;
  unk_673F80 = &dword_673F98;
  dword_673FB4 = (int)&dword_673F98;
  dword_673F98 = (int)&dword_673F7C;
  *(_DWORD *)algn_673F64 = &dword_673F7C;
  dword_673F7C = (int)&dword_673F60;
  unk_673F48 = &dword_673F60;
  dword_673F60 = (int)&dword_673F44;
  unk_673F2C = &dword_673F44;
  dword_673F44 = (int)&dword_673F28;
  dword_674060 = (int)&dword_674078;
  *(_DWORD *)algn_674044 = &dword_67405C;
  dword_674028 = (int)&dword_674040;
  unk_67400C = &dword_674024;
  unk_673F10 = &dword_673F28;
  dword_673F28 = (int)&dword_673F0C;
  *(_DWORD *)algn_673EF4 = &dword_673F0C;
  dword_673F0C = (int)&dword_673EF0;
  unk_673ED8 = &dword_673EF0;
  dword_673EF0 = (int)&dword_673ED4;
  unk_673EBC = &dword_673ED4;
  dword_673ED4 = (int)&dword_673EB8;
  unk_673EA0 = &dword_673EB8;
  dword_673EB8 = (int)&dword_673E9C;
  *(_DWORD *)algn_673E84 = &dword_673E9C;
  dword_673E9C = (int)&dword_673E80;
  unk_673E68 = &dword_673E80;
  dword_673E80 = (int)&dword_673E64;
  unk_673E4C = &dword_673E64;
  dword_673E64 = (int)&dword_673E48;
  unk_673E30 = &dword_673E48;
  dword_673E48 = (int)&dword_673E2C;
  *(_DWORD *)algn_673E14 = &dword_673E2C;
  dword_673E2C = (int)&dword_673E10;
  unk_673DF8 = &dword_673E10;
  dword_673E10 = (int)&dword_673DF4;
  unk_673DDC = &dword_673DF4;
  dword_673DF4 = (int)&dword_673DD8;
  unk_673DC0 = &dword_673DD8;
  dword_673DD8 = (int)&dword_673DBC;
  *(_DWORD *)algn_673DA4 = &dword_673DBC;
  dword_673DBC = (int)&dword_673DA0;
  unk_673D88 = &dword_673DA0;
  dword_673DA0 = (int)&dword_673D84;
  unk_673D6C = &dword_673D84;
  dword_673D84 = (int)&dword_673D68;
  unk_673D50 = &dword_673D68;
  dword_673D68 = (int)&dword_673D4C;
  *(_DWORD *)algn_673D34 = &dword_673D4C;
  dword_673D4C = (int)&dword_673D30;
  unk_673D18 = &dword_673D30;
  dword_673D30 = (int)&dword_673D14;
  unk_673CFC = &dword_673D14;
  dword_673D14 = (int)&dword_673CF8;
  unk_673CE0 = &dword_673CF8;
  dword_673CF8 = (int)&dword_673CDC;
  *(_DWORD *)algn_673CC4 = &dword_673CDC;
  dword_673CDC = (int)&dword_673CC0;
  unk_673CA8 = &dword_673CC0;
  dword_673CC0 = (int)&dword_673CA4;
  unk_673C8C = &dword_673CA4;
  dword_673CA4 = (int)&dword_673C88;
  result = &dword_673C6C;
  off_66B584 = (void **)&dword_673C6C;
  unk_673C70 = &dword_673C88;
  dword_673C88 = (int)&dword_673C6C;
  dword_673C6C = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 673C6C: using guessed type int dword_673C6C;
// 673C88: using guessed type int dword_673C88;
// 673CA4: using guessed type int dword_673CA4;
// 673CC0: using guessed type int dword_673CC0;
// 673CDC: using guessed type int dword_673CDC;
// 673CF8: using guessed type int dword_673CF8;
// 673D14: using guessed type int dword_673D14;
// 673D30: using guessed type int dword_673D30;
// 673D4C: using guessed type int dword_673D4C;
// 673D68: using guessed type int dword_673D68;
// 673D84: using guessed type int dword_673D84;
// 673DA0: using guessed type int dword_673DA0;
// 673DBC: using guessed type int dword_673DBC;
// 673DD8: using guessed type int dword_673DD8;
// 673DF4: using guessed type int dword_673DF4;
// 673E10: using guessed type int dword_673E10;
// 673E2C: using guessed type int dword_673E2C;
// 673E48: using guessed type int dword_673E48;
// 673E64: using guessed type int dword_673E64;
// 673E80: using guessed type int dword_673E80;
// 673E9C: using guessed type int dword_673E9C;
// 673EB8: using guessed type int dword_673EB8;
// 673ED4: using guessed type int dword_673ED4;
// 673EF0: using guessed type int dword_673EF0;
// 673F0C: using guessed type int dword_673F0C;
// 673F28: using guessed type int dword_673F28;
// 673F44: using guessed type int dword_673F44;
// 673F60: using guessed type int dword_673F60;
// 673F7C: using guessed type int dword_673F7C;
// 673F98: using guessed type int dword_673F98;
// 673FB4: using guessed type int dword_673FB4;
// 673FB8: using guessed type int dword_673FB8;
// 673FD0: using guessed type int dword_673FD0;
// 673FEC: using guessed type int dword_673FEC;
// 673FF0: using guessed type int dword_673FF0;
// 674008: using guessed type int dword_674008;
// 674024: using guessed type int dword_674024;
// 674028: using guessed type int dword_674028;
// 674040: using guessed type int dword_674040;
// 67405C: using guessed type int dword_67405C;
// 674060: using guessed type int dword_674060;
// 674078: using guessed type int dword_674078;
// 674094: using guessed type int dword_674094;
// 674098: using guessed type int dword_674098;
// 6740B0: using guessed type int dword_6740B0;
// 6740CC: using guessed type int dword_6740CC;
// 6740D0: using guessed type int dword_6740D0;
// 6740E8: using guessed type int dword_6740E8;
// 674104: using guessed type int dword_674104;
// 674108: using guessed type int dword_674108;
// 674120: using guessed type int dword_674120;
// 67413C: using guessed type int dword_67413C;
// 674140: using guessed type int dword_674140;
// 674158: using guessed type int dword_674158;
// 674174: using guessed type int dword_674174;
// 674190: using guessed type int dword_674190;
// 6741AC: using guessed type int dword_6741AC;
// 6741C8: using guessed type int dword_6741C8;
// 6741E4: using guessed type int dword_6741E4;
// 674200: using guessed type int dword_674200;
// 67421C: using guessed type int dword_67421C;
// 674238: using guessed type int dword_674238;
// 6744BC: using guessed type int dword_6744BC;

//----- (00417FA0) --------------------------------------------------------
int *ctor_069()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_673C50;
  off_66B584 = (void **)&dword_673C50;
  dword_673C50 = (int)&_httpd_cgi_all_fun;
  dword_673C54 = (int)v0;
  *v0 = &dword_673C50;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 673C50: using guessed type int dword_673C50;
// 673C54: using guessed type int dword_673C54;

//----- (00417FD0) --------------------------------------------------------
_DWORD *ctor_070()
{
  _DWORD *result; // $v0

  result = &dword_674F90;
  dword_675138 = (int)off_66B584;
  *off_66B584 = &dword_675134;
  dword_67511C = (int)&dword_675134;
  dword_675134 = (int)&dword_675118;
  dword_675118 = (int)&dword_6750FC;
  dword_6750FC = (int)&dword_6750E0;
  dword_6750E0 = (int)&dword_6750C4;
  dword_6750C4 = (int)&dword_6750A8;
  dword_675100 = (int)&dword_675118;
  dword_6750E4 = (int)&dword_6750FC;
  dword_6750C8 = (int)&dword_6750E0;
  dword_6750AC = (int)&dword_6750C4;
  dword_675090 = (int)&dword_6750A8;
  dword_6750A8 = (int)&dword_67508C;
  dword_675074 = (int)&dword_67508C;
  dword_675058 = (int)&dword_675070;
  dword_67508C = (int)&dword_675070;
  dword_67503C = (int)&dword_675054;
  dword_675070 = &dword_675054;
  dword_675020 = (int)&dword_675038;
  dword_675054 = &dword_675038;
  dword_675004 = (int)&dword_67501C;
  dword_675038 = &dword_67501C;
  dword_674FE8 = (int)&dword_675000;
  dword_67501C = &dword_675000;
  dword_675000 = &dword_674FE4;
  dword_674FCC = (int)&dword_674FE4;
  dword_674FE4 = (int)&dword_674FC8;
  dword_674FB0 = (int)&dword_674FC8;
  dword_674FC8 = (int)&dword_674FAC;
  off_66B584 = (void **)&dword_674F90;
  dword_674F90 = &_httpd_cgi_all_fun;
  dword_674F94 = (int)&dword_674FAC;
  dword_674FAC = (int)&dword_674F90;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 674F94: using guessed type int dword_674F94;
// 674FAC: using guessed type int dword_674FAC;
// 674FB0: using guessed type int dword_674FB0;
// 674FC8: using guessed type int dword_674FC8;
// 674FCC: using guessed type int dword_674FCC;
// 674FE4: using guessed type int dword_674FE4;
// 674FE8: using guessed type int dword_674FE8;
// 675004: using guessed type int dword_675004;
// 675020: using guessed type int dword_675020;
// 67503C: using guessed type int dword_67503C;
// 675058: using guessed type int dword_675058;
// 675074: using guessed type int dword_675074;
// 67508C: using guessed type int dword_67508C;
// 675090: using guessed type int dword_675090;
// 6750A8: using guessed type int dword_6750A8;
// 6750AC: using guessed type int dword_6750AC;
// 6750C4: using guessed type int dword_6750C4;
// 6750C8: using guessed type int dword_6750C8;
// 6750E0: using guessed type int dword_6750E0;
// 6750E4: using guessed type int dword_6750E4;
// 6750FC: using guessed type int dword_6750FC;
// 675100: using guessed type int dword_675100;
// 675118: using guessed type int dword_675118;
// 67511C: using guessed type int dword_67511C;
// 675134: using guessed type int dword_675134;
// 675138: using guessed type int dword_675138;

//----- (00418184) --------------------------------------------------------
int *ctor_071()
{
  int *result; // $v0

  dword_674F74[1] = off_66B584;
  *off_66B584 = dword_674F74;
  dword_674F58[1] = dword_674F74;
  dword_674F74[0] = dword_674F58;
  unk_674F40 = dword_674F58;
  dword_674F58[0] = &dword_674F3C;
  dword_674F20[1] = &dword_674F3C;
  dword_674F3C = (int)dword_674F20;
  dword_674F04[1] = dword_674F20;
  dword_674F20[0] = dword_674F04;
  dword_674EE8[1] = dword_674F04;
  dword_674F04[0] = dword_674EE8;
  dword_674ECC[1] = dword_674EE8;
  dword_674EE8[0] = dword_674ECC;
  dword_674EB0[1] = dword_674ECC;
  dword_674ECC[0] = dword_674EB0;
  dword_674E94[1] = dword_674EB0;
  dword_674EB0[0] = dword_674E94;
  dword_674E78[1] = dword_674E94;
  dword_674E94[0] = dword_674E78;
  dword_674E5C[1] = dword_674E78;
  dword_674E78[0] = dword_674E5C;
  dword_674E40[1] = dword_674E5C;
  dword_674E5C[0] = dword_674E40;
  dword_674E24[1] = dword_674E40;
  dword_674E40[0] = dword_674E24;
  dword_674E08[1] = dword_674E24;
  dword_674E24[0] = dword_674E08;
  dword_674DEC[1] = dword_674E08;
  dword_674E08[0] = dword_674DEC;
  dword_674DD0[1] = dword_674DEC;
  dword_674DEC[0] = dword_674DD0;
  dword_674DB4[1] = dword_674DD0;
  dword_674DD0[0] = dword_674DB4;
  dword_674D98[1] = dword_674DB4;
  dword_674DB4[0] = dword_674D98;
  dword_674D7C[1] = dword_674D98;
  dword_674D98[0] = dword_674D7C;
  dword_674D60[1] = dword_674D7C;
  dword_674D7C[0] = dword_674D60;
  dword_674D44[1] = dword_674D60;
  dword_674D60[0] = dword_674D44;
  dword_674D28[1] = dword_674D44;
  dword_674D44[0] = dword_674D28;
  dword_674D0C[1] = dword_674D28;
  dword_674D28[0] = dword_674D0C;
  dword_674D0C[0] = dword_674CF0;
  dword_674CF0[1] = dword_674D0C;
  dword_674CD4[1] = dword_674CF0;
  unk_674CBC = dword_674CD4;
  dword_674CF0[0] = dword_674CD4;
  unk_674CA0 = &dword_674CB8;
  dword_674CD4[0] = &dword_674CB8;
  *(_DWORD *)algn_674C84 = &dword_674C9C;
  dword_674CB8 = (int)&dword_674C9C;
  dword_674C9C = (int)&dword_674C80;
  dword_674C80 = (int)&dword_674C64;
  dword_674C64 = (int)&dword_674C48;
  dword_674C48 = (int)&dword_674C2C;
  dword_674C2C = (int)&dword_674C10;
  dword_674C10 = (int)&dword_674BF4;
  dword_674BF4 = (int)&dword_674BD8;
  *(_DWORD *)algn_674B34 = &dword_674B4C;
  dword_674BD8 = (int)&dword_674BBC;
  dword_674B18 = (int)&dword_674B30;
  dword_674BBC = (int)&dword_674BA0;
  unk_674C68 = &dword_674C80;
  dword_674BA0 = (int)&dword_674B84;
  unk_674C4C = &dword_674C64;
  dword_674B84 = (int)&dword_674B68;
  unk_674C30 = &dword_674C48;
  dword_674B68 = (int)&dword_674B4C;
  *(_DWORD *)algn_674C14 = &dword_674C2C;
  dword_674B4C = (int)&dword_674B30;
  unk_674BF8 = &dword_674C10;
  dword_674B30 = (int)&dword_674B14;
  unk_674BDC = &dword_674BF4;
  dword_674BC0 = (int)&dword_674BD8;
  *(_DWORD *)algn_674BA4 = &dword_674BBC;
  dword_674B88 = (int)&dword_674BA0;
  unk_674B6C = &dword_674B84;
  dword_674B50 = (int)&dword_674B68;
  unk_674AFC = &dword_674B14;
  dword_674B14 = (int)&dword_674AF8;
  dword_674AF8 = (int)&dword_674ADC;
  dword_674ADC = (int)&dword_674AC0;
  dword_674AC0 = (int)&dword_674AA4;
  dword_674AA4 = (int)&dword_674A88;
  dword_674A70 = (int)&dword_674A88;
  dword_674A88 = (int)&dword_674A6C;
  *(_DWORD *)algn_674A54 = &dword_674A6C;
  dword_674A38 = (int)&dword_674A50;
  unk_674A1C = &dword_674A34;
  dword_674A6C = (int)&dword_674A50;
  dword_674A50 = (int)&dword_674A34;
  unk_674A00 = &dword_674A18;
  dword_674A34 = (int)&dword_674A18;
  dword_674A18 = (int)&dword_6749FC;
  *(_DWORD *)algn_6749E4 = &dword_6749FC;
  dword_6749FC = (int)&dword_6749E0;
  unk_6749C8 = &dword_6749E0;
  dword_6749E0 = (int)&dword_6749C4;
  unk_6749AC = &dword_6749C4;
  dword_6749C4 = (int)&dword_6749A8;
  dword_674AE0 = (int)&dword_674AF8;
  *(_DWORD *)algn_674AC4 = &dword_674ADC;
  dword_674AA8 = (int)&dword_674AC0;
  unk_674A8C = &dword_674AA4;
  unk_674990 = &dword_6749A8;
  dword_6749A8 = (int)&dword_67498C;
  *(_DWORD *)algn_674974 = &dword_67498C;
  dword_67498C = (int)&dword_674970;
  unk_674958 = &dword_674970;
  dword_674970 = (int)&dword_674954;
  unk_67493C = &dword_674954;
  dword_674954 = (int)&dword_674938;
  unk_674920 = &dword_674938;
  dword_674938 = (int)&dword_67491C;
  *(_DWORD *)algn_674904 = &dword_67491C;
  dword_67491C = (int)&dword_674900;
  unk_6748E8 = &dword_674900;
  dword_674900 = (int)&dword_6748E4;
  unk_6748CC = &dword_6748E4;
  dword_6748E4 = (int)&dword_6748C8;
  unk_6748B0 = &dword_6748C8;
  dword_6748C8 = (int)&dword_6748AC;
  *(_DWORD *)algn_674894 = &dword_6748AC;
  dword_6748AC = (int)&dword_674890;
  unk_674878 = &dword_674890;
  dword_674890 = (int)&dword_674874;
  unk_67485C = &dword_674874;
  dword_674874 = (int)&dword_674858;
  unk_674840 = &dword_674858;
  dword_674858 = (int)&dword_67483C;
  *(_DWORD *)algn_674824 = &dword_67483C;
  dword_67483C = (int)&dword_674820;
  unk_674808 = &dword_674820;
  dword_674820 = (int)&dword_674804;
  unk_6747EC = &dword_674804;
  dword_674804 = (int)&dword_6747E8;
  unk_6747D0 = &dword_6747E8;
  dword_6747E8 = (int)&dword_6747CC;
  *(_DWORD *)algn_6747B4 = &dword_6747CC;
  dword_6747CC = (int)&dword_6747B0;
  unk_674798 = &dword_6747B0;
  dword_6747B0 = (int)&dword_674794;
  unk_67477C = &dword_674794;
  dword_674794 = (int)&dword_674778;
  unk_674760 = &dword_674778;
  dword_674778 = (int)&dword_67475C;
  *(_DWORD *)algn_674744 = &dword_67475C;
  dword_67475C = (int)&dword_674740;
  unk_674728 = &dword_674740;
  dword_674740 = (int)&dword_674724;
  unk_67470C = &dword_674724;
  dword_674724 = (int)&dword_674708;
  result = &dword_6746EC;
  off_66B584 = (void **)&dword_6746EC;
  unk_6746F0 = &dword_674708;
  dword_674708 = (int)&dword_6746EC;
  dword_6746EC = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6746EC: using guessed type int dword_6746EC;
// 674708: using guessed type int dword_674708;
// 674724: using guessed type int dword_674724;
// 674740: using guessed type int dword_674740;
// 67475C: using guessed type int dword_67475C;
// 674778: using guessed type int dword_674778;
// 674794: using guessed type int dword_674794;
// 6747B0: using guessed type int dword_6747B0;
// 6747CC: using guessed type int dword_6747CC;
// 6747E8: using guessed type int dword_6747E8;
// 674804: using guessed type int dword_674804;
// 674820: using guessed type int dword_674820;
// 67483C: using guessed type int dword_67483C;
// 674858: using guessed type int dword_674858;
// 674874: using guessed type int dword_674874;
// 674890: using guessed type int dword_674890;
// 6748AC: using guessed type int dword_6748AC;
// 6748C8: using guessed type int dword_6748C8;
// 6748E4: using guessed type int dword_6748E4;
// 674900: using guessed type int dword_674900;
// 67491C: using guessed type int dword_67491C;
// 674938: using guessed type int dword_674938;
// 674954: using guessed type int dword_674954;
// 674970: using guessed type int dword_674970;
// 67498C: using guessed type int dword_67498C;
// 6749A8: using guessed type int dword_6749A8;
// 6749C4: using guessed type int dword_6749C4;
// 6749E0: using guessed type int dword_6749E0;
// 6749FC: using guessed type int dword_6749FC;
// 674A18: using guessed type int dword_674A18;
// 674A34: using guessed type int dword_674A34;
// 674A38: using guessed type int dword_674A38;
// 674A50: using guessed type int dword_674A50;
// 674A6C: using guessed type int dword_674A6C;
// 674A70: using guessed type int dword_674A70;
// 674A88: using guessed type int dword_674A88;
// 674AA4: using guessed type int dword_674AA4;
// 674AA8: using guessed type int dword_674AA8;
// 674AC0: using guessed type int dword_674AC0;
// 674ADC: using guessed type int dword_674ADC;
// 674AE0: using guessed type int dword_674AE0;
// 674AF8: using guessed type int dword_674AF8;
// 674B14: using guessed type int dword_674B14;
// 674B18: using guessed type int dword_674B18;
// 674B30: using guessed type int dword_674B30;
// 674B4C: using guessed type int dword_674B4C;
// 674B50: using guessed type int dword_674B50;
// 674B68: using guessed type int dword_674B68;
// 674B84: using guessed type int dword_674B84;
// 674B88: using guessed type int dword_674B88;
// 674BA0: using guessed type int dword_674BA0;
// 674BBC: using guessed type int dword_674BBC;
// 674BC0: using guessed type int dword_674BC0;
// 674BD8: using guessed type int dword_674BD8;
// 674BF4: using guessed type int dword_674BF4;
// 674C10: using guessed type int dword_674C10;
// 674C2C: using guessed type int dword_674C2C;
// 674C48: using guessed type int dword_674C48;
// 674C64: using guessed type int dword_674C64;
// 674C80: using guessed type int dword_674C80;
// 674C9C: using guessed type int dword_674C9C;
// 674CB8: using guessed type int dword_674CB8;
// 674F3C: using guessed type int dword_674F3C;

//----- (00418AD8) --------------------------------------------------------
int *ctor_072()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_6746D0;
  off_66B584 = (void **)&dword_6746D0;
  dword_6746D0 = (int)&_httpd_cgi_all_fun;
  dword_6746D4 = (int)v0;
  *v0 = &dword_6746D0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6746D0: using guessed type int dword_6746D0;
// 6746D4: using guessed type int dword_6746D4;

//----- (00418B08) --------------------------------------------------------
int *ctor_073()
{
  int *result; // $v0

  dword_6759D8[1] = off_66B584;
  *off_66B584 = dword_6759D8;
  dword_6759BC[1] = dword_6759D8;
  dword_6759D8[0] = dword_6759BC;
  *(_DWORD *)algn_6759A4 = dword_6759BC;
  dword_6759BC[0] = &dword_6759A0;
  dword_675984[1] = &dword_6759A0;
  dword_6759A0 = (int)dword_675984;
  dword_675968[1] = dword_675984;
  dword_675984[0] = dword_675968;
  dword_67594C[1] = dword_675968;
  dword_675968[0] = dword_67594C;
  dword_675930[1] = dword_67594C;
  dword_67594C[0] = dword_675930;
  dword_675914[1] = dword_675930;
  dword_675930[0] = dword_675914;
  dword_6758F8[1] = dword_675914;
  dword_675914[0] = dword_6758F8;
  dword_6758DC[1] = dword_6758F8;
  dword_6758F8[0] = dword_6758DC;
  dword_6758C0[1] = dword_6758DC;
  dword_6758DC[0] = dword_6758C0;
  dword_6758A4[1] = dword_6758C0;
  dword_6758C0[0] = dword_6758A4;
  dword_675888[1] = dword_6758A4;
  dword_6758A4[0] = dword_675888;
  dword_67586C[1] = dword_675888;
  dword_675888[0] = dword_67586C;
  dword_675850[1] = dword_67586C;
  dword_67586C[0] = dword_675850;
  dword_675834[1] = dword_675850;
  dword_675850[0] = dword_675834;
  dword_675818[1] = dword_675834;
  dword_675834[0] = dword_675818;
  dword_6757FC[1] = dword_675818;
  dword_675818[0] = dword_6757FC;
  dword_6757E0[1] = dword_6757FC;
  dword_6757FC[0] = dword_6757E0;
  dword_6757C4[1] = dword_6757E0;
  dword_6757E0[0] = dword_6757C4;
  dword_6757A8[1] = dword_6757C4;
  dword_6757C4[0] = dword_6757A8;
  dword_67578C[1] = dword_6757A8;
  dword_6757A8[0] = dword_67578C;
  dword_675770[1] = dword_67578C;
  dword_67578C[0] = dword_675770;
  dword_675770[0] = dword_675754;
  dword_675754[1] = dword_675770;
  dword_675738[1] = dword_675754;
  unk_675720 = dword_675738;
  dword_675754[0] = dword_675738;
  *(_DWORD *)algn_675704 = &dword_67571C;
  dword_675738[0] = &dword_67571C;
  unk_6756E8 = &dword_675700;
  dword_67571C = (int)&dword_675700;
  dword_675700 = (int)&dword_6756E4;
  dword_6756E4 = (int)&dword_6756C8;
  dword_6756C8 = (int)&dword_6756AC;
  dword_6756AC = (int)&dword_675690;
  dword_675690 = (int)&dword_675674;
  dword_675674 = (int)&dword_675658;
  dword_675658 = (int)&dword_67563C;
  unk_675598 = &dword_6755B0;
  dword_67563C = (int)&dword_675620;
  dword_67557C = (int)&dword_675594;
  dword_675620 = (int)&dword_675604;
  unk_6756CC = &dword_6756E4;
  dword_675604 = (int)&dword_6755E8;
  unk_6756B0 = &dword_6756C8;
  dword_6755E8 = (int)&dword_6755CC;
  *(_DWORD *)algn_675694 = &dword_6756AC;
  dword_6755CC = (int)&dword_6755B0;
  unk_675678 = &dword_675690;
  dword_6755B0 = (int)&dword_675594;
  unk_67565C = &dword_675674;
  dword_675594 = (int)&dword_675578;
  unk_675640 = &dword_675658;
  dword_675624 = (int)&dword_67563C;
  unk_675608 = &dword_675620;
  dword_6755EC = (int)&dword_675604;
  unk_6755D0 = &dword_6755E8;
  dword_6755B4 = (int)&dword_6755CC;
  unk_675560 = &dword_675578;
  dword_675578 = (int)&dword_67555C;
  dword_67555C = (int)&dword_675540;
  dword_675540 = (int)&dword_675524;
  dword_675524 = (int)&dword_675508;
  dword_675508 = (int)&dword_6754EC;
  dword_6754D4 = (int)&dword_6754EC;
  dword_6754EC = (int)&dword_6754D0;
  unk_6754B8 = &dword_6754D0;
  dword_67549C = (int)&dword_6754B4;
  unk_675480 = &dword_675498;
  dword_6754D0 = (int)&dword_6754B4;
  dword_6754B4 = (int)&dword_675498;
  *(_DWORD *)algn_675464 = &dword_67547C;
  dword_675498 = (int)&dword_67547C;
  dword_67547C = (int)&dword_675460;
  unk_675448 = &dword_675460;
  dword_675460 = (int)&dword_675444;
  unk_67542C = &dword_675444;
  dword_675444 = (int)&dword_675428;
  unk_675410 = &dword_675428;
  dword_675428 = (int)&dword_67540C;
  dword_675544 = (int)&dword_67555C;
  unk_675528 = &dword_675540;
  dword_67550C = (int)&dword_675524;
  unk_6754F0 = &dword_675508;
  *(_DWORD *)algn_6753F4 = &dword_67540C;
  dword_67540C = (int)&dword_6753F0;
  unk_6753D8 = &dword_6753F0;
  dword_6753F0 = (int)&dword_6753D4;
  unk_6753BC = &dword_6753D4;
  dword_6753D4 = (int)&dword_6753B8;
  unk_6753A0 = &dword_6753B8;
  dword_6753B8 = (int)&dword_67539C;
  *(_DWORD *)algn_675384 = &dword_67539C;
  dword_67539C = (int)&dword_675380;
  unk_675368 = &dword_675380;
  dword_675380 = (int)&dword_675364;
  unk_67534C = &dword_675364;
  dword_675364 = (int)&dword_675348;
  unk_675330 = &dword_675348;
  dword_675348 = (int)&dword_67532C;
  *(_DWORD *)algn_675314 = &dword_67532C;
  dword_67532C = (int)&dword_675310;
  unk_6752F8 = &dword_675310;
  dword_675310 = (int)&dword_6752F4;
  unk_6752DC = &dword_6752F4;
  dword_6752F4 = (int)&dword_6752D8;
  unk_6752C0 = &dword_6752D8;
  dword_6752D8 = (int)&dword_6752BC;
  *(_DWORD *)algn_6752A4 = &dword_6752BC;
  dword_6752BC = (int)&dword_6752A0;
  unk_675288 = &dword_6752A0;
  dword_6752A0 = (int)&dword_675284;
  unk_67526C = &dword_675284;
  dword_675284 = (int)&dword_675268;
  unk_675250 = &dword_675268;
  dword_675268 = (int)&dword_67524C;
  *(_DWORD *)algn_675234 = &dword_67524C;
  dword_67524C = (int)&dword_675230;
  unk_675218 = &dword_675230;
  dword_675230 = (int)&dword_675214;
  unk_6751FC = &dword_675214;
  dword_675214 = (int)&dword_6751F8;
  unk_6751E0 = &dword_6751F8;
  dword_6751F8 = (int)&dword_6751DC;
  *(_DWORD *)algn_6751C4 = &dword_6751DC;
  dword_6751DC = (int)&dword_6751C0;
  unk_6751A8 = &dword_6751C0;
  dword_6751C0 = (int)&dword_6751A4;
  unk_67518C = &dword_6751A4;
  dword_6751A4 = (int)&dword_675188;
  unk_675170 = &dword_675188;
  dword_675188 = (int)&dword_67516C;
  result = &dword_675150;
  off_66B584 = (void **)&dword_675150;
  *(_DWORD *)algn_675154 = &dword_67516C;
  dword_67516C = (int)&dword_675150;
  dword_675150 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 675150: using guessed type int dword_675150;
// 67516C: using guessed type int dword_67516C;
// 675188: using guessed type int dword_675188;
// 6751A4: using guessed type int dword_6751A4;
// 6751C0: using guessed type int dword_6751C0;
// 6751DC: using guessed type int dword_6751DC;
// 6751F8: using guessed type int dword_6751F8;
// 675214: using guessed type int dword_675214;
// 675230: using guessed type int dword_675230;
// 67524C: using guessed type int dword_67524C;
// 675268: using guessed type int dword_675268;
// 675284: using guessed type int dword_675284;
// 6752A0: using guessed type int dword_6752A0;
// 6752BC: using guessed type int dword_6752BC;
// 6752D8: using guessed type int dword_6752D8;
// 6752F4: using guessed type int dword_6752F4;
// 675310: using guessed type int dword_675310;
// 67532C: using guessed type int dword_67532C;
// 675348: using guessed type int dword_675348;
// 675364: using guessed type int dword_675364;
// 675380: using guessed type int dword_675380;
// 67539C: using guessed type int dword_67539C;
// 6753B8: using guessed type int dword_6753B8;
// 6753D4: using guessed type int dword_6753D4;
// 6753F0: using guessed type int dword_6753F0;
// 67540C: using guessed type int dword_67540C;
// 675428: using guessed type int dword_675428;
// 675444: using guessed type int dword_675444;
// 675460: using guessed type int dword_675460;
// 67547C: using guessed type int dword_67547C;
// 675498: using guessed type int dword_675498;
// 67549C: using guessed type int dword_67549C;
// 6754B4: using guessed type int dword_6754B4;
// 6754D0: using guessed type int dword_6754D0;
// 6754D4: using guessed type int dword_6754D4;
// 6754EC: using guessed type int dword_6754EC;
// 675508: using guessed type int dword_675508;
// 67550C: using guessed type int dword_67550C;
// 675524: using guessed type int dword_675524;
// 675540: using guessed type int dword_675540;
// 675544: using guessed type int dword_675544;
// 67555C: using guessed type int dword_67555C;
// 675578: using guessed type int dword_675578;
// 67557C: using guessed type int dword_67557C;
// 675594: using guessed type int dword_675594;
// 6755B0: using guessed type int dword_6755B0;
// 6755B4: using guessed type int dword_6755B4;
// 6755CC: using guessed type int dword_6755CC;
// 6755E8: using guessed type int dword_6755E8;
// 6755EC: using guessed type int dword_6755EC;
// 675604: using guessed type int dword_675604;
// 675620: using guessed type int dword_675620;
// 675624: using guessed type int dword_675624;
// 67563C: using guessed type int dword_67563C;
// 675658: using guessed type int dword_675658;
// 675674: using guessed type int dword_675674;
// 675690: using guessed type int dword_675690;
// 6756AC: using guessed type int dword_6756AC;
// 6756C8: using guessed type int dword_6756C8;
// 6756E4: using guessed type int dword_6756E4;
// 675700: using guessed type int dword_675700;
// 67571C: using guessed type int dword_67571C;
// 6759A0: using guessed type int dword_6759A0;

//----- (0041945C) --------------------------------------------------------
int *ctor_074()
{
  int *result; // $v0

  result = &dword_675A00;
  dword_675A3C = (int)off_66B584;
  *off_66B584 = &dword_675A38;
  dword_675A20 = (int)&dword_675A38;
  dword_675A38 = (int)&dword_675A1C;
  off_66B584 = (void **)&dword_675A00;
  dword_675A00 = (int)&_httpd_cgi_all_fun;
  dword_675A04 = (int)&dword_675A1C;
  dword_675A1C = (int)&dword_675A00;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 675A00: using guessed type int dword_675A00;
// 675A04: using guessed type int dword_675A04;
// 675A1C: using guessed type int dword_675A1C;
// 675A20: using guessed type int dword_675A20;
// 675A38: using guessed type int dword_675A38;
// 675A3C: using guessed type int dword_675A3C;

//----- (004194AC) --------------------------------------------------------
_DWORD *ctor_075()
{
  _DWORD *result; // $v0

  result = &dword_676320;
  dword_6764C8 = (int)off_66B584;
  *off_66B584 = &dword_6764C4;
  dword_6764AC = (int)&dword_6764C4;
  dword_6764C4 = (int)&dword_6764A8;
  dword_6764A8 = (int)&dword_67648C;
  dword_67648C = (int)&dword_676470;
  dword_676470 = (int)&dword_676454;
  dword_676454 = (int)&dword_676438;
  dword_676490 = (int)&dword_6764A8;
  dword_676474 = (int)&dword_67648C;
  dword_676458 = (int)&dword_676470;
  dword_67643C = (int)&dword_676454;
  dword_676420 = (int)&dword_676438;
  dword_676438 = (int)&dword_67641C;
  dword_676404 = (int)&dword_67641C;
  dword_6763E8 = (int)&dword_676400;
  dword_67641C = (int)&dword_676400;
  dword_6763CC = (int)&dword_6763E4;
  dword_676400 = &dword_6763E4;
  dword_6763B0 = (int)&dword_6763C8;
  dword_6763E4 = &dword_6763C8;
  dword_676394 = (int)&dword_6763AC;
  dword_6763C8 = &dword_6763AC;
  dword_676378 = (int)&dword_676390;
  dword_6763AC = &dword_676390;
  dword_676390 = &dword_676374;
  dword_67635C = (int)&dword_676374;
  dword_676374 = (int)&dword_676358;
  dword_676340 = (int)&dword_676358;
  dword_676358 = (int)&dword_67633C;
  off_66B584 = (void **)&dword_676320;
  dword_676320 = &_httpd_cgi_all_fun;
  dword_676324 = (int)&dword_67633C;
  dword_67633C = (int)&dword_676320;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 676324: using guessed type int dword_676324;
// 67633C: using guessed type int dword_67633C;
// 676340: using guessed type int dword_676340;
// 676358: using guessed type int dword_676358;
// 67635C: using guessed type int dword_67635C;
// 676374: using guessed type int dword_676374;
// 676378: using guessed type int dword_676378;
// 676394: using guessed type int dword_676394;
// 6763B0: using guessed type int dword_6763B0;
// 6763CC: using guessed type int dword_6763CC;
// 6763E8: using guessed type int dword_6763E8;
// 676404: using guessed type int dword_676404;
// 67641C: using guessed type int dword_67641C;
// 676420: using guessed type int dword_676420;
// 676438: using guessed type int dword_676438;
// 67643C: using guessed type int dword_67643C;
// 676454: using guessed type int dword_676454;
// 676458: using guessed type int dword_676458;
// 676470: using guessed type int dword_676470;
// 676474: using guessed type int dword_676474;
// 67648C: using guessed type int dword_67648C;
// 676490: using guessed type int dword_676490;
// 6764A8: using guessed type int dword_6764A8;
// 6764AC: using guessed type int dword_6764AC;
// 6764C4: using guessed type int dword_6764C4;
// 6764C8: using guessed type int dword_6764C8;

//----- (00419660) --------------------------------------------------------
int *ctor_076()
{
  int *result; // $v0

  dword_676304[1] = off_66B584;
  *off_66B584 = dword_676304;
  dword_6762E8[1] = dword_676304;
  dword_676304[0] = dword_6762E8;
  unk_6762D0 = dword_6762E8;
  dword_6762E8[0] = &dword_6762CC;
  dword_6762B0[1] = &dword_6762CC;
  dword_6762CC = (int)dword_6762B0;
  dword_676294[1] = dword_6762B0;
  dword_6762B0[0] = dword_676294;
  dword_676278[1] = dword_676294;
  dword_676294[0] = dword_676278;
  dword_67625C[1] = dword_676278;
  dword_676278[0] = dword_67625C;
  dword_676240[1] = dword_67625C;
  dword_67625C[0] = dword_676240;
  dword_676224[1] = dword_676240;
  dword_676240[0] = dword_676224;
  dword_676208[1] = dword_676224;
  dword_676224[0] = dword_676208;
  dword_6761EC[1] = dword_676208;
  dword_676208[0] = dword_6761EC;
  dword_6761D0[1] = dword_6761EC;
  dword_6761EC[0] = dword_6761D0;
  dword_6761B4[1] = dword_6761D0;
  dword_6761D0[0] = dword_6761B4;
  dword_676198[1] = dword_6761B4;
  dword_6761B4[0] = dword_676198;
  dword_67617C[1] = dword_676198;
  dword_676198[0] = dword_67617C;
  dword_676160[1] = dword_67617C;
  dword_67617C[0] = dword_676160;
  dword_676144[1] = dword_676160;
  dword_676160[0] = dword_676144;
  dword_676128[1] = dword_676144;
  dword_676144[0] = dword_676128;
  dword_67610C[1] = dword_676128;
  dword_676128[0] = dword_67610C;
  dword_6760F0[1] = dword_67610C;
  dword_67610C[0] = dword_6760F0;
  dword_6760D4[1] = dword_6760F0;
  dword_6760F0[0] = dword_6760D4;
  dword_6760B8[1] = dword_6760D4;
  dword_6760D4[0] = dword_6760B8;
  dword_67609C[1] = dword_6760B8;
  dword_6760B8[0] = dword_67609C;
  dword_67609C[0] = dword_676080;
  dword_676080[1] = dword_67609C;
  dword_676064[1] = dword_676080;
  unk_67604C = dword_676064;
  dword_676080[0] = dword_676064;
  unk_676030 = &dword_676048;
  dword_676064[0] = &dword_676048;
  *(_DWORD *)algn_676014 = &dword_67602C;
  dword_676048 = (int)&dword_67602C;
  dword_67602C = (int)&dword_676010;
  dword_676010 = (int)&dword_675FF4;
  dword_675FF4 = (int)&dword_675FD8;
  dword_675FD8 = (int)&dword_675FBC;
  dword_675FBC = (int)&dword_675FA0;
  dword_675FA0 = (int)&dword_675F84;
  dword_675F84 = (int)&dword_675F68;
  *(_DWORD *)algn_675EC4 = &dword_675EDC;
  dword_675F68 = (int)&dword_675F4C;
  dword_675EA8 = (int)&dword_675EC0;
  dword_675F4C = (int)&dword_675F30;
  unk_675FF8 = &dword_676010;
  dword_675F30 = (int)&dword_675F14;
  unk_675FDC = &dword_675FF4;
  dword_675F14 = (int)&dword_675EF8;
  unk_675FC0 = &dword_675FD8;
  dword_675EF8 = (int)&dword_675EDC;
  *(_DWORD *)algn_675FA4 = &dword_675FBC;
  dword_675EDC = (int)&dword_675EC0;
  unk_675F88 = &dword_675FA0;
  dword_675EC0 = (int)&dword_675EA4;
  unk_675F6C = &dword_675F84;
  dword_675F50 = (int)&dword_675F68;
  *(_DWORD *)algn_675F34 = &dword_675F4C;
  dword_675F18 = (int)&dword_675F30;
  unk_675EFC = &dword_675F14;
  dword_675EE0 = (int)&dword_675EF8;
  unk_675E8C = &dword_675EA4;
  dword_675EA4 = (int)&dword_675E88;
  dword_675E88 = (int)&dword_675E6C;
  dword_675E6C = (int)&dword_675E50;
  dword_675E50 = (int)&dword_675E34;
  dword_675E34 = (int)&dword_675E18;
  dword_675E00 = (int)&dword_675E18;
  dword_675E18 = (int)&dword_675DFC;
  *(_DWORD *)algn_675DE4 = &dword_675DFC;
  dword_675DC8 = (int)&dword_675DE0;
  unk_675DAC = &dword_675DC4;
  dword_675DFC = (int)&dword_675DE0;
  dword_675DE0 = (int)&dword_675DC4;
  unk_675D90 = &dword_675DA8;
  dword_675DC4 = (int)&dword_675DA8;
  dword_675DA8 = (int)&dword_675D8C;
  *(_DWORD *)algn_675D74 = &dword_675D8C;
  dword_675D8C = (int)&dword_675D70;
  unk_675D58 = &dword_675D70;
  dword_675D70 = (int)&dword_675D54;
  unk_675D3C = &dword_675D54;
  dword_675D54 = (int)&dword_675D38;
  dword_675E70 = (int)&dword_675E88;
  *(_DWORD *)algn_675E54 = &dword_675E6C;
  dword_675E38 = (int)&dword_675E50;
  unk_675E1C = &dword_675E34;
  unk_675D20 = &dword_675D38;
  dword_675D38 = (int)&dword_675D1C;
  *(_DWORD *)algn_675D04 = &dword_675D1C;
  dword_675D1C = (int)&dword_675D00;
  unk_675CE8 = &dword_675D00;
  dword_675D00 = (int)&dword_675CE4;
  unk_675CCC = &dword_675CE4;
  dword_675CE4 = (int)&dword_675CC8;
  unk_675CB0 = &dword_675CC8;
  dword_675CC8 = (int)&dword_675CAC;
  *(_DWORD *)algn_675C94 = &dword_675CAC;
  dword_675CAC = (int)&dword_675C90;
  unk_675C78 = &dword_675C90;
  dword_675C90 = (int)&dword_675C74;
  unk_675C5C = &dword_675C74;
  dword_675C74 = (int)&dword_675C58;
  unk_675C40 = &dword_675C58;
  dword_675C58 = (int)&dword_675C3C;
  *(_DWORD *)algn_675C24 = &dword_675C3C;
  dword_675C3C = (int)&dword_675C20;
  unk_675C08 = &dword_675C20;
  dword_675C20 = (int)&dword_675C04;
  unk_675BEC = &dword_675C04;
  dword_675C04 = (int)&dword_675BE8;
  unk_675BD0 = &dword_675BE8;
  dword_675BE8 = (int)&dword_675BCC;
  *(_DWORD *)algn_675BB4 = &dword_675BCC;
  dword_675BCC = (int)&dword_675BB0;
  unk_675B98 = &dword_675BB0;
  dword_675BB0 = (int)&dword_675B94;
  unk_675B7C = &dword_675B94;
  dword_675B94 = (int)&dword_675B78;
  unk_675B60 = &dword_675B78;
  dword_675B78 = (int)&dword_675B5C;
  *(_DWORD *)algn_675B44 = &dword_675B5C;
  dword_675B5C = (int)&dword_675B40;
  unk_675B28 = &dword_675B40;
  dword_675B40 = (int)&dword_675B24;
  unk_675B0C = &dword_675B24;
  dword_675B24 = (int)&dword_675B08;
  unk_675AF0 = &dword_675B08;
  dword_675B08 = (int)&dword_675AEC;
  *(_DWORD *)algn_675AD4 = &dword_675AEC;
  dword_675AEC = (int)&dword_675AD0;
  unk_675AB8 = &dword_675AD0;
  dword_675AD0 = (int)&dword_675AB4;
  unk_675A9C = &dword_675AB4;
  dword_675AB4 = (int)&dword_675A98;
  result = &dword_675A7C;
  off_66B584 = (void **)&dword_675A7C;
  unk_675A80 = &dword_675A98;
  dword_675A98 = (int)&dword_675A7C;
  dword_675A7C = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 675A7C: using guessed type int dword_675A7C;
// 675A98: using guessed type int dword_675A98;
// 675AB4: using guessed type int dword_675AB4;
// 675AD0: using guessed type int dword_675AD0;
// 675AEC: using guessed type int dword_675AEC;
// 675B08: using guessed type int dword_675B08;
// 675B24: using guessed type int dword_675B24;
// 675B40: using guessed type int dword_675B40;
// 675B5C: using guessed type int dword_675B5C;
// 675B78: using guessed type int dword_675B78;
// 675B94: using guessed type int dword_675B94;
// 675BB0: using guessed type int dword_675BB0;
// 675BCC: using guessed type int dword_675BCC;
// 675BE8: using guessed type int dword_675BE8;
// 675C04: using guessed type int dword_675C04;
// 675C20: using guessed type int dword_675C20;
// 675C3C: using guessed type int dword_675C3C;
// 675C58: using guessed type int dword_675C58;
// 675C74: using guessed type int dword_675C74;
// 675C90: using guessed type int dword_675C90;
// 675CAC: using guessed type int dword_675CAC;
// 675CC8: using guessed type int dword_675CC8;
// 675CE4: using guessed type int dword_675CE4;
// 675D00: using guessed type int dword_675D00;
// 675D1C: using guessed type int dword_675D1C;
// 675D38: using guessed type int dword_675D38;
// 675D54: using guessed type int dword_675D54;
// 675D70: using guessed type int dword_675D70;
// 675D8C: using guessed type int dword_675D8C;
// 675DA8: using guessed type int dword_675DA8;
// 675DC4: using guessed type int dword_675DC4;
// 675DC8: using guessed type int dword_675DC8;
// 675DE0: using guessed type int dword_675DE0;
// 675DFC: using guessed type int dword_675DFC;
// 675E00: using guessed type int dword_675E00;
// 675E18: using guessed type int dword_675E18;
// 675E34: using guessed type int dword_675E34;
// 675E38: using guessed type int dword_675E38;
// 675E50: using guessed type int dword_675E50;
// 675E6C: using guessed type int dword_675E6C;
// 675E70: using guessed type int dword_675E70;
// 675E88: using guessed type int dword_675E88;
// 675EA4: using guessed type int dword_675EA4;
// 675EA8: using guessed type int dword_675EA8;
// 675EC0: using guessed type int dword_675EC0;
// 675EDC: using guessed type int dword_675EDC;
// 675EE0: using guessed type int dword_675EE0;
// 675EF8: using guessed type int dword_675EF8;
// 675F14: using guessed type int dword_675F14;
// 675F18: using guessed type int dword_675F18;
// 675F30: using guessed type int dword_675F30;
// 675F4C: using guessed type int dword_675F4C;
// 675F50: using guessed type int dword_675F50;
// 675F68: using guessed type int dword_675F68;
// 675F84: using guessed type int dword_675F84;
// 675FA0: using guessed type int dword_675FA0;
// 675FBC: using guessed type int dword_675FBC;
// 675FD8: using guessed type int dword_675FD8;
// 675FF4: using guessed type int dword_675FF4;
// 676010: using guessed type int dword_676010;
// 67602C: using guessed type int dword_67602C;
// 676048: using guessed type int dword_676048;
// 6762CC: using guessed type int dword_6762CC;

//----- (00419FB4) --------------------------------------------------------
int *ctor_077()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_675A60;
  off_66B584 = (void **)&dword_675A60;
  dword_675A60 = (int)&_httpd_cgi_all_fun;
  dword_675A64 = (int)v0;
  *v0 = &dword_675A60;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 675A60: using guessed type int dword_675A60;
// 675A64: using guessed type int dword_675A64;

//----- (00419FE4) --------------------------------------------------------
int *ctor_078()
{
  int *result; // $v0

  dword_676D84[1] = off_66B584;
  *off_66B584 = dword_676D84;
  unk_676D6C = dword_676D84;
  dword_676D84[0] = &unk_676D68;
  unk_676D50 = &unk_676D68;
  unk_676D68 = &dword_676D4C;
  dword_676D30[1] = &dword_676D4C;
  dword_676D4C = (int)dword_676D30;
  dword_676D14[1] = dword_676D30;
  dword_676D30[0] = dword_676D14;
  dword_676CF8[1] = dword_676D14;
  dword_676D14[0] = dword_676CF8;
  dword_676CDC[1] = dword_676CF8;
  dword_676CF8[0] = dword_676CDC;
  dword_676CC0[1] = dword_676CDC;
  dword_676CDC[0] = dword_676CC0;
  dword_676CA4[1] = dword_676CC0;
  dword_676CC0[0] = dword_676CA4;
  dword_676C88[1] = dword_676CA4;
  dword_676CA4[0] = dword_676C88;
  unk_676C70 = dword_676C88;
  dword_676C88[0] = &dword_676C6C;
  dword_676C50[1] = &dword_676C6C;
  dword_676C6C = dword_676C50;
  dword_676C34[1] = dword_676C50;
  dword_676C50[0] = dword_676C34;
  dword_676C18[1] = dword_676C34;
  dword_676C34[0] = dword_676C18;
  dword_676BFC[1] = dword_676C18;
  dword_676C18[0] = dword_676BFC;
  dword_676BE0[1] = dword_676BFC;
  dword_676BFC[0] = dword_676BE0;
  dword_676BC4[1] = dword_676BE0;
  dword_676BE0[0] = dword_676BC4;
  dword_676BA8[1] = dword_676BC4;
  dword_676BC4[0] = dword_676BA8;
  dword_676B8C[1] = dword_676BA8;
  dword_676BA8[0] = dword_676B8C;
  dword_676B70[1] = dword_676B8C;
  dword_676B8C[0] = dword_676B70;
  dword_676B54[1] = dword_676B70;
  dword_676B70[0] = dword_676B54;
  dword_676B38[1] = dword_676B54;
  dword_676B54[0] = dword_676B38;
  dword_676B1C[1] = dword_676B38;
  dword_676B38[0] = dword_676B1C;
  dword_676B1C[0] = dword_676B00;
  dword_676B00[1] = dword_676B1C;
  dword_676AE4[1] = dword_676B00;
  unk_676ACC = dword_676AE4;
  dword_676B00[0] = dword_676AE4;
  unk_676AB0 = &dword_676AC8;
  dword_676AE4[0] = &dword_676AC8;
  *(_DWORD *)algn_676A94 = &dword_676AAC;
  dword_676AC8 = (int)&dword_676AAC;
  dword_676AAC = (int)&dword_676A90;
  dword_676A90 = (int)&dword_676A74;
  dword_676A74 = (int)&dword_676A58;
  dword_676A58 = (int)&dword_676A3C;
  dword_676A3C = (int)&dword_676A20;
  dword_676A20 = (int)&dword_676A04;
  dword_676A04 = (int)&dword_6769E8;
  *(_DWORD *)algn_676944 = &dword_67695C;
  dword_6769E8 = (int)&dword_6769CC;
  dword_676928 = (int)&dword_676940;
  dword_6769CC = (int)&dword_6769B0;
  unk_676A78 = &dword_676A90;
  dword_6769B0 = (int)&dword_676994;
  unk_676A5C = &dword_676A74;
  dword_676994 = (int)&dword_676978;
  unk_676A40 = &dword_676A58;
  dword_676978 = (int)&dword_67695C;
  *(_DWORD *)algn_676A24 = &dword_676A3C;
  dword_67695C = (int)&dword_676940;
  unk_676A08 = &dword_676A20;
  dword_676940 = (int)&dword_676924;
  unk_6769EC = &dword_676A04;
  dword_6769D0 = (int)&dword_6769E8;
  *(_DWORD *)algn_6769B4 = &dword_6769CC;
  dword_676998 = (int)&dword_6769B0;
  unk_67697C = &dword_676994;
  dword_676960 = (int)&dword_676978;
  unk_67690C = &dword_676924;
  dword_676924 = (int)&dword_676908;
  dword_676908 = (int)&dword_6768EC;
  dword_6768EC = (int)&dword_6768D0;
  dword_6768D0 = (int)&dword_6768B4;
  dword_6768B4 = (int)&dword_676898;
  dword_676880 = (int)&dword_676898;
  dword_676898 = (int)&dword_67687C;
  *(_DWORD *)algn_676864 = &dword_67687C;
  dword_676848 = (int)&dword_676860;
  unk_67682C = &dword_676844;
  dword_67687C = (int)&dword_676860;
  dword_676860 = (int)&dword_676844;
  unk_676810 = &dword_676828;
  dword_676844 = (int)&dword_676828;
  dword_676828 = (int)&dword_67680C;
  *(_DWORD *)algn_6767F4 = &dword_67680C;
  dword_67680C = (int)&dword_6767F0;
  unk_6767D8 = &dword_6767F0;
  dword_6767F0 = (int)&dword_6767D4;
  unk_6767BC = &dword_6767D4;
  dword_6767D4 = (int)&dword_6767B8;
  dword_6768F0 = (int)&dword_676908;
  *(_DWORD *)algn_6768D4 = &dword_6768EC;
  dword_6768B8 = (int)&dword_6768D0;
  unk_67689C = &dword_6768B4;
  unk_6767A0 = &dword_6767B8;
  dword_6767B8 = (int)&dword_67679C;
  *(_DWORD *)algn_676784 = &dword_67679C;
  dword_67679C = (int)&dword_676780;
  unk_676768 = &dword_676780;
  dword_676780 = (int)&dword_676764;
  unk_67674C = &dword_676764;
  dword_676764 = (int)&dword_676748;
  unk_676730 = &dword_676748;
  dword_676748 = (int)&dword_67672C;
  *(_DWORD *)algn_676714 = &dword_67672C;
  dword_67672C = (int)&dword_676710;
  unk_6766F8 = &dword_676710;
  dword_676710 = (int)&dword_6766F4;
  unk_6766DC = &dword_6766F4;
  dword_6766F4 = (int)&dword_6766D8;
  unk_6766C0 = &dword_6766D8;
  dword_6766D8 = (int)&dword_6766BC;
  *(_DWORD *)algn_6766A4 = &dword_6766BC;
  dword_6766BC = (int)&dword_6766A0;
  unk_676688 = &dword_6766A0;
  dword_6766A0 = (int)&dword_676684;
  unk_67666C = &dword_676684;
  dword_676684 = (int)&dword_676668;
  unk_676650 = &dword_676668;
  dword_676668 = (int)&dword_67664C;
  *(_DWORD *)algn_676634 = &dword_67664C;
  dword_67664C = (int)&dword_676630;
  unk_676618 = &dword_676630;
  dword_676630 = (int)&dword_676614;
  unk_6765FC = &dword_676614;
  dword_676614 = (int)&dword_6765F8;
  unk_6765E0 = &dword_6765F8;
  dword_6765F8 = (int)&dword_6765DC;
  *(_DWORD *)algn_6765C4 = &dword_6765DC;
  dword_6765DC = (int)&dword_6765C0;
  unk_6765A8 = &dword_6765C0;
  dword_6765C0 = (int)&dword_6765A4;
  unk_67658C = &dword_6765A4;
  dword_6765A4 = (int)&dword_676588;
  unk_676570 = &dword_676588;
  dword_676588 = (int)&dword_67656C;
  *(_DWORD *)algn_676554 = &dword_67656C;
  dword_67656C = (int)&dword_676550;
  unk_676538 = &dword_676550;
  dword_676550 = (int)&dword_676534;
  unk_67651C = &dword_676534;
  dword_676534 = (int)&dword_676518;
  result = &dword_6764FC;
  off_66B584 = (void **)&dword_6764FC;
  unk_676500 = &dword_676518;
  dword_676518 = (int)&dword_6764FC;
  dword_6764FC = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6764FC: using guessed type int dword_6764FC;
// 676518: using guessed type int dword_676518;
// 676534: using guessed type int dword_676534;
// 676550: using guessed type int dword_676550;
// 67656C: using guessed type int dword_67656C;
// 676588: using guessed type int dword_676588;
// 6765A4: using guessed type int dword_6765A4;
// 6765C0: using guessed type int dword_6765C0;
// 6765DC: using guessed type int dword_6765DC;
// 6765F8: using guessed type int dword_6765F8;
// 676614: using guessed type int dword_676614;
// 676630: using guessed type int dword_676630;
// 67664C: using guessed type int dword_67664C;
// 676668: using guessed type int dword_676668;
// 676684: using guessed type int dword_676684;
// 6766A0: using guessed type int dword_6766A0;
// 6766BC: using guessed type int dword_6766BC;
// 6766D8: using guessed type int dword_6766D8;
// 6766F4: using guessed type int dword_6766F4;
// 676710: using guessed type int dword_676710;
// 67672C: using guessed type int dword_67672C;
// 676748: using guessed type int dword_676748;
// 676764: using guessed type int dword_676764;
// 676780: using guessed type int dword_676780;
// 67679C: using guessed type int dword_67679C;
// 6767B8: using guessed type int dword_6767B8;
// 6767D4: using guessed type int dword_6767D4;
// 6767F0: using guessed type int dword_6767F0;
// 67680C: using guessed type int dword_67680C;
// 676828: using guessed type int dword_676828;
// 676844: using guessed type int dword_676844;
// 676848: using guessed type int dword_676848;
// 676860: using guessed type int dword_676860;
// 67687C: using guessed type int dword_67687C;
// 676880: using guessed type int dword_676880;
// 676898: using guessed type int dword_676898;
// 6768B4: using guessed type int dword_6768B4;
// 6768B8: using guessed type int dword_6768B8;
// 6768D0: using guessed type int dword_6768D0;
// 6768EC: using guessed type int dword_6768EC;
// 6768F0: using guessed type int dword_6768F0;
// 676908: using guessed type int dword_676908;
// 676924: using guessed type int dword_676924;
// 676928: using guessed type int dword_676928;
// 676940: using guessed type int dword_676940;
// 67695C: using guessed type int dword_67695C;
// 676960: using guessed type int dword_676960;
// 676978: using guessed type int dword_676978;
// 676994: using guessed type int dword_676994;
// 676998: using guessed type int dword_676998;
// 6769B0: using guessed type int dword_6769B0;
// 6769CC: using guessed type int dword_6769CC;
// 6769D0: using guessed type int dword_6769D0;
// 6769E8: using guessed type int dword_6769E8;
// 676A04: using guessed type int dword_676A04;
// 676A20: using guessed type int dword_676A20;
// 676A3C: using guessed type int dword_676A3C;
// 676A58: using guessed type int dword_676A58;
// 676A74: using guessed type int dword_676A74;
// 676A90: using guessed type int dword_676A90;
// 676AAC: using guessed type int dword_676AAC;
// 676AC8: using guessed type int dword_676AC8;
// 676D4C: using guessed type int dword_676D4C;

//----- (0041A938) --------------------------------------------------------
int *ctor_079()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_6764E0;
  off_66B584 = (void **)&dword_6764E0;
  dword_6764E0 = (int)&_httpd_cgi_all_fun;
  dword_6764E4 = (int)v0;
  *v0 = &dword_6764E0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6764E0: using guessed type int dword_6764E0;
// 6764E4: using guessed type int dword_6764E4;

//----- (0041A968) --------------------------------------------------------
int *ctor_080()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_6770A4;
  off_66B584 = (void **)&dword_6770A4;
  dword_6770A4 = (int)&_httpd_cgi_all_fun;
  dword_6770A8 = (int)v0;
  *v0 = &dword_6770A4;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6770A4: using guessed type int dword_6770A4;
// 6770A8: using guessed type int dword_6770A8;

//----- (0041A998) --------------------------------------------------------
_DWORD *ctor_081()
{
  _DWORD *result; // $v0

  result = dword_676E58;
  dword_67708C = (int)off_66B584;
  *off_66B584 = &dword_677088;
  dword_677054 = (int)&dword_67706C;
  dword_67706C = (int)&dword_677050;
  dword_677038 = (int)&dword_677050;
  dword_677070 = (int)&dword_677088;
  dword_677088 = (int)&dword_67706C;
  dword_677050 = &dword_677034;
  dword_67701C = (int)&dword_677034;
  dword_677000 = (int)&dword_677018;
  dword_677034 = &dword_677018;
  dword_676FE4 = (int)&dword_676FFC;
  dword_677018 = &dword_676FFC;
  dword_676FFC = &dword_676FE0;
  dword_676FC8 = (int)&dword_676FE0;
  dword_676FAC = (int)&dword_676FC4;
  dword_676FE0 = &dword_676FC4;
  dword_676F90 = (int)&dword_676FA8;
  dword_676FC4 = &dword_676FA8;
  dword_676F74 = (int)&dword_676F8C;
  dword_676FA8 = &dword_676F8C;
  dword_676F58 = (int)&dword_676F70;
  dword_676F8C = &dword_676F70;
  dword_676F3C = (int)&dword_676F54;
  dword_676F70 = &dword_676F54;
  dword_676F54 = &dword_676F38;
  dword_676F20 = (int)&dword_676F38;
  dword_676F38 = (int)&dword_676F1C;
  dword_676F04 = (int)&dword_676F1C;
  dword_676F1C = (int)&dword_676F00;
  dword_676EE8 = (int)&dword_676F00;
  dword_676F00 = (int)&dword_676EE4;
  dword_676ECC = (int)&dword_676EE4;
  dword_676EB0 = (int)&dword_676EC8;
  dword_676EE4 = (int)&dword_676EC8;
  dword_676E94 = (int)&dword_676EAC;
  dword_676E78 = (int)&dword_676E90;
  dword_676E90 = (int)&dword_676E74;
  off_66B584 = (void **)dword_676E58;
  dword_676E58[0] = &_httpd_cgi_all_fun;
  dword_676E58[1] = &dword_676E74;
  dword_676E74 = (int)dword_676E58;
  dword_676EC8 = (int)&dword_676EAC;
  dword_676EAC = (int)&dword_676E90;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 676E74: using guessed type int dword_676E74;
// 676E78: using guessed type int dword_676E78;
// 676E90: using guessed type int dword_676E90;
// 676E94: using guessed type int dword_676E94;
// 676EAC: using guessed type int dword_676EAC;
// 676EB0: using guessed type int dword_676EB0;
// 676EC8: using guessed type int dword_676EC8;
// 676ECC: using guessed type int dword_676ECC;
// 676EE4: using guessed type int dword_676EE4;
// 676EE8: using guessed type int dword_676EE8;
// 676F00: using guessed type int dword_676F00;
// 676F04: using guessed type int dword_676F04;
// 676F1C: using guessed type int dword_676F1C;
// 676F20: using guessed type int dword_676F20;
// 676F38: using guessed type int dword_676F38;
// 676F3C: using guessed type int dword_676F3C;
// 676F58: using guessed type int dword_676F58;
// 676F74: using guessed type int dword_676F74;
// 676F90: using guessed type int dword_676F90;
// 676FAC: using guessed type int dword_676FAC;
// 676FC8: using guessed type int dword_676FC8;
// 676FE4: using guessed type int dword_676FE4;
// 677000: using guessed type int dword_677000;
// 67701C: using guessed type int dword_67701C;
// 677038: using guessed type int dword_677038;
// 677054: using guessed type int dword_677054;
// 67706C: using guessed type int dword_67706C;
// 677070: using guessed type int dword_677070;
// 677088: using guessed type int dword_677088;
// 67708C: using guessed type int dword_67708C;

//----- (0041ABD8) --------------------------------------------------------
int *ctor_082()
{
  int *result; // $v0

  result = &dword_676E20;
  dword_676E40 = (int)off_66B584;
  *off_66B584 = &dword_676E3C;
  off_66B584 = (void **)&dword_676E20;
  dword_676E20 = (int)&_httpd_cgi_all_fun;
  dword_676E24 = (int)&dword_676E3C;
  dword_676E3C = (int)&dword_676E20;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 676E20: using guessed type int dword_676E20;
// 676E24: using guessed type int dword_676E24;
// 676E3C: using guessed type int dword_676E3C;
// 676E40: using guessed type int dword_676E40;

//----- (0041AC18) --------------------------------------------------------
int *ctor_083()
{
  int *result; // $v0

  dword_677948[1] = off_66B584;
  *off_66B584 = dword_677948;
  dword_67792C[1] = dword_677948;
  dword_677948[0] = dword_67792C;
  *(_DWORD *)algn_677914 = dword_67792C;
  dword_67792C[0] = &dword_677910;
  dword_6778F4[1] = &dword_677910;
  dword_677910 = (int)dword_6778F4;
  dword_6778D8[1] = dword_6778F4;
  dword_6778F4[0] = dword_6778D8;
  dword_6778BC[1] = dword_6778D8;
  dword_6778D8[0] = dword_6778BC;
  dword_6778A0[1] = dword_6778BC;
  dword_6778BC[0] = dword_6778A0;
  dword_677884[1] = dword_6778A0;
  dword_6778A0[0] = dword_677884;
  dword_677868[1] = dword_677884;
  dword_677884[0] = dword_677868;
  dword_67784C[1] = dword_677868;
  dword_677868[0] = dword_67784C;
  dword_677830[1] = dword_67784C;
  dword_67784C[0] = dword_677830;
  dword_677814[1] = dword_677830;
  dword_677830[0] = dword_677814;
  dword_6777F8[1] = dword_677814;
  dword_677814[0] = dword_6777F8;
  dword_6777DC[1] = dword_6777F8;
  dword_6777F8[0] = dword_6777DC;
  dword_6777C0[1] = dword_6777DC;
  dword_6777DC[0] = dword_6777C0;
  dword_6777A4[1] = dword_6777C0;
  dword_6777C0[0] = dword_6777A4;
  dword_677788[1] = dword_6777A4;
  dword_6777A4[0] = dword_677788;
  dword_67776C[1] = dword_677788;
  dword_677788[0] = dword_67776C;
  dword_677750[1] = dword_67776C;
  dword_67776C[0] = dword_677750;
  dword_677734[1] = dword_677750;
  dword_677750[0] = dword_677734;
  dword_677718[1] = dword_677734;
  dword_677734[0] = dword_677718;
  dword_6776FC[1] = dword_677718;
  dword_677718[0] = dword_6776FC;
  dword_6776E0[1] = dword_6776FC;
  dword_6776FC[0] = dword_6776E0;
  dword_6776E0[0] = dword_6776C4;
  dword_6776C4[1] = dword_6776E0;
  dword_6776A8[1] = dword_6776C4;
  unk_677690 = dword_6776A8;
  dword_6776C4[0] = dword_6776A8;
  *(_DWORD *)algn_677674 = &dword_67768C;
  dword_6776A8[0] = &dword_67768C;
  unk_677658 = &dword_677670;
  dword_67768C = (int)&dword_677670;
  dword_677670 = (int)&dword_677654;
  dword_677654 = (int)&dword_677638;
  dword_677638 = (int)&dword_67761C;
  dword_67761C = (int)&dword_677600;
  dword_677600 = (int)&dword_6775E4;
  dword_6775E4 = (int)&dword_6775C8;
  dword_6775C8 = (int)&dword_6775AC;
  unk_677508 = &dword_677520;
  dword_6775AC = (int)&dword_677590;
  dword_6774EC = (int)&dword_677504;
  dword_677590 = (int)&dword_677574;
  unk_67763C = &dword_677654;
  dword_677574 = (int)&dword_677558;
  unk_677620 = &dword_677638;
  dword_677558 = (int)&dword_67753C;
  *(_DWORD *)algn_677604 = &dword_67761C;
  dword_67753C = (int)&dword_677520;
  unk_6775E8 = &dword_677600;
  dword_677520 = (int)&dword_677504;
  unk_6775CC = &dword_6775E4;
  dword_677504 = (int)&dword_6774E8;
  unk_6775B0 = &dword_6775C8;
  dword_677594 = (int)&dword_6775AC;
  unk_677578 = &dword_677590;
  dword_67755C = (int)&dword_677574;
  unk_677540 = &dword_677558;
  dword_677524 = (int)&dword_67753C;
  unk_6774D0 = &dword_6774E8;
  dword_6774E8 = (int)&dword_6774CC;
  dword_6774CC = (int)&dword_6774B0;
  dword_6774B0 = (int)&dword_677494;
  dword_677494 = (int)&dword_677478;
  dword_677478 = (int)&dword_67745C;
  dword_677444 = (int)&dword_67745C;
  dword_67745C = (int)&dword_677440;
  unk_677428 = &dword_677440;
  dword_67740C = (int)&dword_677424;
  unk_6773F0 = &dword_677408;
  dword_677440 = (int)&dword_677424;
  dword_677424 = (int)&dword_677408;
  *(_DWORD *)algn_6773D4 = &dword_6773EC;
  dword_677408 = (int)&dword_6773EC;
  dword_6773EC = (int)&dword_6773D0;
  unk_6773B8 = &dword_6773D0;
  dword_6773D0 = (int)&dword_6773B4;
  unk_67739C = &dword_6773B4;
  dword_6773B4 = (int)&dword_677398;
  unk_677380 = &dword_677398;
  dword_677398 = (int)&dword_67737C;
  dword_6774B4 = (int)&dword_6774CC;
  unk_677498 = &dword_6774B0;
  dword_67747C = (int)&dword_677494;
  unk_677460 = &dword_677478;
  unk_677364 = &dword_67737C;
  dword_67737C = (int)&dword_677360;
  unk_677348 = &dword_677360;
  dword_677360 = (int)&dword_677344;
  unk_67732C = &dword_677344;
  dword_677344 = (int)&dword_677328;
  unk_677310 = &dword_677328;
  dword_677328 = (int)&dword_67730C;
  *(_DWORD *)algn_6772F4 = &dword_67730C;
  dword_67730C = (int)&dword_6772F0;
  unk_6772D8 = &dword_6772F0;
  dword_6772F0 = (int)&dword_6772D4;
  unk_6772BC = &dword_6772D4;
  dword_6772D4 = (int)&dword_6772B8;
  unk_6772A0 = &dword_6772B8;
  dword_6772B8 = (int)&dword_67729C;
  *(_DWORD *)algn_677284 = &dword_67729C;
  dword_67729C = (int)&dword_677280;
  unk_677268 = &dword_677280;
  dword_677280 = (int)&dword_677264;
  unk_67724C = &dword_677264;
  dword_677264 = (int)&dword_677248;
  unk_677230 = &dword_677248;
  dword_677248 = (int)&dword_67722C;
  *(_DWORD *)algn_677214 = &dword_67722C;
  dword_67722C = (int)&dword_677210;
  unk_6771F8 = &dword_677210;
  dword_677210 = (int)&dword_6771F4;
  unk_6771DC = &dword_6771F4;
  dword_6771F4 = (int)&dword_6771D8;
  unk_6771C0 = &dword_6771D8;
  dword_6771D8 = (int)&dword_6771BC;
  *(_DWORD *)algn_6771A4 = &dword_6771BC;
  dword_6771BC = (int)&dword_6771A0;
  unk_677188 = &dword_6771A0;
  dword_6771A0 = (int)&dword_677184;
  unk_67716C = &dword_677184;
  dword_677184 = (int)&dword_677168;
  unk_677150 = &dword_677168;
  dword_677168 = (int)&dword_67714C;
  *(_DWORD *)algn_677134 = &dword_67714C;
  dword_67714C = (int)&dword_677130;
  unk_677118 = &dword_677130;
  dword_677130 = (int)&dword_677114;
  unk_6770FC = &dword_677114;
  dword_677114 = (int)&dword_6770F8;
  unk_6770E0 = &dword_6770F8;
  dword_6770F8 = (int)&dword_6770DC;
  result = &dword_6770C0;
  off_66B584 = (void **)&dword_6770C0;
  *(_DWORD *)algn_6770C4 = &dword_6770DC;
  dword_6770DC = (int)&dword_6770C0;
  dword_6770C0 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6770C0: using guessed type int dword_6770C0;
// 6770DC: using guessed type int dword_6770DC;
// 6770F8: using guessed type int dword_6770F8;
// 677114: using guessed type int dword_677114;
// 677130: using guessed type int dword_677130;
// 67714C: using guessed type int dword_67714C;
// 677168: using guessed type int dword_677168;
// 677184: using guessed type int dword_677184;
// 6771A0: using guessed type int dword_6771A0;
// 6771BC: using guessed type int dword_6771BC;
// 6771D8: using guessed type int dword_6771D8;
// 6771F4: using guessed type int dword_6771F4;
// 677210: using guessed type int dword_677210;
// 67722C: using guessed type int dword_67722C;
// 677248: using guessed type int dword_677248;
// 677264: using guessed type int dword_677264;
// 677280: using guessed type int dword_677280;
// 67729C: using guessed type int dword_67729C;
// 6772B8: using guessed type int dword_6772B8;
// 6772D4: using guessed type int dword_6772D4;
// 6772F0: using guessed type int dword_6772F0;
// 67730C: using guessed type int dword_67730C;
// 677328: using guessed type int dword_677328;
// 677344: using guessed type int dword_677344;
// 677360: using guessed type int dword_677360;
// 67737C: using guessed type int dword_67737C;
// 677398: using guessed type int dword_677398;
// 6773B4: using guessed type int dword_6773B4;
// 6773D0: using guessed type int dword_6773D0;
// 6773EC: using guessed type int dword_6773EC;
// 677408: using guessed type int dword_677408;
// 67740C: using guessed type int dword_67740C;
// 677424: using guessed type int dword_677424;
// 677440: using guessed type int dword_677440;
// 677444: using guessed type int dword_677444;
// 67745C: using guessed type int dword_67745C;
// 677478: using guessed type int dword_677478;
// 67747C: using guessed type int dword_67747C;
// 677494: using guessed type int dword_677494;
// 6774B0: using guessed type int dword_6774B0;
// 6774B4: using guessed type int dword_6774B4;
// 6774CC: using guessed type int dword_6774CC;
// 6774E8: using guessed type int dword_6774E8;
// 6774EC: using guessed type int dword_6774EC;
// 677504: using guessed type int dword_677504;
// 677520: using guessed type int dword_677520;
// 677524: using guessed type int dword_677524;
// 67753C: using guessed type int dword_67753C;
// 677558: using guessed type int dword_677558;
// 67755C: using guessed type int dword_67755C;
// 677574: using guessed type int dword_677574;
// 677590: using guessed type int dword_677590;
// 677594: using guessed type int dword_677594;
// 6775AC: using guessed type int dword_6775AC;
// 6775C8: using guessed type int dword_6775C8;
// 6775E4: using guessed type int dword_6775E4;
// 677600: using guessed type int dword_677600;
// 67761C: using guessed type int dword_67761C;
// 677638: using guessed type int dword_677638;
// 677654: using guessed type int dword_677654;
// 677670: using guessed type int dword_677670;
// 67768C: using guessed type int dword_67768C;
// 677910: using guessed type int dword_677910;

//----- (0041B56C) --------------------------------------------------------
int *ctor_084()
{
  int *result; // $v0

  dword_6781F8[1] = off_66B584;
  *off_66B584 = dword_6781F8;
  dword_6781DC[1] = dword_6781F8;
  dword_6781F8[0] = dword_6781DC;
  *(_DWORD *)algn_6781C4 = dword_6781DC;
  dword_6781DC[0] = &dword_6781C0;
  dword_6781A4[1] = &dword_6781C0;
  dword_6781C0 = (int)dword_6781A4;
  dword_678188[1] = dword_6781A4;
  dword_6781A4[0] = dword_678188;
  dword_67816C[1] = dword_678188;
  dword_678188[0] = dword_67816C;
  dword_678150[1] = dword_67816C;
  dword_67816C[0] = dword_678150;
  dword_678134[1] = dword_678150;
  dword_678150[0] = dword_678134;
  dword_678118[1] = dword_678134;
  dword_678134[0] = dword_678118;
  dword_6780FC[1] = dword_678118;
  dword_678118[0] = dword_6780FC;
  dword_6780E0[1] = dword_6780FC;
  dword_6780FC[0] = dword_6780E0;
  dword_6780C4[1] = dword_6780E0;
  dword_6780E0[0] = dword_6780C4;
  dword_6780A8[1] = dword_6780C4;
  dword_6780C4[0] = dword_6780A8;
  dword_67808C[1] = dword_6780A8;
  dword_6780A8[0] = dword_67808C;
  dword_678070[1] = dword_67808C;
  dword_67808C[0] = dword_678070;
  dword_678054[1] = dword_678070;
  dword_678070[0] = dword_678054;
  dword_678038[1] = dword_678054;
  dword_678054[0] = dword_678038;
  dword_67801C[1] = dword_678038;
  dword_678038[0] = dword_67801C;
  dword_678000[1] = dword_67801C;
  dword_67801C[0] = dword_678000;
  dword_677FE4[1] = dword_678000;
  dword_678000[0] = dword_677FE4;
  dword_677FC8[1] = dword_677FE4;
  dword_677FE4[0] = dword_677FC8;
  dword_677FAC[1] = dword_677FC8;
  dword_677FC8[0] = dword_677FAC;
  dword_677F90[1] = dword_677FAC;
  dword_677FAC[0] = dword_677F90;
  dword_677F90[0] = dword_677F74;
  dword_677F74[1] = dword_677F90;
  dword_677F58[1] = dword_677F74;
  unk_677F40 = dword_677F58;
  dword_677F74[0] = dword_677F58;
  *(_DWORD *)algn_677F24 = &dword_677F3C;
  dword_677F58[0] = &dword_677F3C;
  unk_677F08 = &dword_677F20;
  dword_677F3C = (int)&dword_677F20;
  dword_677F20 = (int)&dword_677F04;
  dword_677F04 = (int)&dword_677EE8;
  dword_677EE8 = (int)&dword_677ECC;
  dword_677ECC = (int)&dword_677EB0;
  dword_677EB0 = (int)&dword_677E94;
  dword_677E94 = (int)&dword_677E78;
  dword_677E78 = (int)&dword_677E5C;
  unk_677DB8 = &dword_677DD0;
  dword_677E5C = (int)&dword_677E40;
  dword_677D9C = (int)&dword_677DB4;
  dword_677E40 = (int)&dword_677E24;
  unk_677EEC = &dword_677F04;
  dword_677E24 = (int)&dword_677E08;
  unk_677ED0 = &dword_677EE8;
  dword_677E08 = (int)&dword_677DEC;
  *(_DWORD *)algn_677EB4 = &dword_677ECC;
  dword_677DEC = (int)&dword_677DD0;
  unk_677E98 = &dword_677EB0;
  dword_677DD0 = (int)&dword_677DB4;
  unk_677E7C = &dword_677E94;
  dword_677DB4 = (int)&dword_677D98;
  unk_677E60 = &dword_677E78;
  dword_677E44 = (int)&dword_677E5C;
  unk_677E28 = &dword_677E40;
  dword_677E0C = (int)&dword_677E24;
  unk_677DF0 = &dword_677E08;
  dword_677DD4 = (int)&dword_677DEC;
  unk_677D80 = &dword_677D98;
  dword_677D98 = (int)&dword_677D7C;
  dword_677D7C = (int)&dword_677D60;
  dword_677D60 = (int)&dword_677D44;
  dword_677D44 = (int)&dword_677D28;
  dword_677D28 = (int)&dword_677D0C;
  dword_677CF4 = (int)&dword_677D0C;
  dword_677D0C = (int)&dword_677CF0;
  unk_677CD8 = &dword_677CF0;
  dword_677CBC = (int)&dword_677CD4;
  unk_677CA0 = &dword_677CB8;
  dword_677CF0 = (int)&dword_677CD4;
  dword_677CD4 = (int)&dword_677CB8;
  *(_DWORD *)algn_677C84 = &dword_677C9C;
  dword_677CB8 = (int)&dword_677C9C;
  dword_677C9C = (int)&dword_677C80;
  unk_677C68 = &dword_677C80;
  dword_677C80 = (int)&dword_677C64;
  unk_677C4C = &dword_677C64;
  dword_677C64 = (int)&dword_677C48;
  unk_677C30 = &dword_677C48;
  dword_677C48 = (int)&dword_677C2C;
  dword_677D64 = (int)&dword_677D7C;
  unk_677D48 = &dword_677D60;
  dword_677D2C = (int)&dword_677D44;
  unk_677D10 = &dword_677D28;
  *(_DWORD *)algn_677C14 = &dword_677C2C;
  dword_677C2C = (int)&dword_677C10;
  unk_677BF8 = &dword_677C10;
  dword_677C10 = (int)&dword_677BF4;
  unk_677BDC = &dword_677BF4;
  dword_677BF4 = (int)&dword_677BD8;
  unk_677BC0 = &dword_677BD8;
  dword_677BD8 = (int)&dword_677BBC;
  *(_DWORD *)algn_677BA4 = &dword_677BBC;
  dword_677BBC = (int)&dword_677BA0;
  unk_677B88 = &dword_677BA0;
  dword_677BA0 = (int)&dword_677B84;
  unk_677B6C = &dword_677B84;
  dword_677B84 = (int)&dword_677B68;
  unk_677B50 = &dword_677B68;
  dword_677B68 = (int)&dword_677B4C;
  *(_DWORD *)algn_677B34 = &dword_677B4C;
  dword_677B4C = (int)&dword_677B30;
  unk_677B18 = &dword_677B30;
  dword_677B30 = (int)&dword_677B14;
  unk_677AFC = &dword_677B14;
  dword_677B14 = (int)&dword_677AF8;
  unk_677AE0 = &dword_677AF8;
  dword_677AF8 = (int)&dword_677ADC;
  *(_DWORD *)algn_677AC4 = &dword_677ADC;
  dword_677ADC = (int)&dword_677AC0;
  unk_677AA8 = &dword_677AC0;
  dword_677AC0 = (int)&dword_677AA4;
  unk_677A8C = &dword_677AA4;
  dword_677AA4 = (int)&dword_677A88;
  unk_677A70 = &dword_677A88;
  dword_677A88 = (int)&dword_677A6C;
  *(_DWORD *)algn_677A54 = &dword_677A6C;
  dword_677A6C = (int)&dword_677A50;
  unk_677A38 = &dword_677A50;
  dword_677A50 = (int)&dword_677A34;
  unk_677A1C = &dword_677A34;
  dword_677A34 = (int)&dword_677A18;
  unk_677A00 = &dword_677A18;
  dword_677A18 = (int)&dword_6779FC;
  *(_DWORD *)algn_6779E4 = &dword_6779FC;
  dword_6779FC = (int)&dword_6779E0;
  unk_6779C8 = &dword_6779E0;
  dword_6779E0 = (int)&dword_6779C4;
  unk_6779AC = &dword_6779C4;
  dword_6779C4 = (int)&dword_6779A8;
  unk_677990 = &dword_6779A8;
  dword_6779A8 = (int)&dword_67798C;
  result = &dword_677970;
  off_66B584 = (void **)&dword_677970;
  *(_DWORD *)algn_677974 = &dword_67798C;
  dword_67798C = (int)&dword_677970;
  dword_677970 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 677970: using guessed type int dword_677970;
// 67798C: using guessed type int dword_67798C;
// 6779A8: using guessed type int dword_6779A8;
// 6779C4: using guessed type int dword_6779C4;
// 6779E0: using guessed type int dword_6779E0;
// 6779FC: using guessed type int dword_6779FC;
// 677A18: using guessed type int dword_677A18;
// 677A34: using guessed type int dword_677A34;
// 677A50: using guessed type int dword_677A50;
// 677A6C: using guessed type int dword_677A6C;
// 677A88: using guessed type int dword_677A88;
// 677AA4: using guessed type int dword_677AA4;
// 677AC0: using guessed type int dword_677AC0;
// 677ADC: using guessed type int dword_677ADC;
// 677AF8: using guessed type int dword_677AF8;
// 677B14: using guessed type int dword_677B14;
// 677B30: using guessed type int dword_677B30;
// 677B4C: using guessed type int dword_677B4C;
// 677B68: using guessed type int dword_677B68;
// 677B84: using guessed type int dword_677B84;
// 677BA0: using guessed type int dword_677BA0;
// 677BBC: using guessed type int dword_677BBC;
// 677BD8: using guessed type int dword_677BD8;
// 677BF4: using guessed type int dword_677BF4;
// 677C10: using guessed type int dword_677C10;
// 677C2C: using guessed type int dword_677C2C;
// 677C48: using guessed type int dword_677C48;
// 677C64: using guessed type int dword_677C64;
// 677C80: using guessed type int dword_677C80;
// 677C9C: using guessed type int dword_677C9C;
// 677CB8: using guessed type int dword_677CB8;
// 677CBC: using guessed type int dword_677CBC;
// 677CD4: using guessed type int dword_677CD4;
// 677CF0: using guessed type int dword_677CF0;
// 677CF4: using guessed type int dword_677CF4;
// 677D0C: using guessed type int dword_677D0C;
// 677D28: using guessed type int dword_677D28;
// 677D2C: using guessed type int dword_677D2C;
// 677D44: using guessed type int dword_677D44;
// 677D60: using guessed type int dword_677D60;
// 677D64: using guessed type int dword_677D64;
// 677D7C: using guessed type int dword_677D7C;
// 677D98: using guessed type int dword_677D98;
// 677D9C: using guessed type int dword_677D9C;
// 677DB4: using guessed type int dword_677DB4;
// 677DD0: using guessed type int dword_677DD0;
// 677DD4: using guessed type int dword_677DD4;
// 677DEC: using guessed type int dword_677DEC;
// 677E08: using guessed type int dword_677E08;
// 677E0C: using guessed type int dword_677E0C;
// 677E24: using guessed type int dword_677E24;
// 677E40: using guessed type int dword_677E40;
// 677E44: using guessed type int dword_677E44;
// 677E5C: using guessed type int dword_677E5C;
// 677E78: using guessed type int dword_677E78;
// 677E94: using guessed type int dword_677E94;
// 677EB0: using guessed type int dword_677EB0;
// 677ECC: using guessed type int dword_677ECC;
// 677EE8: using guessed type int dword_677EE8;
// 677F04: using guessed type int dword_677F04;
// 677F20: using guessed type int dword_677F20;
// 677F3C: using guessed type int dword_677F3C;
// 6781C0: using guessed type int dword_6781C0;

//----- (0041BEC0) --------------------------------------------------------
int *ctor_085()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_678220;
  off_66B584 = (void **)&dword_678220;
  dword_678220 = (int)&_httpd_cgi_all_fun;
  dword_678224 = (int)v0;
  *v0 = &dword_678220;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 678220: using guessed type int dword_678220;
// 678224: using guessed type int dword_678224;

//----- (0041BEF0) --------------------------------------------------------
int *ctor_086()
{
  int *result; // $v0

  dword_678AC8[1] = off_66B584;
  *off_66B584 = dword_678AC8;
  dword_678AAC[1] = dword_678AC8;
  dword_678AC8[0] = dword_678AAC;
  *(_DWORD *)algn_678A94 = dword_678AAC;
  dword_678AAC[0] = &dword_678A90;
  dword_678A74[1] = &dword_678A90;
  dword_678A90 = (int)dword_678A74;
  dword_678A58[1] = dword_678A74;
  dword_678A74[0] = dword_678A58;
  dword_678A3C[1] = dword_678A58;
  dword_678A58[0] = dword_678A3C;
  dword_678A20[1] = dword_678A3C;
  dword_678A3C[0] = dword_678A20;
  dword_678A04[1] = dword_678A20;
  dword_678A20[0] = dword_678A04;
  dword_6789E8[1] = dword_678A04;
  dword_678A04[0] = dword_6789E8;
  dword_6789CC[1] = dword_6789E8;
  dword_6789E8[0] = dword_6789CC;
  dword_6789B0[1] = dword_6789CC;
  dword_6789CC[0] = dword_6789B0;
  dword_678994[1] = dword_6789B0;
  dword_6789B0[0] = dword_678994;
  dword_678978[1] = dword_678994;
  dword_678994[0] = dword_678978;
  dword_67895C[1] = dword_678978;
  dword_678978[0] = dword_67895C;
  dword_678940[1] = dword_67895C;
  dword_67895C[0] = dword_678940;
  dword_678924[1] = dword_678940;
  dword_678940[0] = dword_678924;
  dword_678908[1] = dword_678924;
  dword_678924[0] = dword_678908;
  dword_6788EC[1] = dword_678908;
  dword_678908[0] = dword_6788EC;
  dword_6788D0[1] = dword_6788EC;
  dword_6788EC[0] = dword_6788D0;
  dword_6788B4[1] = dword_6788D0;
  dword_6788D0[0] = dword_6788B4;
  dword_678898[1] = dword_6788B4;
  dword_6788B4[0] = dword_678898;
  dword_67887C[1] = dword_678898;
  dword_678898[0] = dword_67887C;
  dword_678860[1] = dword_67887C;
  dword_67887C[0] = dword_678860;
  dword_678860[0] = dword_678844;
  dword_678844[1] = dword_678860;
  dword_678828[1] = dword_678844;
  unk_678810 = dword_678828;
  dword_678844[0] = dword_678828;
  *(_DWORD *)algn_6787F4 = &dword_67880C;
  dword_678828[0] = &dword_67880C;
  unk_6787D8 = &dword_6787F0;
  dword_67880C = (int)&dword_6787F0;
  dword_6787F0 = (int)&dword_6787D4;
  dword_6787D4 = (int)&dword_6787B8;
  dword_6787B8 = (int)&dword_67879C;
  dword_67879C = (int)&dword_678780;
  dword_678780 = (int)&dword_678764;
  dword_678764 = (int)&dword_678748;
  dword_678748 = (int)&dword_67872C;
  unk_678688 = &dword_6786A0;
  dword_67872C = (int)&dword_678710;
  dword_67866C = (int)&dword_678684;
  dword_678710 = (int)&dword_6786F4;
  unk_6787BC = &dword_6787D4;
  dword_6786F4 = (int)&dword_6786D8;
  unk_6787A0 = &dword_6787B8;
  dword_6786D8 = (int)&dword_6786BC;
  *(_DWORD *)algn_678784 = &dword_67879C;
  dword_6786BC = (int)&dword_6786A0;
  unk_678768 = &dword_678780;
  dword_6786A0 = (int)&dword_678684;
  unk_67874C = &dword_678764;
  dword_678684 = (int)&dword_678668;
  unk_678730 = &dword_678748;
  dword_678714 = (int)&dword_67872C;
  unk_6786F8 = &dword_678710;
  dword_6786DC = (int)&dword_6786F4;
  unk_6786C0 = &dword_6786D8;
  dword_6786A4 = (int)&dword_6786BC;
  unk_678650 = &dword_678668;
  dword_678668 = (int)&dword_67864C;
  dword_67864C = (int)&dword_678630;
  dword_678630 = (int)&dword_678614;
  dword_678614 = (int)&dword_6785F8;
  dword_6785F8 = (int)&dword_6785DC;
  dword_6785C4 = (int)&dword_6785DC;
  dword_6785DC = (int)&dword_6785C0;
  unk_6785A8 = &dword_6785C0;
  dword_67858C = (int)&dword_6785A4;
  unk_678570 = &dword_678588;
  dword_6785C0 = (int)&dword_6785A4;
  dword_6785A4 = (int)&dword_678588;
  *(_DWORD *)algn_678554 = &dword_67856C;
  dword_678588 = (int)&dword_67856C;
  dword_67856C = (int)&dword_678550;
  unk_678538 = &dword_678550;
  dword_678550 = (int)&dword_678534;
  unk_67851C = &dword_678534;
  dword_678534 = (int)&dword_678518;
  unk_678500 = &dword_678518;
  dword_678518 = (int)&dword_6784FC;
  dword_678634 = (int)&dword_67864C;
  unk_678618 = &dword_678630;
  dword_6785FC = (int)&dword_678614;
  unk_6785E0 = &dword_6785F8;
  *(_DWORD *)algn_6784E4 = &dword_6784FC;
  dword_6784FC = (int)&dword_6784E0;
  unk_6784C8 = &dword_6784E0;
  dword_6784E0 = (int)&dword_6784C4;
  unk_6784AC = &dword_6784C4;
  dword_6784C4 = (int)&dword_6784A8;
  unk_678490 = &dword_6784A8;
  dword_6784A8 = (int)&dword_67848C;
  *(_DWORD *)algn_678474 = &dword_67848C;
  dword_67848C = (int)&dword_678470;
  unk_678458 = &dword_678470;
  dword_678470 = (int)&dword_678454;
  unk_67843C = &dword_678454;
  dword_678454 = (int)&dword_678438;
  unk_678420 = &dword_678438;
  dword_678438 = (int)&dword_67841C;
  *(_DWORD *)algn_678404 = &dword_67841C;
  dword_67841C = (int)&dword_678400;
  unk_6783E8 = &dword_678400;
  dword_678400 = (int)&dword_6783E4;
  unk_6783CC = &dword_6783E4;
  dword_6783E4 = (int)&dword_6783C8;
  unk_6783B0 = &dword_6783C8;
  dword_6783C8 = (int)&dword_6783AC;
  *(_DWORD *)algn_678394 = &dword_6783AC;
  dword_6783AC = (int)&dword_678390;
  unk_678378 = &dword_678390;
  dword_678390 = (int)&dword_678374;
  unk_67835C = &dword_678374;
  dword_678374 = (int)&dword_678358;
  unk_678340 = &dword_678358;
  dword_678358 = (int)&dword_67833C;
  *(_DWORD *)algn_678324 = &dword_67833C;
  dword_67833C = (int)&dword_678320;
  unk_678308 = &dword_678320;
  dword_678320 = (int)&dword_678304;
  unk_6782EC = &dword_678304;
  dword_678304 = (int)&dword_6782E8;
  unk_6782D0 = &dword_6782E8;
  dword_6782E8 = (int)&dword_6782CC;
  *(_DWORD *)algn_6782B4 = &dword_6782CC;
  dword_6782CC = (int)&dword_6782B0;
  unk_678298 = &dword_6782B0;
  dword_6782B0 = (int)&dword_678294;
  unk_67827C = &dword_678294;
  dword_678294 = (int)&dword_678278;
  unk_678260 = &dword_678278;
  dword_678278 = (int)&dword_67825C;
  result = &dword_678240;
  off_66B584 = (void **)&dword_678240;
  *(_DWORD *)algn_678244 = &dword_67825C;
  dword_67825C = (int)&dword_678240;
  dword_678240 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 678240: using guessed type int dword_678240;
// 67825C: using guessed type int dword_67825C;
// 678278: using guessed type int dword_678278;
// 678294: using guessed type int dword_678294;
// 6782B0: using guessed type int dword_6782B0;
// 6782CC: using guessed type int dword_6782CC;
// 6782E8: using guessed type int dword_6782E8;
// 678304: using guessed type int dword_678304;
// 678320: using guessed type int dword_678320;
// 67833C: using guessed type int dword_67833C;
// 678358: using guessed type int dword_678358;
// 678374: using guessed type int dword_678374;
// 678390: using guessed type int dword_678390;
// 6783AC: using guessed type int dword_6783AC;
// 6783C8: using guessed type int dword_6783C8;
// 6783E4: using guessed type int dword_6783E4;
// 678400: using guessed type int dword_678400;
// 67841C: using guessed type int dword_67841C;
// 678438: using guessed type int dword_678438;
// 678454: using guessed type int dword_678454;
// 678470: using guessed type int dword_678470;
// 67848C: using guessed type int dword_67848C;
// 6784A8: using guessed type int dword_6784A8;
// 6784C4: using guessed type int dword_6784C4;
// 6784E0: using guessed type int dword_6784E0;
// 6784FC: using guessed type int dword_6784FC;
// 678518: using guessed type int dword_678518;
// 678534: using guessed type int dword_678534;
// 678550: using guessed type int dword_678550;
// 67856C: using guessed type int dword_67856C;
// 678588: using guessed type int dword_678588;
// 67858C: using guessed type int dword_67858C;
// 6785A4: using guessed type int dword_6785A4;
// 6785C0: using guessed type int dword_6785C0;
// 6785C4: using guessed type int dword_6785C4;
// 6785DC: using guessed type int dword_6785DC;
// 6785F8: using guessed type int dword_6785F8;
// 6785FC: using guessed type int dword_6785FC;
// 678614: using guessed type int dword_678614;
// 678630: using guessed type int dword_678630;
// 678634: using guessed type int dword_678634;
// 67864C: using guessed type int dword_67864C;
// 678668: using guessed type int dword_678668;
// 67866C: using guessed type int dword_67866C;
// 678684: using guessed type int dword_678684;
// 6786A0: using guessed type int dword_6786A0;
// 6786A4: using guessed type int dword_6786A4;
// 6786BC: using guessed type int dword_6786BC;
// 6786D8: using guessed type int dword_6786D8;
// 6786DC: using guessed type int dword_6786DC;
// 6786F4: using guessed type int dword_6786F4;
// 678710: using guessed type int dword_678710;
// 678714: using guessed type int dword_678714;
// 67872C: using guessed type int dword_67872C;
// 678748: using guessed type int dword_678748;
// 678764: using guessed type int dword_678764;
// 678780: using guessed type int dword_678780;
// 67879C: using guessed type int dword_67879C;
// 6787B8: using guessed type int dword_6787B8;
// 6787D4: using guessed type int dword_6787D4;
// 6787F0: using guessed type int dword_6787F0;
// 67880C: using guessed type int dword_67880C;
// 678A90: using guessed type int dword_678A90;

//----- (0041C844) --------------------------------------------------------
int *ctor_087()
{
  int *result; // $v0

  dword_6797EC[1] = off_66B584;
  *off_66B584 = dword_6797EC;
  dword_6797D0[1] = dword_6797EC;
  dword_6797EC[0] = dword_6797D0;
  unk_6797B8 = dword_6797D0;
  dword_6797D0[0] = &dword_6797B4;
  dword_679798[1] = &dword_6797B4;
  dword_6797B4 = (int)dword_679798;
  dword_67977C[1] = dword_679798;
  dword_679798[0] = dword_67977C;
  dword_679760[1] = dword_67977C;
  dword_67977C[0] = dword_679760;
  dword_679744[1] = dword_679760;
  dword_679760[0] = dword_679744;
  dword_679728[1] = dword_679744;
  dword_679744[0] = dword_679728;
  dword_67970C[1] = dword_679728;
  dword_679728[0] = dword_67970C;
  dword_6796F0[1] = dword_67970C;
  dword_67970C[0] = dword_6796F0;
  dword_6796D4[1] = dword_6796F0;
  dword_6796F0[0] = dword_6796D4;
  dword_6796B8[1] = dword_6796D4;
  dword_6796D4[0] = dword_6796B8;
  dword_67969C[1] = dword_6796B8;
  dword_6796B8[0] = dword_67969C;
  dword_679680[1] = dword_67969C;
  dword_67969C[0] = dword_679680;
  dword_679664[1] = dword_679680;
  dword_679680[0] = dword_679664;
  dword_679648[1] = dword_679664;
  dword_679664[0] = dword_679648;
  dword_67962C[1] = dword_679648;
  dword_679648[0] = dword_67962C;
  dword_679610[1] = dword_67962C;
  dword_67962C[0] = dword_679610;
  dword_6795F4[1] = dword_679610;
  dword_679610[0] = dword_6795F4;
  dword_6795D8[1] = dword_6795F4;
  dword_6795F4[0] = dword_6795D8;
  dword_6795BC[1] = dword_6795D8;
  dword_6795D8[0] = dword_6795BC;
  dword_6795A0[1] = dword_6795BC;
  dword_6795BC[0] = dword_6795A0;
  dword_679584[1] = dword_6795A0;
  dword_6795A0[0] = dword_679584;
  dword_679584[0] = dword_679568;
  dword_679568[1] = dword_679584;
  dword_67954C[1] = dword_679568;
  *(_DWORD *)algn_679534 = dword_67954C;
  dword_679568[0] = dword_67954C;
  unk_679518 = &dword_679530;
  dword_67954C[0] = &dword_679530;
  unk_6794FC = &dword_679514;
  dword_679530 = (int)&dword_679514;
  dword_679514 = (int)&dword_6794F8;
  dword_6794F8 = (int)&dword_6794DC;
  dword_6794DC = (int)&dword_6794C0;
  dword_6794C0 = (int)&dword_6794A4;
  dword_6794A4 = (int)&dword_679488;
  dword_679488 = (int)&dword_67946C;
  dword_67946C = (int)&dword_679450;
  unk_6793AC = &dword_6793C4;
  dword_679450 = (int)&dword_679434;
  dword_679390 = (int)&dword_6793A8;
  dword_679434 = (int)&dword_679418;
  unk_6794E0 = &dword_6794F8;
  dword_679418 = (int)&dword_6793FC;
  *(_DWORD *)algn_6794C4 = &dword_6794DC;
  dword_6793FC = (int)&dword_6793E0;
  unk_6794A8 = &dword_6794C0;
  dword_6793E0 = (int)&dword_6793C4;
  unk_67948C = &dword_6794A4;
  dword_6793C4 = (int)&dword_6793A8;
  unk_679470 = &dword_679488;
  dword_6793A8 = (int)&dword_67938C;
  *(_DWORD *)algn_679454 = &dword_67946C;
  dword_679438 = (int)&dword_679450;
  unk_67941C = &dword_679434;
  dword_679400 = (int)&dword_679418;
  *(_DWORD *)algn_6793E4 = &dword_6793FC;
  dword_6793C8 = (int)&dword_6793E0;
  *(_DWORD *)algn_679374 = &dword_67938C;
  dword_67938C = (int)&dword_679370;
  dword_679370 = (int)&dword_679354;
  dword_679354 = (int)&dword_679338;
  dword_679338 = (int)&dword_67931C;
  dword_67931C = (int)&dword_679300;
  dword_6792E8 = (int)&dword_679300;
  dword_679300 = (int)&dword_6792E4;
  unk_6792CC = &dword_6792E4;
  dword_6792B0 = (int)&dword_6792C8;
  *(_DWORD *)algn_679294 = &dword_6792AC;
  dword_6792E4 = (int)&dword_6792C8;
  dword_6792C8 = (int)&dword_6792AC;
  unk_679278 = &dword_679290;
  dword_6792AC = (int)&dword_679290;
  dword_679290 = (int)&dword_679274;
  unk_67925C = &dword_679274;
  dword_679274 = (int)&dword_679258;
  unk_679240 = &dword_679258;
  dword_679258 = (int)&dword_67923C;
  *(_DWORD *)algn_679224 = &dword_67923C;
  dword_67923C = (int)&dword_679220;
  dword_679358 = (int)&dword_679370;
  unk_67933C = &dword_679354;
  dword_679320 = (int)&dword_679338;
  *(_DWORD *)algn_679304 = &dword_67931C;
  unk_679208 = &dword_679220;
  dword_679220 = (int)&dword_679204;
  unk_6791EC = &dword_679204;
  dword_679204 = (int)&dword_6791E8;
  unk_6791D0 = &dword_6791E8;
  dword_6791E8 = (int)&dword_6791CC;
  *(_DWORD *)algn_6791B4 = &dword_6791CC;
  dword_6791CC = (int)&dword_6791B0;
  unk_679198 = &dword_6791B0;
  dword_6791B0 = (int)&dword_679194;
  unk_67917C = &dword_679194;
  dword_679194 = (int)&dword_679178;
  unk_679160 = &dword_679178;
  dword_679178 = (int)&dword_67915C;
  *(_DWORD *)algn_679144 = &dword_67915C;
  dword_67915C = (int)&dword_679140;
  unk_679128 = &dword_679140;
  dword_679140 = (int)&dword_679124;
  unk_67910C = &dword_679124;
  dword_679124 = (int)&dword_679108;
  unk_6790F0 = &dword_679108;
  dword_679108 = (int)&dword_6790EC;
  *(_DWORD *)algn_6790D4 = &dword_6790EC;
  dword_6790EC = (int)&dword_6790D0;
  unk_6790B8 = &dword_6790D0;
  dword_6790D0 = (int)&dword_6790B4;
  unk_67909C = &dword_6790B4;
  dword_6790B4 = (int)&dword_679098;
  unk_679080 = &dword_679098;
  dword_679098 = (int)&dword_67907C;
  *(_DWORD *)algn_679064 = &dword_67907C;
  dword_67907C = (int)&dword_679060;
  unk_679048 = &dword_679060;
  dword_679060 = (int)&dword_679044;
  unk_67902C = &dword_679044;
  dword_679044 = (int)&dword_679028;
  unk_679010 = &dword_679028;
  dword_679028 = (int)&dword_67900C;
  *(_DWORD *)algn_678FF4 = &dword_67900C;
  dword_67900C = (int)&dword_678FF0;
  unk_678FD8 = &dword_678FF0;
  dword_678FF0 = (int)&dword_678FD4;
  unk_678FBC = &dword_678FD4;
  dword_678FD4 = (int)&dword_678FB8;
  unk_678FA0 = &dword_678FB8;
  dword_678FB8 = (int)&dword_678F9C;
  *(_DWORD *)algn_678F84 = &dword_678F9C;
  dword_678F9C = (int)&dword_678F80;
  result = &dword_678F64;
  off_66B584 = (void **)&dword_678F64;
  unk_678F68 = &dword_678F80;
  dword_678F80 = (int)&dword_678F64;
  dword_678F64 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 678F64: using guessed type int dword_678F64;
// 678F80: using guessed type int dword_678F80;
// 678F9C: using guessed type int dword_678F9C;
// 678FB8: using guessed type int dword_678FB8;
// 678FD4: using guessed type int dword_678FD4;
// 678FF0: using guessed type int dword_678FF0;
// 67900C: using guessed type int dword_67900C;
// 679028: using guessed type int dword_679028;
// 679044: using guessed type int dword_679044;
// 679060: using guessed type int dword_679060;
// 67907C: using guessed type int dword_67907C;
// 679098: using guessed type int dword_679098;
// 6790B4: using guessed type int dword_6790B4;
// 6790D0: using guessed type int dword_6790D0;
// 6790EC: using guessed type int dword_6790EC;
// 679108: using guessed type int dword_679108;
// 679124: using guessed type int dword_679124;
// 679140: using guessed type int dword_679140;
// 67915C: using guessed type int dword_67915C;
// 679178: using guessed type int dword_679178;
// 679194: using guessed type int dword_679194;
// 6791B0: using guessed type int dword_6791B0;
// 6791CC: using guessed type int dword_6791CC;
// 6791E8: using guessed type int dword_6791E8;
// 679204: using guessed type int dword_679204;
// 679220: using guessed type int dword_679220;
// 67923C: using guessed type int dword_67923C;
// 679258: using guessed type int dword_679258;
// 679274: using guessed type int dword_679274;
// 679290: using guessed type int dword_679290;
// 6792AC: using guessed type int dword_6792AC;
// 6792B0: using guessed type int dword_6792B0;
// 6792C8: using guessed type int dword_6792C8;
// 6792E4: using guessed type int dword_6792E4;
// 6792E8: using guessed type int dword_6792E8;
// 679300: using guessed type int dword_679300;
// 67931C: using guessed type int dword_67931C;
// 679320: using guessed type int dword_679320;
// 679338: using guessed type int dword_679338;
// 679354: using guessed type int dword_679354;
// 679358: using guessed type int dword_679358;
// 679370: using guessed type int dword_679370;
// 67938C: using guessed type int dword_67938C;
// 679390: using guessed type int dword_679390;
// 6793A8: using guessed type int dword_6793A8;
// 6793C4: using guessed type int dword_6793C4;
// 6793C8: using guessed type int dword_6793C8;
// 6793E0: using guessed type int dword_6793E0;
// 6793FC: using guessed type int dword_6793FC;
// 679400: using guessed type int dword_679400;
// 679418: using guessed type int dword_679418;
// 679434: using guessed type int dword_679434;
// 679438: using guessed type int dword_679438;
// 679450: using guessed type int dword_679450;
// 67946C: using guessed type int dword_67946C;
// 679488: using guessed type int dword_679488;
// 6794A4: using guessed type int dword_6794A4;
// 6794C0: using guessed type int dword_6794C0;
// 6794DC: using guessed type int dword_6794DC;
// 6794F8: using guessed type int dword_6794F8;
// 679514: using guessed type int dword_679514;
// 679530: using guessed type int dword_679530;
// 6797B4: using guessed type int dword_6797B4;

//----- (0041D198) --------------------------------------------------------
int *ctor_088()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_678F48;
  off_66B584 = (void **)&dword_678F48;
  dword_678F48 = (int)&_httpd_cgi_all_fun;
  dword_678F4C = (int)v0;
  *v0 = &dword_678F48;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 678F48: using guessed type int dword_678F48;
// 678F4C: using guessed type int dword_678F4C;

//----- (0041D1C8) --------------------------------------------------------
_DWORD *ctor_089()
{
  _DWORD *result; // $v0

  result = dword_678CE0;
  dword_678F30 = (int)off_66B584;
  *off_66B584 = &dword_678F2C;
  dword_678F14 = (int)&dword_678F2C;
  dword_678F2C = (int)&dword_678F10;
  dword_678EF8 = (int)&dword_678F10;
  dword_678F10 = &dword_678EF4;
  dword_678EDC = (int)&dword_678EF4;
  dword_678EF4 = &dword_678ED8;
  dword_678EC0 = (int)&dword_678ED8;
  dword_678EA4 = (int)&dword_678EBC;
  dword_678ED8 = &dword_678EBC;
  dword_678E88 = (int)&dword_678EA0;
  dword_678EBC = &dword_678EA0;
  dword_678E6C = (int)&dword_678E84;
  dword_678EA0 = &dword_678E84;
  dword_678E50 = (int)&dword_678E68;
  dword_678E84 = &dword_678E68;
  dword_678E68 = &dword_678E4C;
  dword_678E34 = (int)&dword_678E4C;
  dword_678E18 = (int)&dword_678E30;
  dword_678E4C = &dword_678E30;
  dword_678DFC = (int)&dword_678E14;
  dword_678E30 = &dword_678E14;
  dword_678E14 = &dword_678DF8;
  dword_678DE0 = (int)&dword_678DF8;
  dword_678DF8 = &dword_678DDC;
  dword_678DC4 = (int)&dword_678DDC;
  dword_678DDC = (int)&dword_678DC0;
  dword_678DA8 = (int)&dword_678DC0;
  dword_678DC0 = (int)&dword_678DA4;
  dword_678D1C = (int)&dword_678D34;
  dword_678D34 = (int)&dword_678D18;
  dword_678D00 = (int)&dword_678D18;
  dword_678D8C = (int)&dword_678DA4;
  unk_678D70 = &dword_678D88;
  *(_DWORD *)algn_678D54 = &dword_678D6C;
  dword_678D38 = (int)&dword_678D50;
  dword_678D50 = (int)&dword_678D34;
  off_66B584 = (void **)dword_678CE0;
  dword_678CE0[0] = &_httpd_cgi_all_fun;
  dword_678CE0[1] = &dword_678CFC;
  dword_678CFC = (int)dword_678CE0;
  dword_678DA4 = (int)&dword_678D88;
  dword_678D88 = (int)&dword_678D6C;
  dword_678D6C = (int)&dword_678D50;
  dword_678D18 = (int)&dword_678CFC;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 678CFC: using guessed type int dword_678CFC;
// 678D00: using guessed type int dword_678D00;
// 678D18: using guessed type int dword_678D18;
// 678D1C: using guessed type int dword_678D1C;
// 678D34: using guessed type int dword_678D34;
// 678D38: using guessed type int dword_678D38;
// 678D50: using guessed type int dword_678D50;
// 678D6C: using guessed type int dword_678D6C;
// 678D88: using guessed type int dword_678D88;
// 678D8C: using guessed type int dword_678D8C;
// 678DA4: using guessed type int dword_678DA4;
// 678DA8: using guessed type int dword_678DA8;
// 678DC0: using guessed type int dword_678DC0;
// 678DC4: using guessed type int dword_678DC4;
// 678DDC: using guessed type int dword_678DDC;
// 678DE0: using guessed type int dword_678DE0;
// 678DFC: using guessed type int dword_678DFC;
// 678E18: using guessed type int dword_678E18;
// 678E34: using guessed type int dword_678E34;
// 678E50: using guessed type int dword_678E50;
// 678E6C: using guessed type int dword_678E6C;
// 678E88: using guessed type int dword_678E88;
// 678EA4: using guessed type int dword_678EA4;
// 678EC0: using guessed type int dword_678EC0;
// 678EDC: using guessed type int dword_678EDC;
// 678EF8: using guessed type int dword_678EF8;
// 678F14: using guessed type int dword_678F14;
// 678F2C: using guessed type int dword_678F2C;
// 678F30: using guessed type int dword_678F30;

//----- (0041D424) --------------------------------------------------------
_DWORD *ctor_090()
{
  _DWORD *result; // $v0

  result = &dword_678B20;
  dword_678CC8 = (int)off_66B584;
  *off_66B584 = &dword_678CC4;
  dword_678CAC = (int)&dword_678CC4;
  dword_678CC4 = (int)&dword_678CA8;
  dword_678CA8 = (int)&dword_678C8C;
  dword_678C8C = (int)&dword_678C70;
  dword_678C70 = (int)&dword_678C54;
  dword_678C54 = (int)&dword_678C38;
  dword_678C90 = (int)&dword_678CA8;
  dword_678C74 = (int)&dword_678C8C;
  dword_678C58 = (int)&dword_678C70;
  dword_678C3C = (int)&dword_678C54;
  dword_678C20 = (int)&dword_678C38;
  dword_678C38 = (int)&dword_678C1C;
  dword_678C04 = (int)&dword_678C1C;
  dword_678BE8 = (int)&dword_678C00;
  dword_678C1C = (int)&dword_678C00;
  dword_678BCC = (int)&dword_678BE4;
  dword_678C00 = &dword_678BE4;
  dword_678BB0 = (int)&dword_678BC8;
  dword_678BE4 = &dword_678BC8;
  dword_678B94 = (int)&dword_678BAC;
  dword_678BC8 = &dword_678BAC;
  dword_678B78 = (int)&dword_678B90;
  dword_678BAC = &dword_678B90;
  dword_678B90 = &dword_678B74;
  dword_678B5C = (int)&dword_678B74;
  dword_678B74 = (int)&dword_678B58;
  dword_678B40 = (int)&dword_678B58;
  dword_678B58 = (int)&dword_678B3C;
  off_66B584 = (void **)&dword_678B20;
  dword_678B20 = &_httpd_cgi_all_fun;
  dword_678B24 = (int)&dword_678B3C;
  dword_678B3C = (int)&dword_678B20;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 678B24: using guessed type int dword_678B24;
// 678B3C: using guessed type int dword_678B3C;
// 678B40: using guessed type int dword_678B40;
// 678B58: using guessed type int dword_678B58;
// 678B5C: using guessed type int dword_678B5C;
// 678B74: using guessed type int dword_678B74;
// 678B78: using guessed type int dword_678B78;
// 678B94: using guessed type int dword_678B94;
// 678BB0: using guessed type int dword_678BB0;
// 678BCC: using guessed type int dword_678BCC;
// 678BE8: using guessed type int dword_678BE8;
// 678C04: using guessed type int dword_678C04;
// 678C1C: using guessed type int dword_678C1C;
// 678C20: using guessed type int dword_678C20;
// 678C38: using guessed type int dword_678C38;
// 678C3C: using guessed type int dword_678C3C;
// 678C54: using guessed type int dword_678C54;
// 678C58: using guessed type int dword_678C58;
// 678C70: using guessed type int dword_678C70;
// 678C74: using guessed type int dword_678C74;
// 678C8C: using guessed type int dword_678C8C;
// 678C90: using guessed type int dword_678C90;
// 678CA8: using guessed type int dword_678CA8;
// 678CAC: using guessed type int dword_678CAC;
// 678CC4: using guessed type int dword_678CC4;
// 678CC8: using guessed type int dword_678CC8;

//----- (0041D5D8) --------------------------------------------------------
int *ctor_091()
{
  int *result; // $v0

  dword_67A58C[1] = off_66B584;
  *off_66B584 = dword_67A58C;
  dword_67A570[1] = dword_67A58C;
  dword_67A58C[0] = dword_67A570;
  unk_67A558 = dword_67A570;
  dword_67A570[0] = &dword_67A554;
  dword_67A538[1] = &dword_67A554;
  dword_67A554 = (int)dword_67A538;
  dword_67A51C[1] = dword_67A538;
  dword_67A538[0] = dword_67A51C;
  dword_67A500[1] = dword_67A51C;
  dword_67A51C[0] = dword_67A500;
  dword_67A4E4[1] = dword_67A500;
  dword_67A500[0] = dword_67A4E4;
  dword_67A4C8[1] = dword_67A4E4;
  dword_67A4E4[0] = dword_67A4C8;
  dword_67A4AC[1] = dword_67A4C8;
  dword_67A4C8[0] = dword_67A4AC;
  dword_67A490[1] = dword_67A4AC;
  dword_67A4AC[0] = dword_67A490;
  dword_67A474[1] = dword_67A490;
  dword_67A490[0] = dword_67A474;
  dword_67A458[1] = dword_67A474;
  dword_67A474[0] = dword_67A458;
  dword_67A43C[1] = dword_67A458;
  dword_67A458[0] = dword_67A43C;
  dword_67A420[1] = dword_67A43C;
  dword_67A43C[0] = dword_67A420;
  dword_67A404[1] = dword_67A420;
  dword_67A420[0] = dword_67A404;
  dword_67A3E8[1] = dword_67A404;
  dword_67A404[0] = dword_67A3E8;
  dword_67A3CC[1] = dword_67A3E8;
  dword_67A3E8[0] = dword_67A3CC;
  dword_67A3B0[1] = dword_67A3CC;
  dword_67A3CC[0] = dword_67A3B0;
  dword_67A394[1] = dword_67A3B0;
  dword_67A3B0[0] = dword_67A394;
  dword_67A378[1] = dword_67A394;
  dword_67A394[0] = dword_67A378;
  dword_67A35C[1] = dword_67A378;
  dword_67A378[0] = dword_67A35C;
  dword_67A340[1] = dword_67A35C;
  dword_67A35C[0] = dword_67A340;
  dword_67A324[1] = dword_67A340;
  dword_67A340[0] = dword_67A324;
  dword_67A324[0] = dword_67A308;
  dword_67A308[1] = dword_67A324;
  dword_67A2EC[1] = dword_67A308;
  *(_DWORD *)algn_67A2D4 = dword_67A2EC;
  dword_67A308[0] = dword_67A2EC;
  unk_67A2B8 = &dword_67A2D0;
  dword_67A2EC[0] = &dword_67A2D0;
  unk_67A29C = &dword_67A2B4;
  dword_67A2D0 = (int)&dword_67A2B4;
  dword_67A2B4 = (int)&dword_67A298;
  dword_67A298 = (int)&dword_67A27C;
  dword_67A27C = (int)&dword_67A260;
  dword_67A260 = (int)&dword_67A244;
  dword_67A244 = (int)&dword_67A228;
  dword_67A228 = (int)&dword_67A20C;
  dword_67A20C = (int)&dword_67A1F0;
  unk_67A14C = &dword_67A164;
  dword_67A1F0 = (int)&dword_67A1D4;
  dword_67A130 = (int)&dword_67A148;
  dword_67A1D4 = (int)&dword_67A1B8;
  unk_67A280 = &dword_67A298;
  dword_67A1B8 = (int)&dword_67A19C;
  *(_DWORD *)algn_67A264 = &dword_67A27C;
  dword_67A19C = (int)&dword_67A180;
  unk_67A248 = &dword_67A260;
  dword_67A180 = (int)&dword_67A164;
  unk_67A22C = &dword_67A244;
  dword_67A164 = (int)&dword_67A148;
  unk_67A210 = &dword_67A228;
  dword_67A148 = (int)&dword_67A12C;
  *(_DWORD *)algn_67A1F4 = &dword_67A20C;
  dword_67A1D8 = (int)&dword_67A1F0;
  unk_67A1BC = &dword_67A1D4;
  dword_67A1A0 = (int)&dword_67A1B8;
  *(_DWORD *)algn_67A184 = &dword_67A19C;
  dword_67A168 = (int)&dword_67A180;
  *(_DWORD *)algn_67A114 = &dword_67A12C;
  dword_67A12C = (int)&dword_67A110;
  dword_67A110 = (int)&dword_67A0F4;
  dword_67A0F4 = (int)&dword_67A0D8;
  dword_67A0D8 = (int)&dword_67A0BC;
  dword_67A0BC = (int)&dword_67A0A0;
  dword_67A088 = (int)&dword_67A0A0;
  dword_67A0A0 = (int)&dword_67A084;
  unk_67A06C = &dword_67A084;
  dword_67A050 = (int)&dword_67A068;
  *(_DWORD *)algn_67A034 = &dword_67A04C;
  dword_67A084 = (int)&dword_67A068;
  dword_67A068 = (int)&dword_67A04C;
  unk_67A018 = &dword_67A030;
  dword_67A04C = (int)&dword_67A030;
  dword_67A030 = (int)&dword_67A014;
  unk_679FFC = &dword_67A014;
  dword_67A014 = (int)&dword_679FF8;
  unk_679FE0 = &dword_679FF8;
  dword_679FF8 = (int)&dword_679FDC;
  *(_DWORD *)algn_679FC4 = &dword_679FDC;
  dword_679FDC = (int)&dword_679FC0;
  dword_67A0F8 = (int)&dword_67A110;
  unk_67A0DC = &dword_67A0F4;
  dword_67A0C0 = (int)&dword_67A0D8;
  *(_DWORD *)algn_67A0A4 = &dword_67A0BC;
  unk_679FA8 = &dword_679FC0;
  dword_679FC0 = (int)&dword_679FA4;
  unk_679F8C = &dword_679FA4;
  dword_679FA4 = (int)&dword_679F88;
  unk_679F70 = &dword_679F88;
  dword_679F88 = (int)&dword_679F6C;
  *(_DWORD *)algn_679F54 = &dword_679F6C;
  dword_679F6C = (int)&dword_679F50;
  unk_679F38 = &dword_679F50;
  dword_679F50 = (int)&dword_679F34;
  unk_679F1C = &dword_679F34;
  dword_679F34 = (int)&dword_679F18;
  unk_679F00 = &dword_679F18;
  dword_679F18 = (int)&dword_679EFC;
  *(_DWORD *)algn_679EE4 = &dword_679EFC;
  dword_679EFC = (int)&dword_679EE0;
  unk_679EC8 = &dword_679EE0;
  dword_679EE0 = (int)&dword_679EC4;
  unk_679EAC = &dword_679EC4;
  dword_679EC4 = (int)&dword_679EA8;
  unk_679E90 = &dword_679EA8;
  dword_679EA8 = (int)&dword_679E8C;
  *(_DWORD *)algn_679E74 = &dword_679E8C;
  dword_679E8C = (int)&dword_679E70;
  unk_679E58 = &dword_679E70;
  dword_679E70 = (int)&dword_679E54;
  unk_679E3C = &dword_679E54;
  dword_679E54 = (int)&dword_679E38;
  unk_679E20 = &dword_679E38;
  dword_679E38 = (int)&dword_679E1C;
  *(_DWORD *)algn_679E04 = &dword_679E1C;
  dword_679E1C = (int)&dword_679E00;
  unk_679DE8 = &dword_679E00;
  dword_679E00 = (int)&dword_679DE4;
  unk_679DCC = &dword_679DE4;
  dword_679DE4 = (int)&dword_679DC8;
  unk_679DB0 = &dword_679DC8;
  dword_679DC8 = (int)&dword_679DAC;
  *(_DWORD *)algn_679D94 = &dword_679DAC;
  dword_679DAC = (int)&dword_679D90;
  unk_679D78 = &dword_679D90;
  dword_679D90 = (int)&dword_679D74;
  unk_679D5C = &dword_679D74;
  dword_679D74 = (int)&dword_679D58;
  unk_679D40 = &dword_679D58;
  dword_679D58 = (int)&dword_679D3C;
  *(_DWORD *)algn_679D24 = &dword_679D3C;
  dword_679D3C = (int)&dword_679D20;
  result = &dword_679D04;
  off_66B584 = (void **)&dword_679D04;
  unk_679D08 = &dword_679D20;
  dword_679D20 = (int)&dword_679D04;
  dword_679D04 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 679D04: using guessed type int dword_679D04;
// 679D20: using guessed type int dword_679D20;
// 679D3C: using guessed type int dword_679D3C;
// 679D58: using guessed type int dword_679D58;
// 679D74: using guessed type int dword_679D74;
// 679D90: using guessed type int dword_679D90;
// 679DAC: using guessed type int dword_679DAC;
// 679DC8: using guessed type int dword_679DC8;
// 679DE4: using guessed type int dword_679DE4;
// 679E00: using guessed type int dword_679E00;
// 679E1C: using guessed type int dword_679E1C;
// 679E38: using guessed type int dword_679E38;
// 679E54: using guessed type int dword_679E54;
// 679E70: using guessed type int dword_679E70;
// 679E8C: using guessed type int dword_679E8C;
// 679EA8: using guessed type int dword_679EA8;
// 679EC4: using guessed type int dword_679EC4;
// 679EE0: using guessed type int dword_679EE0;
// 679EFC: using guessed type int dword_679EFC;
// 679F18: using guessed type int dword_679F18;
// 679F34: using guessed type int dword_679F34;
// 679F50: using guessed type int dword_679F50;
// 679F6C: using guessed type int dword_679F6C;
// 679F88: using guessed type int dword_679F88;
// 679FA4: using guessed type int dword_679FA4;
// 679FC0: using guessed type int dword_679FC0;
// 679FDC: using guessed type int dword_679FDC;
// 679FF8: using guessed type int dword_679FF8;
// 67A014: using guessed type int dword_67A014;
// 67A030: using guessed type int dword_67A030;
// 67A04C: using guessed type int dword_67A04C;
// 67A050: using guessed type int dword_67A050;
// 67A068: using guessed type int dword_67A068;
// 67A084: using guessed type int dword_67A084;
// 67A088: using guessed type int dword_67A088;
// 67A0A0: using guessed type int dword_67A0A0;
// 67A0BC: using guessed type int dword_67A0BC;
// 67A0C0: using guessed type int dword_67A0C0;
// 67A0D8: using guessed type int dword_67A0D8;
// 67A0F4: using guessed type int dword_67A0F4;
// 67A0F8: using guessed type int dword_67A0F8;
// 67A110: using guessed type int dword_67A110;
// 67A12C: using guessed type int dword_67A12C;
// 67A130: using guessed type int dword_67A130;
// 67A148: using guessed type int dword_67A148;
// 67A164: using guessed type int dword_67A164;
// 67A168: using guessed type int dword_67A168;
// 67A180: using guessed type int dword_67A180;
// 67A19C: using guessed type int dword_67A19C;
// 67A1A0: using guessed type int dword_67A1A0;
// 67A1B8: using guessed type int dword_67A1B8;
// 67A1D4: using guessed type int dword_67A1D4;
// 67A1D8: using guessed type int dword_67A1D8;
// 67A1F0: using guessed type int dword_67A1F0;
// 67A20C: using guessed type int dword_67A20C;
// 67A228: using guessed type int dword_67A228;
// 67A244: using guessed type int dword_67A244;
// 67A260: using guessed type int dword_67A260;
// 67A27C: using guessed type int dword_67A27C;
// 67A298: using guessed type int dword_67A298;
// 67A2B4: using guessed type int dword_67A2B4;
// 67A2D0: using guessed type int dword_67A2D0;
// 67A554: using guessed type int dword_67A554;

//----- (0041DF2C) --------------------------------------------------------
int *ctor_092()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_679CE8;
  off_66B584 = (void **)&dword_679CE8;
  dword_679CE8 = (int)&_httpd_cgi_all_fun;
  dword_679CEC = (int)v0;
  *v0 = &dword_679CE8;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 679CE8: using guessed type int dword_679CE8;
// 679CEC: using guessed type int dword_679CEC;

//----- (0041DF5C) --------------------------------------------------------
_DWORD *ctor_093()
{
  _DWORD *result; // $v0

  result = dword_679A80;
  dword_679CD0 = (int)off_66B584;
  *off_66B584 = &dword_679CCC;
  dword_679CB4 = (int)&dword_679CCC;
  dword_679CCC = (int)&dword_679CB0;
  dword_679C98 = (int)&dword_679CB0;
  dword_679CB0 = &dword_679C94;
  dword_679C7C = (int)&dword_679C94;
  dword_679C94 = &dword_679C78;
  dword_679C60 = (int)&dword_679C78;
  dword_679C44 = (int)&dword_679C5C;
  dword_679C78 = &dword_679C5C;
  dword_679C28 = (int)&dword_679C40;
  dword_679C5C = &dword_679C40;
  dword_679C0C = (int)&dword_679C24;
  dword_679C40 = &dword_679C24;
  dword_679BF0 = (int)&dword_679C08;
  dword_679C24 = &dword_679C08;
  dword_679C08 = &dword_679BEC;
  dword_679BD4 = (int)&dword_679BEC;
  dword_679BB8 = (int)&dword_679BD0;
  dword_679BEC = &dword_679BD0;
  dword_679B9C = (int)&dword_679BB4;
  dword_679BD0 = &dword_679BB4;
  dword_679BB4 = &dword_679B98;
  dword_679B80 = (int)&dword_679B98;
  dword_679B98 = &dword_679B7C;
  dword_679B64 = (int)&dword_679B7C;
  dword_679B7C = (int)&dword_679B60;
  dword_679B48 = (int)&dword_679B60;
  dword_679B60 = (int)&dword_679B44;
  dword_679ABC = (int)&dword_679AD4;
  dword_679AD4 = (int)&dword_679AB8;
  dword_679AA0 = (int)&dword_679AB8;
  dword_679B2C = (int)&dword_679B44;
  unk_679B10 = &dword_679B28;
  *(_DWORD *)algn_679AF4 = &dword_679B0C;
  dword_679AD8 = (int)&dword_679AF0;
  dword_679AF0 = (int)&dword_679AD4;
  off_66B584 = (void **)dword_679A80;
  dword_679A80[0] = &_httpd_cgi_all_fun;
  dword_679A80[1] = &dword_679A9C;
  dword_679A9C = (int)dword_679A80;
  dword_679B44 = (int)&dword_679B28;
  dword_679B28 = (int)&dword_679B0C;
  dword_679B0C = (int)&dword_679AF0;
  dword_679AB8 = (int)&dword_679A9C;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 679A9C: using guessed type int dword_679A9C;
// 679AA0: using guessed type int dword_679AA0;
// 679AB8: using guessed type int dword_679AB8;
// 679ABC: using guessed type int dword_679ABC;
// 679AD4: using guessed type int dword_679AD4;
// 679AD8: using guessed type int dword_679AD8;
// 679AF0: using guessed type int dword_679AF0;
// 679B0C: using guessed type int dword_679B0C;
// 679B28: using guessed type int dword_679B28;
// 679B2C: using guessed type int dword_679B2C;
// 679B44: using guessed type int dword_679B44;
// 679B48: using guessed type int dword_679B48;
// 679B60: using guessed type int dword_679B60;
// 679B64: using guessed type int dword_679B64;
// 679B7C: using guessed type int dword_679B7C;
// 679B80: using guessed type int dword_679B80;
// 679B9C: using guessed type int dword_679B9C;
// 679BB8: using guessed type int dword_679BB8;
// 679BD4: using guessed type int dword_679BD4;
// 679BF0: using guessed type int dword_679BF0;
// 679C0C: using guessed type int dword_679C0C;
// 679C28: using guessed type int dword_679C28;
// 679C44: using guessed type int dword_679C44;
// 679C60: using guessed type int dword_679C60;
// 679C7C: using guessed type int dword_679C7C;
// 679C98: using guessed type int dword_679C98;
// 679CB4: using guessed type int dword_679CB4;
// 679CCC: using guessed type int dword_679CCC;
// 679CD0: using guessed type int dword_679CD0;

//----- (0041E1B8) --------------------------------------------------------
_DWORD *ctor_094()
{
  _DWORD *result; // $v0

  result = &dword_6798C0;
  dword_679A68 = (int)off_66B584;
  *off_66B584 = &dword_679A64;
  dword_679A4C = (int)&dword_679A64;
  dword_679A64 = (int)&dword_679A48;
  dword_679A48 = (int)&dword_679A2C;
  dword_679A2C = (int)&dword_679A10;
  dword_679A10 = (int)&dword_6799F4;
  dword_6799F4 = (int)&dword_6799D8;
  dword_679A30 = (int)&dword_679A48;
  dword_679A14 = (int)&dword_679A2C;
  dword_6799F8 = (int)&dword_679A10;
  dword_6799DC = (int)&dword_6799F4;
  dword_6799C0 = (int)&dword_6799D8;
  dword_6799D8 = (int)&dword_6799BC;
  dword_6799A4 = (int)&dword_6799BC;
  dword_679988 = (int)&dword_6799A0;
  dword_6799BC = (int)&dword_6799A0;
  dword_67996C = (int)&dword_679984;
  dword_6799A0 = &dword_679984;
  dword_679950 = (int)&dword_679968;
  dword_679984 = &dword_679968;
  dword_679934 = (int)&dword_67994C;
  dword_679968 = &dword_67994C;
  dword_679918 = (int)&dword_679930;
  dword_67994C = &dword_679930;
  dword_679930 = &dword_679914;
  dword_6798FC = (int)&dword_679914;
  dword_679914 = (int)&dword_6798F8;
  dword_6798E0 = (int)&dword_6798F8;
  dword_6798F8 = (int)&dword_6798DC;
  off_66B584 = (void **)&dword_6798C0;
  dword_6798C0 = &_httpd_cgi_all_fun;
  dword_6798C4 = (int)&dword_6798DC;
  dword_6798DC = (int)&dword_6798C0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 6798C4: using guessed type int dword_6798C4;
// 6798DC: using guessed type int dword_6798DC;
// 6798E0: using guessed type int dword_6798E0;
// 6798F8: using guessed type int dword_6798F8;
// 6798FC: using guessed type int dword_6798FC;
// 679914: using guessed type int dword_679914;
// 679918: using guessed type int dword_679918;
// 679934: using guessed type int dword_679934;
// 679950: using guessed type int dword_679950;
// 67996C: using guessed type int dword_67996C;
// 679988: using guessed type int dword_679988;
// 6799A4: using guessed type int dword_6799A4;
// 6799BC: using guessed type int dword_6799BC;
// 6799C0: using guessed type int dword_6799C0;
// 6799D8: using guessed type int dword_6799D8;
// 6799DC: using guessed type int dword_6799DC;
// 6799F4: using guessed type int dword_6799F4;
// 6799F8: using guessed type int dword_6799F8;
// 679A10: using guessed type int dword_679A10;
// 679A14: using guessed type int dword_679A14;
// 679A2C: using guessed type int dword_679A2C;
// 679A30: using guessed type int dword_679A30;
// 679A48: using guessed type int dword_679A48;
// 679A4C: using guessed type int dword_679A4C;
// 679A64: using guessed type int dword_679A64;
// 679A68: using guessed type int dword_679A68;

//----- (0041E36C) --------------------------------------------------------
int *ctor_095()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_67A5B0;
  off_66B584 = (void **)&dword_67A5B0;
  dword_67A5B0 = (int)&_httpd_cgi_all_fun;
  dword_67A5B4 = (int)v0;
  *v0 = &dword_67A5B0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67A5B0: using guessed type int dword_67A5B0;
// 67A5B4: using guessed type int dword_67A5B4;

//----- (0041E39C) --------------------------------------------------------
int *ctor_096()
{
  int *result; // $v0

  dword_67B108[1] = off_66B584;
  *off_66B584 = dword_67B108;
  dword_67B0EC[1] = dword_67B108;
  dword_67B108[0] = dword_67B0EC;
  *(_DWORD *)algn_67B0D4 = dword_67B0EC;
  dword_67B0EC[0] = &dword_67B0D0;
  dword_67B0B4[1] = &dword_67B0D0;
  dword_67B0D0 = (int)dword_67B0B4;
  dword_67B098[1] = dword_67B0B4;
  dword_67B0B4[0] = dword_67B098;
  dword_67B07C[1] = dword_67B098;
  dword_67B098[0] = dword_67B07C;
  dword_67B060[1] = dword_67B07C;
  dword_67B07C[0] = dword_67B060;
  dword_67B044[1] = dword_67B060;
  dword_67B060[0] = dword_67B044;
  dword_67B028[1] = dword_67B044;
  dword_67B044[0] = dword_67B028;
  dword_67B00C[1] = dword_67B028;
  dword_67B028[0] = dword_67B00C;
  dword_67AFF0[1] = dword_67B00C;
  dword_67B00C[0] = dword_67AFF0;
  dword_67AFD4[1] = dword_67AFF0;
  dword_67AFF0[0] = dword_67AFD4;
  dword_67AFB8[1] = dword_67AFD4;
  dword_67AFD4[0] = dword_67AFB8;
  dword_67AF9C[1] = dword_67AFB8;
  dword_67AFB8[0] = dword_67AF9C;
  dword_67AF80[1] = dword_67AF9C;
  dword_67AF9C[0] = dword_67AF80;
  dword_67AF64[1] = dword_67AF80;
  dword_67AF80[0] = dword_67AF64;
  dword_67AF48[1] = dword_67AF64;
  dword_67AF64[0] = dword_67AF48;
  dword_67AF2C[1] = dword_67AF48;
  dword_67AF48[0] = dword_67AF2C;
  dword_67AF10[1] = dword_67AF2C;
  dword_67AF2C[0] = dword_67AF10;
  dword_67AEF4[1] = dword_67AF10;
  dword_67AF10[0] = dword_67AEF4;
  dword_67AED8[1] = dword_67AEF4;
  dword_67AEF4[0] = dword_67AED8;
  dword_67AEBC[1] = dword_67AED8;
  dword_67AED8[0] = dword_67AEBC;
  dword_67AEA0[1] = dword_67AEBC;
  dword_67AEBC[0] = dword_67AEA0;
  dword_67AEA0[0] = dword_67AE84;
  dword_67AE84[1] = dword_67AEA0;
  dword_67AE68[1] = dword_67AE84;
  unk_67AE50 = dword_67AE68;
  dword_67AE84[0] = dword_67AE68;
  *(_DWORD *)algn_67AE34 = &dword_67AE4C;
  dword_67AE68[0] = &dword_67AE4C;
  unk_67AE18 = &dword_67AE30;
  dword_67AE4C = (int)&dword_67AE30;
  dword_67AE30 = (int)&dword_67AE14;
  dword_67AE14 = (int)&dword_67ADF8;
  dword_67ADF8 = (int)&dword_67ADDC;
  dword_67ADDC = (int)&dword_67ADC0;
  dword_67ADC0 = (int)&dword_67ADA4;
  dword_67ADA4 = (int)&dword_67AD88;
  dword_67AD88 = (int)&dword_67AD6C;
  unk_67ACC8 = &dword_67ACE0;
  dword_67AD6C = (int)&dword_67AD50;
  dword_67ACAC = (int)&dword_67ACC4;
  dword_67AD50 = (int)&dword_67AD34;
  unk_67ADFC = &dword_67AE14;
  dword_67AD34 = (int)&dword_67AD18;
  unk_67ADE0 = &dword_67ADF8;
  dword_67AD18 = (int)&dword_67ACFC;
  *(_DWORD *)algn_67ADC4 = &dword_67ADDC;
  dword_67ACFC = (int)&dword_67ACE0;
  unk_67ADA8 = &dword_67ADC0;
  dword_67ACE0 = (int)&dword_67ACC4;
  unk_67AD8C = &dword_67ADA4;
  dword_67ACC4 = (int)&dword_67ACA8;
  unk_67AD70 = &dword_67AD88;
  dword_67AD54 = (int)&dword_67AD6C;
  unk_67AD38 = &dword_67AD50;
  dword_67AD1C = (int)&dword_67AD34;
  unk_67AD00 = &dword_67AD18;
  dword_67ACE4 = (int)&dword_67ACFC;
  unk_67AC90 = &dword_67ACA8;
  dword_67ACA8 = (int)&dword_67AC8C;
  dword_67AC8C = (int)&dword_67AC70;
  dword_67AC70 = (int)&dword_67AC54;
  dword_67AC54 = (int)&dword_67AC38;
  dword_67AC38 = (int)&dword_67AC1C;
  dword_67AC04 = (int)&dword_67AC1C;
  dword_67AC1C = (int)&dword_67AC00;
  unk_67ABE8 = &dword_67AC00;
  dword_67ABCC = (int)&dword_67ABE4;
  unk_67ABB0 = &dword_67ABC8;
  dword_67AC00 = (int)&dword_67ABE4;
  dword_67ABE4 = (int)&dword_67ABC8;
  *(_DWORD *)algn_67AB94 = &dword_67ABAC;
  dword_67ABC8 = (int)&dword_67ABAC;
  dword_67ABAC = (int)&dword_67AB90;
  unk_67AB78 = &dword_67AB90;
  dword_67AB90 = (int)&dword_67AB74;
  unk_67AB5C = &dword_67AB74;
  dword_67AB74 = (int)&dword_67AB58;
  unk_67AB40 = &dword_67AB58;
  dword_67AB58 = (int)&dword_67AB3C;
  dword_67AC74 = (int)&dword_67AC8C;
  unk_67AC58 = &dword_67AC70;
  dword_67AC3C = (int)&dword_67AC54;
  unk_67AC20 = &dword_67AC38;
  *(_DWORD *)algn_67AB24 = &dword_67AB3C;
  dword_67AB3C = (int)&dword_67AB20;
  unk_67AB08 = &dword_67AB20;
  dword_67AB20 = (int)&dword_67AB04;
  unk_67AAEC = &dword_67AB04;
  dword_67AB04 = (int)&dword_67AAE8;
  unk_67AAD0 = &dword_67AAE8;
  dword_67AAE8 = (int)&dword_67AACC;
  *(_DWORD *)algn_67AAB4 = &dword_67AACC;
  dword_67AACC = (int)&dword_67AAB0;
  unk_67AA98 = &dword_67AAB0;
  dword_67AAB0 = (int)&dword_67AA94;
  unk_67AA7C = &dword_67AA94;
  dword_67AA94 = (int)&dword_67AA78;
  unk_67AA60 = &dword_67AA78;
  dword_67AA78 = (int)&dword_67AA5C;
  *(_DWORD *)algn_67AA44 = &dword_67AA5C;
  dword_67AA5C = (int)&dword_67AA40;
  unk_67AA28 = &dword_67AA40;
  dword_67AA40 = (int)&dword_67AA24;
  unk_67AA0C = &dword_67AA24;
  dword_67AA24 = (int)&dword_67AA08;
  unk_67A9F0 = &dword_67AA08;
  dword_67AA08 = (int)&dword_67A9EC;
  *(_DWORD *)algn_67A9D4 = &dword_67A9EC;
  dword_67A9EC = (int)&dword_67A9D0;
  unk_67A9B8 = &dword_67A9D0;
  dword_67A9D0 = (int)&dword_67A9B4;
  unk_67A99C = &dword_67A9B4;
  dword_67A9B4 = (int)&dword_67A998;
  unk_67A980 = &dword_67A998;
  dword_67A998 = (int)&dword_67A97C;
  *(_DWORD *)algn_67A964 = &dword_67A97C;
  dword_67A97C = (int)&dword_67A960;
  unk_67A948 = &dword_67A960;
  dword_67A960 = (int)&dword_67A944;
  unk_67A92C = &dword_67A944;
  dword_67A944 = (int)&dword_67A928;
  unk_67A910 = &dword_67A928;
  dword_67A928 = (int)&dword_67A90C;
  *(_DWORD *)algn_67A8F4 = &dword_67A90C;
  dword_67A90C = (int)&dword_67A8F0;
  unk_67A8D8 = &dword_67A8F0;
  dword_67A8F0 = (int)&dword_67A8D4;
  unk_67A8BC = &dword_67A8D4;
  dword_67A8D4 = (int)&dword_67A8B8;
  unk_67A8A0 = &dword_67A8B8;
  dword_67A8B8 = (int)&dword_67A89C;
  result = &dword_67A880;
  off_66B584 = (void **)&dword_67A880;
  *(_DWORD *)algn_67A884 = &dword_67A89C;
  dword_67A89C = (int)&dword_67A880;
  dword_67A880 = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67A880: using guessed type int dword_67A880;
// 67A89C: using guessed type int dword_67A89C;
// 67A8B8: using guessed type int dword_67A8B8;
// 67A8D4: using guessed type int dword_67A8D4;
// 67A8F0: using guessed type int dword_67A8F0;
// 67A90C: using guessed type int dword_67A90C;
// 67A928: using guessed type int dword_67A928;
// 67A944: using guessed type int dword_67A944;
// 67A960: using guessed type int dword_67A960;
// 67A97C: using guessed type int dword_67A97C;
// 67A998: using guessed type int dword_67A998;
// 67A9B4: using guessed type int dword_67A9B4;
// 67A9D0: using guessed type int dword_67A9D0;
// 67A9EC: using guessed type int dword_67A9EC;
// 67AA08: using guessed type int dword_67AA08;
// 67AA24: using guessed type int dword_67AA24;
// 67AA40: using guessed type int dword_67AA40;
// 67AA5C: using guessed type int dword_67AA5C;
// 67AA78: using guessed type int dword_67AA78;
// 67AA94: using guessed type int dword_67AA94;
// 67AAB0: using guessed type int dword_67AAB0;
// 67AACC: using guessed type int dword_67AACC;
// 67AAE8: using guessed type int dword_67AAE8;
// 67AB04: using guessed type int dword_67AB04;
// 67AB20: using guessed type int dword_67AB20;
// 67AB3C: using guessed type int dword_67AB3C;
// 67AB58: using guessed type int dword_67AB58;
// 67AB74: using guessed type int dword_67AB74;
// 67AB90: using guessed type int dword_67AB90;
// 67ABAC: using guessed type int dword_67ABAC;
// 67ABC8: using guessed type int dword_67ABC8;
// 67ABCC: using guessed type int dword_67ABCC;
// 67ABE4: using guessed type int dword_67ABE4;
// 67AC00: using guessed type int dword_67AC00;
// 67AC04: using guessed type int dword_67AC04;
// 67AC1C: using guessed type int dword_67AC1C;
// 67AC38: using guessed type int dword_67AC38;
// 67AC3C: using guessed type int dword_67AC3C;
// 67AC54: using guessed type int dword_67AC54;
// 67AC70: using guessed type int dword_67AC70;
// 67AC74: using guessed type int dword_67AC74;
// 67AC8C: using guessed type int dword_67AC8C;
// 67ACA8: using guessed type int dword_67ACA8;
// 67ACAC: using guessed type int dword_67ACAC;
// 67ACC4: using guessed type int dword_67ACC4;
// 67ACE0: using guessed type int dword_67ACE0;
// 67ACE4: using guessed type int dword_67ACE4;
// 67ACFC: using guessed type int dword_67ACFC;
// 67AD18: using guessed type int dword_67AD18;
// 67AD1C: using guessed type int dword_67AD1C;
// 67AD34: using guessed type int dword_67AD34;
// 67AD50: using guessed type int dword_67AD50;
// 67AD54: using guessed type int dword_67AD54;
// 67AD6C: using guessed type int dword_67AD6C;
// 67AD88: using guessed type int dword_67AD88;
// 67ADA4: using guessed type int dword_67ADA4;
// 67ADC0: using guessed type int dword_67ADC0;
// 67ADDC: using guessed type int dword_67ADDC;
// 67ADF8: using guessed type int dword_67ADF8;
// 67AE14: using guessed type int dword_67AE14;
// 67AE30: using guessed type int dword_67AE30;
// 67AE4C: using guessed type int dword_67AE4C;
// 67B0D0: using guessed type int dword_67B0D0;

//----- (0041ECF0) --------------------------------------------------------
_DWORD *ctor_097()
{
  _DWORD *result; // $v0

  result = dword_67A634;
  dword_67A868 = (int)off_66B584;
  *off_66B584 = &dword_67A864;
  dword_67A830 = (int)&dword_67A848;
  dword_67A848 = (int)&dword_67A82C;
  dword_67A814 = (int)&dword_67A82C;
  dword_67A84C = (int)&dword_67A864;
  dword_67A864 = (int)&dword_67A848;
  dword_67A82C = &dword_67A810;
  dword_67A7F8 = (int)&dword_67A810;
  dword_67A7DC = (int)&dword_67A7F4;
  dword_67A810 = &dword_67A7F4;
  dword_67A7C0 = (int)&dword_67A7D8;
  dword_67A7F4 = &dword_67A7D8;
  dword_67A7D8 = &dword_67A7BC;
  dword_67A7A4 = (int)&dword_67A7BC;
  dword_67A788 = (int)&dword_67A7A0;
  dword_67A7BC = &dword_67A7A0;
  dword_67A76C = (int)&dword_67A784;
  dword_67A7A0 = &dword_67A784;
  dword_67A750 = (int)&dword_67A768;
  dword_67A784 = &dword_67A768;
  dword_67A734 = (int)&dword_67A74C;
  dword_67A768 = &dword_67A74C;
  dword_67A718 = (int)&dword_67A730;
  dword_67A74C = &dword_67A730;
  dword_67A730 = &dword_67A714;
  dword_67A6FC = (int)&dword_67A714;
  dword_67A714 = (int)&dword_67A6F8;
  dword_67A6E0 = (int)&dword_67A6F8;
  dword_67A6F8 = (int)&dword_67A6DC;
  dword_67A6C4 = (int)&dword_67A6DC;
  dword_67A6DC = (int)&dword_67A6C0;
  dword_67A6A8 = (int)&dword_67A6C0;
  dword_67A68C = (int)&dword_67A6A4;
  dword_67A6C0 = (int)&dword_67A6A4;
  dword_67A670 = (int)&dword_67A688;
  dword_67A654 = (int)&dword_67A66C;
  dword_67A66C = (int)&dword_67A650;
  off_66B584 = (void **)dword_67A634;
  dword_67A634[0] = &_httpd_cgi_all_fun;
  dword_67A634[1] = &dword_67A650;
  dword_67A650 = (int)dword_67A634;
  dword_67A6A4 = (int)&dword_67A688;
  dword_67A688 = (int)&dword_67A66C;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67A650: using guessed type int dword_67A650;
// 67A654: using guessed type int dword_67A654;
// 67A66C: using guessed type int dword_67A66C;
// 67A670: using guessed type int dword_67A670;
// 67A688: using guessed type int dword_67A688;
// 67A68C: using guessed type int dword_67A68C;
// 67A6A4: using guessed type int dword_67A6A4;
// 67A6A8: using guessed type int dword_67A6A8;
// 67A6C0: using guessed type int dword_67A6C0;
// 67A6C4: using guessed type int dword_67A6C4;
// 67A6DC: using guessed type int dword_67A6DC;
// 67A6E0: using guessed type int dword_67A6E0;
// 67A6F8: using guessed type int dword_67A6F8;
// 67A6FC: using guessed type int dword_67A6FC;
// 67A714: using guessed type int dword_67A714;
// 67A718: using guessed type int dword_67A718;
// 67A734: using guessed type int dword_67A734;
// 67A750: using guessed type int dword_67A750;
// 67A76C: using guessed type int dword_67A76C;
// 67A788: using guessed type int dword_67A788;
// 67A7A4: using guessed type int dword_67A7A4;
// 67A7C0: using guessed type int dword_67A7C0;
// 67A7DC: using guessed type int dword_67A7DC;
// 67A7F8: using guessed type int dword_67A7F8;
// 67A814: using guessed type int dword_67A814;
// 67A830: using guessed type int dword_67A830;
// 67A848: using guessed type int dword_67A848;
// 67A84C: using guessed type int dword_67A84C;
// 67A864: using guessed type int dword_67A864;
// 67A868: using guessed type int dword_67A868;

//----- (0041EF30) --------------------------------------------------------
int *ctor_098()
{
  int *result; // $v0

  result = &dword_67A5E0;
  dword_67A61C = (int)off_66B584;
  *off_66B584 = &dword_67A618;
  dword_67A600 = (int)&dword_67A618;
  dword_67A618 = (int)&dword_67A5FC;
  off_66B584 = (void **)&dword_67A5E0;
  dword_67A5E0 = (int)&_httpd_cgi_all_fun;
  dword_67A5E4 = (int)&dword_67A5FC;
  dword_67A5FC = (int)&dword_67A5E0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67A5E0: using guessed type int dword_67A5E0;
// 67A5E4: using guessed type int dword_67A5E4;
// 67A5FC: using guessed type int dword_67A5FC;
// 67A600: using guessed type int dword_67A600;
// 67A618: using guessed type int dword_67A618;
// 67A61C: using guessed type int dword_67A61C;

//----- (0041EF80) --------------------------------------------------------
_DWORD *ctor_099()
{
  _DWORD *result; // $v0

  result = &dword_67BBB0;
  dword_67BD20 = (int)off_66B584;
  *off_66B584 = &dword_67BD1C;
  dword_67BD1C = (int)&dword_67BD00;
  dword_67BD00 = (int)&dword_67BCE4;
  dword_67BCE4 = (int)&dword_67BCC8;
  dword_67BCC8 = (int)&dword_67BCAC;
  dword_67BCAC = (int)&dword_67BC90;
  dword_67BC90 = (int)&dword_67BC74;
  dword_67BD04 = (int)&dword_67BD1C;
  dword_67BCE8 = (int)&dword_67BD00;
  dword_67BCCC = (int)&dword_67BCE4;
  dword_67BCB0 = (int)&dword_67BCC8;
  dword_67BC94 = (int)&dword_67BCAC;
  dword_67BC78 = (int)&dword_67BC90;
  dword_67BC5C = (int)&dword_67BC74;
  dword_67BC74 = (int)&dword_67BC58;
  dword_67BC08 = (int)&dword_67BC20;
  dword_67BC24 = (int)&dword_67BC3C;
  dword_67BC3C = (int)&dword_67BC20;
  dword_67BBEC = (int)&dword_67BC04;
  dword_67BC20 = &dword_67BC04;
  dword_67BBD0 = (int)&dword_67BBE8;
  dword_67BC04 = &dword_67BBE8;
  dword_67BBE8 = &dword_67BBCC;
  dword_67BC58 = (int)&dword_67BC3C;
  off_66B584 = (void **)&dword_67BBB0;
  dword_67BBB4 = (int)&dword_67BBCC;
  dword_67BC40 = (int)&dword_67BC58;
  dword_67BBB0 = &_httpd_cgi_all_fun;
  dword_67BBCC = (int)&dword_67BBB0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67BBB4: using guessed type int dword_67BBB4;
// 67BBCC: using guessed type int dword_67BBCC;
// 67BBD0: using guessed type int dword_67BBD0;
// 67BBEC: using guessed type int dword_67BBEC;
// 67BC08: using guessed type int dword_67BC08;
// 67BC24: using guessed type int dword_67BC24;
// 67BC3C: using guessed type int dword_67BC3C;
// 67BC40: using guessed type int dword_67BC40;
// 67BC58: using guessed type int dword_67BC58;
// 67BC5C: using guessed type int dword_67BC5C;
// 67BC74: using guessed type int dword_67BC74;
// 67BC78: using guessed type int dword_67BC78;
// 67BC90: using guessed type int dword_67BC90;
// 67BC94: using guessed type int dword_67BC94;
// 67BCAC: using guessed type int dword_67BCAC;
// 67BCB0: using guessed type int dword_67BCB0;
// 67BCC8: using guessed type int dword_67BCC8;
// 67BCCC: using guessed type int dword_67BCCC;
// 67BCE4: using guessed type int dword_67BCE4;
// 67BCE8: using guessed type int dword_67BCE8;
// 67BD00: using guessed type int dword_67BD00;
// 67BD04: using guessed type int dword_67BD04;
// 67BD1C: using guessed type int dword_67BD1C;
// 67BD20: using guessed type int dword_67BD20;

//----- (0041F0FC) --------------------------------------------------------
int *ctor_100()
{
  int *result; // $v0

  dword_67BB94[1] = off_66B584;
  *off_66B584 = dword_67BB94;
  dword_67BB78[1] = dword_67BB94;
  dword_67BB94[0] = dword_67BB78;
  unk_67BB60 = dword_67BB78;
  dword_67BB78[0] = &dword_67BB5C;
  dword_67BB40[1] = &dword_67BB5C;
  dword_67BB5C = (int)dword_67BB40;
  dword_67BB24[1] = dword_67BB40;
  dword_67BB40[0] = dword_67BB24;
  dword_67BB08[1] = dword_67BB24;
  dword_67BB24[0] = dword_67BB08;
  dword_67BAEC[1] = dword_67BB08;
  dword_67BB08[0] = dword_67BAEC;
  dword_67BAD0[1] = dword_67BAEC;
  dword_67BAEC[0] = dword_67BAD0;
  dword_67BAB4[1] = dword_67BAD0;
  dword_67BAD0[0] = dword_67BAB4;
  dword_67BA98[1] = dword_67BAB4;
  dword_67BAB4[0] = dword_67BA98;
  dword_67BA7C[1] = dword_67BA98;
  dword_67BA98[0] = dword_67BA7C;
  dword_67BA60[1] = dword_67BA7C;
  dword_67BA7C[0] = dword_67BA60;
  dword_67BA44[1] = dword_67BA60;
  dword_67BA60[0] = dword_67BA44;
  dword_67BA28[1] = dword_67BA44;
  dword_67BA44[0] = dword_67BA28;
  dword_67BA0C[1] = dword_67BA28;
  dword_67BA28[0] = dword_67BA0C;
  dword_67B9F0[1] = dword_67BA0C;
  dword_67BA0C[0] = dword_67B9F0;
  dword_67B9D4[1] = dword_67B9F0;
  dword_67B9F0[0] = dword_67B9D4;
  dword_67B9B8[1] = dword_67B9D4;
  dword_67B9D4[0] = dword_67B9B8;
  dword_67B99C[1] = dword_67B9B8;
  dword_67B9B8[0] = dword_67B99C;
  dword_67B980[1] = dword_67B99C;
  dword_67B99C[0] = dword_67B980;
  dword_67B964[1] = dword_67B980;
  dword_67B980[0] = dword_67B964;
  dword_67B948[1] = dword_67B964;
  dword_67B964[0] = dword_67B948;
  dword_67B92C[1] = dword_67B948;
  dword_67B948[0] = dword_67B92C;
  dword_67B92C[0] = dword_67B910;
  dword_67B910[1] = dword_67B92C;
  dword_67B8F4[1] = dword_67B910;
  unk_67B8DC = dword_67B8F4;
  dword_67B910[0] = dword_67B8F4;
  unk_67B8C0 = &dword_67B8D8;
  dword_67B8F4[0] = &dword_67B8D8;
  *(_DWORD *)algn_67B8A4 = &dword_67B8BC;
  dword_67B8D8 = (int)&dword_67B8BC;
  dword_67B8BC = (int)&dword_67B8A0;
  dword_67B8A0 = (int)&dword_67B884;
  dword_67B884 = (int)&dword_67B868;
  dword_67B868 = (int)&dword_67B84C;
  dword_67B84C = (int)&dword_67B830;
  dword_67B830 = (int)&dword_67B814;
  dword_67B814 = (int)&dword_67B7F8;
  *(_DWORD *)algn_67B754 = &dword_67B76C;
  dword_67B7F8 = (int)&dword_67B7DC;
  dword_67B738 = (int)&dword_67B750;
  dword_67B7DC = (int)&dword_67B7C0;
  unk_67B888 = &dword_67B8A0;
  dword_67B7C0 = (int)&dword_67B7A4;
  unk_67B86C = &dword_67B884;
  dword_67B7A4 = (int)&dword_67B788;
  unk_67B850 = &dword_67B868;
  dword_67B788 = (int)&dword_67B76C;
  *(_DWORD *)algn_67B834 = &dword_67B84C;
  dword_67B76C = (int)&dword_67B750;
  unk_67B818 = &dword_67B830;
  dword_67B750 = (int)&dword_67B734;
  unk_67B7FC = &dword_67B814;
  dword_67B7E0 = (int)&dword_67B7F8;
  *(_DWORD *)algn_67B7C4 = &dword_67B7DC;
  dword_67B7A8 = (int)&dword_67B7C0;
  unk_67B78C = &dword_67B7A4;
  dword_67B770 = (int)&dword_67B788;
  unk_67B71C = &dword_67B734;
  dword_67B734 = (int)&dword_67B718;
  dword_67B718 = (int)&dword_67B6FC;
  dword_67B6FC = (int)&dword_67B6E0;
  dword_67B6E0 = (int)&dword_67B6C4;
  dword_67B6C4 = (int)&dword_67B6A8;
  dword_67B690 = (int)&dword_67B6A8;
  dword_67B6A8 = (int)&dword_67B68C;
  *(_DWORD *)algn_67B674 = &dword_67B68C;
  dword_67B658 = (int)&dword_67B670;
  unk_67B63C = &dword_67B654;
  dword_67B68C = (int)&dword_67B670;
  dword_67B670 = (int)&dword_67B654;
  unk_67B620 = &dword_67B638;
  dword_67B654 = (int)&dword_67B638;
  dword_67B638 = (int)&dword_67B61C;
  *(_DWORD *)algn_67B604 = &dword_67B61C;
  dword_67B61C = (int)&dword_67B600;
  unk_67B5E8 = &dword_67B600;
  dword_67B600 = (int)&dword_67B5E4;
  unk_67B5CC = &dword_67B5E4;
  dword_67B5E4 = (int)&dword_67B5C8;
  dword_67B700 = (int)&dword_67B718;
  *(_DWORD *)algn_67B6E4 = &dword_67B6FC;
  dword_67B6C8 = (int)&dword_67B6E0;
  unk_67B6AC = &dword_67B6C4;
  unk_67B5B0 = &dword_67B5C8;
  dword_67B5C8 = (int)&dword_67B5AC;
  *(_DWORD *)algn_67B594 = &dword_67B5AC;
  dword_67B5AC = (int)&dword_67B590;
  unk_67B578 = &dword_67B590;
  dword_67B590 = (int)&dword_67B574;
  unk_67B55C = &dword_67B574;
  dword_67B574 = (int)&dword_67B558;
  unk_67B540 = &dword_67B558;
  dword_67B558 = (int)&dword_67B53C;
  *(_DWORD *)algn_67B524 = &dword_67B53C;
  dword_67B53C = (int)&dword_67B520;
  unk_67B508 = &dword_67B520;
  dword_67B520 = (int)&dword_67B504;
  unk_67B4EC = &dword_67B504;
  dword_67B504 = (int)&dword_67B4E8;
  unk_67B4D0 = &dword_67B4E8;
  dword_67B4E8 = (int)&dword_67B4CC;
  *(_DWORD *)algn_67B4B4 = &dword_67B4CC;
  dword_67B4CC = (int)&dword_67B4B0;
  unk_67B498 = &dword_67B4B0;
  dword_67B4B0 = (int)&dword_67B494;
  unk_67B47C = &dword_67B494;
  dword_67B494 = (int)&dword_67B478;
  unk_67B460 = &dword_67B478;
  dword_67B478 = (int)&dword_67B45C;
  *(_DWORD *)algn_67B444 = &dword_67B45C;
  dword_67B45C = (int)&dword_67B440;
  unk_67B428 = &dword_67B440;
  dword_67B440 = (int)&dword_67B424;
  unk_67B40C = &dword_67B424;
  dword_67B424 = (int)&dword_67B408;
  unk_67B3F0 = &dword_67B408;
  dword_67B408 = (int)&dword_67B3EC;
  *(_DWORD *)algn_67B3D4 = &dword_67B3EC;
  dword_67B3EC = (int)&dword_67B3D0;
  unk_67B3B8 = &dword_67B3D0;
  dword_67B3D0 = (int)&dword_67B3B4;
  unk_67B39C = &dword_67B3B4;
  dword_67B3B4 = (int)&dword_67B398;
  unk_67B380 = &dword_67B398;
  dword_67B398 = (int)&dword_67B37C;
  *(_DWORD *)algn_67B364 = &dword_67B37C;
  dword_67B37C = (int)&dword_67B360;
  unk_67B348 = &dword_67B360;
  dword_67B360 = (int)&dword_67B344;
  unk_67B32C = &dword_67B344;
  dword_67B344 = (int)&dword_67B328;
  result = &dword_67B30C;
  off_66B584 = (void **)&dword_67B30C;
  unk_67B310 = &dword_67B328;
  dword_67B328 = (int)&dword_67B30C;
  dword_67B30C = (int)&_httpd_cgi_all_fun;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67B30C: using guessed type int dword_67B30C;
// 67B328: using guessed type int dword_67B328;
// 67B344: using guessed type int dword_67B344;
// 67B360: using guessed type int dword_67B360;
// 67B37C: using guessed type int dword_67B37C;
// 67B398: using guessed type int dword_67B398;
// 67B3B4: using guessed type int dword_67B3B4;
// 67B3D0: using guessed type int dword_67B3D0;
// 67B3EC: using guessed type int dword_67B3EC;
// 67B408: using guessed type int dword_67B408;
// 67B424: using guessed type int dword_67B424;
// 67B440: using guessed type int dword_67B440;
// 67B45C: using guessed type int dword_67B45C;
// 67B478: using guessed type int dword_67B478;
// 67B494: using guessed type int dword_67B494;
// 67B4B0: using guessed type int dword_67B4B0;
// 67B4CC: using guessed type int dword_67B4CC;
// 67B4E8: using guessed type int dword_67B4E8;
// 67B504: using guessed type int dword_67B504;
// 67B520: using guessed type int dword_67B520;
// 67B53C: using guessed type int dword_67B53C;
// 67B558: using guessed type int dword_67B558;
// 67B574: using guessed type int dword_67B574;
// 67B590: using guessed type int dword_67B590;
// 67B5AC: using guessed type int dword_67B5AC;
// 67B5C8: using guessed type int dword_67B5C8;
// 67B5E4: using guessed type int dword_67B5E4;
// 67B600: using guessed type int dword_67B600;
// 67B61C: using guessed type int dword_67B61C;
// 67B638: using guessed type int dword_67B638;
// 67B654: using guessed type int dword_67B654;
// 67B658: using guessed type int dword_67B658;
// 67B670: using guessed type int dword_67B670;
// 67B68C: using guessed type int dword_67B68C;
// 67B690: using guessed type int dword_67B690;
// 67B6A8: using guessed type int dword_67B6A8;
// 67B6C4: using guessed type int dword_67B6C4;
// 67B6C8: using guessed type int dword_67B6C8;
// 67B6E0: using guessed type int dword_67B6E0;
// 67B6FC: using guessed type int dword_67B6FC;
// 67B700: using guessed type int dword_67B700;
// 67B718: using guessed type int dword_67B718;
// 67B734: using guessed type int dword_67B734;
// 67B738: using guessed type int dword_67B738;
// 67B750: using guessed type int dword_67B750;
// 67B76C: using guessed type int dword_67B76C;
// 67B770: using guessed type int dword_67B770;
// 67B788: using guessed type int dword_67B788;
// 67B7A4: using guessed type int dword_67B7A4;
// 67B7A8: using guessed type int dword_67B7A8;
// 67B7C0: using guessed type int dword_67B7C0;
// 67B7DC: using guessed type int dword_67B7DC;
// 67B7E0: using guessed type int dword_67B7E0;
// 67B7F8: using guessed type int dword_67B7F8;
// 67B814: using guessed type int dword_67B814;
// 67B830: using guessed type int dword_67B830;
// 67B84C: using guessed type int dword_67B84C;
// 67B868: using guessed type int dword_67B868;
// 67B884: using guessed type int dword_67B884;
// 67B8A0: using guessed type int dword_67B8A0;
// 67B8BC: using guessed type int dword_67B8BC;
// 67B8D8: using guessed type int dword_67B8D8;
// 67BB5C: using guessed type int dword_67BB5C;

//----- (0041FA50) --------------------------------------------------------
_DWORD *ctor_101()
{
  _DWORD *result; // $v0

  result = &dword_67B14C;
  dword_67B2F4 = (int)off_66B584;
  *off_66B584 = &dword_67B2F0;
  dword_67B2D8 = (int)&dword_67B2F0;
  dword_67B2F0 = (int)&dword_67B2D4;
  dword_67B2D4 = (int)&dword_67B2B8;
  dword_67B2B8 = (int)&dword_67B29C;
  dword_67B29C = (int)&dword_67B280;
  dword_67B280 = (int)&dword_67B264;
  dword_67B2BC = (int)&dword_67B2D4;
  dword_67B2A0 = (int)&dword_67B2B8;
  dword_67B284 = (int)&dword_67B29C;
  dword_67B268 = (int)&dword_67B280;
  dword_67B24C = (int)&dword_67B264;
  dword_67B264 = (int)&dword_67B248;
  dword_67B230 = (int)&dword_67B248;
  dword_67B214 = (int)&dword_67B22C;
  dword_67B248 = (int)&dword_67B22C;
  dword_67B1F8 = (int)&dword_67B210;
  dword_67B22C = &dword_67B210;
  dword_67B1DC = (int)&dword_67B1F4;
  dword_67B210 = &dword_67B1F4;
  dword_67B1C0 = (int)&dword_67B1D8;
  dword_67B1F4 = &dword_67B1D8;
  dword_67B1A4 = (int)&dword_67B1BC;
  dword_67B1D8 = &dword_67B1BC;
  dword_67B1BC = &dword_67B1A0;
  dword_67B188 = (int)&dword_67B1A0;
  dword_67B1A0 = (int)&dword_67B184;
  dword_67B16C = (int)&dword_67B184;
  dword_67B184 = (int)&dword_67B168;
  off_66B584 = (void **)&dword_67B14C;
  dword_67B14C = &_httpd_cgi_all_fun;
  dword_67B150 = (int)&dword_67B168;
  dword_67B168 = (int)&dword_67B14C;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67B150: using guessed type int dword_67B150;
// 67B168: using guessed type int dword_67B168;
// 67B16C: using guessed type int dword_67B16C;
// 67B184: using guessed type int dword_67B184;
// 67B188: using guessed type int dword_67B188;
// 67B1A0: using guessed type int dword_67B1A0;
// 67B1A4: using guessed type int dword_67B1A4;
// 67B1C0: using guessed type int dword_67B1C0;
// 67B1DC: using guessed type int dword_67B1DC;
// 67B1F8: using guessed type int dword_67B1F8;
// 67B214: using guessed type int dword_67B214;
// 67B230: using guessed type int dword_67B230;
// 67B248: using guessed type int dword_67B248;
// 67B24C: using guessed type int dword_67B24C;
// 67B264: using guessed type int dword_67B264;
// 67B268: using guessed type int dword_67B268;
// 67B280: using guessed type int dword_67B280;
// 67B284: using guessed type int dword_67B284;
// 67B29C: using guessed type int dword_67B29C;
// 67B2A0: using guessed type int dword_67B2A0;
// 67B2B8: using guessed type int dword_67B2B8;
// 67B2BC: using guessed type int dword_67B2BC;
// 67B2D4: using guessed type int dword_67B2D4;
// 67B2D8: using guessed type int dword_67B2D8;
// 67B2F0: using guessed type int dword_67B2F0;
// 67B2F4: using guessed type int dword_67B2F4;

//----- (0041FC04) --------------------------------------------------------
int *ctor_102()
{
  void **v0; // $a0
  int *result; // $v0

  v0 = off_66B584;
  result = &dword_67B130;
  off_66B584 = (void **)&dword_67B130;
  dword_67B130 = (int)&_httpd_cgi_all_fun;
  dword_67B134 = (int)v0;
  *v0 = &dword_67B130;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67B130: using guessed type int dword_67B130;
// 67B134: using guessed type int dword_67B134;

//----- (0041FC34) --------------------------------------------------------
_DWORD *ctor_103()
{
  _DWORD *result; // $v0

  result = &dword_67BD50;
  dword_67BEA4 = (int)off_66B584;
  *off_66B584 = &dword_67BEA0;
  dword_67BEA0 = (int)&dword_67BE84;
  dword_67BE84 = (int)&dword_67BE68;
  dword_67BE68 = (int)&dword_67BE4C;
  dword_67BE4C = (int)&dword_67BE30;
  dword_67BE30 = (int)&dword_67BE14;
  dword_67BE14 = (int)&dword_67BDF8;
  dword_67BDF8 = (int)&dword_67BDDC;
  dword_67BE88 = (int)&dword_67BEA0;
  dword_67BE6C = (int)&dword_67BE84;
  dword_67BE50 = (int)&dword_67BE68;
  dword_67BE34 = (int)&dword_67BE4C;
  dword_67BE18 = (int)&dword_67BE30;
  dword_67BDFC = (int)&dword_67BE14;
  dword_67BDE0 = (int)&dword_67BDF8;
  dword_67BDC4 = (int)&dword_67BDDC;
  dword_67BD70 = (int)&dword_67BD88;
  dword_67BD8C = (int)&dword_67BDA4;
  dword_67BDA4 = (int)&dword_67BD88;
  dword_67BD54 = (int)&dword_67BD6C;
  dword_67BD88 = &dword_67BD6C;
  dword_67BDDC = (int)&dword_67BDC0;
  dword_67BDA8 = (int)&dword_67BDC0;
  dword_67BDC0 = (int)&dword_67BDA4;
  off_66B584 = (void **)&dword_67BD50;
  dword_67BD50 = &_httpd_cgi_all_fun;
  dword_67BD6C = &dword_67BD50;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67BD54: using guessed type int dword_67BD54;
// 67BD70: using guessed type int dword_67BD70;
// 67BD8C: using guessed type int dword_67BD8C;
// 67BDA4: using guessed type int dword_67BDA4;
// 67BDA8: using guessed type int dword_67BDA8;
// 67BDC0: using guessed type int dword_67BDC0;
// 67BDC4: using guessed type int dword_67BDC4;
// 67BDDC: using guessed type int dword_67BDDC;
// 67BDE0: using guessed type int dword_67BDE0;
// 67BDF8: using guessed type int dword_67BDF8;
// 67BDFC: using guessed type int dword_67BDFC;
// 67BE14: using guessed type int dword_67BE14;
// 67BE18: using guessed type int dword_67BE18;
// 67BE30: using guessed type int dword_67BE30;
// 67BE34: using guessed type int dword_67BE34;
// 67BE4C: using guessed type int dword_67BE4C;
// 67BE50: using guessed type int dword_67BE50;
// 67BE68: using guessed type int dword_67BE68;
// 67BE6C: using guessed type int dword_67BE6C;
// 67BE84: using guessed type int dword_67BE84;
// 67BE88: using guessed type int dword_67BE88;
// 67BEA0: using guessed type int dword_67BEA0;
// 67BEA4: using guessed type int dword_67BEA4;

//----- (0041FD94) --------------------------------------------------------
int *ctor_104()
{
  int *result; // $v0

  result = &dword_67BED0;
  dword_67BF0C = (int)off_66B584;
  *off_66B584 = &dword_67BF08;
  dword_67BEF0 = (int)&dword_67BF08;
  dword_67BF08 = (int)&dword_67BEEC;
  off_66B584 = (void **)&dword_67BED0;
  dword_67BED0 = (int)&_httpd_cgi_all_fun;
  dword_67BED4 = (int)&dword_67BEEC;
  dword_67BEEC = (int)&dword_67BED0;
  return result;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;
// 66B584: using guessed type void **off_66B584;
// 67BED0: using guessed type int dword_67BED0;
// 67BED4: using guessed type int dword_67BED4;
// 67BEEC: using guessed type int dword_67BEEC;
// 67BEF0: using guessed type int dword_67BEF0;
// 67BF08: using guessed type int dword_67BF08;
// 67BF0C: using guessed type int dword_67BF0C;

//----- (0041FDF0) --------------------------------------------------------
int start()
{
  int v0; // $v0

  v0 = sub_41FE04();
  __asm { dsll    $ra, $at, 23 }
  if ( v0 >= _$AT )
    __trap(0x3F8u);
  return sub_41FE04();
}
// 41FDFC: variable '_$AT' is possibly undefined

//----- (0041FE04) --------------------------------------------------------
int sub_41FE04()
{
  _DWORD *v0; // $ra
  int v1; // $a0
  void *v3; // [sp+8h] [-20h]
  int v4; // [sp+28h] [+0h] BYREF

  ((void (__fastcall *)(int *, char *))((char *)v0 + v0[1] - *v0))(&v4, (char *)v0 + v0[2] - *v0);
  _libc_start_main(main, *(_DWORD *)v1, (char **)(v1 + 4), init_proc, (void (*)(void))term_proc, 0, v3);
  return sub_41FE70();
}
// 41FE18: variable 'v0' is possibly undefined
// 41FE3C: variable 'v1' is possibly undefined
// 41FE5C: variable 'v3' is possibly undefined

//----- (0041FE70) --------------------------------------------------------
int sub_41FE70()
{
  int result; // $v0
  unsigned int i; // $v0
  bool v2; // dc
  int v3; // $v0

  result = (unsigned __int8)byte_67D070;
  if ( !byte_67D070 )
  {
    for ( i = dword_67D074; ; i = dword_67D074 )
    {
      v2 = i >= &dword_66523C - dword_665238 - 1;
      v3 = i + 1;
      if ( v2 )
        break;
      dword_67D074 = v3;
      ((void (*)(void))dword_665238[v3])();
    }
    result = 1;
    if ( __deregister_frame_info )
    {
      __deregister_frame_info(&unk_65503C);
      result = 1;
    }
    byte_67D070 = 1;
  }
  return result;
}
// 655070: using guessed type int __fastcall __deregister_frame_info(_DWORD);
// 665238: using guessed type int dword_665238[];
// 66523C: using guessed type int dword_66523C;
// 67D070: using guessed type char byte_67D070;
// 67D074: using guessed type int dword_67D074;

//----- (0041FF2C) --------------------------------------------------------
int (__fastcall *sub_41FF2C())(_DWORD, _DWORD)
{
  int (__fastcall *result)(_DWORD, _DWORD); // $v0

  result = __register_frame_info;
  if ( __register_frame_info )
    result = (int (__fastcall *)(_DWORD, _DWORD))__register_frame_info(&unk_65503C, &unk_67D078);
  return result;
}
// 655060: using guessed type int __fastcall __register_frame_info(_DWORD, _DWORD);

//----- (0041FF60) --------------------------------------------------------
int __fastcall _httpd_parm_do(char *a1)
{
  int result; // $v0
  char *v2; // $a0
  int v3; // $a2
  unsigned int v4; // $v1
  int v5; // $t1
  unsigned int v6; // $a3
  _BOOL4 v7; // $t3
  unsigned int v8; // $t4
  unsigned int v9; // $v0
  char v10; // $v0
  unsigned int v11; // $v1
  int v12; // $v1
  _BYTE *v13; // $v0

  result = *a1;
  v2 = a1 + 1;
  if ( result )
  {
    while ( result != 37 )
    {
LABEL_3:
      result = *v2;
LABEL_4:
      ++v2;
      if ( !result )
        return result;
    }
    result = *v2;
    v3 = (unsigned __int8)*v2;
    v4 = (unsigned __int8)(v3 - 48);
    if ( v4 < 0xA )
    {
      v5 = (unsigned __int8)v2[1];
      v6 = (unsigned __int8)(v5 - 48);
      v7 = v6 < 0xA;
      v8 = v5 & 0xFFFFFFDF;
      if ( v6 < 0xA )
      {
        v10 = v6 + 16 * v4;
        goto LABEL_15;
      }
    }
    else
    {
      if ( (v3 & 0xFFFFFFDF) - 65 >= 6 )
        goto LABEL_4;
      v5 = (unsigned __int8)v2[1];
      v6 = (unsigned __int8)(v5 - 48);
      v7 = v6 < 0xA;
      v8 = v5 & 0xFFFFFFDF;
      if ( v6 < 0xA )
      {
        v9 = v3 - 97;
        goto LABEL_10;
      }
    }
    if ( v8 - 65 >= 6 )
      goto LABEL_4;
    v9 = v3 - 97;
    if ( v4 < 0xA )
    {
      v10 = 16 * v4;
      v11 = v5 - 97;
      goto LABEL_22;
    }
LABEL_10:
    if ( v9 < 6 )
    {
      v10 = 16 * (v3 - 87);
    }
    else
    {
      v10 = 0;
      if ( (unsigned int)(v3 - 65) < 6 )
        v10 = 16 * (v3 - 55);
    }
    v11 = v5 - 97;
    if ( v7 )
    {
      v10 += v6;
LABEL_15:
      v12 = v2[2];
      *(v2 - 1) = v10;
      v13 = v2;
      if ( v12 )
      {
        do
        {
          *v13++ = v12;
          LOBYTE(v12) = v13[2];
        }
        while ( (_BYTE)v12 );
      }
      *v13 = 0;
      goto LABEL_3;
    }
LABEL_22:
    if ( v11 < 6 )
    {
      v10 += v5 - 87;
    }
    else if ( (unsigned int)(v5 - 65) < 6 )
    {
      v10 += v5 - 55;
    }
    goto LABEL_15;
  }
  return result;
}

//----- (004200EC) --------------------------------------------------------
char *__fastcall httpd_find_type(const char *a1)
{
  char *v1; // $v0
  int v2; // $v0
  char *result; // $v0

  v1 = strrchr(a1, 46);
  if ( !v1 )
    return httpd_file_xtypes[0];
  switch ( v1[1] )
  {
    case 'c':
      return off_6676E0[0];
    case 'e':
    case 'o':
    case 'r':
      return off_667704[0];
    case 'g':
      return off_6676E4[0];
    case 'i':
      return off_6676F0[0];
    case 'j':
      if ( v1[2] == 112 )
        result = off_6676E8[0];
      else
        result = off_6676F4[0];
      return result;
    case 'p':
      return off_6676EC[0];
    case 's':
      v2 = v1[2];
      if ( v2 == 119 )
      {
        result = off_667708[0];
      }
      else
      {
        if ( v2 != 118 )
          return httpd_file_xtypes[0];
        result = off_66770C;
      }
      break;
    case 't':
      if ( v1[2] == 97 )
        result = off_667700[0];
      else
        result = off_6676F8[0];
      return result;
    case 'x':
      return off_6676DC[0];
    case 'z':
      return off_6676FC[0];
    default:
      return httpd_file_xtypes[0];
  }
  return result;
}
// 6676D8: using guessed type char *httpd_file_xtypes[14];
// 6676DC: using guessed type char *off_6676DC[13];
// 6676E0: using guessed type char *off_6676E0[12];
// 6676E4: using guessed type char *off_6676E4[11];
// 6676E8: using guessed type char *off_6676E8[10];
// 6676EC: using guessed type char *off_6676EC[9];
// 6676F0: using guessed type char *off_6676F0[8];
// 6676F4: using guessed type char *off_6676F4[7];
// 6676F8: using guessed type char *off_6676F8[6];
// 6676FC: using guessed type char *off_6676FC[5];
// 667700: using guessed type char *off_667700[4];
// 667704: using guessed type char *off_667704[3];
// 667708: using guessed type char *off_667708[2];
// 66770C: using guessed type char *off_66770C;

//----- (004202B4) --------------------------------------------------------
char *httpd_find_type2_init()
{
  char *result; // $v0
  unsigned __int8 *v1; // $a0
  void **v2; // $s0
  void **v3; // $v1
  bool v4; // dc

  result = (char *)&file_type2_str_hash;
  do
  {
    *(_DWORD *)result = 0;
    result += 4;
  }
  while ( result != gl_httpd_high_adminpwd_md5 );
  v1 = (unsigned __int8 *)file_type2_str;
  v2 = (void **)&unk_66619C;
  if ( file_type2_str )
  {
    do
    {
      v3 = (void **)((char *)&file_type2_str_hash + 4 * get_name_hash(v1));
      result = (char *)*v3;
      v4 = *v3 == 0;
      *v2 = *v3;
      if ( !v4 )
        *((_DWORD *)result + 1) = v2;
      *v3 = v2;
      v2[1] = v3;
      v2 += 4;
      v1 = (unsigned __int8 *)*(v2 - 2);
    }
    while ( v1 );
  }
  return result;
}
// 666194: using guessed type char **file_type2_str;

//----- (00420364) --------------------------------------------------------
char *__fastcall httpd_find_ext_name(const char *a1)
{
  char *v1; // $v0
  char *result; // $v0

  v1 = strchr(a1, 63);
  if ( v1 )
    *v1 = 0;
  result = strrchr(a1, 46);
  if ( result )
    ++result;
  return result;
}

//----- (004203CC) --------------------------------------------------------
const char *__fastcall httpd_find_type2(const char *a1)
{
  char *v1; // $v0
  char *v3; // $s2
  char *v4; // $v0
  const char *v5; // $s1
  _DWORD *v6; // $s0
  char *v8; // $v0

  v1 = strchr(a1, 63);
  v3 = v1;
  if ( v1 )
  {
    *v1 = 0;
    v4 = strrchr(a1, 46);
    v5 = v4 + 1;
    if ( v4 )
    {
      v6 = (_DWORD *)file_type2_str_hash[get_name_hash((unsigned __int8 *)v4 + 1)];
      if ( v6 )
        goto LABEL_6;
      *v3 = 63;
      return "application/octet-stream";
    }
LABEL_11:
    *v3 = 63;
    return "application/octet-stream";
  }
  v8 = strrchr(a1, 46);
  v5 = v8 + 1;
  if ( v8 )
  {
    v6 = (_DWORD *)file_type2_str_hash[get_name_hash((unsigned __int8 *)v8 + 1)];
    if ( v6 )
    {
      do
      {
LABEL_6:
        if ( !strcmp((const char *)*(v6 - 2), v5) )
        {
          if ( v3 )
            *v3 = 63;
          return (const char *)*(v6 - 1);
        }
        v6 = (_DWORD *)*v6;
      }
      while ( v6 );
      if ( !v3 )
        return "application/octet-stream";
      goto LABEL_11;
    }
  }
  return "application/octet-stream";
}

//----- (0042054C) --------------------------------------------------------
void __fastcall strlower(char *a1)
{
  int v2; // $a0
  _BYTE *v3; // $s0
  unsigned int v4; // $v1

  if ( a1 )
  {
    v2 = *a1;
    v3 = a1;
    if ( v2 )
    {
      v4 = v2 - 65;
      do
      {
        if ( v4 < 0x1A )
          *v3 = tolower(v2);
        v2 = (char)*++v3;
        v4 = v2 - 65;
      }
      while ( *v3 );
    }
    *v3 = 0;
  }
}

//----- (004205E4) --------------------------------------------------------
char *__fastcall unescape(char *a1)
{
  char *result; // $v0
  int v3; // $v0
  int v4; // [sp+18h] [-Ch] BYREF

  while ( 1 )
  {
    result = strpbrk(a1, "%+");
    a1 = result;
    if ( !result )
      break;
    v3 = *result;
    if ( v3 == 37 )
    {
      sscanf(a1 + 1, "%02x", &v4);
      *a1 = v4;
      strcpy(a1 + 1, a1 + 3);
      ++a1;
    }
    else if ( v3 == 43 )
    {
      ++a1;
    }
  }
  return result;
}

//----- (004206D0) --------------------------------------------------------
int __fastcall do_file(const char *a1, int a2, int a3)
{
  FILE *v5; // $s3
  int v6; // $s0
  int v7; // $v0
  void *v8; // $a0
  char v10[1028]; // [sp+18h] [-404h] BYREF

  v5 = fopen(a1, "r");
  if ( !v5 )
    return 0;
  v6 = 0;
  while ( 1 )
  {
    v7 = fread(v10, 1u, 0x400u, v5);
    v8 = (void *)(a2 + v6);
    if ( v7 <= 0 || a3 < v6 + v7 )
      break;
    v6 += v7;
    memcpy(v8, v10, v7);
  }
  fclose(v5);
  return v6;
}

//----- (004207C0) --------------------------------------------------------
int httpd_get_cgi()
{
  return 0;
}

//----- (004207C8) --------------------------------------------------------
int __fastcall httpd_get_json_parm(int a1, int a2)
{
  int v2; // $a0
  int result; // $v0

  v2 = *(_DWORD *)(a1 + 48);
  if ( v2 )
    result = cJSON_GetObjectItem(v2, a2);
  else
    result = 0;
  return result;
}
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (004207FC) --------------------------------------------------------
char *__fastcall httpd_get_parm(int a1, char *a2)
{
  char *v2; // $v0
  int v3; // $t0
  int v4; // $a2
  char *v5; // $v1
  int v6; // $a3
  char *v7; // $v0
  char *v8; // $s0
  int v9; // $v0
  int v10; // $s0
  char *result; // $v0

  v2 = *(char **)(a1 + 52);
  v3 = a1 + 56;
  if ( v2 )
  {
    while ( 1 )
    {
      v4 = *v2;
      v5 = a2;
      v6 = *a2;
      if ( v6 == v4 )
      {
        v7 = v2 + 1;
        do
        {
          ++v5;
          v4 = *v7;
          v6 = *v5;
          ++v7;
        }
        while ( v4 == v6 );
        v2 = v7 - 1;
      }
      if ( !v6 )
      {
        v8 = v2 + 1;
        if ( v4 == 61 )
          break;
      }
      v3 += 4;
      v2 = *(char **)(v3 - 4);
      if ( !v2 )
        goto LABEL_9;
    }
    _httpd_parm_do(v2 + 1);
    result = v8;
  }
  else
  {
LABEL_9:
    v9 = httpd_get_json_parm(a1, (int)a2);
    v10 = v9;
    if ( v9 && cJSON_IsString(v9) )
      result = *(char **)(v10 + 16);
    else
      result = 0;
  }
  return result;
}
// 6A8248: using guessed type int __fastcall cJSON_IsString(_DWORD);

//----- (00420900) --------------------------------------------------------
char *__fastcall sub_420900(int a1, char *a2)
{
  char *v3; // $v0
  int v5; // $a0
  int v6; // $v0
  char *v7; // $s0
  char *result; // $v0

  v3 = httpd_get_parm(a1, a2);
  v5 = a1;
  v7 = v3;
  v6 = httpd_get_json_parm(v5, (int)a2);
  if ( v7 || !v6 )
    result = v7;
  else
    result = *(char **)(v6 + 16);
  return result;
}

//----- (00420A08) --------------------------------------------------------
int __fastcall httpd_send_data(int a1)
{
  int v2; // $v0
  int v3; // $a1
  int v4; // $v0

  if ( *(_DWORD *)(a1 + 209984) )
    v2 = https_ssl_write(a1);
  else
    v2 = send(*(_DWORD *)(a1 + 205416), *(const void **)(a1 + 205368), *(_DWORD *)(a1 + 205380), 0);
  if ( v2 >= 0 )
  {
    v3 = *(_DWORD *)(a1 + 205368) + v2;
    v4 = *(_DWORD *)(a1 + 205380) - v2;
    *(_DWORD *)(a1 + 205368) = v3;
    *(_DWORD *)(a1 + 205380) = v4;
    if ( v4 <= 0 || !httpd_conn_epoll_write(a1) )
      return 0;
  }
  httpd_conn_close((int *)a1);
  return -1;
}

//----- (00420AE4) --------------------------------------------------------
int __fastcall httpd_send_data_alloc(int a1, char *a2, signed int a3)
{
  int v6; // $s1
  int result; // $v0
  int v8; // $s2
  void *v9; // $v0
  int *v10; // $v0
  char *v11; // $v0

  if ( *(_DWORD *)(a1 + 209984) )
    v6 = https_ssl_write(a1);
  else
    v6 = send(*(_DWORD *)(a1 + 205416), a2, a3, 0);
  if ( v6 < 0 )
  {
    if ( debug_level > 0 )
    {
      v10 = _errno_location();
      v11 = strerror(*v10);
      printf("%s:%d httpd_send_data_alloc failed: %s\n", "httpd_send_data_alloc", 936, v11);
    }
    goto LABEL_9;
  }
  if ( v6 >= a3 )
  {
    *(_DWORD *)(a1 + 205380) = 0;
    return 0;
  }
  v8 = a3 - v6;
  _mem_malloc(v8, "httpd_send_data_alloc", 943);
  *(_DWORD *)(a1 + 205372) = v9;
  if ( !v9
    || (memcpy(v9, &a2[v6], v8),
        *(_DWORD *)(a1 + 205368) = *(_DWORD *)(a1 + 205372),
        *(_BYTE *)(a1 + 42) = 1,
        *(_DWORD *)(a1 + 205380) = v8,
        (result = httpd_conn_epoll_write(a1)) != 0) )
  {
LABEL_9:
    httpd_conn_close((int *)a1);
    result = -1;
  }
  return result;
}
// 420BAC: variable 'v9' is possibly undefined
// 67D0BC: using guessed type int debug_level;

//----- (00420C98) --------------------------------------------------------
int __fastcall httpd_send_data_not_alloc(int a1, char *a2, signed int a3)
{
  int v6; // $v0
  int result; // $v0
  int *v8; // $v0
  char *v9; // $v0

  if ( *(_DWORD *)(a1 + 209984) )
    v6 = https_ssl_write(a1);
  else
    v6 = send(*(_DWORD *)(a1 + 205416), a2, a3, 0);
  if ( v6 < 0 )
  {
    if ( debug_level > 0 )
    {
      v8 = _errno_location();
      v9 = strerror(*v8);
      printf("%s:%d httpd_send_data_alloc failed: %s\n", "httpd_send_data_not_alloc", 982, v9);
    }
    _mem_free(a2);
    goto LABEL_8;
  }
  if ( v6 >= a3 )
  {
    *(_DWORD *)(a1 + 205380) = 0;
    _mem_free(a2);
    return 0;
  }
  *(_DWORD *)(a1 + 205368) = &a2[v6];
  *(_DWORD *)(a1 + 205372) = a2;
  *(_BYTE *)(a1 + 42) = 1;
  *(_DWORD *)(a1 + 205380) = a3 - v6;
  result = httpd_conn_epoll_write(a1);
  if ( result )
  {
LABEL_8:
    httpd_conn_close((int *)a1);
    result = -1;
  }
  return result;
}
// 67D0BC: using guessed type int debug_level;

//----- (00420E3C) --------------------------------------------------------
int __fastcall httpd_send_data_const(int a1, char *a2, signed int a3)
{
  int v6; // $v0
  int result; // $v0
  int *v8; // $v0
  char *v9; // $v0

  if ( *(_DWORD *)(a1 + 209984) )
    v6 = https_ssl_write(a1);
  else
    v6 = send(*(_DWORD *)(a1 + 205416), a2, a3, 0);
  if ( v6 < 0 )
  {
    if ( debug_level > 0 )
    {
      v8 = _errno_location();
      v9 = strerror(*v8);
      printf("%s:%d httpd_send_data_alloc failed: %s\n", "httpd_send_data_const", 1022, v9);
    }
    goto LABEL_8;
  }
  if ( v6 >= a3 )
  {
    *(_DWORD *)(a1 + 205380) = 0;
    return 0;
  }
  *(_DWORD *)(a1 + 205368) = &a2[v6];
  *(_DWORD *)(a1 + 205372) = a2;
  *(_BYTE *)(a1 + 42) = 0;
  *(_DWORD *)(a1 + 205380) = a3 - v6;
  result = httpd_conn_epoll_write(a1);
  if ( result )
  {
LABEL_8:
    httpd_conn_close((int *)a1);
    result = -1;
  }
  return result;
}
// 67D0BC: using guessed type int debug_level;

//----- (00420FA0) --------------------------------------------------------
int __fastcall httpd_send_data_file(int a1, const char *a2, int a3, int a4)
{
  FILE *v6; // $v0
  FILE *v8; // $s1
  int result; // $v0

  v6 = fopen(a2, "rb");
  if ( !v6 )
    goto LABEL_3;
  v8 = v6;
  fseek(v6, a4, 0);
  *(_DWORD *)(a1 + 205368) = 0;
  *(_DWORD *)(a1 + 205592) = v8;
  *(_DWORD *)(a1 + 209692) = 0;
  *(_BYTE *)(a1 + 42) = 2;
  *(_DWORD *)(a1 + 205376) = 0;
  *(_DWORD *)(a1 + 205380) = a3;
  result = httpd_conn_epoll_write(a1);
  if ( result )
  {
LABEL_3:
    httpd_conn_close((int *)a1);
    result = -1;
  }
  return result;
}

//----- (00421080) --------------------------------------------------------
bool __fastcall hs_addr_loopback(int a1)
{
  int v1; // $a0
  int v2; // $s0
  int v3; // $s1
  uint32_t v4; // $v0
  int v6; // $s0

  v1 = a1 + 196608;
  if ( *(_BYTE *)(v1 + 8852) )
  {
    v2 = *(_DWORD *)(v1 + 8868);
    v3 = *(_DWORD *)(v1 + 8856) | *(_DWORD *)(v1 + 8860) | *(_DWORD *)(v1 + 8864);
    v4 = v2 ^ htonl(1u) | v3;
  }
  else
  {
    v6 = *(_DWORD *)(v1 + 8856);
    v4 = v6 ^ htonl(0x7F000001u);
  }
  return v4 == 0;
}

//----- (0042112C) --------------------------------------------------------
int __fastcall httpd_send_data_file_ll(int a1, const char *a2, int a3, int a4, int a5)
{
  FILE *v8; // $v0
  FILE *v10; // $s1
  int result; // $v0

  v8 = fopen(a2, "rb");
  if ( v8 )
  {
    v10 = v8;
    fseek(v8, a5, 0);
    *(_DWORD *)(a1 + 205368) = 0;
    *(_DWORD *)(a1 + 205592) = v10;
    *(_DWORD *)(a1 + 209692) = 0;
    *(_BYTE *)(a1 + 42) = 2;
    *(_DWORD *)(a1 + 205376) = 1;
    *(_DWORD *)(a1 + 205384) = a3;
    *(_DWORD *)(a1 + 205388) = a4;
    result = httpd_conn_epoll_write(a1);
    if ( result )
    {
      httpd_conn_close((int *)a1);
      result = -1;
    }
  }
  else
  {
    perror(a2);
    httpd_conn_close((int *)a1);
    result = -1;
  }
  return result;
}

//----- (00421258) --------------------------------------------------------
int __fastcall httpd_check_parm_auth_xx(int a1)
{
  char *v2; // $s0
  char *v3; // $s1
  size_t v4; // $v0
  int *v5; // $s0
  int result; // $v0
  const char **v7; // $s2
  char *v8; // $v0
  int v9; // $v0
  int v10; // $a0
  size_t v11; // $v0
  int v12; // $s2
  int v13; // $s0
  unsigned __int8 v14; // $v0
  int v15; // $a0
  unsigned __int8 v16; // $s0
  const char *v17; // $s0
  bool v18; // dc
  char v19[256]; // [sp+20h] [-2C0h] BYREF
  char v20[128]; // [sp+120h] [-1C0h] BYREF
  char v21[128]; // [sp+1A0h] [-140h] BYREF
  char v22[128]; // [sp+220h] [-C0h] BYREF
  const char *v23; // [sp+2A0h] [-40h] BYREF
  int v24; // [sp+2A4h] [-3Ch]
  const char *v25; // [sp+2A8h] [-38h]
  const char *v26; // [sp+2ACh] [-34h]
  int v27; // [sp+2B0h] [-30h]
  int v28; // [sp+2B4h] [-2Ch]
  int v29; // [sp+2B8h] [-28h]
  int v30[6]; // [sp+2BCh] [-24h] BYREF
  int v31; // [sp+2D4h] [-Ch] BYREF
  char v32[4]; // [sp+2D8h] [-8h] BYREF
  char *v33; // [sp+2DCh] [-4h]

  v2 = httpd_get_parm(a1, "wt_wys_token");
  if ( v2 || (result = (int)httpd_get_parm(a1, "_wtoken"), (v2 = (char *)result) != 0) )
  {
    memset(v19, 0, sizeof(v19));
    memset(v22, 0, sizeof(v22));
    v30[0] = 0;
    v30[1] = 0;
    v30[2] = 0;
    v30[3] = 0;
    v30[4] = 0;
    v30[5] = 0;
    v31 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    memset(v21, 0, sizeof(v21));
    v3 = v20;
    memset(v20, 0, sizeof(v20));
    v4 = strlen(v2);
    base64_decode(v2, v19, v4);
    v5 = v30;
    result = split_string(v19, 38, v30, 6) < 4;
    v7 = &v23;
    if ( !result )
    {
      do
      {
        split_string(*v5, 61, v32, 2);
        v8 = v33;
        ++v5;
        if ( !v33 )
          v8 = "";
        *v7++ = v8;
      }
      while ( &v31 != v5 );
      v9 = StrToIp(v27);
      v10 = v28;
      *(_DWORD *)(a1 + 205452) = v9;
      *(_WORD *)(a1 + 205448) = J_atoi(v10);
      sq_file_get_ssid_en(v22, 128);
      if ( !strcmp(v22, "no-ssid") )
        memset(v22, 0, sizeof(v22));
      sprintf(v21, "%s%s%s", v22, v25, v26);
      v11 = strlen(v21);
      getMD5Str(v21, v11, v20);
      v12 = v24;
LABEL_9:
      ++v12;
      while ( 1 )
      {
        result = *(unsigned __int8 *)(v12 - 1);
        v13 = (unsigned __int8)*v3++;
        if ( !*(_BYTE *)(v12 - 1) )
          break;
        if ( !*(v3 - 1) )
          return result;
        if ( result == v13 )
          goto LABEL_9;
        v14 = tolower(*(unsigned __int8 *)(v12 - 1));
        v15 = v13;
        v16 = v14;
        result = (unsigned __int8)tolower(v15);
        ++v12;
        if ( v16 != result )
          return result;
      }
      if ( !*(v3 - 1) )
      {
        v17 = v23;
        if ( !strcmp(v23, "vue") )
        {
          result = 1;
          *(_BYTE *)(a1 + 210100) = 1;
        }
        else
        {
          v18 = strcmp(v17, "wys_ai") != 0;
          result = 196608;
          if ( !v18 )
          {
            result = 2;
            *(_BYTE *)(a1 + 210100) = 2;
          }
        }
      }
    }
  }
  return result;
}
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A862C: using guessed type int __fastcall StrToIp(_DWORD);
// 6A8660: using guessed type int __fastcall getMD5Str(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8800: using guessed type int __fastcall sq_file_get_ssid_en(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00421604) --------------------------------------------------------
int __fastcall httpd_formdata_parse(_DWORD *a1, _BYTE *a2, int a3)
{
  int result; // $v0
  int v6; // $a0
  int v7; // $v0
  int v8; // $v0
  _DWORD *v9; // $v1
  int v10; // $a1
  char *v11; // $v1
  int v12; // $v0

  if ( !a3 || (result = a1[8] & 0x8080000) != 0 )
  {
    if ( (a1[8] & 0x8000000) != 0 )
    {
      v6 = a1[12];
      if ( v6 )
      {
        cJSON_Delete(v6);
        a1[12] = 0;
      }
      v7 = cJSON_Parse(a2);
      a1[12] = v7;
      cJSON_NumberToString(v7);
      cJSON_CodeString(a1[12], _httpd_parm_do);
      result = httpd_check_parm_auth_xx((int)a1);
    }
    else
    {
      v8 = a1[13];
      v9 = a1 + 14;
      if ( v8 )
      {
        v8 = 0;
        do
        {
          ++v8;
          if ( !*v9 )
            break;
          ++v9;
        }
        while ( v8 != 127 );
      }
      a1[v8 + 13] = a2;
      if ( a2 && (v10 = (char)*a2, *a2) )
      {
        v11 = a2 + 1;
        while ( v8 != 127 )
        {
          if ( v10 == 38 )
          {
            ++v8;
            *(v11 - 1) = 0;
            a1[v8 + 13] = v11;
            v10 = *v11++;
            if ( !v10 )
              goto LABEL_20;
          }
          else
          {
            if ( !v11 )
              goto LABEL_20;
            v10 = *v11++;
            if ( !v10 )
              goto LABEL_20;
          }
        }
        v12 = 128;
      }
      else
      {
LABEL_20:
        v12 = v8 + 1;
      }
      a1[v12 + 13] = 0;
      result = httpd_check_parm_auth_xx((int)a1);
    }
  }
  return result;
}
// 6A8184: using guessed type int __fastcall cJSON_NumberToString(_DWORD);
// 6A844C: using guessed type int __fastcall cJSON_CodeString(_DWORD, _DWORD);
// 6A8780: using guessed type int __fastcall cJSON_Parse(_DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);

//----- (004217E4) --------------------------------------------------------
int __fastcall httpd_check_aitoken(int a1)
{
  char *v2; // $v0
  unsigned int v3; // $s3
  size_t v4; // $v0
  const char *v5; // $s0
  int v6; // $v0
  int v7; // $v0
  int v8; // $s1
  int v9; // $v0
  int v10; // $s2
  size_t v11; // $v0
  const time_t *v12; // $a0
  struct tm *v13; // $v0
  size_t v14; // $s2
  char *v15; // $v0
  int v16; // $s0
  char v18[2048]; // [sp+20h] [-C08h] BYREF
  char v19[1024]; // [sp+820h] [-408h] BYREF
  int v20; // [sp+C20h] [-8h]
  int v21; // [sp+C24h] [-4h] BYREF

  memset(v18, 0, sizeof(v18));
  memset(v19, 0, sizeof(v19));
  v3 = time(0);
  v2 = httpd_get_parm(a1, "aitoken");
  if ( !v2 )
    return -1;
  v5 = v2;
  v4 = strlen(v2);
  v6 = base64_decode(v5, v19, v4);
  ai_aes_cbc_decrypt(v19, v6, v18);
  v7 = cJSON_Parse(v18);
  v8 = v7;
  if ( !v7 )
    return -1;
  v9 = cJSON_GetObjectItem(v7, "expire_at");
  v10 = v9;
  if ( !v9 || v3 >= *(_DWORD *)(v9 + 20) )
    goto LABEL_11;
  v21 = 0;
  v20 = 0;
  if ( gl_httpd_high_admin_en )
  {
    if ( httpd_cgi_user_check(gl_httpd_high_admin, gl_httpd_high_adminpwd, &v21) > 0 )
      goto LABEL_7;
LABEL_11:
    v16 = -1;
    goto LABEL_8;
  }
  if ( httpd_cgi_user_check(gl_httpd_admin, gl_httpd_adminpwd, &v21) <= 0 )
    goto LABEL_11;
LABEL_7:
  v11 = strlen(httpd_set_cookie);
  v12 = (const time_t *)(v10 + 20);
  v14 = v11;
  v13 = gmtime(v12);
  v15 = asctime(v13);
  snprintf(&httpd_set_cookie[v14], 256 - v14, ",vue_aitoken=%s;expires=%s", v5, v15);
  v16 = 0;
  *(_DWORD *)(a1 + 36) |= 0x1000u;
LABEL_8:
  cJSON_Delete(v8);
  return v16;
}
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A8670: using guessed type int __fastcall ai_aes_cbc_decrypt(_DWORD, _DWORD, _DWORD);
// 6A8780: using guessed type int __fastcall cJSON_Parse(_DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (00421A44) --------------------------------------------------------
int __fastcall httpd_send_referer(int a1)
{
  int v2; // $v0
  int result; // $v0
  char v4[2048]; // [sp+18h] [-800h] BYREF

  memset(v4, 0, sizeof(v4));
  v2 = sprintf(v4, (char *)re_httphead_str1, gl_referer);
  *(_BYTE *)(a1 + 41) = 2;
  *(_DWORD *)(a1 + 205392) = 0;
  result = httpd_send_data_alloc(a1, v4, v2);
  if ( !result )
  {
    result = *(_DWORD *)(a1 + 205380);
    if ( !result )
      result = httpd_conn_close((int *)a1);
  }
  return result;
}
// 666180: using guessed type void *re_httphead_str1;
// 666190: using guessed type char *gl_referer;

//----- (00421B30) --------------------------------------------------------
void __fastcall sub_421B30(_DWORD *a1, const char *a2)
{
  const char *v4; // $s1

  if ( a1[51397] == 3 && (!strcmp(a2, "index.htm") || !strcmp(a2, "index.html")) )
  {
    if ( (a1[8] & 0x400) == 0
      || (v4 = (const char *)a1[51380], strcmp(v4, gl_referer))
      && strncmp(v4, gl_referer2[0], 0x18u)
      && strncmp(v4, gl_referer3[0], 0x18u) )
    {
      httpd_send_referer((int)a1);
    }
  }
}
// 666188: using guessed type char *gl_referer3[3];
// 66618C: using guessed type char *gl_referer2[2];
// 666190: using guessed type char *gl_referer;

//----- (00421C6C) --------------------------------------------------------
int __fastcall usb_httpd_user_check_cookie(int a1, int a2, const char *a3)
{
  bool v5; // dc
  int result; // $v0

  if ( !nvram_match_def("usb_husername", a2) || (v5 = strcmp(a3, gl_usb_hpassword_md5) != 0, result = 2, v5) )
  {
    result = nvram_match_def("usb_username", a2);
    if ( result )
      result = strcmp(a3, gl_usb_password_md5) == 0;
  }
  return result;
}
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);

//----- (00421D28) --------------------------------------------------------
int __fastcall usb_httpd_cgi_user_check(const char *a1, int a2)
{
  int result; // $v0

  memset(httpd_set_cookie, 0, sizeof(httpd_set_cookie));
  if ( nvram_match_def("usb_husername", a1) && nvram_match_def("usb_hpasswd", a2) )
  {
    sprintf(httpd_set_cookie, "usb_userid=%s,usb_passwd=%s", a1, gl_usb_hpassword_md5);
    result = 2;
  }
  else if ( nvram_match_def("usb_username", a1) && nvram_match_def("usb_passwd", a2) )
  {
    sprintf(httpd_set_cookie, "usb_userid=%s,usb_passwd=%s", a1, gl_usb_password_md5);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);

//----- (00421E64) --------------------------------------------------------
void __fastcall usb_httpd_conn_check_user(int a1)
{
  char *v2; // $v0
  int v3; // $s1
  char *v4; // $v0
  int v5; // $v1
  const char *v6; // $a2
  _BYTE *v7; // $v0
  int v8; // $v0

  if ( !*(_BYTE *)(a1 + 43) )
  {
    if ( (*(_DWORD *)(a1 + 32) & 0x800) != 0 )
    {
      v2 = strstr(*(const char **)(a1 + 205524), "usb_userid=");
      v3 = (int)(v2 + 11);
      if ( v2 )
      {
        v4 = strstr(v2 + 11, "usb_passwd=");
        if ( v4 )
        {
          v5 = *v4;
          *(v4 - 1) = 0;
          v6 = v4 + 11;
          if ( v5 )
          {
            v7 = v4 + 1;
            if ( v5 == 59 )
            {
              --v7;
LABEL_15:
              *v7 = 0;
              v8 = usb_httpd_user_check_cookie(a1, v3, v6);
              if ( v8 <= 0 )
                goto LABEL_14;
              goto LABEL_12;
            }
            while ( *v7 )
            {
              if ( *v7 == 59 )
                goto LABEL_15;
              ++v7;
            }
          }
          v8 = usb_httpd_user_check_cookie(a1, v3, v6);
          if ( v8 > 0 )
          {
LABEL_12:
            *(_DWORD *)(a1 + 205588) = v8;
            *(_BYTE *)(a1 + 43) = 1;
            return;
          }
        }
      }
    }
LABEL_14:
    *(_BYTE *)(a1 + 43) = 3;
  }
}

//----- (00421FB0) --------------------------------------------------------
int __fastcall usb_acc_check(int *a1)
{
  int v2; // $a1
  int v3; // $a0
  int v4; // $v0
  int v5; // $a2
  int v6; // $v1
  int result; // $v0
  int v8[257]; // [sp+18h] [-404h] BYREF

  memset(v8, 0, 0x400u);
  v2 = a1[2];
  v3 = a1[3];
  v4 = *a1;
  v5 = a1[1];
  v6 = a1[4];
  v8[0] = 11;
  v8[3] = 29;
  v8[6] = v2;
  v8[7] = v3;
  v8[1] = 1024;
  v8[4] = v4;
  v8[5] = v5;
  v8[8] = v6;
  result = jianhl_order_opt_fun(v8, 1024, v5);
  if ( result )
    return 0;
  if ( !v8[2] )
  {
    if ( v8[9] )
      result = v8[10];
    else
      result = nvram_match_def("usb_acc_wan", "1") == 0;
  }
  return result;
}
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (004220E0) --------------------------------------------------------
void __fastcall check_client_is_or_not_mobile(int a1)
{
  const char *v1; // $s0

  if ( a1 )
  {
    if ( (*(_DWORD *)(a1 + 32) & 0x10000) != 0 )
    {
      v1 = *(const char **)(a1 + 205528);
      if ( v1 )
      {
        if ( !strstr(v1, "iPhone")
          && !strstr(v1, "iPad")
          && !strstr(v1, "iPod")
          && !strstr(v1, "Android")
          && !strstr(v1, "IEMobile")
          && !strstr(v1, "Symbian")
          && !strstr(v1, "BlackBerry")
          && !strstr(v1, "Blazer")
          && !strstr(v1, "BOLT")
          && !strstr(v1, "Fennec")
          && !strstr(v1, "GoBrowser")
          && !strstr(v1, "lris")
          && !strstr(v1, "Maemo")
          && !strstr(v1, (const char *)&off_4CEDB4)
          && !strstr(v1, "Minimo")
          && !strstr(v1, "NetFront")
          && !strstr(v1, "Presto")
          && !strstr(v1, "SEMC")
          && !strstr(v1, "Skyfire")
          && !strstr(v1, "TeaShark")
          && !strstr(v1, "Teleca")
          && !strstr(v1, "uZardWeb")
          && !strstr(v1, "Dorothy") )
        {
          strstr(v1, "Windows Phone");
        }
      }
    }
  }
}
// 4CEDB4: using guessed type void *off_4CEDB4;

//----- (00422448) --------------------------------------------------------
int __fastcall httpds_send_redirect(int a1, const char *a2)
{
  unsigned int v3; // $v0
  char v5[4100]; // [sp+18h] [-1004h] BYREF

  v3 = snprintf(
         v5,
         4096,
         "HTTP/1.1 302 Found\r\n"
         "Location: %s\r\n"
         "Content-Type: text/html\r\n"
         "Pragma: no-cache\r\n"
         "Cache-Control: no-cache\r\n"
         "Expires: 0\r\n"
         "Content-Length: 0\r\n"
         "\r\n",
         a2);
  *(_BYTE *)(a1 + 41) = 2;
  *(_DWORD *)(a1 + 205392) = 0;
  if ( v3 >= 0x1000 )
    v3 = 4095;
  if ( !httpd_send_data_alloc(a1, v5, v3) && (!*(_DWORD *)(a1 + 205380) || *(_DWORD *)(a1 + 209984)) )
    httpd_conn_close((int *)a1);
  return 0;
}

//----- (0042251C) --------------------------------------------------------
int __fastcall jhl_get_hi_redirect_url(_DWORD *a1, char *a2, int a3)
{
  int v6; // $a1
  int v7; // $v0
  int v8; // $a3
  int v9; // $a2
  int v10; // $v1
  int v11; // $s0
  int v13[513]; // [sp+18h] [-804h] BYREF

  memset(v13, 0, 0x800u);
  v6 = a1[51368];
  v7 = a1[51365];
  v8 = a1[51366];
  v9 = a1[51367];
  v10 = a1[51369];
  v13[0] = 13;
  v13[3] = 47;
  v13[1] = 2048;
  v13[7] = v6;
  v13[4] = v7;
  v13[5] = v8;
  v13[6] = v9;
  v13[8] = v10;
  if ( jianhl_order_opt_fun(v13, 2048, v9) )
    return -1;
  v11 = v13[2];
  if ( v13[2] )
    return -1;
  snprintf(a2, a3, "http://%s", (const char *)&v13[11]);
  if ( (v13[10] & 0xFFFF0000) != 16842752 )
    v11 = HIBYTE(v13[10]);
  return v11;
}
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00422670) --------------------------------------------------------
int __fastcall httpds_send_redirect_ipmac(int a1, const char *a2, const char *a3)
{
  bool v6; // dc
  int v7; // $v0
  unsigned int v8; // $v0
  char v10[4100]; // [sp+20h] [-1004h] BYREF

  v6 = strchr(a2, 63) == 0;
  v7 = 63;
  if ( !v6 )
    v7 = 38;
  v8 = snprintf(
         v10,
         4096,
         "HTTP/1.1 302 Found\r\n"
         "Location: %s%c%s\r\n"
         "Content-Type: text/html\r\n"
         "Pragma: no-cache\r\n"
         "Cache-Control: no-cache\r\n"
         "Expires: 0\r\n"
         "Content-Length: 0\r\n"
         "\r\n",
         a2,
         v7,
         a3);
  *(_BYTE *)(a1 + 41) = 2;
  *(_DWORD *)(a1 + 205392) = 0;
  if ( v8 >= 0x1000 )
    v8 = 4095;
  if ( httpd_send_data_alloc(a1, v10, v8) || *(_DWORD *)(a1 + 205380) )
    return 0;
  httpd_conn_close((int *)a1);
  return 0;
}

//----- (00422794) --------------------------------------------------------
int __fastcall jhl_get_hi_redirect_ipmac(_DWORD *a1, char *a2)
{
  int v4; // $a1
  int v5; // $v0
  int v6; // $a3
  int v7; // $a2
  int v8; // $v1
  int v10[512]; // [sp+18h] [-800h] BYREF

  memset(v10, 0, sizeof(v10));
  v4 = a1[51368];
  v5 = a1[51365];
  v6 = a1[51366];
  v7 = a1[51367];
  v8 = a1[51369];
  v10[0] = 13;
  v10[3] = 49;
  v10[1] = 2048;
  v10[7] = v4;
  v10[4] = v5;
  v10[5] = v6;
  v10[6] = v7;
  v10[8] = v8;
  if ( jianhl_order_opt_fun(v10, 2048, v7) || v10[2] )
    return -1;
  strcpy(a2, (char *)&v10[9]);
  return 0;
}
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (004228B4) --------------------------------------------------------
int __fastcall sub_4228B4(int a1)
{
  int v2; // $t0
  int v3; // $a3
  int v4; // $a2
  int v5; // $v1
  int v6; // $a0
  char v7; // $t2
  int v8; // $a1
  char v9; // $t1
  int result; // $v0
  int v11; // $t2
  int v12; // $t3
  int v13; // $t1
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  char v18; // $a0
  int v19[257]; // [sp+18h] [-404h] BYREF

  memset(v19, 0, 0x400u);
  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 24);
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_BYTE *)(a1 + 4);
  v8 = *(_DWORD *)a1;
  v9 = *(_BYTE *)(a1 + 5);
  v19[0] = 13;
  v19[3] = 52;
  v19[1] = 1024;
  v19[4] = v8;
  LOBYTE(v19[5]) = v7;
  BYTE1(v19[5]) = v9;
  v19[6] = v6;
  v19[7] = v2;
  v19[8] = v3;
  v19[9] = v4;
  v19[10] = v5;
  if ( jianhl_order_opt_fun(v19, 1024, v4) )
    return -1;
  result = v19[2];
  if ( v19[2] )
    return -1;
  v11 = *(int *)((char *)&v19[29] + 1);
  v12 = *(int *)((char *)&v19[28] + 1);
  *(_BYTE *)(a1 + 96) = v19[28];
  v13 = *(int *)((char *)&v19[30] + 1);
  v14 = *(int *)((char *)&v19[31] + 1);
  v15 = *(int *)((char *)&v19[32] + 1);
  v16 = *(int *)((char *)&v19[33] + 1);
  v17 = *(int *)((char *)&v19[34] + 1);
  *(_DWORD *)(a1 + 97) = v12;
  *(_DWORD *)(a1 + 101) = v11;
  *(_DWORD *)(a1 + 105) = v13;
  *(_DWORD *)(a1 + 109) = v14;
  *(_DWORD *)(a1 + 113) = v15;
  *(_DWORD *)(a1 + 117) = v16;
  *(_DWORD *)(a1 + 121) = v17;
  LOBYTE(v17) = BYTE2(v19[35]);
  v18 = HIBYTE(v19[35]);
  *(_BYTE *)(a1 + 125) = BYTE1(v19[35]);
  *(_BYTE *)(a1 + 126) = v17;
  *(_BYTE *)(a1 + 127) = v18;
  return result;
}
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00422A50) --------------------------------------------------------
int __fastcall httpd_do_wwwparm(_DWORD *a1, const char *a2)
{
  char *v3; // $v0
  char *v4; // $s1
  char *v5; // $v0
  char *v6; // $v0
  char *v7; // $s0
  int v8; // $v1
  char *v9; // $fp
  char *v10; // $v0
  unsigned int v11; // $v0
  int v13; // $v1
  int v14; // $v0
  int v15; // $v1
  char *v16; // $v0
  int v17; // $v0
  char *v18; // $v0
  const char *v19; // $a0
  size_t v20; // $v0
  int v21; // $v1

  v3 = strchr(a2, 10);
  v4 = v3 + 1;
  if ( v3 && v3 != (char *)-1 && v3[1] )
  {
    do
    {
      v5 = strchr(v4, 10);
      if ( v5 )
      {
        *v5 = 0;
        v7 = v5 + 1;
        v6 = strchr(v4, 58);
        if ( !v6 )
          goto LABEL_22;
      }
      else
      {
        v6 = strchr(v4, 58);
        v7 = 0;
        if ( !v6 )
          break;
      }
      v8 = v6[1];
      v9 = v6 + 1;
      *v6 = 0;
      if ( v8 )
      {
        do
        {
          if ( v8 != 32 && v8 != 9 )
            break;
          v8 = *++v9;
        }
        while ( *v9 );
      }
      v10 = strchr(v9, 13);
      if ( !v10 )
        goto LABEL_22;
      *v10 = 0;
      strlower(v4);
      if ( !strcmp(v4, "content-length") )
      {
        v14 = J_atoi(v9);
        v15 = a1[8] | 0x80;
        a1[51374] = v14;
        v4 = v7;
        a1[8] = v15;
      }
      else
      {
        if ( !strcmp(v4, "content-type") )
        {
          if ( strstr(v9, "x-www-form-urlencoded") )
          {
            a1[8] |= 0x80000u;
          }
          else
          {
            v18 = strstr(v9, "boundary=");
            v19 = v18 + 9;
            if ( v18 )
            {
              a1[51378] = v19;
              v20 = strlen(v19);
              v21 = a1[8] | 0x100;
              a1[51379] = v20;
              a1[8] = v21;
            }
          }
          if ( strstr(v9, "application/json") )
          {
            a1[8] |= 0x8000000u;
            v4 = v7;
            continue;
          }
LABEL_22:
          v4 = v7;
          continue;
        }
        if ( !strcmp(v4, "connection") )
        {
          strlower(v9);
          v4 = v7;
          if ( !strcmp(v9, "keep-alive") )
          {
            a1[8] |= 2u;
          }
          else
          {
            if ( strcmp(v9, "upgrade") )
              goto LABEL_22;
            a1[8] |= 0x100000u;
            v4 = v7;
          }
        }
        else if ( !strcmp(v4, "cookie") )
        {
          v13 = a1[8] | 0x800;
          a1[51372] = v9;
          v4 = v7;
          a1[8] = v13;
          a1[51381] = v9;
        }
        else
        {
          if ( !strcmp(v4, "if-modified-since") )
          {
            v16 = strchr(v9, 59);
            if ( v16 )
              *v16 = 0;
            v17 = a1[8] | 4;
            a1[51373] = v9;
            v4 = v7;
            a1[8] = v17;
            continue;
          }
          if ( !strcmp(v4, "x-jhlss") )
          {
            a1[8] |= 0x10u;
            v4 = v7;
            a1[51375] = v9;
          }
          else if ( !strcmp(v4, "host") )
          {
            a1[8] |= 0x20u;
            v4 = v7;
            a1[51376] = v9;
          }
          else if ( !strcmp(v4, "x-jhljson") )
          {
            v4 = v7;
            a1[8] |= 0x40u;
          }
          else if ( !strcmp(v4, "authorization") )
          {
            a1[8] |= 0x200u;
            v4 = v7;
            a1[51377] = v9;
          }
          else if ( !strcmp(v4, "referer") )
          {
            a1[8] |= 0x400u;
            v4 = v7;
            a1[51380] = v9;
          }
          else if ( !strcmp(v4, "user-agent") )
          {
            a1[8] |= 0x10000u;
            v4 = v7;
            a1[51382] = v9;
          }
          else if ( !strcmp(v4, "range") )
          {
            a1[8] |= 0x20000u;
            v4 = v7;
            a1[51383] = v9;
          }
          else if ( !strcmp(v4, "upgrade") )
          {
            strlower(v9);
            if ( strcmp(v9, "websocket") )
              goto LABEL_22;
            a1[8] |= 0x200000u;
            v4 = v7;
            a1[52498] = v9;
          }
          else if ( !strcmp(v4, "sec-websocket-version") )
          {
            if ( strcmp(v9, "13") )
              goto LABEL_22;
            a1[8] |= 0x400000u;
            v4 = v7;
            a1[52499] = v9;
          }
          else if ( !strcmp(v4, "sec-websocket-key") )
          {
            a1[8] |= 0x800000u;
            v4 = v7;
            a1[52500] = v9;
          }
          else if ( !strcmp(v4, "sec-websocket-extensions") )
          {
            a1[8] |= 0x1000000u;
            v4 = v7;
            a1[52501] = v9;
          }
          else if ( !strcmp(v4, "sec-websocket-protocol") )
          {
            a1[8] |= 0x2000000u;
            v4 = v7;
            a1[52502] = v9;
          }
          else if ( !strcmp(v4, "origin") )
          {
            a1[8] |= 0x4000000u;
            v4 = v7;
            a1[52503] = v9;
          }
          else
          {
            if ( strcmp(v4, "accept-language") )
              goto LABEL_22;
            a1[8] |= 0x10000000u;
            v4 = v7;
            a1[51384] = v9;
          }
        }
      }
    }
    while ( v7 && *v7 );
  }
  v11 = a1[9] & 0xFFFFFFFE;
  a1[8] &= 0xFFFFFFFD;
  a1[9] = v11;
  httpd_set_cookie_language((int)a1);
  return 0;
}
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00423278) --------------------------------------------------------
int httpd_file_init()
{
  char *v0; // $v0
  _DWORD *v1; // $v0
  char *v2; // $v0
  int v3; // $s1
  void **v4; // $s2
  _DWORD *v5; // $s0
  int v6; // $v0
  int v7; // $v1
  _DWORD *v8; // $v0

  v0 = (char *)gl_vfile_ext_hash;
  do
  {
    *(_DWORD *)v0 = 0;
    v0 += 4;
  }
  while ( v0 != gl_httpd_adminpwd );
  v1 = gl_file_hash;
  do
    *v1++ = 0;
  while ( v1 != (_DWORD *)&gl_cgi_ext_hash );
  v2 = (char *)&gl_cgi_ext_hash;
  do
  {
    *(_DWORD *)v2 = 0;
    v2 += 4;
  }
  while ( gl_httpd_user != v2 );
  v3 = 0;
  v4 = &httpd_all_file;
  do
  {
    v5 = *v4;
    ++v3;
    v6 = get_name_hash(*((unsigned __int8 **)*v4 + 2));
    v7 = gl_file_hash[v6];
    v8 = &gl_file_hash[v6];
    *v5 = v7;
    if ( v7 )
      *(_DWORD *)(v7 + 4) = v5;
    *v8 = v5;
    ++v4;
    v5[1] = v8;
  }
  while ( v3 != 62 );
  return 0;
}
// 6679D0: using guessed type void *httpd_all_file;

//----- (00423380) --------------------------------------------------------
int *__fastcall httpd_get_file(const char *a1, int a2)
{
  int *v2; // $s0
  bool v4; // dc
  int *result; // $v0

  v2 = (int *)gl_file_hash[a2];
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    v4 = strcmp((const char *)v2[2], a1) != 0;
    result = v2;
    if ( !v4 )
      break;
    v2 = (int *)*v2;
    if ( !v2 )
      return 0;
  }
  return result;
}

//----- (00423418) --------------------------------------------------------
int __fastcall sub_423418(int a1)
{
  int *v2; // $v0
  int v3; // $s1
  int v4; // $a1
  int *v5; // $v0
  int *v6; // $s1
  const char *v7; // $s0
  int result; // $v0
  int *v9; // $s2

  v3 = get_name_hash((unsigned __int8 *)(*(_DWORD *)(a1 + 44) + 1));
  v2 = httpd_find_ext_file((const char *)(*(_DWORD *)(a1 + 44) + 1), v3);
  v4 = v3;
  v6 = v2;
  v5 = httpd_get_file((const char *)(*(_DWORD *)(a1 + 44) + 1), v4);
  v7 = *(const char **)(a1 + 44);
  v9 = v5;
  result = strcmp(v7, "/relogin.htm");
  if ( result )
  {
    result = strcmp(v7, "/login.html");
    if ( result )
    {
      if ( !v6 || (result = 1, v6[4] >= 2) )
      {
        result = 0;
        if ( v9 )
          result = v9[3] < 2;
      }
    }
  }
  return result;
}

//----- (00423520) --------------------------------------------------------
int __fastcall httpd_send_continue(int a1)
{
  _DWORD *v2; // $s0
  _DWORD *v3; // $v1
  int v4; // $v0
  int *v5; // $a1
  int v6; // $a0
  bool v7; // dc
  int v8; // $s7
  int v9; // $v0
  char *v10; // $s5
  int v11; // $v0
  int result; // $v0
  int v13; // $v0
  int v14; // $a2
  int v15; // $v0
  char v16[256]; // [sp+18h] [-108h] BYREF
  char *format; // [sp+118h] [-8h]

  format = "%s/%s";
LABEL_2:
  while ( 2 )
  {
    v2 = (_DWORD *)(a1 + 196608);
    v3 = *(_DWORD **)(a1 + 205392);
    if ( !v3 )
    {
LABEL_17:
      if ( *(int *)(a1 + 205380) <= 0 )
      {
        httpd_conn_send_finish(a1);
        return -1;
      }
      return 0;
    }
    while ( 1 )
    {
      v4 = v2[2198];
      if ( v4 >= v3[6] )
        goto LABEL_17;
      v5 = *(int **)(v3[8] + 4 * v4);
      v6 = *v5;
      v7 = *v5 == 1;
      v2[2198] = v4 + 1;
      if ( v7 )
      {
        *(_BYTE *)(a1 + 42) = 0;
        v13 = v5[2];
        v2[2190] = v5[1];
        v2[2193] = v13;
        v7 = httpd_send_data(a1) != 0;
        result = -1;
        if ( v7 )
          return result;
        if ( (int)v2[2193] > 0 )
          return 0;
        goto LABEL_2;
      }
      if ( v6 != 2 )
        break;
      ((void (__fastcall *)(int, int))v5[1])(a1, v5[3]);
      if ( (int)v2[2193] > 0 )
        return 0;
      v2 = (_DWORD *)(a1 + 196608);
      v3 = *(_DWORD **)(a1 + 205392);
      if ( !v3 )
        goto LABEL_17;
    }
    if ( v6 != 3 )
      goto LABEL_17;
    v8 = v3[5];
    sprintf(v16, format, "/etc_ro/web", v3[2]);
    _mem_malloc(v8 + 4, "httpd_send_continue", 4881);
    v10 = (char *)v9;
    if ( !v9 )
    {
      v14 = sprintf(v16, "malloc(%d);err!", v8 + 4);
      if ( v2[3344] )
        https_ssl_write(a1);
      else
        send(v2[2202], v16, v14, 0);
LABEL_22:
      httpd_conn_close((int *)a1);
      return -1;
    }
    v11 = do_file(v16, v9, v8);
    if ( v8 != v11 )
    {
      if ( v11 )
        v15 = sprintf(v10, "%s is modify !", v16);
      else
        v15 = sprintf(v10, "%s not exist !", v16);
      if ( v2[3344] )
        https_ssl_write(a1);
      else
        send(v2[2202], v10, v15, 0);
      _mem_free(v10);
      goto LABEL_22;
    }
    v2[2191] = v10;
    v2[2190] = v10;
    *(_BYTE *)(a1 + 42) = 1;
    v2[2193] = v8;
    result = httpd_send_data(a1);
    if ( result )
      return -1;
    if ( (int)v2[2193] <= 0 )
      continue;
    return result;
  }
}
// 423620: variable 'v9' is possibly undefined

//----- (00423868) --------------------------------------------------------
int __fastcall httpd_enable_write(int a1)
{
  int v1; // $s0
  int v2; // $v0
  size_t *v4; // $a1
  int result; // $v0
  int v6; // $v0
  _DWORD *v7; // $a1
  int v8; // $a2
  bool v9; // dc
  size_t *v10; // $a1
  ssize_t v11; // $v0
  int *v12; // $a1
  int v13; // $a2
  size_t v14; // $a2
  ssize_t v15; // $v0
  int v16; // $a2
  int v17; // $v0
  signed int v18; // $a2
  const void *v19; // $a1
  int v20; // $v0
  int v21; // $a1
  int v22; // $v0
  int v23; // $v0
  unsigned int v24; // $v0
  size_t v25; // $a1
  int v26; // $s2
  FILE *v27; // $a3
  int v28; // $a0
  size_t v29; // $a2
  const void *v30; // $s0
  signed int v31; // $v0
  size_t v32; // $a2
  int v33; // $v0
  unsigned int v34; // $a1
  unsigned int v35; // $a3
  int v36; // $a1
  int v37; // $a0
  int v38; // $v0
  FILE *v39; // $a3
  int v40; // $a0
  size_t v41; // $a2
  char *v42; // $s2
  signed int v43; // $v0
  size_t v44; // $a2
  int v45; // $v0
  int v46; // $a1
  int v47; // $v0
  int v48; // $s2
  int v49; // $v0
  int v50; // $a2
  unsigned int v51; // $v1
  int v52; // $a1
  int v53; // $v0
  int v54; // $s0
  int v55; // $v0
  int v56; // $a2
  unsigned int v57; // $v1
  int v58; // $a1
  int v59; // $v0

  v1 = a1 + 196608;
  v2 = *(_DWORD *)(a1 + 205412);
  if ( v2 != *(_DWORD *)(a1 + 205420) )
  {
    if ( v2 == *(_DWORD *)(a1 + 205424) )
    {
      v10 = *(size_t **)(a1 + 205444);
      if ( *v10 )
      {
        v11 = send(*(_DWORD *)(a1 + 205412), v10 + 1, *v10, 0);
        if ( v11 < 0 )
        {
          if ( *_errno_location() != 11 )
          {
            httpd_proxy_client_close(a1);
            return -1;
          }
        }
        else if ( v11 )
        {
          v12 = *(int **)(v1 + 8836);
          v13 = *v12 - v11;
          v9 = *v12 == v11;
          *v12 = v13;
          if ( v9 )
          {
            httpd_conn_epoll_read_proxy(a1);
            return 0;
          }
          memmove(v12 + 1, (char *)v12 + v11 + 4, v13);
          httpd_conn_epoll_write_proxy(a1);
        }
      }
      return 0;
    }
    v4 = *(size_t **)(a1 + 205440);
    if ( v4 )
    {
      result = 0;
      if ( !*v4 )
        return result;
      if ( *(_DWORD *)(a1 + 209984) )
        v6 = https_ssl_write(a1);
      else
        v6 = send(*(_DWORD *)(a1 + 205416), v4 + 1, *v4, 0);
      if ( v6 < 0 )
      {
        if ( *_errno_location() != 11 )
        {
          httpd_proxy_server_close(a1);
          return -1;
        }
      }
      else if ( v6 )
      {
        v7 = *(_DWORD **)(a1 + 205440);
        v8 = *v7 - v6;
        v9 = *v7 == v6;
        *v7 = v8;
        if ( v9 )
        {
          httpd_conn_epoll_read(a1);
        }
        else
        {
          memmove(v7 + 1, (char *)v7 + v6 + 4, v8);
          httpd_conn_epoll_write(a1);
        }
        return 0;
      }
      return 0;
    }
    v17 = *(unsigned __int8 *)(a1 + 42);
    if ( v17 == 2 )
    {
      if ( *(_DWORD *)(a1 + 205376) )
      {
        v24 = *(_DWORD *)(a1 + 205388);
        v25 = *(_DWORD *)(a1 + 205384);
        if ( __SPAIR64__(v24, v25) <= 0 )
          goto LABEL_38;
        v26 = a1 + 196608;
        v27 = *(FILE **)(a1 + 205592);
        if ( v27 )
        {
          if ( gl_hs_speed )
          {
            v54 = *(_DWORD *)(a1 + 209980);
            if ( v54 != jiffies_get() )
            {
              v55 = jiffies_get();
              v56 = *(_DWORD *)(v26 + 13364);
              v57 = v55 - *(_DWORD *)(v26 + 13372);
              *(_DWORD *)(v26 + 13372) = v55;
              v58 = 300 * v56;
              if ( v57 >= 0x12D )
                v57 = 300;
              v59 = v57 * v56 + *(_DWORD *)(a1 + 209976);
              if ( v58 >= v59 )
                *(_DWORD *)(a1 + 209976) = v59;
              else
                *(_DWORD *)(a1 + 209976) = v58;
            }
            if ( *(int *)(a1 + 209976) <= 0 )
              goto LABEL_32;
            v25 = *(_DWORD *)(a1 + 205384);
            v24 = *(_DWORD *)(a1 + 205388);
            v27 = *(FILE **)(a1 + 205592);
          }
          v28 = *(_DWORD *)(a1 + 209692);
          v29 = 4096 - v28;
          if ( __SPAIR64__(v24, v25) < 4096 - v28 )
            v29 = v25;
          v30 = (const void *)(a1 + 205596);
          v31 = fread((void *)(a1 + 205596 + v28), 1u, v29, v27);
          if ( v31 <= 0 )
          {
            fclose(*(FILE **)(a1 + 205592));
            *(_DWORD *)(a1 + 205592) = 0;
            *(_DWORD *)(a1 + 205384) = 0;
            *(_DWORD *)(a1 + 205388) = 0;
            httpd_release_caches();
            v32 = *(_DWORD *)(a1 + 209692);
          }
          else
          {
            v32 = v31 + *(_DWORD *)(a1 + 209692);
            v9 = gl_hs_speed == 0;
            *(_DWORD *)(a1 + 209692) = v32;
            if ( !v9 )
              *(_DWORD *)(a1 + 209976) -= v31;
          }
        }
        else
        {
          v32 = *(_DWORD *)(a1 + 209692);
          v30 = (const void *)(a1 + 205596);
        }
        if ( *(_DWORD *)(a1 + 209984) )
          v33 = https_ssl_write(a1);
        else
          v33 = send(*(_DWORD *)(a1 + 205416), v30, v32, 0);
        if ( v33 >= 0 )
        {
          v34 = *(_DWORD *)(a1 + 205384);
          v35 = v34 - v33;
          v36 = v34 < v33;
          v37 = *(_DWORD *)(a1 + 205388) - (v33 >> 31);
          *(_DWORD *)(a1 + 209692) -= v33;
          *(_DWORD *)(a1 + 205384) = v35;
          *(_DWORD *)(a1 + 205388) = v37 - v36;
          if ( v37 - v36 > 0 || v37 == v36 && v35 )
            goto LABEL_32;
          goto LABEL_38;
        }
      }
      else
      {
        v38 = *(_DWORD *)(a1 + 205380);
        if ( v38 <= 0 )
          goto LABEL_38;
        v39 = *(FILE **)(a1 + 205592);
        if ( v39 )
        {
          if ( gl_hs_speed )
          {
            v48 = *(_DWORD *)(a1 + 209980);
            if ( v48 != jiffies_get() )
            {
              v49 = jiffies_get();
              v50 = *(_DWORD *)(v1 + 13364);
              v51 = v49 - *(_DWORD *)(v1 + 13372);
              *(_DWORD *)(v1 + 13372) = v49;
              v52 = 300 * v50;
              if ( v51 >= 0x12D )
                v51 = 300;
              v53 = v51 * v50 + *(_DWORD *)(a1 + 209976);
              if ( v52 >= v53 )
                *(_DWORD *)(a1 + 209976) = v53;
              else
                *(_DWORD *)(a1 + 209976) = v52;
            }
            if ( *(int *)(a1 + 209976) <= 0 )
              goto LABEL_32;
            v38 = *(_DWORD *)(a1 + 205380);
            v39 = *(FILE **)(a1 + 205592);
          }
          v40 = *(_DWORD *)(a1 + 209692);
          v41 = 4096 - v40;
          v42 = (char *)(a1 + 205596);
          if ( v38 < 4096 - v40 )
            v41 = v38;
          v43 = fread(&v42[v40], 1u, v41, v39);
          if ( v43 <= 0 )
          {
            fclose(*(FILE **)(a1 + 205592));
            *(_DWORD *)(a1 + 205592) = 0;
            *(_DWORD *)(a1 + 205380) = 0;
            httpd_release_caches();
            v44 = *(_DWORD *)(a1 + 209692);
          }
          else
          {
            v44 = v43 + *(_DWORD *)(a1 + 209692);
            v9 = gl_hs_speed == 0;
            *(_DWORD *)(a1 + 209692) = v44;
            if ( !v9 )
              *(_DWORD *)(a1 + 209976) -= v43;
          }
        }
        else
        {
          v44 = *(_DWORD *)(a1 + 209692);
          v42 = (char *)(a1 + 205596);
        }
        if ( *(_DWORD *)(a1 + 209984) )
          v45 = https_ssl_write(a1);
        else
          v45 = send(*(_DWORD *)(a1 + 205416), v42, v44, 0);
        if ( v45 >= 0 )
        {
          v46 = *(_DWORD *)(a1 + 209692) - v45;
          v47 = *(_DWORD *)(a1 + 205380) - v45;
          *(_DWORD *)(a1 + 209692) = v46;
          *(_DWORD *)(a1 + 205380) = v47;
          if ( v47 > 0 )
            goto LABEL_32;
          goto LABEL_38;
        }
      }
    }
    else
    {
      v18 = *(_DWORD *)(a1 + 205380);
      if ( v18 <= 0 )
      {
LABEL_36:
        if ( v17 == 1 )
        {
          _mem_free(*(void **)(a1 + 205372));
          *(_DWORD *)(a1 + 205372) = 0;
          *(_BYTE *)(a1 + 42) = 0;
        }
LABEL_38:
        result = httpd_send_continue(a1);
        if ( result )
          return result;
LABEL_32:
        v23 = jiffies_get();
        mod_timer(a1 + 205540, v23 + 5000);
        return 0;
      }
      v19 = *(const void **)(a1 + 205368);
      if ( !v19 )
        goto LABEL_32;
      if ( *(_DWORD *)(a1 + 209984) )
        v20 = https_ssl_write(a1);
      else
        v20 = send(*(_DWORD *)(a1 + 205416), v19, v18, 0);
      if ( v20 >= 0 )
      {
        v21 = *(_DWORD *)(a1 + 205368) + v20;
        v22 = *(_DWORD *)(a1 + 205380) - v20;
        *(_DWORD *)(a1 + 205368) = v21;
        *(_DWORD *)(a1 + 205380) = v22;
        if ( v22 > 0 )
          goto LABEL_32;
        v17 = *(unsigned __int8 *)(a1 + 42);
        goto LABEL_36;
      }
    }
LABEL_61:
    httpd_conn_close((int *)a1);
    return -1;
  }
  v14 = *(_DWORD *)(a1 + 210028);
  if ( !v14 )
    return 0;
  v15 = write(*(_DWORD *)(a1 + 205412), *(const void **)(a1 + 210020), v14);
  if ( v15 < 0 )
  {
    if ( *_errno_location() == 11 )
      return 0;
    goto LABEL_61;
  }
  if ( !v15 )
    return 0;
  v16 = *(_DWORD *)(v1 + 13420) - v15;
  *(_DWORD *)(v1 + 13420) = v16;
  if ( v16 <= 0 )
    httpd_conn_epoll_read_pty(a1);
  else
    memmove(*(void **)(v1 + 13412), (void *)(*(_DWORD *)(v1 + 13412) + v15), v16);
  return 0;
}
// 67D0A0: using guessed type int gl_hs_speed;
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00424168) --------------------------------------------------------
time_t get_sys_time()
{
  time_t v1; // [sp+18h] [-Ch] BYREF

  time(&v1);
  return v1;
}

//----- (0042419C) --------------------------------------------------------
char *__fastcall GetDateString(char *a1, const time_t *a2)
{
  int *v2; // $v0
  int *v4; // $v1
  int v5; // $t1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  struct tm *v9; // $v0
  _DWORD v11[19]; // [sp+30h] [-50h] BYREF
  time_t v12; // [sp+7Ch] [-4h] BYREF

  v11[12] = "Sun";
  v11[13] = "Mon";
  v11[14] = "Tue";
  v2 = (int *)fdata;
  v11[15] = &off_4CF0FC;
  v11[16] = &unk_4CF100;
  v11[17] = &off_4CF104;
  v11[18] = &unk_4CF108;
  v4 = v11;
  do
  {
    v5 = *v2;
    v6 = v2[1];
    v7 = v2[2];
    v8 = v2[3];
    v2 += 4;
    *v4 = v5;
    v4[1] = v6;
    v4[2] = v7;
    v4[3] = v8;
    v4 += 4;
  }
  while ( v2 != &gl_httpd_admin_en );
  if ( a2 )
  {
    v9 = gmtime(a2);
  }
  else
  {
    time(&v12);
    v9 = gmtime(&v12);
  }
  sprintf(
    a1,
    "%s, %02d %s %d %02d:%02d:%02d GMT",
    (const char *)v11[v9->tm_wday + 12],
    v9->tm_mday,
    (const char *)v11[v9->tm_mon],
    v9->tm_year + 1900,
    v9->tm_hour,
    v9->tm_min,
    v9->tm_sec);
  return a1;
}
// 4CF0FC: using guessed type void *off_4CF0FC;
// 4CF104: using guessed type void *off_4CF104;
// 666140: using guessed type char *fdata[2];
// 666170: using guessed type int gl_httpd_admin_en;

//----- (00424324) --------------------------------------------------------
char *__fastcall sub_424324(char *a1, const time_t *a2)
{
  struct tm *v3; // $v0
  time_t v5; // [sp+28h] [-Ch] BYREF

  if ( a2 )
  {
    v3 = gmtime(a2);
  }
  else
  {
    time(&v5);
    v3 = gmtime(&v5);
  }
  sprintf(a1, aD_0, v3->tm_year + 1900, v3->tm_mon + 1, v3->tm_mday, v3->tm_hour, v3->tm_min, v3->tm_sec);
  return a1;
}

//----- (004243F0) --------------------------------------------------------
int __fastcall httpd_start(int a1, int a2)
{
  unsigned int v4; // $s5
  unsigned int v5; // $v0
  unsigned int v6; // $s5
  unsigned int v7; // $s0
  int v8; // $v0
  int v9; // $s5
  unsigned int v10; // $v0
  unsigned int v11; // $s0
  char **v12; // $v0
  unsigned int v13; // $s6
  unsigned int v14; // $v0
  unsigned int v15; // $v0
  unsigned int v16; // $s0
  unsigned int v17; // $v0
  char *v18; // $v0
  unsigned int v19; // $v0
  unsigned int v20; // $s0
  unsigned int v21; // $v0
  int result; // $v0
  unsigned int v23; // $v0
  unsigned int v24; // $v0
  unsigned int v25; // $v0
  char v26[1024]; // [sp+18h] [-480h] BYREF
  char v27[128]; // [sp+418h] [-80h] BYREF

  if ( (*(_DWORD *)(a1 + 32) & 2) != 0 )
    *(_DWORD *)(a1 + 36) |= 1u;
  v4 = snprintf(v26, 1024, "%s", httpd_oktok[0]);
  if ( v4 >= 0x400 )
    v4 = 1023;
  v5 = snprintf(&v26[v4], 1024 - v4, "%s", httpd_servertok[0]);
  if ( v5 >= 1024 - v4 )
    v5 = 1023 - v4;
  v6 = v5 + v4;
  v7 = v6;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 205392) + 16) == 2 )
  {
    v25 = snprintf(&v26[v6], 1024 - v6, "%s", "Content-Encoding: gzip\r\n");
    if ( v25 >= 1024 - v6 )
      v25 = 1023 - v6;
    v7 = v25 + v6;
  }
  if ( (*(_DWORD *)(a1 + 36) & 0x1000) != 0 )
  {
    v24 = snprintf(&v26[v7], 1024 - v7, "Set-Cookie: %s; path=/\r\n", httpd_set_cookie);
    if ( v24 >= 1024 - v7 )
      v24 = 1023 - v7;
    *(_DWORD *)(a1 + 36) &= 0xFFFFEFFF;
    v7 += v24;
    memset(httpd_set_cookie, 0, sizeof(httpd_set_cookie));
  }
  v8 = *(_DWORD *)(a1 + 205392);
  if ( *(_DWORD *)(v8 + 16) == 1 || *(_BYTE *)(a1 + 43) == 3 )
  {
    *(_DWORD *)(a1 + 36) &= 0xFFFFFFFE;
    v14 = snprintf(&v26[v7], 1024 - v7, "Pragma: no-cache\r\nCache-Control: no-cache\r\n");
    if ( v14 >= 1024 - v7 )
      v14 = 1023 - v7;
    v11 = v14 + v7;
    *(_DWORD *)(a1 + 36) = 0;
    v9 = 0;
  }
  else
  {
    v9 = *(_DWORD *)(v8 + 20);
    v10 = snprintf(&v26[v7], 1024 - v7, "Last-modified: %s\r\n", *(const char **)(v8 + 28));
    if ( v10 >= 1024 - v7 )
      v10 = 1023 - v7;
    v11 = v10 + v7;
    if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
    {
      v12 = httpd_ctalive;
      v13 = 1024 - v11;
      goto LABEL_19;
    }
  }
  v12 = httpd_ctclose;
  v13 = 1024 - v11;
LABEL_19:
  v15 = snprintf(&v26[v11], v13, "%s", *v12);
  if ( v15 >= v13 )
    v15 = 1023 - v11;
  v16 = v15 + v11;
  if ( a2 )
  {
    v17 = snprintf(&v26[v16], 1024 - v16, httpd_typetok[0], a2);
    if ( v17 >= 1024 - v16 )
      v17 = 1023 - v16;
    v16 += v17;
  }
  if ( v9 )
  {
    v23 = snprintf(&v26[v16], 1024 - v16, httpd_lengthtok[0], v9);
    if ( v23 >= 1024 - v16 )
      v23 = 1023 - v16;
    v16 += v23;
  }
  v18 = GetDateString(v27, 0);
  v19 = snprintf(&v26[v16], 1024 - v16, "Date: %s\r\n", v18);
  if ( v19 >= 1024 - v16 )
    v19 = 1023 - v16;
  v20 = v19 + v16;
  v21 = snprintf(&v26[v20], 1024 - v20, "\r\n");
  if ( v21 >= 1024 - v20 )
    v21 = 1023 - v20;
  result = httpd_send_data_alloc(a1, v26, v21 + v20);
  if ( result )
    return -1;
  if ( !*(_DWORD *)(a1 + 205380) )
    result = httpd_send_continue(a1);
  return result;
}
// 6676B8: using guessed type char *httpd_lengthtok[22];
// 6676BC: using guessed type char *httpd_typetok[21];
// 6676C0: using guessed type char *httpd_ctalive[20];
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D0: using guessed type char *httpd_oktok[16];

//----- (00424854) --------------------------------------------------------
int __fastcall httpd_send_info(int a1, char *a2, int a3)
{
  unsigned int v6; // $s7
  unsigned int v7; // $v0
  unsigned int v8; // $s0
  char **v9; // $v0
  unsigned int v10; // $v0
  unsigned int v11; // $s0
  unsigned int v12; // $v0
  unsigned int v13; // $s0
  unsigned int v14; // $v0
  unsigned int v15; // $s0
  unsigned int v16; // $v0
  bool v17; // dc
  int result; // $v0
  char v19[4100]; // [sp+18h] [-1004h] BYREF

  v6 = snprintf(v19, 4096, "%s", httpd_oktok[0]);
  if ( v6 >= 0x1000 )
    v6 = 4095;
  v7 = snprintf(&v19[v6], 4096 - v6, "%s", httpd_servertok[0]);
  if ( v7 >= 4096 - v6 )
    v7 = 4095 - v6;
  v8 = v7 + v6;
  if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
    v9 = httpd_ctalive;
  else
    v9 = httpd_ctclose;
  v10 = snprintf(&v19[v8], 4096 - v8, "%s", *v9);
  if ( v10 >= 4096 - v8 )
    v10 = 4095 - v8;
  v11 = v10 + v8;
  v12 = snprintf(&v19[v11], 4096 - v11, "Pragma: no-cache\r\nCache-Control: no-cache\r\n");
  if ( v12 >= 4096 - v11 )
    v12 = 4095 - v11;
  v13 = v12 + v11;
  v14 = snprintf(&v19[v13], 4096 - v13, "Content-Type: text/html;charset=gb2312\r\n\r\n");
  if ( v14 >= 4096 - v13 )
    v14 = 4095 - v13;
  v15 = v14 + v13;
  if ( a3 )
  {
    v16 = snprintf(&v19[v15], 4096 - v15, a2, a3);
    if ( v16 < 4096 - v15 )
      goto LABEL_15;
  }
  else
  {
    v16 = snprintf(&v19[v15], 4096 - v15, "%s", a2);
    if ( v16 < 4096 - v15 )
      goto LABEL_15;
  }
  v16 = 4095 - v15;
LABEL_15:
  v17 = httpd_send_data_alloc(a1, v19, v16 + v15) != 0;
  result = 196608;
  if ( !v17 )
  {
    result = *(_DWORD *)(a1 + 205380);
    if ( !result )
      result = httpd_conn_send_finish(a1);
  }
  return result;
}
// 6676C0: using guessed type char *httpd_ctalive[20];
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D0: using guessed type char *httpd_oktok[16];

//----- (00424ACC) --------------------------------------------------------
int __fastcall httpd_check_user(int a1, unsigned int a2)
{
  int v4; // $v0
  _BOOL4 v5; // $v0
  int v6; // $s1
  signed int v7; // $s4
  const char *v8; // $s2
  int v9; // $a2
  int v10; // $v0
  int v11; // $v0
  bool v13; // dc
  const char *v14; // $v0
  char v15[128]; // [sp+20h] [-80h] BYREF

  if ( !httpd_check_aitoken(a1) )
  {
    v6 = 0;
    v11 = *(_DWORD *)(a1 + 205408);
    if ( !v11 || v11 == https_fd )
      return 0;
    return v6;
  }
  v4 = *(_DWORD *)(a1 + 205408);
  if ( v4 )
  {
    v13 = v4 == https_fd;
    v5 = a2 < 2;
    if ( !v13 )
      return a2 != 0;
  }
  else
  {
    v5 = a2 < 2;
  }
  if ( v5 || *(_BYTE *)(a1 + 43) == 1 && *(_DWORD *)(a1 + 205588) >= (signed int)a2 )
    return 0;
  v6 = -1;
  if ( httpd_user_auth_cookie(a1) )
    return v6;
  v7 = *(_DWORD *)(a1 + 205588);
  if ( v7 >= (int)a2 )
    return 0;
  v8 = *(const char **)(a1 + 44);
  if ( !strstr(v8, ".asp") && !strstr(v8, ".data") && !strstr(v8, ".cgi") && !strstr(v8, ".php") && !strstr(v8, ".xml") )
  {
    if ( v7 == 2 )
    {
      httpd_send_info(a1, "<html><head></head><body></body></html>", 0);
    }
    else
    {
      v10 = _GET_LANG_TEXT(2, *(unsigned __int8 *)(a1 + 210102), 0);
      httpd_send_info(
        a1,
        "<html><head></head><body><script type='text/javascript'>alert('%s');</script></body></html>",
        v10);
    }
    return v6;
  }
  v14 = (const char *)_GET_LANG_TEXT(2, *(unsigned __int8 *)(a1 + 210102), v9);
  snprintf(v15, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
  httpd_send_info(a1, v15, 0);
  return -1;
}
// 424D28: variable 'v9' is possibly undefined
// 67BD44: using guessed type int https_fd;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00424DB4) --------------------------------------------------------
int __fastcall httpd_send_404_info(int a1, char *a2, int a3)
{
  unsigned int v6; // $s5
  unsigned int v7; // $v0
  unsigned int v8; // $s5
  char **v9; // $v0
  unsigned int v10; // $v0
  unsigned int v11; // $s1
  unsigned int v12; // $v0
  int v13; // $a3
  unsigned int v14; // $v0
  unsigned int v15; // $s1
  unsigned int v16; // $v0
  unsigned int v17; // $s1
  unsigned int v18; // $v0
  bool v19; // dc
  int result; // $v0
  char v21[4096]; // [sp+20h] [-2000h] BYREF
  char v22[4096]; // [sp+1020h] [-1000h] BYREF

  memset(v22, 0, sizeof(v22));
  memset(v21, 0, sizeof(v21));
  v6 = snprintf(v22, 4096, httpd_errtok[0], 404, "Page Not found");
  if ( v6 >= 0x1000 )
    v6 = 4095;
  v7 = snprintf(&v22[v6], 4096 - v6, "%s", httpd_servertok[0]);
  if ( v7 >= 4096 - v6 )
    v7 = 4095 - v6;
  v8 = v7 + v6;
  if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
    v9 = httpd_ctalive;
  else
    v9 = httpd_ctclose;
  v10 = snprintf(&v22[v8], 4096 - v8, "%s", *v9);
  if ( v10 >= 4096 - v8 )
    v10 = 4095 - v8;
  v11 = v10 + v8;
  if ( a3 )
    v12 = snprintf(v21, 4096, a2, a3);
  else
    v12 = snprintf(v21, 4096, "%s", a2);
  v13 = v12;
  if ( v12 >= 0x1000 )
    v13 = 4095;
  v14 = snprintf(&v22[v11], 4096 - v11, "Content-Length: %d\r\n", v13);
  if ( v14 >= 4096 - v11 )
    v14 = 4095 - v11;
  v15 = v14 + v11;
  v16 = snprintf(&v22[v15], 4096 - v15, "Content-Type: text/html;charset=gb2312\r\n\r\n");
  if ( v16 >= 4096 - v15 )
    v16 = 4095 - v15;
  v17 = v16 + v15;
  v18 = snprintf(&v22[v17], 4096 - v17, "%s", v21);
  if ( v18 >= 4096 - v17 )
    v18 = 4095 - v17;
  v19 = httpd_send_data_alloc(a1, v22, v18 + v17) != 0;
  result = 196608;
  if ( !v19 )
  {
    result = *(_DWORD *)(a1 + 205380);
    if ( !result )
      result = httpd_conn_send_finish(a1);
  }
  return result;
}
// 6676C0: using guessed type char *httpd_ctalive[20];
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D4: using guessed type char *httpd_errtok[15];

//----- (00425080) --------------------------------------------------------
int __fastcall httpd_dowith_post(int a1)
{
  int v2; // $a0
  int v3; // $v0
  char *v5; // $a1

  *(_BYTE *)(a1 + 41) = 3;
  if ( (!*(_DWORD *)(a1 + 205496)
     || (httpd_formdata_parse((_DWORD *)a1, (_BYTE *)(a1 + 564 + *(_DWORD *)(a1 + 205484)), 1), *(_BYTE *)(a1 + 41) == 3))
    && (v2 = *(_DWORD *)(a1 + 44)) != 0
    && *(_BYTE *)(v2 + 1) )
  {
    v3 = httpd_get_cgi();
    *(_DWORD *)(a1 + 205396) = v3;
    if ( v3 )
    {
      if ( !httpd_check_user(a1, *(_DWORD *)(v3 + 4)) )
        (*(void (__fastcall **)(int))(*(_DWORD *)(a1 + 205396) + 8))(a1);
    }
    else
    {
      v5 = httpd_not_found[0];
      *(_BYTE *)(a1 + 41) = 2;
      httpd_send_404_info(a1, v5, 0);
    }
  }
  else
  {
    httpd_conn_close((int *)a1);
  }
  return 0;
}
// 6676A4: using guessed type char *httpd_not_found[27];

//----- (004251B4) --------------------------------------------------------
void __fastcall find_file_head(int a1, const char *a2)
{
  if ( a2 )
    strstr(a2, "\r\n\r\n");
}

//----- (00425210) --------------------------------------------------------
char *__fastcall find_file_end(int a1, char *a2, signed int a3)
{
  int v3; // $a0
  const void *v4; // $s3
  signed int v6; // $s2
  signed int v7; // $s0

  v3 = a1 + 196608;
  v4 = *(const void **)(v3 + 8904);
  if ( !v4 )
    return (char *)v4;
  v6 = *(_DWORD *)(v3 + 8908);
  v7 = a3;
  if ( a3 >= v6 )
  {
    while ( 1 )
    {
      --v7;
      if ( !memcmp(a2, v4, v6) )
        break;
      ++a2;
      if ( v7 < v6 )
        return 0;
    }
    return a2 - 4;
  }
  return 0;
}

//----- (004252DC) --------------------------------------------------------
int __fastcall httpd_send_mime_file(int a1, const char *a2, void *a3, int a4)
{
  const char *v5; // $a3
  unsigned int v9; // $s1
  unsigned int v10; // $v0
  unsigned int v11; // $s1
  unsigned int v12; // $v0
  int v13; // $s2
  unsigned int v14; // $v0
  unsigned int v15; // $s1
  char **v16; // $v0
  unsigned int v17; // $v0
  unsigned int v18; // $s0
  unsigned int v19; // $v0
  signed int v20; // $a0
  signed int v21; // $s0
  int v22; // $s0
  unsigned int v24; // $v0
  unsigned int v25; // $v0
  char v26[1400]; // [sp+18h] [-578h] BYREF

  v5 = httpd_oktok[0];
  *(_DWORD *)(a1 + 36) &= 0xFFFFFFFE;
  v9 = snprintf(v26, 1400, "%s", v5);
  if ( v9 >= 0x578 )
    v9 = 1399;
  v10 = snprintf(&v26[v9], 1400 - v9, "%s", httpd_servertok[0]);
  if ( v10 >= 1400 - v9 )
    v10 = 1399 - v9;
  v11 = v10 + v9;
  v12 = snprintf(&v26[v11], 1400 - v11, "%s", httpd_Accept_Ranges[0]);
  v13 = v12 + v11;
  if ( v12 >= 1400 - v11 )
    v13 = 1399;
  v14 = snprintf(&v26[v13], 1400 - v13, httpd_lengthtok[0], a4);
  if ( v14 >= 1400 - v13 )
    v14 = 1399 - v13;
  v15 = v14 + v13;
  if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
    v16 = httpd_ctalive;
  else
    v16 = httpd_ctclose;
  v17 = snprintf(&v26[v15], 1400 - v15, "%s", *v16);
  if ( v17 >= 1400 - v15 )
    v17 = 1399 - v15;
  v18 = v17 + v15;
  if ( (*(_DWORD *)(a1 + 36) & 0x2000) == 0 )
  {
    if ( (*(_DWORD *)(a1 + 36) & 0x4000) == 0 )
      goto LABEL_15;
    goto LABEL_30;
  }
  v24 = snprintf(&v26[v18], 1400 - v18, "Content-Encoding: gzip\r\n");
  if ( v24 >= 1400 - v18 )
    v24 = 1399 - v18;
  v18 += v24;
  if ( (*(_DWORD *)(a1 + 36) & 0x4000) != 0 )
  {
LABEL_30:
    v25 = snprintf(&v26[v18], 1400 - v18, "Content-disposition: attachment; filename=%s\r\n", *(const char **)(a1 + 44));
    if ( v25 >= 1400 - v18 )
      v25 = 1399 - v18;
    v18 += v25;
  }
LABEL_15:
  v19 = snprintf(&v26[v18], 1400 - v18, "Content-Type: %s\r\n\r\n", a2);
  v20 = v18 + v19;
  if ( v19 >= 1400 - v18 )
    v20 = 1399;
  v21 = a4 + v20;
  if ( a4 + v20 < 1400 )
  {
    memcpy(&v26[v20], a3, a4);
    _mem_free(a3);
    if ( httpd_send_data_alloc(a1, v26, v21) )
      return -1;
    goto LABEL_25;
  }
  if ( httpd_send_data_alloc(a1, v26, v20) )
  {
    if ( a3 )
    {
      v22 = -1;
      _mem_free(a3);
      return v22;
    }
    return -1;
  }
  if ( !*(_DWORD *)(a1 + 205380) )
  {
    v22 = -1;
    if ( httpd_send_data_not_alloc(a1, (char *)a3, a4) )
      return v22;
LABEL_25:
    v22 = *(_DWORD *)(a1 + 205380);
    if ( v22 )
      return 0;
    httpd_conn_send_finish(a1);
    return v22;
  }
  if ( a3 )
    _mem_free(a3);
  httpd_conn_close((int *)a1);
  return -1;
}
// 6676B0: using guessed type char *httpd_Accept_Ranges[24];
// 6676B8: using guessed type char *httpd_lengthtok[22];
// 6676C0: using guessed type char *httpd_ctalive[20];
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D0: using guessed type char *httpd_oktok[16];

//----- (004256F8) --------------------------------------------------------
int __fastcall httpd_send_html_file(int a1, const char *a2, char *a3, signed int a4)
{
  const char *v5; // $a3
  unsigned int v9; // $s1
  unsigned int v10; // $v0
  unsigned int v11; // $s1
  unsigned int v12; // $v0
  int v13; // $s2
  unsigned int v14; // $v0
  unsigned int v15; // $s1
  char **v16; // $v0
  unsigned int v17; // $v0
  int v18; // $v1
  unsigned int v19; // $s0
  unsigned int v20; // $v0
  int v21; // $a0
  signed int v22; // $s0
  int v23; // $s0
  unsigned int v25; // $v0
  unsigned int v26; // $v0
  char v27[1400]; // [sp+18h] [-578h] BYREF

  v5 = httpd_oktok[0];
  *(_DWORD *)(a1 + 36) &= 0xFFFFFFFE;
  v9 = snprintf(v27, 1400, "%s", v5);
  if ( v9 >= 0x578 )
    v9 = 1399;
  v10 = snprintf(&v27[v9], 1400 - v9, "%s", httpd_servertok[0]);
  if ( v10 >= 1400 - v9 )
    v10 = 1399 - v9;
  v11 = v10 + v9;
  v12 = snprintf(&v27[v11], 1400 - v11, "%s", httpd_Accept_Ranges[0]);
  v13 = v12 + v11;
  if ( v12 >= 1400 - v11 )
    v13 = 1399;
  v14 = snprintf(&v27[v13], 1400 - v13, httpd_lengthtok[0], a4);
  if ( v14 >= 1400 - v13 )
    v14 = 1399 - v13;
  v15 = v14 + v13;
  if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
    v16 = httpd_ctalive;
  else
    v16 = httpd_ctclose;
  v17 = snprintf(&v27[v15], 1400 - v15, "%s", *v16);
  if ( v17 >= 1400 - v15 )
    v17 = 1399 - v15;
  v18 = *(_DWORD *)(a1 + 36);
  v19 = v17 + v15;
  if ( (v18 & 0x2000) != 0 )
  {
    v26 = snprintf(&v27[v19], 1400 - v19, "Content-Encoding: gzip\r\n");
    if ( v26 >= 1400 - v19 )
      v26 = 1399 - v19;
    v18 = *(_DWORD *)(a1 + 36);
    v19 += v26;
  }
  if ( (v18 & 0x4000) != 0 )
  {
    v25 = snprintf(&v27[v19], 1400 - v19, "Content-disposition: attachment; filename=%s\r\n", *(const char **)(a1 + 44));
    if ( v25 >= 1400 - v19 )
      v25 = 1399 - v19;
    v19 += v25;
  }
  v20 = snprintf(&v27[v19], 1400 - v19, "Content-Type: %s\r\n\r\n", a2);
  v21 = v20 + v19;
  if ( v20 >= 1400 - v19 )
    v21 = 1399;
  v22 = a4 + v21;
  if ( a4 + v21 >= 1400 )
  {
    if ( !httpd_send_data_alloc(a1, v27, v21) )
    {
      if ( !*(_DWORD *)(a1 + 205380) )
      {
        v23 = -1;
        if ( httpd_send_data_const(a1, a3, a4) )
          return v23;
        goto LABEL_21;
      }
      httpd_conn_close((int *)a1);
    }
    return -1;
  }
  memcpy(&v27[v21], a3, a4);
  if ( httpd_send_data_alloc(a1, v27, v22) )
    return -1;
LABEL_21:
  v23 = *(_DWORD *)(a1 + 205380);
  if ( v23 )
    return 0;
  httpd_conn_send_finish(a1);
  return v23;
}
// 6676B0: using guessed type char *httpd_Accept_Ranges[24];
// 6676B8: using guessed type char *httpd_lengthtok[22];
// 6676C0: using guessed type char *httpd_ctalive[20];
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D0: using guessed type char *httpd_oktok[16];

//----- (00425AA4) --------------------------------------------------------
int __fastcall httpd_send_redirect(int a1, const char *a2)
{
  char *v4; // $v0
  char *v5; // $s0
  const char *v6; // $a3
  char *v7; // $v0
  int v8; // $v0

  if ( !strncmp(a2, "http", 4u) )
  {
    _mem_malloc(20480, "httpd_send_redirect", 6028);
    v5 = v4;
    if ( !v4 )
      return 0;
    v6 = "";
  }
  else
  {
    _mem_malloc(20480, "httpd_send_redirect", 6028);
    v5 = v7;
    if ( !v7 )
      return 0;
    v6 = "http://";
  }
  v8 = snprintf(
         v5,
         20480,
         "HTTP/1.1 302 Found\r\n"
         "Location: %s%s\r\n"
         "Content-Type: text/html;charset=gb2312\r\n"
         "Pragma: no-cache\r\n"
         "Cache-Control: no-cache\r\n"
         "Connection: close\r\n"
         "Server: HTTPD 1.0\r\n"
         "Content-Length: 0\r\n"
         "\r\n",
         v6,
         a2);
  *(_BYTE *)(a1 + 41) = 2;
  *(_DWORD *)(a1 + 205392) = 0;
  if ( v8 >= 20480 )
    v8 = 20479;
  if ( !httpd_send_data_alloc(a1, v5, v8) && !*(_DWORD *)(a1 + 205380) )
    httpd_conn_close((int *)a1);
  _mem_free(v5);
  return 0;
}
// 425B14: variable 'v4' is possibly undefined
// 425B40: variable 'v7' is possibly undefined

//----- (00425C14) --------------------------------------------------------
int __fastcall httpd_send_big_file(int a1, int a2, unsigned int a3)
{
  const char *v3; // $s0
  const char *v7; // $s2
  char *v8; // $v0
  int v9; // $v1
  char *v10; // $s0
  int v11; // $v0
  unsigned int v12; // $v1
  unsigned int v13; // $s5
  unsigned int v14; // $s6
  unsigned int v15; // $v0
  unsigned int v16; // $s6
  unsigned int v17; // $v0
  unsigned int v18; // $s7
  unsigned int v19; // $v0
  unsigned int v20; // $s6
  char **v21; // $v0
  unsigned int v22; // $v0
  int v23; // $v1
  unsigned int v24; // $s0
  char *v25; // $v0
  unsigned int v26; // $v0
  unsigned int v27; // $s0
  const char *v28; // $v0
  unsigned int v29; // $v0
  int v30; // $s0
  unsigned int v32; // $v0
  unsigned int v33; // $v0
  unsigned int v34; // $s0
  char v35[2048]; // [sp+28h] [-880h] BYREF
  char v36[128]; // [sp+828h] [-80h] BYREF

  v3 = *(const char **)(a1 + 205532);
  *(_DWORD *)(a1 + 36) &= 0xFFFFFFFE;
  if ( !v3 )
    goto LABEL_9;
  if ( (*(_DWORD *)(a1 + 32) & 0x20000) == 0 )
    goto LABEL_9;
  v7 = v3 + 6;
  if ( strncmp(v3, "bytes=", 6u) )
    goto LABEL_9;
  v8 = strchr(v3 + 6, 45);
  if ( !v8 )
    goto LABEL_9;
  *v8 = 0;
  v9 = v3[6];
  v10 = v8 + 1;
  if ( v9 )
  {
    v13 = J_atoi(v7);
    v12 = J_atoi(v10);
    if ( !v12 )
      v12 = a3 - 1;
  }
  else
  {
    v11 = J_atoi(v8 + 1);
    v12 = a3 - 1;
    v13 = a3 - v11;
  }
  if ( v13 < a3 && v12 >= v13 )
  {
    v34 = v12 + 1 - v13;
    v18 = snprintf(
            v35,
            2048,
            "HTTP/1.1 206 Partial Content\r\nContent-Length: %u\r\nContent-Range: bytes %u-%u/%u\r\n",
            v34,
            v13,
            v12,
            a3);
    if ( v18 >= 0x800 )
      v18 = 2047;
    a3 = v34;
  }
  else
  {
LABEL_9:
    v14 = snprintf(v35, 2048, "%s", httpd_oktok[0]);
    if ( v14 >= 0x800 )
      v14 = 2047;
    v15 = snprintf(&v35[v14], 2048 - v14, "%s", httpd_Accept_Ranges[0]);
    if ( v15 >= 2048 - v14 )
      v15 = 2047 - v14;
    v16 = v15 + v14;
    v17 = snprintf(&v35[v16], 2048 - v16, httpd_lengthtok[0], a3);
    if ( v17 >= 2048 - v16 )
      v17 = 2047 - v16;
    v18 = v17 + v16;
    v13 = 0;
  }
  v19 = snprintf(&v35[v18], 2048 - v18, "%s", httpd_servertok[0]);
  if ( v19 >= 2048 - v18 )
    v19 = 2047 - v18;
  v20 = v19 + v18;
  if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
    v21 = httpd_ctalive;
  else
    v21 = httpd_ctclose;
  v22 = snprintf(&v35[v20], 2048 - v20, "%s", *v21);
  if ( v22 >= 2048 - v20 )
    v22 = 2047 - v20;
  v23 = *(_DWORD *)(a1 + 36);
  v24 = v22 + v20;
  if ( (v23 & 0x2000) != 0 )
  {
    v33 = snprintf(&v35[v24], 2048 - v24, "Content-Encoding: gzip\r\n");
    if ( v33 >= 2048 - v24 )
      v33 = 2047 - v24;
    v23 = *(_DWORD *)(a1 + 36);
    v24 += v33;
  }
  if ( (v23 & 0x4000) != 0 )
  {
    v32 = snprintf(&v35[v24], 2048 - v24, "Content-disposition: attachment; filename=%s\r\n", *(const char **)(a1 + 44));
    if ( v32 >= 2048 - v24 )
      v32 = 2047 - v24;
    v24 += v32;
  }
  v25 = GetDateString(v36, 0);
  v26 = snprintf(&v35[v24], 2048 - v24, "Date: %s\r\n", v25);
  if ( v26 >= 2048 - v24 )
    v26 = 2047 - v24;
  v27 = v26 + v24;
  v28 = httpd_find_type2((const char *)a2);
  v29 = snprintf(&v35[v27], 2048 - v27, "Content-Type: %s\r\n\r\n", v28);
  if ( v29 >= 2048 - v27 )
    v29 = 2047 - v27;
  if ( httpd_send_data_alloc(a1, v35, v29 + v27) )
    return -1;
  v30 = httpd_send_data_file(a1, (const char *)a2, a3, v13);
  if ( v30 )
    return -1;
  if ( !*(_DWORD *)(a1 + 205380) )
    httpd_conn_send_finish(a1);
  return v30;
}
// 6676B0: using guessed type char *httpd_Accept_Ranges[24];
// 6676B8: using guessed type char *httpd_lengthtok[22];
// 6676C0: using guessed type char *httpd_ctalive[20];
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D0: using guessed type char *httpd_oktok[16];
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004260D4) --------------------------------------------------------
int __fastcall sub_4260D4(int a1)
{
  char v3[256]; // [sp+18h] [-1A4h] BYREF
  struct stat v4; // [sp+118h] [-A4h] BYREF

  snprintf(v3, 256, "/tmp/wxwifi/%s", (const char *)(*(_DWORD *)(a1 + 44) + 16));
  if ( stat(v3, &v4) || (v4.st_uid & 0xF000) == 0x4000 )
    return -1;
  httpd_send_big_file(a1, (int)v3, v4.st_atim.tv_sec);
  return 0;
}

//----- (00426184) --------------------------------------------------------
int __fastcall httpd_send_logs_file(int a1)
{
  char *v2; // $v0
  void *v3; // $s0
  size_t v4; // $v0
  char v6[256]; // [sp+18h] [-1A0h] BYREF
  struct stat v7; // [sp+118h] [-A0h] BYREF

  strcpy(v6, "/tmp/logs/");
  memset(&v6[11], 0, 0xF5u);
  v2 = strstr(*(const char **)(a1 + 44), "/logs/");
  v3 = v2 + 6;
  if ( !v2 )
    return -1;
  v4 = strlen(v2 + 6);
  if ( v4 >= 0xC9 )
    return -1;
  memcpy(&v6[10], v3, v4 + 1);
  if ( stat(v6, &v7) )
  {
    unescape(v6);
    if ( stat(v6, &v7) )
      return -1;
  }
  if ( (v7.st_uid & 0xF000) == 0x4000 )
    return -1;
  httpd_send_big_file(a1, (int)v6, v7.st_atim.tv_sec);
  return 0;
}

//----- (004262F8) --------------------------------------------------------
int __fastcall httpd_send_big_file_ll(int a1, int a2, unsigned int a3, signed int a4)
{
  const char *v4; // $s0
  const char *v9; // $s2
  char *v10; // $v0
  int v11; // $v1
  char *v12; // $s0
  unsigned int v13; // $s0
  __int64 v14; // $v0
  int v15; // $fp
  unsigned int v16; // $s7
  signed int v17; // $s5
  _BOOL4 v18; // $v0
  unsigned int v19; // $fp
  unsigned int v20; // $v0
  int v21; // $s5
  unsigned int v22; // $v0
  unsigned int v23; // $fp
  unsigned int v24; // $v0
  unsigned int v25; // $t0
  unsigned int v26; // $fp
  char **v27; // $v0
  const char *v28; // $a3
  unsigned int v29; // $v0
  int v30; // $v1
  unsigned int v31; // $s0
  char *v32; // $v0
  unsigned int v33; // $v0
  const char *v34; // $v0
  unsigned int v35; // $s0
  unsigned int v36; // $v0
  int v37; // $s0
  unsigned int v39; // $v0
  unsigned int v40; // $v0
  __int64 v41; // kr00_8
  __int64 v42; // kr08_8
  char v43[2048]; // [sp+38h] [-888h] BYREF
  char v44[128]; // [sp+838h] [-88h] BYREF
  unsigned int v45; // [sp+8B8h] [-8h]
  unsigned int v46; // [sp+8BCh] [-4h]

  v4 = *(const char **)(a1 + 205532);
  *(_DWORD *)(a1 + 36) &= 0xFFFFFFFE;
  if ( !v4 )
    goto LABEL_9;
  if ( (*(_DWORD *)(a1 + 32) & 0x20000) == 0 )
    goto LABEL_9;
  v9 = v4 + 6;
  if ( strncmp(v4, "bytes=", 6u) )
    goto LABEL_9;
  v10 = strchr(v4 + 6, 45);
  if ( !v10 )
    goto LABEL_9;
  *v10 = 0;
  v11 = v4[6];
  v12 = v10 + 1;
  if ( v11 )
  {
    v41 = J_atoi_ull(v9);
    v17 = HIDWORD(v41);
    v16 = v41;
    v42 = J_atoi_ull(v12);
    v15 = HIDWORD(v42);
    v13 = v42;
    if ( !v42 )
    {
      v13 = a3 - 1;
      v15 = (a3 != 0) + a4 - 1;
    }
  }
  else
  {
    v13 = a3 - 1;
    v15 = (a3 != 0) + a4 - 1;
    v14 = J_atoi_ull(v10 + 1);
    v16 = a3 - v14;
    v17 = (__PAIR64__(a4, a3) - __PAIR64__(HIDWORD(v14), a3 - (unsigned int)v14)) >> 32;
  }
  if ( ((v18 = v15 < v17, v17 < a4) || a4 == v17 && (v18 = v15 < v17, v16 < a3)) && !v18 && (v17 != v15 || v13 >= v16) )
  {
    v46 = v13 - v16 + 1;
    v45 = (__PAIR64__(v15, v13) - __PAIR64__(v17, v16) + 1) >> 32;
    v23 = snprintf(
            v43,
            2048,
            "HTTP/1.1 206 Partial Content\r\nContent-Length: %lld\r\nContent-Range: bytes %lld-%lld/%lld\r\n",
            __PAIR64__(v15, v13) - __PAIR64__(v17, v16) + 1,
            __PAIR64__(v17, v16),
            __PAIR64__(v15, v13),
            __PAIR64__(a4, a3));
    if ( v23 >= 0x800 )
      v23 = 2047;
    a3 = v46;
    a4 = v45;
  }
  else
  {
LABEL_9:
    v19 = snprintf(v43, 2048, "%s", httpd_oktok[0]);
    if ( v19 >= 0x800 )
      v19 = 2047;
    v20 = snprintf(&v43[v19], 2048 - v19, "%s", httpd_Accept_Ranges[0]);
    v21 = v20 + v19;
    if ( v20 >= 2048 - v19 )
      v21 = 2047;
    v22 = snprintf(&v43[v21], 2048 - v21, httpd_lengthtok_ll[0]);
    if ( v22 >= 2048 - v21 )
      v22 = 2047 - v21;
    v23 = v22 + v21;
    v16 = 0;
  }
  v45 = 2048 - v23;
  v24 = snprintf(&v43[v23], 2048 - v23, "%s", httpd_servertok[0]);
  if ( v24 >= v45 )
    v24 = 2047 - v23;
  v25 = v24 + v23;
  v26 = 2048 - (v24 + v23);
  if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
    v27 = httpd_ctalive;
  else
    v27 = httpd_ctclose;
  v28 = *v27;
  v45 = v25;
  v29 = snprintf(&v43[v25], v26, "%s", v28);
  if ( v29 >= v26 )
    v29 = 2047 - v45;
  v30 = *(_DWORD *)(a1 + 36);
  v31 = v29 + v45;
  if ( (v30 & 0x2000) != 0 )
  {
    v40 = snprintf(&v43[v31], 2048 - v31, "Content-Encoding: gzip\r\n");
    if ( v40 >= 2048 - v31 )
      v40 = 2047 - v31;
    v30 = *(_DWORD *)(a1 + 36);
    v31 += v40;
  }
  if ( (v30 & 0x4000) != 0 )
  {
    v39 = snprintf(&v43[v31], 2048 - v31, "Content-disposition: attachment; filename=%s\r\n", *(const char **)(a1 + 44));
    if ( v39 >= 2048 - v31 )
      v39 = 2047 - v31;
    v31 += v39;
  }
  v32 = GetDateString(v44, 0);
  v33 = snprintf(&v43[v31], 2048 - v31, "Date: %s\r\n", v32);
  if ( v33 >= 2048 - v31 )
    v33 = 2047 - v31;
  v35 = v33 + v31;
  v34 = httpd_find_type2((const char *)a2);
  v36 = snprintf(&v43[v35], 2048 - v35, "Content-Type: %s\r\n\r\n", v34);
  if ( v36 >= 2048 - v35 )
    v36 = 2047 - v35;
  if ( httpd_send_data_alloc(a1, v43, v36 + v35) )
    return -1;
  v37 = httpd_send_data_file_ll(a1, (const char *)a2, a3, a4, v16);
  if ( v37 )
    return -1;
  if ( !*(_QWORD *)(a1 + 205384) )
    httpd_conn_send_finish(a1);
  return v37;
}
// 6676B0: using guessed type char *httpd_Accept_Ranges[24];
// 6676B4: using guessed type char *httpd_lengthtok_ll[23];
// 6676C0: using guessed type char *httpd_ctalive[20];
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D0: using guessed type char *httpd_oktok[16];
// 6A83B0: using guessed type __int64 __fastcall J_atoi_ull(_DWORD);

//----- (00426888) --------------------------------------------------------
int __fastcall httpd_send_usb_file(int a1)
{
  const char *v2; // $s5
  int v3; // $s1
  int v4; // $s4
  void *v6; // $v0
  void *v7; // $s2
  char *v8; // $v0
  char *v9; // $s3
  const char *v10; // $s6
  const char *v11; // $v0
  int v12; // $s0
  char *v13; // $v0
  int v14; // $s7
  DIR *v15; // $fp
  struct dirent *v16; // $v0
  char *v17; // $s6
  struct tm *v18; // $v0
  int v19; // $a3
  char *v20; // $v0
  int v21; // $s7
  const char *v22; // $a2
  int v23; // $v0
  char *v24; // $a1
  _BYTE v25[1024]; // [sp+30h] [-538h] BYREF
  struct stat v26; // [sp+430h] [-138h] BYREF
  char v27[128]; // [sp+4D0h] [-98h] BYREF
  char *v28; // [sp+550h] [-18h]
  char *v29; // [sp+554h] [-14h]
  char *format; // [sp+558h] [-10h]
  const char *v31; // [sp+55Ch] [-Ch]
  char *v32; // [sp+560h] [-8h]
  const char *v33; // [sp+564h] [-4h]

  v2 = (const char *)jhl_nv_get_def("lan_ipaddr");
  if ( !strncmp(*(const char **)(a1 + 44), "/usb/app/", 9u) )
    goto LABEL_7;
  if ( nvram_match_def("usb_share_enable", "0") )
    goto LABEL_9;
  v3 = usb_acc_check((int *)(a1 + 205460));
  if ( v3 )
    goto LABEL_9;
  if ( !nvram_match_def("usb_acc_auth", "1") )
  {
LABEL_7:
    v4 = 0;
    goto LABEL_8;
  }
  v4 = 1;
  if ( !usb_httpd_check_user(a1, 1) )
  {
LABEL_8:
    if ( !check_usb_state() )
    {
LABEL_9:
      v3 = 0;
      httpd_conn_close((int *)a1);
      return v3;
    }
    _mem_malloc(512, "httpd_send_usb_file", 1786);
    v7 = v6;
    if ( !v6 )
      return -1;
    _mem_malloc(512, "httpd_send_usb_file", 1792);
    v9 = v8;
    if ( !v8 )
    {
      _mem_free(v7);
      return -1;
    }
    v10 = *(const char **)(a1 + 44);
    v11 = &v10[strlen(v10) - 1];
    if ( *v11 == 47 )
    {
      *v11 = 0;
      v10 = *(const char **)(a1 + 44);
    }
    if ( !strcmp(v10, "/usb") )
    {
      memset(v25, 0, sizeof(v25));
      snprintf(v25, 1024, "%s%s", *(const char **)(a1 + 205504), "/usb_list.html");
      return httpd_send_redirect(a1, v25);
    }
    snprintf((char *)v7, 512, "/tmp/mnt/sda1/%s", v10 + 5);
    if ( !stat((const char *)v7, &v26) || (unescape((char *)v7), !stat((const char *)v7, &v26)) )
    {
      if ( (v26.st_uid & 0xF000) != 0x4000 )
      {
        if ( *(_QWORD *)&v26.st_atim < 0x80000000LL )
          httpd_send_big_file(a1, (int)v7, v26.st_atim.tv_sec);
        else
          httpd_send_big_file_ll(a1, (int)v7, v26.st_atim.tv_sec, v26.st_atim.tv_nsec);
        v12 = 0;
        goto LABEL_20;
      }
      _mem_malloc(1024000, "httpd_send_usb_file", 1823);
      v29 = v13;
      if ( v13 )
      {
        v14 = sprintf(
                v13,
                "<html><head><META http-eqiu='Content-Type' content='text/html; charset=UTF-8'><title>%s - %s/</title></h"
                "ead><body><H1>%s - %s/</H1><hr><pre>",
                v2,
                (const char *)(*(_DWORD *)(a1 + 44) + 5),
                v2,
                (const char *)(*(_DWORD *)(a1 + 44) + 5));
        v15 = opendir((const char *)v7);
        if ( v15 )
        {
          v28 = ".";
          format = "%s/%s";
          v31 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
          v32 = "%s   %lld   <A HREF='%s/%s'>%s</A><br>\r\n";
          v33 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
          while ( 1 )
          {
            v16 = readdir(v15);
            v17 = &v16->d_name[8];
            if ( !v16 || v14 >= 1022977 )
              break;
            if ( strcmp(&v16->d_name[8], v28) )
            {
              sprintf(v9, format, v7, v17);
              if ( stat(v9, (struct stat *)v25) == -1 )
              {
                perror("stat");
              }
              else
              {
                v18 = localtime((const time_t *)&v25[72]);
                strftime(v27, 0x80u, v31 - 2456, v18);
                if ( (*(_WORD *)&v25[24] & 0xF000) == 0x4000 )
                  v14 += sprintf(&v29[v14], (char *)v33 - 2444, v27, *(_DWORD *)(a1 + 44), v17, v17);
                else
                  v14 += sprintf(&v29[v14], v32, v27);
              }
            }
          }
          closedir(v15);
        }
        v19 = (int)v29;
        v20 = &v29[v14];
        strcpy(&v29[v14], "</pre>");
        v21 = v14 + 6;
        *(_DWORD *)v20 = *(_DWORD *)"</pre>";
        if ( v4 )
          v22 = "<iframe src='/usb_upload.htm'  id='fram_id' height='200px' width='1000' frameborder='0' scrolling='no'> </iframe>";
        else
          v22 = "";
        v23 = sprintf((char *)(v19 + v21), "<hr>%s</body></html>", v22);
        v24 = v29;
        *(_DWORD *)(a1 + 36) |= 0x8000u;
        httpd_cgi_ret(a1, v24, v21 + v23, 8);
        v12 = 0;
        goto LABEL_20;
      }
    }
    v12 = -1;
LABEL_20:
    _mem_free(v7);
    _mem_free(v9);
    v3 = v12;
  }
  return v3;
}
// 426A0C: variable 'v6' is possibly undefined
// 426A2C: variable 'v8' is possibly undefined
// 426C4C: variable 'v13' is possibly undefined
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (00426F10) --------------------------------------------------------
int __fastcall httpd_send_file(int a1, int a2)
{
  int v4; // $v0
  const char *v5; // $s1
  int v6; // $s1
  int v7; // $s1
  char *v8; // $s1
  int *v9; // $v0
  int v10; // $s2
  int v11; // $a1
  int *v12; // $s2
  int *v13; // $v0
  int *v14; // $s2
  const char *v15; // $s1
  char *v16; // $a1
  int v17; // $s3
  char *v19; // $s1
  size_t v20; // $v0
  const char **v21; // $s2
  int v22; // $s3
  const char *v23; // $s1
  int v24; // $s1
  const char *v25; // $v0
  time_t v26; // $s1
  int v27; // $v0
  int v28; // $v0
  time_t v29; // $s1
  int v30; // $a3
  const char *v31; // $s1
  unsigned int v32; // $s1
  int v33; // $a2
  const char *v34; // $s3
  int v35; // $v0
  const char *v36; // $a0
  int v37; // $v0
  int v38; // $v0
  time_t v39; // $v0
  unsigned int v40; // $v0
  char *v41; // $v0
  void (__fastcall *v42)(int); // $t9
  const char *v43; // $v0
  const char *v44; // $s3
  char *v45; // $v0
  const char *v46; // $s1
  const char *v47; // $v0
  int v48; // $v0
  char v49[1024]; // [sp+50h] [-750h] BYREF
  char v50[256]; // [sp+450h] [-350h] BYREF
  char v51[104]; // [sp+550h] [-250h] BYREF
  char v52[64]; // [sp+5B8h] [-1E8h] BYREF
  char v53[64]; // [sp+5F8h] [-1A8h] BYREF
  char v54[64]; // [sp+638h] [-168h] BYREF
  char v55[64]; // [sp+678h] [-128h] BYREF
  char v56[64]; // [sp+6B8h] [-E8h] BYREF
  char v57[64]; // [sp+6F8h] [-A8h] BYREF
  int v58[8]; // [sp+738h] [-68h] BYREF
  int v59[8]; // [sp+758h] [-48h] BYREF
  int v60; // [sp+778h] [-28h]
  char *v61; // [sp+780h] [-20h]
  char *v62; // [sp+784h] [-1Ch]
  char *v63; // [sp+788h] [-18h]
  const char *v64; // [sp+78Ch] [-14h]
  char *v65; // [sp+790h] [-10h]
  char *v66; // [sp+794h] [-Ch]
  char *v67; // [sp+798h] [-8h]
  char *v68; // [sp+79Ch] [-4h]

  v4 = nvram_match_def("billing_en", "1");
  v5 = *(const char **)(a1 + 44);
  if ( v4 && !strcmp(*(const char **)(a1 + 44), "/user_pppoe_group.htm") )
  {
    *(_DWORD *)(a1 + 44) = "/user.htm";
  }
  else if ( !strncmp(v5, "/welcome/gethiipmac.", 0x14u) )
  {
    memset(v49, 0, 0x200u);
    v45 = httpd_get_parm(a1, "ld");
    v46 = v45;
    if ( v45 && *v45 && !jhl_get_hi_redirect_ipmac((_DWORD *)a1, v49) )
    {
      httpds_send_redirect_ipmac(a1, v46, v49);
      return -1;
    }
LABEL_98:
    httpd_conn_close((int *)a1);
    return -1;
  }
  if ( *(_DWORD *)(a1 + 209984) )
  {
    memset(v49, 0, sizeof(v49));
    v6 = jhl_get_hi_redirect_url((_DWORD *)a1, v49, 1024);
    if ( *(_DWORD *)(a1 + 205504) && !hs_addr_loopback(a1) )
    {
      if ( nvram_match_def("https_lanport", "443") )
      {
        v25 = (const char *)jhl_nv_get_def("lan_ipaddr");
        snprintf(v50, 128, "%s", v25);
      }
      else
      {
        v44 = (const char *)jhl_nv_get_def("lan_ipaddr");
        v43 = (const char *)jhl_nv_get_def("https_lanport");
        snprintf(v50, 128, "%s:%s", v44, v43);
      }
      if ( !strcmp(*(const char **)(a1 + 205504), v50) )
        v6 = 1;
    }
    if ( v6 == 3 )
    {
      httpds_send_redirect(a1, v49);
      return -1;
    }
    if ( !v6 )
    {
      v47 = (const char *)jhl_nv_get_def("https_auth_redirect");
      httpds_send_redirect(a1, v47);
      return -1;
    }
  }
  if ( *(_BYTE *)(a1 + 41) != 2 )
    goto LABEL_98;
  v7 = *(_DWORD *)(a1 + 44);
  if ( !v7 )
    goto LABEL_98;
  if ( *(_BYTE *)(v7 + 1) )
  {
    v8 = (char *)(v7 + 1);
    if ( !a2 )
      goto LABEL_13;
    goto LABEL_20;
  }
  v59[0] = 0;
  v59[1] = 0;
  v59[2] = 0;
  v59[3] = 0;
  v59[4] = 0;
  v59[5] = 0;
  v59[6] = 0;
  v59[7] = 0;
  v58[0] = 0;
  v58[1] = 0;
  v58[2] = 0;
  v58[3] = 0;
  v58[4] = 0;
  v58[5] = 0;
  v58[6] = 0;
  v58[7] = 0;
  v60 = 0;
  v67 = v57;
  memset(v50, 0, sizeof(v50));
  memset(v57, 0, sizeof(v57));
  v66 = v56;
  memset(v56, 0, sizeof(v56));
  v62 = v55;
  memset(v55, 0, sizeof(v55));
  memset(v54, 0, sizeof(v54));
  v65 = v53;
  memset(v53, 0, sizeof(v53));
  v63 = v52;
  memset(v52, 0, sizeof(v52));
  v19 = httpd_get_parm(a1, "extend");
  if ( !v19 || !hs_addr_loopback(a1) )
    goto LABEL_42;
  v20 = strlen(v19);
  base64_decode(v19, v50, v20);
  v21 = (const char **)v49;
  v60 = split_string(v50, 38, v49, 60);
  if ( v60 <= 0 )
    goto LABEL_59;
  v64 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
  v61 = "sign=";
  v22 = 0;
  v68 = "letmego";
  while ( 1 )
  {
    v23 = *v21;
    if ( !strncmp(*v21, "tag=", 4u) )
    {
      strlcpy(v62, v23 + 4, 64);
      goto LABEL_38;
    }
    if ( !strncmp(v23, "time=", 5u) )
      break;
    if ( !strncmp(v23, v61, 5u) )
    {
      strlcpy(v65, v23 + 5, 64);
    }
    else if ( !strncmp(v23, v64 - 2120, 4u) )
    {
      strlcpy(v63, v23 + 4, 64);
      if ( strcmp(v63, v68) )
      {
        printf("%s[%d]: cmd:%s error \n", "httpd_send_file", 3670, v63);
        goto LABEL_59;
      }
    }
LABEL_38:
    ++v22;
    ++v21;
    if ( v22 >= v60 )
      goto LABEL_59;
  }
  strlcpy(v54, v23 + 5, 64);
  v26 = time(0);
  v27 = v26 - atoi(v54);
  if ( v27 < 0 )
    v27 = -v27;
  if ( v27 < 601 )
    goto LABEL_38;
  v29 = time(0);
  v28 = atoi(v54);
  v30 = v29 - v28;
  if ( v29 - v28 < 0 )
    v30 = v28 - v29;
  printf("%s[%d]: %d timeout 600\n", "httpd_send_file", 3657, v30);
LABEL_59:
  if ( v55[0] && v54[0] && v53[0] && v52[0] )
  {
    v31 = v67;
    sq_file_get_ssid_en(v67, 64);
    v32 = snprintf(v50, 256, "%s%s%s", v31, v54, v62);
    MD5Init(v51);
    v33 = v32;
    if ( v32 >= 0x100 )
      v33 = 255;
    MD5Update(v51, v50, v33);
    MD5Final(v51);
    v34 = v66;
    sprintf(
      v66,
      "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
      (unsigned __int8)v51[88],
      (unsigned __int8)v51[89],
      (unsigned __int8)v51[90],
      (unsigned __int8)v51[91],
      (unsigned __int8)v51[92],
      (unsigned __int8)v51[93],
      (unsigned __int8)v51[94],
      (unsigned __int8)v51[95],
      (unsigned __int8)v51[96],
      (unsigned __int8)v51[97],
      (unsigned __int8)v51[98],
      (unsigned __int8)v51[99],
      (unsigned __int8)v51[100],
      (unsigned __int8)v51[101],
      (unsigned __int8)v51[102],
      (unsigned __int8)v51[103]);
    if ( !strcmp(v65, v34) )
    {
      if ( gl_httpd_high_admin_en )
      {
        v35 = jhl_nv_get_def("http_hadmin");
        strlcpy(v59, v35, 32);
        v36 = "http_hadminpwd";
      }
      else
      {
        v48 = jhl_nv_get_def("http_username");
        strlcpy(v59, v48, 32);
        v36 = "http_passwd";
      }
      v37 = jhl_nv_get_def(v36);
      strlcpy(v58, v37, 32);
      httpd_cgi_user_check((const char *)v59, (const char *)v58, (_DWORD *)(a1 + 205588));
      v38 = *(_DWORD *)(a1 + 36) | 0x1000;
      *(_BYTE *)(a1 + 43) = 1;
      *(_DWORD *)(a1 + 36) = v38;
      v39 = time(0);
      v40 = snprintf(
              v50,
              256,
              "<html><head><script type='text/javascript'>function init(){window.open('/index.htm?_%lu','_self');}</scrip"
              "t></head><body onLoad='init();'></body></html>",
              v39);
      if ( v40 >= 0x100 )
        v40 = 255;
      return httpd_cgi_ret(a1, v50, v40, 4);
    }
    printf("%s[%d]: error sign:%s, md5:%s\n", "httpd_send_file", 3698, v65, v66);
  }
LABEL_42:
  v8 = "index.htm";
  if ( a2 )
  {
LABEL_20:
    v15 = *(const char **)(a1 + 44);
    if ( !strncmp(v15, "/usb/", 5u) )
    {
      v24 = httpd_send_usb_file(a1);
    }
    else
    {
      if ( !strncmp(v15, "/usb_json/", 0xAu) )
      {
        v17 = 0;
        if ( !httpd_send_usb_file_json((int *)a1) )
          return v17;
        goto LABEL_26;
      }
      if ( !strncmp(v15, "/auth_pic/", 0xAu) )
      {
        v17 = 0;
        if ( !httpd_send_auth_pic_file(a1) )
          return v17;
        goto LABEL_26;
      }
      if ( !strncmp(v15, "/auth_html/", 0xBu) )
      {
        v17 = 0;
        if ( !httpd_send_auth_html_file(a1) )
          return v17;
        goto LABEL_26;
      }
      if ( strncmp(v15, "/logs/", 6u) )
      {
        if ( strncmp(v15, "/sj/", 4u) )
        {
LABEL_26:
          v16 = httpd_not_found[0];
          *(_BYTE *)(a1 + 41) = 2;
          httpd_send_404_info(a1, v16, 0);
          return 0;
        }
LABEL_92:
        v17 = 0;
        if ( httpd_check_user(a1, 4u) )
          return v17;
        v17 = 0;
        if ( !httpd_send_sj_file((_DWORD *)a1) )
          return v17;
        goto LABEL_26;
      }
      v17 = 0;
      if ( httpd_check_user(a1, 4u) )
        return v17;
      v24 = httpd_send_logs_file(a1);
      if ( !strncmp(*(const char **)(a1 + 44), "/sj/", 4u) )
        goto LABEL_92;
    }
    v17 = 0;
    if ( !v24 )
      return v17;
    goto LABEL_26;
  }
LABEL_13:
  while ( 1 )
  {
    v10 = get_name_hash((unsigned __int8 *)v8);
    v9 = httpd_get_file(v8, v10);
    v11 = v10;
    v12 = v9;
    if ( v9 )
      break;
    v13 = httpd_find_ext_file(v8, v11);
    v14 = v13;
    if ( v13 )
    {
      v17 = httpd_check_user(a1, v13[4]);
      if ( !v17 )
      {
        v42 = (void (__fastcall *)(int))v14[6];
        if ( v42 )
        {
          v42(a1);
          return v17;
        }
      }
      return 0;
    }
    if ( !strcmp(v8, "index.htm") )
    {
      v8 = "index.html";
    }
    else
    {
      if ( strcmp(v8, "login.htm") )
      {
        if ( debug_level > 0 )
          printf("%s:%d not find ext file, %s\n", "httpd_send_file", 3789, v8);
        goto LABEL_20;
      }
      v8 = "login.html";
    }
  }
  *(_DWORD *)(a1 + 205392) = v9;
  *(_DWORD *)(a1 + 205400) = 0;
  if ( !strcmp(v8, "index.html") && httpd_get_parm(a1, "ip") && httpd_get_parm(a1, "port") && httpd_get_parm(a1, "sn") )
    v12[3] = 0;
  if ( !strcmp(v8, "config.html") )
    goto LABEL_20;
  v17 = httpd_check_user(a1, v12[3]);
  if ( v17 )
    return 0;
  v41 = httpd_find_type(v8);
  httpd_start(a1, (int)v41);
  return v17;
}
// 6676A4: using guessed type char *httpd_not_found[27];
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 67D0BC: using guessed type int debug_level;
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A8384: using guessed type int __fastcall MD5Init(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8800: using guessed type int __fastcall sq_file_get_ssid_en(_DWORD, _DWORD);
// 6A8850: using guessed type int __fastcall MD5Final(_DWORD);
// 6A8928: using guessed type int __fastcall MD5Update(_DWORD, _DWORD, _DWORD);

//----- (00427DF0) --------------------------------------------------------
int __fastcall httpd_cgi_ret(int a1, char *a2, int a3, int a4)
{
  int v4; // $s2
  unsigned int v7; // $v0
  unsigned int v8; // $s5
  unsigned int v9; // $v0
  unsigned int v10; // $s5
  unsigned int v11; // $v0
  unsigned int v12; // $s5
  unsigned int v13; // $v0
  unsigned int v14; // $s5
  char **v15; // $v0
  unsigned int v16; // $v0
  unsigned int v17; // $s5
  unsigned int v18; // $v0
  int v19; // $v1
  unsigned int v20; // $s5
  unsigned int v21; // $s4
  unsigned int v22; // $v0
  signed int v23; // $a0
  signed int v24; // $s4
  char *v25; // $a0
  int v26; // $v0
  int result; // $v0
  signed int v28; // $s2
  char *v29; // $v0
  unsigned int v30; // $v0
  unsigned int v31; // $s5
  unsigned int v32; // $v0
  unsigned int v33; // $s5
  unsigned int v34; // $v0
  unsigned int v35; // $s5
  char **v36; // $v0
  unsigned int v37; // $v0
  int v38; // $s4
  unsigned int v39; // $v0
  int v40; // $v1
  unsigned int v41; // $s4
  unsigned int v42; // $s5
  unsigned int v43; // $v0
  signed int v44; // $a0
  bool v45; // dc
  unsigned int v46; // $v0
  unsigned int v47; // $s5
  unsigned int v48; // $v0
  unsigned int v49; // $s5
  unsigned int v50; // $v0
  unsigned int v51; // $s5
  char **v52; // $v0
  unsigned int v53; // $v0
  int v54; // $s4
  unsigned int v55; // $v0
  int v56; // $v1
  unsigned int v57; // $s4
  unsigned int v58; // $s5
  unsigned int v59; // $v0
  unsigned int v60; // $v0
  unsigned int v61; // $s5
  unsigned int v62; // $v0
  unsigned int v63; // $s5
  unsigned int v64; // $v0
  unsigned int v65; // $s5
  char **v66; // $v0
  unsigned int v67; // $v0
  unsigned int v68; // $s5
  unsigned int v69; // $v0
  int v70; // $v1
  unsigned int v71; // $s5
  unsigned int v72; // $s4
  unsigned int v73; // $v0
  unsigned int v74; // $v0
  unsigned int v75; // $v0
  char v76[1400]; // [sp+18h] [-578h] BYREF

  switch ( a4 )
  {
    case 1:
      *(_BYTE *)(a1 + 41) = 2;
      httpd_send_info(a1, "<head><title>Information</title></head>\n<body><h2> %s </h2></body>\n", (int)a2);
      return 0;
    case 2:
      v28 = strlen(a2);
      if ( v28 >= 102400 )
        v28 = 102399;
      strlcpy(a1 + 564, a2, 102400);
      *(_BYTE *)(a1 + v28 + 564) = 0;
      *(_DWORD *)(a1 + 205364) = v28;
      *(_DWORD *)(a1 + 44) = a1 + 564;
      v29 = strchr((const char *)(a1 + 564), 63);
      if ( v29 )
        *v29 = 0;
      *(_BYTE *)(a1 + 41) = 2;
      httpd_send_file(a1, 0);
      return 0;
    case 4:
      if ( (*(_DWORD *)(a1 + 32) & 2) != 0 )
        v30 = *(_DWORD *)(a1 + 36) | 1;
      else
        v30 = *(_DWORD *)(a1 + 36) & 0xFFFFFFFE;
      *(_DWORD *)(a1 + 36) = v30;
      v31 = snprintf(v76, 1400, "%s", httpd_oktok[0]);
      if ( v31 >= 0x578 )
        v31 = 1399;
      v32 = snprintf(&v76[v31], 1400 - v31, "%s", httpd_servertok[0]);
      if ( v32 >= 1400 - v31 )
        v32 = 1399 - v31;
      v33 = v32 + v31;
      v34 = snprintf(&v76[v33], 1400 - v33, httpd_lengthtok[0], v4);
      if ( v34 >= 1400 - v33 )
        v34 = 1399 - v33;
      v35 = v34 + v33;
      if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
        v36 = httpd_ctalive;
      else
        v36 = httpd_ctclose;
      v37 = snprintf(&v76[v35], 1400 - v35, "%s", *v36);
      v38 = v37 + v35;
      if ( v37 >= 1400 - v35 )
        v38 = 1399;
      if ( (*(_DWORD *)(a1 + 36) & 0x1000) != 0 )
      {
        v74 = snprintf(&v76[v38], 1400 - v38, "Set-Cookie: %s; path=/\r\n", httpd_set_cookie);
        if ( v74 >= 1400 - v38 )
          v74 = 1399 - v38;
        *(_DWORD *)(a1 + 36) &= 0xFFFFEFFF;
        v38 += v74;
        memset(httpd_set_cookie, 0, sizeof(httpd_set_cookie));
      }
      v39 = snprintf(&v76[v38], 1400 - v38, "Pragma: no-cache\r\nCache-Control: no-cache\r\n");
      if ( v39 >= 1400 - v38 )
        v39 = 1399 - v38;
      v40 = *(_DWORD *)(a1 + 36);
      v41 = v39 + v38;
      if ( (v40 & 0x40000) != 0 )
      {
        v42 = 1400 - v41;
        v43 = snprintf(&v76[v41], 1400 - v41, "Content-Type: application/json;charset=utf-8\r\n\r\n");
      }
      else
      {
        v42 = 1400 - v41;
        if ( (v40 & 0x8000) != 0 )
          v43 = snprintf(&v76[v41], v42, "Content-Type: text/html;charset=utf-8\r\n\r\n");
        else
          v43 = snprintf(&v76[v41], v42, "Content-Type: text/html;charset=gb2312\r\n\r\n");
      }
      v44 = v43 + v41;
      if ( v43 >= v42 )
        v44 = 1399;
      v24 = v44 + v4;
      if ( v44 + v4 < 1400 )
        goto LABEL_106;
      goto LABEL_55;
    case 8:
      if ( (*(_DWORD *)(a1 + 32) & 2) != 0 )
        v46 = *(_DWORD *)(a1 + 36) | 1;
      else
        v46 = *(_DWORD *)(a1 + 36) & 0xFFFFFFFE;
      *(_DWORD *)(a1 + 36) = v46;
      v47 = snprintf(v76, 1400, "%s", httpd_oktok[0]);
      if ( v47 >= 0x578 )
        v47 = 1399;
      v48 = snprintf(&v76[v47], 1400 - v47, "%s", httpd_servertok[0]);
      if ( v48 >= 1400 - v47 )
        v48 = 1399 - v47;
      v49 = v48 + v47;
      v50 = snprintf(&v76[v49], 1400 - v49, httpd_lengthtok[0], v4);
      if ( v50 >= 1400 - v49 )
        v50 = 1399 - v49;
      v51 = v50 + v49;
      if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
        v52 = httpd_ctalive;
      else
        v52 = httpd_ctclose;
      v53 = snprintf(&v76[v51], 1400 - v51, "%s", *v52);
      v54 = v53 + v51;
      if ( v53 >= 1400 - v51 )
        v54 = 1399;
      if ( (*(_DWORD *)(a1 + 36) & 0x1000) != 0 )
      {
        v75 = snprintf(&v76[v54], 1400 - v54, "Set-Cookie: %s; path=/\r\n", httpd_set_cookie);
        if ( v75 >= 1400 - v54 )
          v75 = 1399 - v54;
        *(_DWORD *)(a1 + 36) &= 0xFFFFEFFF;
        v54 += v75;
        memset(httpd_set_cookie, 0, sizeof(httpd_set_cookie));
      }
      v55 = snprintf(&v76[v54], 1400 - v54, "Pragma: no-cache\r\nCache-Control: no-cache\r\n");
      if ( v55 >= 1400 - v54 )
        v55 = 1399 - v54;
      v56 = *(_DWORD *)(a1 + 36);
      v57 = v55 + v54;
      if ( (v56 & 0x40000) != 0 )
      {
        v58 = 1400 - v57;
        v59 = snprintf(&v76[v57], 1400 - v57, "Content-Type: application/json;charset=utf-8\r\n\r\n");
      }
      else
      {
        v58 = 1400 - v57;
        if ( (v56 & 0x8000) != 0 )
          v59 = snprintf(&v76[v57], v58, "Content-Type: text/html;charset=utf-8\r\n\r\n");
        else
          v59 = snprintf(&v76[v57], v58, "Content-Type: text/html;charset=gb2312\r\n\r\n");
      }
      v23 = v59 + v57;
      if ( v59 >= v58 )
        v23 = 1399;
      v24 = v23 + v4;
      if ( v23 + v4 < 1400 )
        goto LABEL_123;
      if ( httpd_send_data_alloc(a1, v76, v23) )
        goto LABEL_135;
      v25 = a2;
      if ( *(_DWORD *)(a1 + 205380) )
        goto LABEL_85;
      goto LABEL_26;
    case 16:
      if ( (*(_DWORD *)(a1 + 32) & 2) != 0 )
        v60 = *(_DWORD *)(a1 + 36) | 1;
      else
        v60 = *(_DWORD *)(a1 + 36) & 0xFFFFFFFE;
      *(_DWORD *)(a1 + 36) = v60;
      v61 = snprintf(v76, 1400, "%s", httpd_oktok[0]);
      if ( v61 >= 0x578 )
        v61 = 1399;
      v62 = snprintf(&v76[v61], 1400 - v61, "%s", httpd_servertok[0]);
      if ( v62 >= 1400 - v61 )
        v62 = 1399 - v61;
      v63 = v62 + v61;
      v64 = snprintf(&v76[v63], 1400 - v63, httpd_lengthtok[0], v4);
      if ( v64 >= 1400 - v63 )
        v64 = 1399 - v63;
      v65 = v64 + v63;
      if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
        v66 = httpd_ctalive;
      else
        v66 = httpd_ctclose;
      v67 = snprintf(&v76[v65], 1400 - v65, "%s", *v66);
      if ( v67 >= 1400 - v65 )
        v67 = 1399 - v65;
      v68 = v67 + v65;
      v69 = snprintf(&v76[v68], 1400 - v68, "Pragma: no-cache\r\nCache-Control: no-cache\r\n");
      if ( v69 >= 1400 - v68 )
        v69 = 1399 - v68;
      v70 = *(_DWORD *)(a1 + 36);
      v71 = v69 + v68;
      if ( (v70 & 0x40000) != 0 )
      {
        v72 = 1400 - v71;
        v73 = snprintf(&v76[v71], 1400 - v71, "Content-Type: application/json;charset=utf-8\r\n\r\n");
      }
      else
      {
        v72 = 1400 - v71;
        if ( (v70 & 0x8000) != 0 )
          v73 = snprintf(&v76[v71], v72, "Content-Type: text/html;charset=utf-8\r\n\r\n");
        else
          v73 = snprintf(&v76[v71], v72, "Content-Type: text/html;charset=gb2312\r\n\r\n");
      }
      v44 = v73 + v71;
      if ( v73 >= v72 )
        v44 = 1399;
      v24 = v44 + v4;
      if ( v44 + v4 < 1400 )
      {
LABEL_106:
        memcpy(&v76[v44], a2, v4);
        goto LABEL_107;
      }
LABEL_55:
      v45 = httpd_send_data_alloc(a1, v76, v44) != 0;
      result = -1;
      if ( v45 )
        return result;
      if ( !*(_DWORD *)(a1 + 205380) )
      {
        v26 = httpd_send_data_alloc(a1, a2, v4);
        goto LABEL_58;
      }
LABEL_109:
      httpd_conn_close((int *)a1);
      return -1;
    case 32:
      if ( (*(_DWORD *)(a1 + 32) & 2) != 0 )
        v7 = *(_DWORD *)(a1 + 36) | 1;
      else
        v7 = *(_DWORD *)(a1 + 36) & 0xFFFFFFFE;
      *(_DWORD *)(a1 + 36) = v7;
      v8 = snprintf(v76, 1400, "%s", httpd_oktok[0]);
      if ( v8 >= 0x578 )
        v8 = 1399;
      v9 = snprintf(&v76[v8], 1400 - v8, "%s", httpd_servertok[0]);
      if ( v9 >= 1400 - v8 )
        v9 = 1399 - v8;
      v10 = v9 + v8;
      v11 = snprintf(&v76[v10], 1400 - v10, "Content-Encoding: gzip\r\n");
      if ( v11 >= 1400 - v10 )
        v11 = 1399 - v10;
      v12 = v11 + v10;
      v13 = snprintf(&v76[v12], 1400 - v12, httpd_lengthtok[0], v4);
      if ( v13 >= 1400 - v12 )
        v13 = 1399 - v12;
      v14 = v13 + v12;
      if ( (*(_DWORD *)(a1 + 36) & 1) != 0 )
        v15 = httpd_ctalive;
      else
        v15 = httpd_ctclose;
      v16 = snprintf(&v76[v14], 1400 - v14, "%s", *v15);
      if ( v16 >= 1400 - v14 )
        v16 = 1399 - v14;
      v17 = v16 + v14;
      v18 = snprintf(&v76[v17], 1400 - v17, "Pragma: no-cache\r\nCache-Control: no-cache\r\n");
      if ( v18 >= 1400 - v17 )
        v18 = 1399 - v17;
      v19 = *(_DWORD *)(a1 + 36);
      v20 = v18 + v17;
      if ( (v19 & 0x40000) != 0 )
      {
        v21 = 1400 - v20;
        v22 = snprintf(&v76[v20], 1400 - v20, "Content-Type: application/json;charset=utf-8\r\n\r\n");
      }
      else
      {
        v21 = 1400 - v20;
        if ( (v19 & 0x8000) != 0 )
          v22 = snprintf(&v76[v20], v21, "Content-Type: text/html;charset=utf-8\r\n\r\n");
        else
          v22 = snprintf(&v76[v20], v21, "Content-Type: text/html;charset=gb2312\r\n\r\n");
      }
      v23 = v22 + v20;
      if ( v22 >= v21 )
        v23 = 1399;
      v24 = v23 + v4;
      if ( v23 + v4 < 1400 )
      {
LABEL_123:
        memcpy(&v76[v23], a2, v4);
        _mem_free(a2);
LABEL_107:
        v45 = httpd_send_data_alloc(a1, v76, v24) == 0;
        result = -1;
        if ( v45 )
        {
LABEL_59:
          if ( !*(_DWORD *)(a1 + 205380) )
            httpd_conn_send_finish(a1);
          return 0;
        }
      }
      else
      {
        if ( httpd_send_data_alloc(a1, v76, v23) )
        {
LABEL_135:
          _mem_free(a2);
          return -1;
        }
        v25 = a2;
        if ( *(_DWORD *)(a1 + 205380) )
        {
LABEL_85:
          _mem_free(v25);
          httpd_conn_close((int *)a1);
          return -1;
        }
LABEL_26:
        v26 = httpd_send_data_not_alloc(a1, a2, v4);
LABEL_58:
        v45 = v26 != 0;
        result = -1;
        if ( !v45 )
          goto LABEL_59;
      }
      return result;
    default:
      goto LABEL_109;
  }
}
// 427F4C: variable 'v4' is possibly undefined
// 6676B8: using guessed type char *httpd_lengthtok[22];
// 6676C0: using guessed type char *httpd_ctalive[20];
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D0: using guessed type char *httpd_oktok[16];
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);

//----- (00428B08) --------------------------------------------------------
int __fastcall usb_httpd_send_login_html(int a1)
{
  char *v2; // $v0
  int v3; // $a2
  const char *v4; // $s0
  unsigned int v5; // $v0
  int v6; // $v0
  const char *v7; // $a3
  int v8; // $s0
  int v9; // $s1
  int v10; // $v0
  int v11; // $v0
  int result; // $v0
  const char *v13; // $v0
  unsigned int v14; // $v0
  char v15[1024]; // [sp+20h] [-804h] BYREF
  char v16[1028]; // [sp+420h] [-404h] BYREF

  memset(v16, 0, 0x400u);
  v2 = httpd_find_ext_name(*(const char **)(a1 + 44));
  if ( v2
    && ((v4 = v2, !strcmp(v2, "data"))
     || !strcmp(v4, "asp")
     || !strcmp(v4, (const char *)&off_4CFE60)
     || !strcmp(v4, "txt")
     || !strcmp(v4, (const char *)&off_641118)) )
  {
    v13 = (const char *)_GET_LANG_TEXT(2, *(unsigned __int8 *)(a1 + 210102), v3);
    v14 = snprintf(v16, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 5, v13);
    if ( v14 >= 0x400 )
      v14 = 1023;
    result = httpd_cgi_ret(a1, v16, v14, 4);
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 36) & 0xFFFFFFFE;
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    *(_DWORD *)(a1 + 36) = v5;
    memset(v15, 0, sizeof(v15));
    v6 = snprintf(v15, 1024, "%s%s?", *(const char **)(a1 + 205504), "/usb_login.htm");
    v7 = *(const char **)(a1 + 52);
    v8 = v6;
    if ( v7 )
    {
      v9 = a1 + 56;
      do
      {
        v9 += 4;
        v10 = snprintf(&v15[v8], 1024 - v8, "%s&", v7);
        v7 = *(const char **)(v9 - 4);
        v8 += v10;
      }
      while ( v7 );
    }
    v11 = jiffies_get();
    snprintf(&v15[v8], 1024 - v8, "_t=%lu", v11);
    result = httpd_send_redirect(a1, v15);
  }
  return result;
}
// 428D30: variable 'v3' is possibly undefined
// 4CFE60: using guessed type void *off_4CFE60;
// 641118: using guessed type void *off_641118;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00428DB0) --------------------------------------------------------
int __fastcall usb_httpd_user_auth_cookie(int a1)
{
  char *v2; // $a1
  char *v3; // $v0
  int v4; // $v1
  bool v5; // dc
  _BYTE *v6; // $v1
  int v7; // $v0
  int result; // $v0
  char v9[1028]; // [sp+18h] [-404h] BYREF

  if ( (*(_DWORD *)(a1 + 32) & 0x800) == 0 )
    goto LABEL_13;
  memset(v9, 0, 0x400u);
  v2 = strstr(*(const char **)(a1 + 205524), "usb_userid=");
  if ( !v2 )
    goto LABEL_13;
  strlcpy(v9, v2, 1024);
  v3 = strstr(&v9[11], "usb_passwd=");
  if ( !v3 )
    goto LABEL_13;
  v4 = v3[11];
  *(v3 - 1) = 0;
  if ( v4 )
  {
    v5 = v4 == 59;
    v6 = v3 + 11;
    if ( v5 )
    {
LABEL_12:
      *v6 = 0;
    }
    else
    {
      while ( *++v6 )
      {
        if ( *v6 == 59 )
          goto LABEL_12;
      }
    }
  }
  v7 = usb_httpd_user_check_cookie(a1, (int)&v9[11], v3 + 11);
  if ( v7 > 0 )
  {
    *(_DWORD *)(a1 + 205588) = v7;
    result = 0;
    *(_BYTE *)(a1 + 43) = 1;
  }
  else
  {
LABEL_13:
    *(_BYTE *)(a1 + 43) = 3;
    usb_httpd_send_login_html(a1);
    result = -1;
  }
  return result;
}
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);

//----- (00428F08) --------------------------------------------------------
int __fastcall usb_httpd_check_user(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 43) == 1 && *(_DWORD *)(a1 + 205588) >= a2 )
    return 0;
  if ( usb_httpd_user_auth_cookie(a1) )
    return -1;
  if ( *(_DWORD *)(a1 + 205588) < a2 )
  {
    usb_httpd_send_login_html(a1);
    return -1;
  }
  return 0;
}

//----- (00428FE8) --------------------------------------------------------
int __fastcall sub_428FE8(int *a1)
{
  int v2; // $s5
  int v3; // $s1
  void *v4; // $v0
  void *v5; // $s1
  char *v6; // $v0
  char *v7; // $s4
  const char *v8; // $s3
  const char *v9; // $v0
  int v10; // $s6
  int v12; // $s0
  int v13; // $v0
  DIR *v14; // $fp
  int v15; // $s7
  struct dirent *v16; // $v0
  const char *v17; // $s3
  struct tm *v18; // $v0
  int v19; // $v0
  char *v20; // $a1
  int v21; // $v1
  struct stat v22; // [sp+30h] [-1E0h] BYREF
  struct stat v23; // [sp+D0h] [-140h] BYREF
  char v24[128]; // [sp+170h] [-A0h] BYREF
  char *v25; // [sp+1F0h] [-20h]
  char *v26; // [sp+1F4h] [-1Ch]
  char *format; // [sp+1F8h] [-18h]
  const char *v28; // [sp+1FCh] [-14h]
  char *v29; // [sp+200h] [-10h]
  const char *v30; // [sp+204h] [-Ch]
  char *v31; // [sp+208h] [-8h]

  if ( !nvram_match_def("usb_acc_auth", "1") )
  {
    v2 = 0;
    v3 = check_usb_state();
    if ( v3 )
      goto LABEL_4;
LABEL_14:
    httpd_conn_close(a1);
    return v3;
  }
  if ( usb_httpd_check_user((int)a1, 1) )
    return 0;
  v2 = 1;
  v3 = check_usb_state();
  if ( !v3 )
    goto LABEL_14;
LABEL_4:
  _mem_malloc(512, "httpd_send_usb_file_json", 1937);
  v5 = v4;
  if ( !v4 )
    return -1;
  _mem_malloc(512, "httpd_send_usb_file_json", 1943);
  v7 = v6;
  if ( !v6 )
  {
    _mem_free(v5);
    return -1;
  }
  v8 = (const char *)a1[11];
  v9 = &v8[strlen(v8) - 1];
  if ( *v9 == 47 )
  {
    *v9 = 0;
    v8 = (const char *)a1[11];
  }
  v10 = strcmp(v8, "/usb_json");
  snprintf((char *)v5, 512, "/tmp/mnt/sda1/%s", v8 + 10);
  if ( !stat((const char *)v5, &v23) || (unescape((char *)v5), !stat((const char *)v5, &v23)) )
  {
    if ( (v23.st_uid & 0xF000) != 0x4000 )
    {
      if ( *(_QWORD *)&v23.st_atim >= 0x80000000LL )
        httpd_send_big_file_ll((int)a1, (int)v5, v23.st_atim.tv_sec, v23.st_atim.tv_nsec);
      else
        httpd_send_big_file((int)a1, (int)v5, v23.st_atim.tv_sec);
      v12 = 0;
      goto LABEL_12;
    }
    _mem_malloc(1024000, "httpd_send_usb_file_json", 1968);
    v26 = (char *)v13;
    if ( v13 )
    {
      *(_BYTE *)v13 = 91;
      *(_WORD *)(v13 + 1) = 32;
      v14 = opendir((const char *)v5);
      if ( v14 )
      {
        v15 = 2;
        v25 = ".";
        format = "%s/%s";
        v30 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
        v31 = "{\"filesize\":%lld,\"filename\":\"%s\",\"lastdate\":\"%s\",\"url\":\"%s/%s\",\"type\":\"%d\"},";
        v28 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
        while ( 1 )
        {
          v16 = readdir(v14);
          if ( !v16 )
            break;
          v17 = &v16->d_name[8];
          if ( v15 >= 1022977 )
          {
            closedir(v14);
            v19 = v15;
            goto LABEL_40;
          }
          if ( strcmp(&v16->d_name[8], v25)
            && (v10
             || strcmp(v17, v28 - 1460)
             && (!v2 || a1[51397] >= 2 || !strcmp(v17, (const char *)&off_4CFA50) || !strcmp(v17, "share"))) )
          {
            sprintf(v7, format, v5, v17);
            if ( !stat(v7, &v22) )
            {
              v18 = localtime(&v22.st_ctim.tv_sec);
              v29 = v24;
              strftime(v24, 0x80u, v30 - 2456, v18);
              v15 += sprintf(
                       &v26[v15],
                       v31,
                       v22.st_atim.tv_sec,
                       v22.st_atim.tv_nsec,
                       v17,
                       v29,
                       a1[11],
                       v17,
                       2 - ((v22.st_uid & 0xF000) != 0x4000));
            }
          }
        }
        closedir(v14);
        v19 = v15;
        if ( v15 <= 0 )
          goto LABEL_37;
LABEL_40:
        v21 = v15 - 1;
      }
      else
      {
        v21 = 1;
        v19 = 2;
        v15 = 2;
      }
      if ( v26[v21] == 44 )
      {
        --v15;
LABEL_37:
        v19 = v15;
      }
      v20 = v26;
      *(_WORD *)&v26[v19] = 93;
      a1[9] |= 0x8000u;
      httpd_cgi_ret((int)a1, v20, v15 + 1, 8);
      v12 = 0;
      goto LABEL_12;
    }
  }
  v12 = -1;
LABEL_12:
  _mem_free(v5);
  _mem_free(v7);
  return v12;
}
// 4290A4: variable 'v4' is possibly undefined
// 4290C4: variable 'v6' is possibly undefined
// 4292E4: variable 'v13' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (004295B8) --------------------------------------------------------
int __fastcall httpd_send_usb_file_json(int *a1)
{
  if ( !nvram_match_def("usb_share_enable", "0") && !usb_acc_check(a1 + 51365) )
    return sub_428FE8(a1);
  httpd_conn_close(a1);
  return 0;
}
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);

//----- (00429654) --------------------------------------------------------
int __fastcall sub_429654(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  int v4; // $v0
  int v5; // $a2
  char v7[1028]; // [sp+18h] [-404h] BYREF

  v3 = httpd_get_parm(a1, "user");
  v2 = httpd_get_parm(a1, "password");
  if ( v3 )
  {
    if ( v2 )
      goto LABEL_3;
  }
  else
  {
    v3 = "";
    if ( v2 )
      goto LABEL_3;
  }
  v2 = "";
LABEL_3:
  v4 = usb_httpd_cgi_user_check(v3, (int)v2);
  if ( v4 <= 0 )
  {
    if ( !v4 )
    {
      v5 = sprintf(
             v7,
             "<html><head><script type='text/javascript'>function init(){window.open('%s','_self');}</script></head><body"
             " onLoad='init();'></body></html>",
             "/usb_login.htm?flag=0");
      return httpd_cgi_ret(a1, v7, v5, 4);
    }
    v5 = 0;
  }
  else
  {
    v5 = sprintf(
           v7,
           "<html><head><script type='text/javascript'>function init(){window.open('%s','_self');}</script></head><body o"
           "nLoad='init();'></body></html>",
           "/usb_list.html");
  }
  *(_DWORD *)(a1 + 36) |= 0x1000u;
  return httpd_cgi_ret(a1, v7, v5, 4);
}

//----- (00429788) --------------------------------------------------------
int __fastcall httpd_send_auth_html_file(int a1)
{
  const char *v2; // $s3
  const char *v3; // $s0
  const char *v4; // $v0
  int v5; // $s7
  int result; // $v0
  bool v7; // dc
  char *v8; // $v0
  char *v9; // $fp
  int v10; // $s3
  DIR *v11; // $s4
  struct dirent *v12; // $v0
  const char *v13; // $s0
  struct tm *v14; // $v0
  char *v15; // $a0
  char v16[1024]; // [sp+30h] [-9D0h] BYREF
  int v17[3]; // [sp+430h] [-5D0h] BYREF
  char v18; // [sp+43Ch] [-5C4h]
  struct stat v19; // [sp+830h] [-1D0h] BYREF
  struct stat v20; // [sp+8D0h] [-130h] BYREF
  char v21[128]; // [sp+970h] [-90h] BYREF
  char *format; // [sp+9F0h] [-10h]
  const char *v23; // [sp+9F4h] [-Ch]
  char *v24; // [sp+9F8h] [-8h]
  const char *v25; // [sp+9FCh] [-4h]

  v2 = (const char *)jhl_nv_get_def("lan_ipaddr");
  if ( stat("/tmp/auth_html", &v20) && check_usb_state() && !stat("/tmp/mnt/sda1/auth_html/auth.tar.gz", &v20) )
  {
    system("mkdir -p /tmp/auth_html");
    system("tar -zxf /tmp/mnt/sda1/auth_html/auth.tar.gz -C /tmp/auth_html");
  }
  v3 = *(const char **)(a1 + 44);
  v4 = &v3[strlen(v3) - 1];
  if ( *v4 == 47 )
  {
    *v4 = 0;
    v3 = *(const char **)(a1 + 44);
  }
  v5 = strcmp(v3, "/auth_html");
  snprintf((char *)v17, 1024, "/tmp%s", v3);
  if ( !stat((const char *)v17, &v20)
    || (unescape((char *)v17), v7 = stat((const char *)v17, &v20) == 0, result = -1, v7) )
  {
    if ( (v20.st_uid & 0xF000) == 0x4000 )
    {
      _mem_malloc(1024000, "httpd_send_auth_html_file", 2494);
      v9 = v8;
      if ( v8 )
      {
        v10 = sprintf(
                v8,
                "<html><head><META http-eqiu='Content-Type' content='text/html; charset=UTF-8'><title>%s - %s/</title></h"
                "ead><body><H1>%s - %s/</H1><hr><pre>",
                v2,
                (const char *)(*(_DWORD *)(a1 + 44) + 11),
                v2,
                (const char *)(*(_DWORD *)(a1 + 44) + 11));
        v11 = opendir((const char *)v17);
        if ( v11 )
        {
          format = "%s/%s";
          v23 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
          v24 = "%s   %lld   <A HREF='%s/%s'>%s</A><br>\r\n";
          v25 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
          while ( 1 )
          {
            v12 = readdir(v11);
            v13 = &v12->d_name[8];
            if ( !v12 || v10 >= 1022977 )
              break;
            if ( strcmp(&v12->d_name[8], ".") && (v5 || strcmp(v13, "..")) )
            {
              sprintf(v16, format, v17, v13);
              if ( !stat(v16, &v19) )
              {
                v14 = localtime(&v19.st_ctim.tv_sec);
                strftime(v21, 0x80u, v23 - 2456, v14);
                v15 = &v9[v10];
                if ( (v19.st_uid & 0xF000) == 0x4000 )
                  v10 += sprintf(v15, (char *)v25 - 2444, v21, *(_DWORD *)(a1 + 44), v13, v13);
                else
                  v10 += sprintf(v15, v24, v21);
              }
            }
          }
          closedir(v11);
        }
        strcpy(&v9[v10], "</pre><hr></body></html>");
        qmemcpy(&v9[v10], "</pre><hr></body></html>", 24);
        *(_DWORD *)(a1 + 36) |= 0x8000u;
        httpd_cgi_ret(a1, v9, v10 + 24, 8);
        result = 0;
      }
      else
      {
        v17[0] = -456796489;
        v17[1] = -424355132;
        v17[2] = -592402486;
        v18 = 0;
        result = httpd_cgi_ret(a1, (char *)v17, 12, 4);
      }
    }
    else
    {
      httpd_send_big_file(a1, (int)v17, v20.st_atim.tv_sec);
      result = 0;
    }
  }
  return result;
}
// 4299D4: variable 'v8' is possibly undefined
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (00429CA4) --------------------------------------------------------
int __fastcall httpd_send_auth_pic_file(int a1)
{
  int v2; // $s1
  const char *v3; // $v0
  const char *v5; // $v0
  char v6[256]; // [sp+18h] [-2A0h] BYREF
  int v7[64]; // [sp+118h] [-1A0h] BYREF
  struct stat v8; // [sp+218h] [-A0h] BYREF

  memset(v7, 0, sizeof(v7));
  v2 = -1;
  if ( strncmp(*(const char **)(a1 + 44), "/auth_pic/auth.", 0xFu) )
    return v2;
  if ( stat("/tmp/auth_pic", &v8) && check_usb_state() )
  {
    memset(v6, 0, sizeof(v6));
    v5 = (const char *)nvram_get("auth_pic_ext");
    if ( !v5 )
      v5 = ".jpg";
    snprintf(v6, 256, "/tmp/mnt/sda1/auth_pic/auth%s", v5);
    if ( !stat(v6, &v8) )
      system("cp -rf /tmp/mnt/sda1/auth_pic /tmp/auth_pic");
  }
  v3 = (const char *)nvram_get("auth_pic_ext");
  if ( !v3 )
    v3 = ".jpg";
  snprintf((char *)v7, 256, "/tmp/auth_pic/auth%s", v3);
  v2 = stat((const char *)v7, &v8);
  if ( !v2 )
  {
    httpd_send_big_file(a1, (int)v7, v8.st_atim.tv_sec);
    return v2;
  }
  v7[0] = -808864562;
  v7[1] = -1127371852;
  LOWORD(v7[2]) = -21306;
  BYTE2(v7[2]) = 0;
  httpd_cgi_ret(a1, (char *)v7, 10, 4);
  return 0;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (00429F08) --------------------------------------------------------
int __fastcall httpd_send_sj_file(_DWORD *a1)
{
  char *v2; // $s0
  char *v3; // $v0
  size_t v4; // $v0
  int v5; // $v0
  const char *v6; // $a0
  int v7; // $s3
  char *v8; // $v0
  char *v9; // $s1
  int v10; // $s7
  const char *v11; // $a3
  int v12; // $v0
  const char *v13; // $a3
  _DWORD *v14; // $fp
  int v15; // $v0
  int v16; // $s0
  signed int v17; // $s3
  int v19; // $s2
  char v20[256]; // [sp+20h] [-1A0h] BYREF
  struct stat v21; // [sp+120h] [-A0h] BYREF

  strcpy(v20, "/tmp/sj/");
  memset(&v20[9], 0, 0xF7u);
  v2 = (char *)a1[11];
  v3 = strstr(v2, "/sj/");
  if ( v3 )
    v2 = v3 + 4;
  if ( *v2 == 47 )
    ++v2;
  v4 = strlen(v2);
  if ( v4 < 0xC9 )
  {
    memcpy(&v20[8], v2, v4 + 1);
    if ( !stat(v20, &v21) || (unescape(v20), !stat(v20, &v21)) )
    {
      if ( (v21.st_uid & 0xF000) != 0x4000 )
      {
        httpd_send_big_file((int)a1, (int)v20, v21.st_atim.tv_sec);
        return 0;
      }
    }
  }
  v5 = nvram_get("sj_http_port");
  if ( v5 )
    v6 = (const char *)v5;
  else
    v6 = "";
  v7 = atoi(v6);
  if ( v7 < 80 )
    return -1;
  _mem_malloc(419430, "httpd_send_sj_file", 3214);
  v9 = v8;
  if ( !v8 )
    return -1;
  v10 = snprintf(v8, 419430, "http://127.0.0.1:%d/sj/%s", v7, v2);
  if ( v10 >= 419430 )
  {
    v11 = (const char *)a1[13];
    v10 = 419429;
    if ( v11 )
      goto LABEL_12;
  }
  else
  {
    v11 = (const char *)a1[13];
    if ( v11 )
    {
LABEL_12:
      v12 = snprintf(&v9[v10], 419430 - v10, "?%s", v11);
      if ( v12 >= 419430 - v10 )
        v12 = 419429 - v10;
      v13 = (const char *)a1[14];
      v10 += v12;
      if ( v13 )
      {
        v14 = a1 + 15;
        do
        {
          v15 = snprintf(&v9[v10], 419430 - v10, "&%s", v13);
          if ( v15 >= 419430 - v10 )
            v15 = 419429 - v10;
          v13 = (const char *)*v14++;
          v10 += v15;
        }
        while ( v13 );
      }
      goto LABEL_19;
    }
  }
LABEL_19:
  v16 = -1;
  if ( v10 < 419429 )
  {
    v17 = httpd_wget(v9, "/tmp/sj_ack");
    if ( v17 && f_exists("/tmp/sj_ack") )
    {
      if ( v17 < 10240 )
      {
        v19 = f_read("/tmp/sj_ack", v9, 419429);
        unlink("/tmp/sj_ack");
        if ( v19 >= 0 )
        {
          v9[v19] = 0;
          return httpd_cgi_ret((int)a1, v9, v19, 8);
        }
        v16 = -1;
      }
      else
      {
        httpd_send_big_file((int)a1, (int)"/tmp/sj_ack", v17);
        v16 = 0;
        unlink("/tmp/sj_ack");
      }
    }
    else
    {
      unlink("/tmp/sj_ack");
      v16 = -1;
    }
  }
  _mem_free(v9);
  return v16;
}
// 42A040: variable 'v8' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);
// 6A8718: using guessed type int __fastcall httpd_wget(_DWORD, _DWORD);

//----- (0042A354) --------------------------------------------------------
int __fastcall jhl_data_giz(int a1, char *a2, int a3, int a4)
{
  int v7; // $s2
  const char *v9; // $v0
  int v10; // $v0
  int v11; // $a2

  f_write("/tmp/webdata", a2, a3, 0, 0);
  system("gzip /tmp/webdata");
  v7 = f_read("/tmp/webdata.gz", a2, a4);
  system("rm -f /tmp/webdata.gz");
  if ( v7 > 0 )
    return httpd_cgi_ret(a1, a2, v7, 32);
  v9 = (const char *)_GET_LANG_TEXT(5, *(unsigned __int8 *)(a1 + 210102), v7);
  v10 = snprintf(a2, a4, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
  if ( v10 >= a4 )
    v11 = a4 - 1;
  else
    v11 = v10;
  return httpd_cgi_ret(a1, a2, v11, 8);
}
// 6A8204: using guessed type int __fastcall f_write(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);

//----- (0042A4B0) --------------------------------------------------------
int __fastcall exec_service_timeout(int a1)
{
  int v2; // $s0
  char *v3; // $v0
  int v4; // $a0
  const char *v5; // $s2
  const char *v6; // $v0
  int v7; // $a2
  _BYTE *v8; // $v0
  const char *v9; // $a2
  const char *v10; // $v0
  unsigned int v11; // $v0
  const char *v13; // $v0
  const char *v14; // $v0
  char *v15; // $v1
  int v16; // $t0
  int v17; // $a3
  int v18; // $a2
  int v19; // $a1
  int v20; // $v0
  char *v21; // $v0
  char v22[516]; // [sp+20h] [-204h] BYREF

  v2 = a1 + 196608;
  v3 = httpd_get_parm(a1, "exec_service");
  v4 = *(_DWORD *)(v2 + 8968);
  v5 = v3;
  ++*(_DWORD *)(v2 + 8964);
  if ( v4 )
  {
    v13 = (const char *)nvram_get("action_service");
    if ( !v13 || !v5 || strcmp(v13, v5) )
    {
      v14 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      v15 = v22;
      do
      {
        v16 = *(_DWORD *)v14;
        v17 = *((_DWORD *)v14 + 1);
        v18 = *((_DWORD *)v14 + 2);
        v19 = *((_DWORD *)v14 + 3);
        v14 += 16;
        *(_DWORD *)v15 = v16;
        *((_DWORD *)v15 + 1) = v17;
        *((_DWORD *)v15 + 2) = v18;
        *((_DWORD *)v15 + 3) = v19;
        v15 += 16;
      }
      while ( v14 != "}" );
      *(_WORD *)v15 = *(_WORD *)v14;
      return httpd_cgi_ret(a1, v22, 33, 4);
    }
    if ( *(int *)(v2 + 8964) >= 21 )
      goto LABEL_8;
    v20 = jiffies_get() + 1000;
    goto LABEL_27;
  }
  v6 = (const char *)nvram_get("action_service");
  if ( !v6 || !v5 || strcmp(v6, v5) )
  {
    v8 = (_BYTE *)nvram_get("action_service");
    if ( !v8 || *v8 )
    {
      if ( *(int *)(a1 + 205572) < 11 )
      {
        *(_DWORD *)(a1 + 205548) = jiffies_get() + 1000;
        *(_DWORD *)(a1 + 205556) = a1;
        *(_DWORD *)(a1 + 205552) = exec_service_timeout;
        return add_timer(a1 + 205540);
      }
LABEL_8:
      if ( *(_DWORD *)(a1 + 205576) )
        v9 = "after";
      else
        v9 = "before";
      v10 = (const char *)_GET_LANG_TEXT(37, *(unsigned __int8 *)(a1 + 210102), v9);
      goto LABEL_11;
    }
    v21 = httpd_get_parm(a1, "action_iface");
    if ( v21 )
      nvram_set("action_iface", v21);
    nvram_set("action_service", v5);
    kill(1, 16);
    v2 = a1 + 196608;
    *(_DWORD *)(a1 + 205576) = 1;
    *(_DWORD *)(a1 + 205572) = 0;
    v20 = jiffies_get() + 1000;
LABEL_27:
    *(_DWORD *)(v2 + 8940) = v20;
    *(_DWORD *)(v2 + 8948) = a1;
    *(_DWORD *)(v2 + 8944) = exec_service_timeout;
    return add_timer(a1 + 205540);
  }
  v10 = (const char *)_GET_LANG_TEXT(36, *(unsigned __int8 *)(v2 + 13494), v7);
LABEL_11:
  v11 = snprintf(v22, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
  if ( v11 >= 0x200 )
    v11 = 511;
  return httpd_cgi_ret(a1, v22, v11, 4);
}
// 42A810: variable 'v7' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0042A864) --------------------------------------------------------
int __fastcall httpd_dowith_get(int a1)
{
  int v1; // $v0
  _BYTE *v2; // $s0
  int v4; // $v0
  const char *v5; // $s0
  const char *v6; // $s0
  int v7; // $a1
  int v8; // $s0
  char *v10; // $a0
  _BYTE *v11; // $a1
  int v12; // $v0
  _BYTE *v13; // $s0
  _BYTE *v14; // $s0
  char v16[32]; // [sp+18h] [-4Ch] BYREF
  int v17[7]; // [sp+38h] [-2Ch] BYREF
  int v18[4]; // [sp+54h] [-10h] BYREF

  v1 = *(char *)(a1 + 568);
  v2 = (_BYTE *)(a1 + 568);
  v18[0] = 0;
  *(_DWORD *)(a1 + 44) = a1 + 568;
  if ( v1 == 32 )
  {
LABEL_8:
    *v2 = 0;
    v5 = v2 + 1;
    unescape(*(char **)(a1 + 44));
    *(_DWORD *)(a1 + 52) = 0;
    goto LABEL_9;
  }
  if ( v1 != 63 )
  {
    if ( v1 )
    {
      do
      {
        v4 = (char)*++v2;
        if ( v4 == 32 )
          break;
        if ( v4 == 63 )
          goto LABEL_18;
      }
      while ( *v2 );
    }
    goto LABEL_8;
  }
LABEL_18:
  *v2 = 0;
  v10 = *(char **)(a1 + 44);
  v18[1] = (int)(v2 + 1);
  unescape(v10);
  v11 = v2 + 1;
  *(_DWORD *)(a1 + 52) = 0;
  if ( v2 == (_BYTE *)-1 )
  {
    v5 = 0;
  }
  else
  {
    v12 = v2[1] & 0xDF;
    v13 = v2 + 1;
    if ( v12 )
    {
      v14 = v11 + 1;
      while ( *v14++ & 0xDF )
        ;
      v13 = v14 - 1;
    }
    *v13 = 0;
    httpd_formdata_parse((_DWORD *)a1, v11, 0);
    v5 = v13 + 1;
  }
LABEL_9:
  httpd_do_wwwparm((_DWORD *)a1, v5);
  if ( !httpd_proxy_check(a1, v18) )
  {
    v6 = *(const char **)(a1 + 44);
    goto LABEL_11;
  }
  v8 = httpd_proxy_is_self(a1);
  if ( v8 )
  {
    v6 = *(const char **)(a1 + 44);
    if ( !strncmp(v6, "/ap/", 4u) )
    {
      v6 += 3;
      *(_DWORD *)(a1 + 44) = v6;
    }
    if ( !strncmp(v6, "/rt/", 4u) )
    {
      v6 += 3;
      *(_DWORD *)(a1 + 44) = v6;
    }
LABEL_11:
    if ( !strncmp(v6, "/usb/", 5u) || !strncmp(v6, "/auth_html/", 0xBu) )
    {
      v7 = 1;
    }
    else
    {
      if ( !strcmp(v6, "/welcome/ioswificheck.php") )
      {
        IpaddrToStr(v16, a1 + 205460);
        v17[0] = (int)"wys";
        v17[1] = (int)"hi";
        v17[2] = (int)"redirct_flag";
        v17[3] = (int)"set";
        v17[4] = (int)v16;
        v17[5] = (int)"1";
        v17[6] = 0;
        eval(v17, 0, 0, 0);
        strcpy(v16, "{ok}");
        return httpd_cgi_ret(a1, v16, 4, 4);
      }
      v7 = 0;
    }
    *(_BYTE *)(a1 + 41) = 2;
    v8 = 0;
    httpd_send_file(a1, v7);
    return v8;
  }
  if ( v18[0] && httdp_proxy_check_user(a1) )
    return v8;
  return httpd_proxy_cgi(a1);
}
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);

//----- (0042ABE4) --------------------------------------------------------
int __fastcall httpd_do_recv(int a1)
{
  int v1; // $v0
  int v3; // $v0
  int *v4; // $v0
  int *v5; // $s5
  int v6; // $s7
  int v7; // $s6
  int (__fastcall *v8)(int); // $s3
  unsigned int v9; // $a0
  int v10; // $v0
  int v11; // $s6
  unsigned int v12; // $s0
  unsigned int v13; // $v1
  int (__fastcall *v14)(int); // $t9
  int v15; // $s3
  int v17; // $s4
  int v18; // $s0
  int v19; // $a2
  int v20; // $s0
  int v21; // $v0
  int v22; // $v0
  int v23; // $v0
  _BYTE *v24; // $v1
  const char *v25; // $s2
  int v26; // $s0
  int v27; // $a2
  int v28; // $s0
  char *v29; // $v0
  bool v30; // dc
  char *v31; // $v0
  int v32; // $v0
  int v33; // $v0
  _BYTE *v34; // $s0
  int v35; // $v0
  int v36; // $v0
  const char *v37; // $s4
  int v38; // $v1
  int v39; // $a1
  unsigned int v40; // $a0
  unsigned int v41; // $v1
  int v42; // $v0
  int v43; // $v0
  int v44; // $v0
  char *v45; // $a0
  _BYTE *v46; // $a1
  int v47; // $v0
  _BYTE *v48; // $s0
  _BYTE *v49; // $s0
  const char *v51; // $s0
  int v52; // $v0
  const char *v53; // $s0
  int v54; // $v0
  int v55; // $v1
  int v56; // $a2
  size_t v57; // $a2
  int v58; // $v0
  int v59; // $v0
  _BYTE *v60; // $a0
  char v61[4]; // [sp+18h] [-24h] BYREF
  unsigned int v62; // [sp+1Ch] [-20h]
  int v63[5]; // [sp+28h] [-14h] BYREF

  v1 = *(unsigned __int8 *)(a1 + 41);
  v63[0] = 0;
  switch ( v1 )
  {
    case 0:
      if ( *(_DWORD *)(a1 + 209984) )
      {
        v25 = (const char *)(a1 + 564);
        v26 = https_ssl_read(a1);
        v27 = 0;
        if ( v26 == -2 )
        {
          v26 = 0;
          goto LABEL_38;
        }
      }
      else
      {
        v25 = (const char *)(a1 + 564);
        v26 = recv(
                *(_DWORD *)(a1 + 205416),
                (void *)(a1 + 564 + *(_DWORD *)(a1 + 205364)),
                102399 - *(_DWORD *)(a1 + 205364),
                0);
      }
      v27 = v26;
      if ( v26 <= 0 )
        goto LABEL_34;
LABEL_38:
      memcpy((void *)(a1 + 102964 + *(_DWORD *)(a1 + 205364)), (void *)&v25[*(_DWORD *)(a1 + 205364)], v27);
      v28 = v26 + *(_DWORD *)(a1 + 205364);
      *(_DWORD *)(a1 + 205364) = v28;
      *(_BYTE *)(a1 + v28 + 564) = 0;
      *(_BYTE *)(a1 + v28 + 102964) = 0;
      v29 = strstr(v25, "\r\n\r\n");
      v30 = v29 == 0;
      v31 = v29 + 4;
      if ( v30 )
        goto LABEL_28;
      v32 = v31 - v25;
      *(_DWORD *)(a1 + 205484) = v32;
      *(_BYTE *)(a1 + v32 + 563) = 0;
      if ( !memcmp(v25, "GET ", 4u) )
      {
        *(_BYTE *)(a1 + 40) = 1;
        *(_BYTE *)(a1 + 43) = 0;
        return httpd_dowith_get(a1);
      }
      v15 = memcmp(v25, "POST ", 5u);
      if ( v15 )
        goto LABEL_34;
      v33 = *(char *)(a1 + 569);
      *(_BYTE *)(a1 + 40) = 2;
      *(_BYTE *)(a1 + 43) = 0;
      *(_DWORD *)(a1 + 44) = a1 + 569;
      if ( v33 == 32 )
      {
        v34 = (_BYTE *)(a1 + 569);
        goto LABEL_48;
      }
      v34 = (_BYTE *)(a1 + 569);
      if ( v33 == 63 )
      {
LABEL_67:
        *v34 = 0;
        v45 = *(char **)(a1 + 44);
        v63[2] = (int)(v34 + 1);
        unescape(v45);
        v46 = v34 + 1;
        *(_DWORD *)(a1 + 52) = 0;
        if ( v34 == (_BYTE *)-1 )
        {
          v34 = 0;
        }
        else
        {
          v47 = v34[1] & 0xDF;
          v48 = v34 + 1;
          if ( v47 )
          {
            v49 = v46 + 1;
            while ( *v49++ & 0xDF )
              ;
            v48 = v49 - 1;
          }
          *v48 = 0;
          httpd_formdata_parse((_DWORD *)a1, v46, 0);
          v34 = v48 + 1;
        }
      }
      else
      {
        if ( v33 )
        {
          while ( 1 )
          {
            v35 = (char)*++v34;
            if ( v35 == 32 )
              break;
            if ( v35 == 63 )
              goto LABEL_67;
            if ( !*v34 )
              goto LABEL_73;
          }
LABEL_48:
          *v34++ = 0;
          unescape(*(char **)(a1 + 44));
          *(_DWORD *)(a1 + 52) = 0;
          goto LABEL_49;
        }
LABEL_73:
        unescape((char *)(a1 + 569));
        *(_DWORD *)(a1 + 52) = 0;
      }
LABEL_49:
      httpd_do_wwwparm((_DWORD *)a1, v34);
      if ( !httpd_proxy_check(a1, v63) )
        goto LABEL_50;
      if ( !httpd_proxy_is_self(a1) )
      {
        if ( v63[0] && httdp_proxy_check_user(a1) )
          v15 = 0;
        else
          v15 = httpd_proxy_cgi(a1);
        return v15;
      }
      v51 = *(const char **)(a1 + 44);
      if ( !strncmp(v51, "/ap/", 4u) )
      {
        v51 += 3;
        *(_DWORD *)(a1 + 44) = v51;
      }
      v52 = strncmp(v51, "/rt/", 4u);
      v53 = v51 + 3;
      if ( !v52 )
        *(_DWORD *)(a1 + 44) = v53;
LABEL_50:
      if ( (*(_DWORD *)(a1 + 32) & 0x80) == 0 )
      {
        if ( debug_level > 0 )
          printf("%s:%d post not  Content-Length\n ", "httpd_do_recv", 4449);
        goto LABEL_34;
      }
      v36 = *(_DWORD *)(a1 + 44);
      v37 = (const char *)(v36 + 1);
      if ( *(_BYTE *)(v36 + 1) )
      {
        v3 = get_name_hash((unsigned __int8 *)(v36 + 1));
        v4 = httpd_find_ext_cgi(v37, v3);
        v5 = v4;
        if ( v4 )
        {
          v6 = *(_DWORD *)(a1 + 205364);
          v7 = *(_DWORD *)(a1 + 205484);
          if ( httpd_check_user(a1, v4[4]) )
            return v15;
          v8 = (int (__fastcall *)(int))v5[6];
          *(_DWORD *)(a1 + 205560) = v8;
          if ( !strcmp(v37, "upload_manage/upload.htm")
            || !strcmp(v37, "upload_manage/upload2.htm")
            || !strcmp(v37, aUsbUpload2)
            || !strcmp(v37, "auth_upload.cgi") )
          {
            if ( !v8 )
              goto LABEL_34;
            return v8(a1);
          }
          *(_DWORD *)(a1 + 205568) = (*(_DWORD *)(a1 + 205496) & 0xFFFFFC00) + 1025;
          if ( !strcmp(v37, "upfile.cgi") )
          {
            upgrade_prepare();
            get_memory(v61);
            v9 = *(_DWORD *)(a1 + 205568);
            if ( v62 < v9 )
            {
              upgrade_after(v9);
              if ( debug_level > 0 )
                printf("%s:%d mem_malloc %d false \n ", "httpd_do_recv", 4535, *(_DWORD *)(a1 + 205568));
              goto LABEL_34;
            }
          }
          else
          {
            get_memory(v61);
            v9 = *(_DWORD *)(a1 + 205568);
            if ( v62 < v9 )
            {
              if ( debug_level > 0 )
                printf("%s:%d mem_malloc %d false \n ", "httpd_do_recv", 4544, *(_DWORD *)(a1 + 205568));
              nvram_set("jhttpd_no_mem", "1");
              goto LABEL_34;
            }
          }
          _mem_malloc(v9, "httpd_do_recv", 4550);
          *(_DWORD *)(a1 + 205564) = v10;
          if ( !v10 )
          {
            if ( debug_level > 0 )
              printf("%s:%d mem_malloc %d false \n ", "httpd_do_recv", 4553, *(_DWORD *)(a1 + 205568));
            goto LABEL_34;
          }
          if ( strcmp(v37, "login.cgi") && strcmp(v37, "log_in.cgi") )
            nvram_set("jhttpd_no_mem", "0");
          v11 = v6 - v7;
          if ( v11 > 0 )
          {
            memcpy(*(void **)(a1 + 205564), (void *)(a1 + *(_DWORD *)(a1 + 205484) + 564), v11);
            v12 = v11;
            *(_BYTE *)(*(_DWORD *)(a1 + 205564) + v11) = 0;
          }
          else
          {
            v12 = v11;
          }
          *(_BYTE *)(a1 + 41) = 6;
          if ( *(_DWORD *)(a1 + 205364) != 102400 )
          {
            *(_DWORD *)(a1 + 205364) = v11;
LABEL_18:
            v13 = *(_DWORD *)(a1 + 205496);
            if ( v12 >= v13 )
            {
              if ( v13 )
                httpd_formdata_parse((_DWORD *)a1, &v25[*(_DWORD *)(a1 + 205484)], 1);
              goto LABEL_21;
            }
            v54 = jiffies_get();
            mod_timer(a1 + 205540, v54 + 15000);
            return 0;
          }
          v55 = *(_DWORD *)(a1 + 209984);
          v56 = *(_DWORD *)(a1 + 205568) - 1;
          *(_DWORD *)(a1 + 205364) = v11;
          v57 = v56 - v11;
          if ( v55 )
          {
            v58 = https_ssl_read(a1);
            if ( v58 == -2 )
            {
              v58 = 0;
LABEL_98:
              v59 = v58 + *(_DWORD *)(a1 + 205364);
              v60 = (_BYTE *)(*(_DWORD *)(a1 + 205564) + v59);
              *(_DWORD *)(a1 + 205364) = v59;
              *v60 = 0;
              v12 = *(_DWORD *)(a1 + 205364);
              goto LABEL_18;
            }
          }
          else
          {
            v58 = recv(*(_DWORD *)(a1 + 205416), (void *)(*(_DWORD *)(a1 + 205564) + v11), v57, 0);
          }
          if ( v58 <= 0 )
            goto LABEL_34;
          goto LABEL_98;
        }
      }
      v38 = *(_DWORD *)(a1 + 205364);
      if ( v38 == 102400 )
      {
        if ( debug_level > 0 )
          printf("%s:%d len == HTTPD_CONN_DATA_LEN \n ", "httpd_do_recv", 4634);
        goto LABEL_34;
      }
      v39 = *(_DWORD *)(a1 + 205484);
      v40 = *(_DWORD *)(a1 + 205496);
      v41 = v38 - v39;
      if ( 102400 - v39 < v40 )
      {
        if ( debug_level > 0 )
          printf("%s:%d post Content-Length too big \n ", "httpd_do_recv", 4640);
        goto LABEL_34;
      }
      if ( v41 >= v40 )
      {
        v43 = jiffies_get();
        mod_timer(a1 + 205540, v43 + 5000);
        return httpd_dowith_post(a1);
      }
      *(_BYTE *)(a1 + 41) = 1;
      v42 = jiffies_get();
      mod_timer(a1 + 205540, v42 + 15000);
      return v15;
    case 1:
      if ( *(_DWORD *)(a1 + 209984) )
      {
        v17 = a1 + 564;
        v18 = https_ssl_read(a1);
        v19 = 0;
        if ( v18 == -2 )
        {
          v18 = 0;
          goto LABEL_27;
        }
      }
      else
      {
        v17 = a1 + 564;
        v18 = recv(
                *(_DWORD *)(a1 + 205416),
                (void *)(a1 + 564 + *(_DWORD *)(a1 + 205364)),
                102399 - *(_DWORD *)(a1 + 205364),
                0);
      }
      v19 = v18;
      if ( v18 <= 0 )
        goto LABEL_34;
LABEL_27:
      memcpy((void *)(a1 + 102964 + *(_DWORD *)(a1 + 205364)), (void *)(v17 + *(_DWORD *)(a1 + 205364)), v19);
      v20 = v18 + *(_DWORD *)(a1 + 205364);
      *(_DWORD *)(a1 + 205364) = v20;
      *(_BYTE *)(a1 + v20 + 564) = 0;
      *(_BYTE *)(a1 + v20 + 102964) = 0;
      if ( (unsigned int)(v20 - *(_DWORD *)(a1 + 205484)) >= *(_DWORD *)(a1 + 205496) )
        return httpd_dowith_post(a1);
LABEL_28:
      v21 = jiffies_get();
      mod_timer(a1 + 205540, v21 + 2000);
      return 0;
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
LABEL_21:
      v14 = *(int (__fastcall **)(int))(a1 + 205560);
      if ( !v14 )
        goto LABEL_34;
      return v14(a1);
    case 6:
      if ( *(_DWORD *)(a1 + 209984) )
      {
        v22 = https_ssl_read(a1);
        if ( v22 == -2 )
        {
          v22 = 0;
          goto LABEL_32;
        }
      }
      else
      {
        v22 = recv(
                *(_DWORD *)(a1 + 205416),
                (void *)(*(_DWORD *)(a1 + 205564) + *(_DWORD *)(a1 + 205364)),
                *(_DWORD *)(a1 + 205568) - 1 - *(_DWORD *)(a1 + 205364),
                0);
      }
      if ( v22 <= 0 )
      {
LABEL_34:
        httpd_conn_close((int *)a1);
        return -1;
      }
LABEL_32:
      v23 = v22 + *(_DWORD *)(a1 + 205364);
      v24 = (_BYTE *)(*(_DWORD *)(a1 + 205564) + v23);
      *(_DWORD *)(a1 + 205364) = v23;
      *v24 = 0;
      if ( *(_DWORD *)(a1 + 205364) >= *(_DWORD *)(a1 + 205496) )
      {
        httpd_formdata_parse((_DWORD *)a1, *(_BYTE **)(a1 + 205564), 1);
        v14 = *(int (__fastcall **)(int))(a1 + 205560);
        if ( v14 )
          return v14(a1);
        goto LABEL_34;
      }
      v15 = 0;
      v44 = jiffies_get();
      mod_timer(a1 + 205540, v44 + 20000);
      return v15;
    default:
      goto LABEL_34;
  }
}
// 42ADD4: variable 'v10' is possibly undefined
// 67D0BC: using guessed type int debug_level;
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A837C: using guessed type int __fastcall upgrade_after(_DWORD);
// 6A85CC: using guessed type int __fastcall get_memory(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8894: using guessed type int upgrade_prepare(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0042B858) --------------------------------------------------------
int __fastcall exec_service(const char *a1)
{
  int v2; // $s0
  _BYTE *v3; // $v0
  int v4; // $s0
  int result; // $v0
  bool v6; // dc

  if ( debug_level > 0 )
    printf("%s:%d exec_service: %s\n", "exec_service", 6260, a1);
  v2 = 10;
  while ( 1 )
  {
    v3 = (_BYTE *)nvram_get("action_service");
    --v2;
    if ( v3 )
    {
      if ( !*v3 )
        break;
    }
    if ( v2 == -1 )
      break;
    if ( debug_level > 0 )
      printf("%s:%d %s: waiting before %d\n", "exec_service", 6264, "exec_service", v2);
    sleep(1u);
  }
  nvram_set("action_service", a1);
  kill(1, 16);
  v4 = 3;
  while ( 1 )
  {
    result = nvram_get("action_service");
    if ( !result )
      break;
    if ( !a1 )
      break;
    v6 = strcmp((const char *)result, a1) == 0;
    result = -1;
    if ( !v6 )
      break;
    if ( --v4 == -1 )
      break;
    if ( debug_level > 0 )
      printf("%s:%d %s: waiting after %d\n", "exec_service", 6273, "exec_service", v4);
    sleep(1u);
  }
  return result;
}
// 67D0BC: using guessed type int debug_level;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0042BA64) --------------------------------------------------------
int __fastcall sub_42BA64(int a1)
{
  *(_DWORD *)(a1 + 205576) = 0;
  *(_DWORD *)(a1 + 205572) = 0;
  exec_service_timeout(a1);
  return 0;
}

//----- (0042BAA4) --------------------------------------------------------
int __fastcall find_hs_mac(_DWORD *a1, int a2, _BYTE *a3)
{
  int v6; // $a1
  int v7; // $v0
  int v8; // $a3
  int v9; // $a2
  int v10; // $v1
  bool v11; // dc
  int result; // $v0
  char v13; // $a1
  char v14; // $v1
  int v15[129]; // [sp+18h] [-204h] BYREF

  memset(v15, 0, 0x200u);
  v6 = a1[51368];
  v7 = a1[51365];
  v8 = a1[51366];
  v9 = a1[51367];
  v10 = a1[51369];
  v15[0] = 13;
  v15[3] = 30;
  v15[1] = 512;
  v15[7] = v6;
  v15[4] = v7;
  v15[5] = v8;
  v15[6] = v9;
  v15[8] = v10;
  v11 = jianhl_order_opt_fun(v15, 512, v9) != 0;
  result = -1;
  if ( !v11 )
  {
    result = v15[2];
    if ( v15[2] )
    {
      result = -1;
    }
    else
    {
      if ( a2 )
      {
        v13 = v15[10];
        v14 = BYTE1(v15[10]);
        *(_DWORD *)a2 = v15[9];
        *(_BYTE *)(a2 + 4) = v13;
        *(_BYTE *)(a2 + 5) = v14;
      }
      if ( a3 )
        *a3 = v15[12];
    }
  }
  return result;
}
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0042BBD8) --------------------------------------------------------
int __fastcall websocket_respond_head(int a1)
{
  size_t v2; // $v0
  size_t v3; // $v0
  const char *v4; // $s0
  char *v5; // $v0
  int v6; // $v0
  char v8[10240]; // [sp+20h] [-308Ch] BYREF
  char v9[1024]; // [sp+2820h] [-88Ch] BYREF
  char v10[1024]; // [sp+2C20h] [-48Ch] BYREF
  char v11[128]; // [sp+3020h] [-8Ch] BYREF
  int v12[3]; // [sp+30A0h] [-Ch] BYREF

  v12[0] = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  if ( (*(_DWORD *)(a1 + 32) & 0x4F00000) == 0 )
    return -1;
  snprintf(v10, 1024, "%s%s", *(const char **)(a1 + 210000), "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
  v2 = strlen(v10);
  v4 = (const char *)crypt_sha1(v10, v2, v12);
  v3 = strlen(v4);
  base64_encode(v4, v9, v3);
  v5 = GetDateString(v11, 0);
  v6 = snprintf(
         v8,
         10240,
         "HTTP/1.1 101 Switching Protocols\r\n"
         "Date: %s\r\n"
         "Connection: Upgrade\r\n"
         "Server: HTTPD_gw 1.0\r\n"
         "Expires: 0\r\n"
         "Upgrade: websocket\r\n"
         "Pragma: no-cache\r\n"
         "Cache-Control: no-cache\r\n"
         "Sec-WebSocket-Accept: %s\r\n"
         "\r\n",
         v5,
         v9);
  httpd_send_data_alloc(a1, v8, v6);
  return 0;
}
// 6A8304: using guessed type int __fastcall crypt_sha1(_DWORD, _DWORD, _DWORD);
// 6A8474: using guessed type int __fastcall base64_encode(_DWORD, _DWORD, _DWORD);

//----- (0042BD78) --------------------------------------------------------
int __fastcall websocket_send_data(int a1, int a2, int a3)
{
  unsigned int v4; // $s0
  int v5; // $s2
  char v7; // [sp+18h] [-20004h] BYREF
  char v8; // [sp+19h] [-20003h]
  unsigned int v9; // [sp+1Ah] [-20002h]
  char v10; // [sp+1Eh] [-1FFFEh]
  char v11; // [sp+1Fh] [-1FFFDh]
  char v12; // [sp+20h] [-1FFFCh]
  char v13; // [sp+21h] [-1FFFBh]
  _BYTE v14[65540]; // [sp+10018h] [-10004h] BYREF

  v4 = jhl_str_to_utf8_max(a2, a3, v14, 0x10000);
  v7 = -127;
  if ( v4 < 0x7E )
  {
    v8 = v4;
    v5 = 2;
  }
  else if ( v4 < 0x10000 )
  {
    v8 = 126;
    LOWORD(v9) = htons(v4);
    v5 = 4;
  }
  else
  {
    htonl(v4);
    v8 = 127;
    v9 = v4;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v5 = 10;
  }
  memcpy(&v7 + v5, v14, v4);
  return httpd_send_data_alloc(a1, &v7, v5 + v4);
}
// 6A8880: using guessed type int __fastcall jhl_str_to_utf8_max(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042BED8) --------------------------------------------------------
void __fastcall websocket_recv_data(_BYTE *a1, int a2, _BYTE *a3, unsigned int a4)
{
  unsigned int v5; // $v0
  _BYTE *v8; // $s0
  _BYTE *v9; // $t2
  _BYTE *v10; // $a2
  _BYTE *v11; // $t0
  _BYTE *v12; // $a3
  int v13; // $v1
  _BYTE *v14; // $a1
  int v15; // $v0
  _BYTE *v16; // t1

  if ( (unsigned __int8)(*a1 + 127) < 2u && a2 >= 6 )
  {
    v5 = a1[1] & 0x7F;
    v8 = a1;
    if ( v5 >= 0x7E )
    {
      if ( v5 == 126 )
      {
        v5 = ntohs(((unsigned __int8)a1[3] << 8) | (unsigned __int8)a1[2]);
        if ( a2 - 8 < v5 )
          return;
        v9 = v8 + 4;
      }
      else
      {
        BYTE2(v15) = a1[8];
        HIBYTE(v15) = a1[9];
        v16 = a1 + 4;
        BYTE2(a1) = a1[4];
        HIBYTE(a1) = v16[1];
        LOWORD(v15) = *((_WORD *)v8 + 3);
        if ( v15 )
          return;
        LOWORD(a1) = *((_WORD *)v8 + 1);
        v5 = ntohl((uint32_t)a1);
        if ( a2 - 14 < v5 )
          return;
        v9 = v8 + 10;
      }
    }
    else
    {
      if ( a2 - 6 < v5 )
        return;
      v9 = a1 + 2;
    }
    if ( v5 >= a4 )
      v5 = a4 - 1;
    v10 = &a3[v5];
    if ( v5 )
    {
      v11 = v9 + 4;
      v12 = a3;
      v13 = 0;
      do
      {
        v14 = &v9[v13++ & 3];
        *v12++ = *v14 ^ *v11++;
      }
      while ( v5 != v13 );
      v10 = &a3[v5];
    }
    *v10 = 0;
  }
}

//----- (0042C070) --------------------------------------------------------
int __fastcall setnonblocking(int a1)
{
  int v1; // $v0

  v1 = fcntl(a1, 3, 0);
  return -(fcntl(a1, 4, v1 | 0x80) == -1);
}

//----- (0042C0D4) --------------------------------------------------------
int __fastcall setblocking(int a1)
{
  int v1; // $v0

  v1 = fcntl(a1, 3, 0);
  return -(fcntl(a1, 4, v1 & 0xFFFFFF7F) == -1);
}

//----- (0042C13C) --------------------------------------------------------
int _httpd_mem_clean()
{
  return 0;
}

//----- (0042C144) --------------------------------------------------------
int httpd_release_caches()
{
  sync();
  sync();
  return system("echo 3 > /proc/sys/vm/drop_caches");
}

//----- (0042C19C) --------------------------------------------------------
int *__fastcall _httpd_conn_find(int a1)
{
  _DWORD *v1; // $v1
  int *result; // $v0
  int *v3; // $v1
  int *v4; // $v1

  v1 = (_DWORD *)ll_httpd_conn_hash[a1 & 0xFFF];
  if ( !v1 )
    goto LABEL_6;
  if ( a1 != v1[51348] )
  {
    while ( 1 )
    {
      v1 = (_DWORD *)*v1;
      if ( !v1 )
        break;
      if ( a1 == v1[51348] )
      {
        result = v1 - 6;
        goto LABEL_18;
      }
    }
LABEL_6:
    v3 = (int *)ll_httpd_conn_pty;
    if ( (int *)ll_httpd_conn_pty != &ll_httpd_conn_pty )
    {
      if ( a1 == *(_DWORD *)(ll_httpd_conn_pty + 205412) )
      {
LABEL_19:
        result = v3 - 2;
        v3[51351] = a1;
        return result;
      }
      while ( 1 )
      {
        v3 = (int *)*v3;
        if ( v3 == &ll_httpd_conn_pty )
          break;
        if ( a1 == v3[51353] )
          goto LABEL_19;
      }
    }
    v4 = (int *)fbss;
    if ( (int *)fbss != &fbss )
    {
      if ( a1 == *(_DWORD *)(fbss + 205408) )
      {
LABEL_20:
        result = v4 - 4;
        v4[51349] = a1;
        return result;
      }
      while ( 1 )
      {
        v4 = (int *)*v4;
        if ( v4 == &fbss )
          break;
        if ( a1 == v4[51352] )
          goto LABEL_20;
      }
    }
    return 0;
  }
  result = v1 - 6;
LABEL_18:
  v1[51347] = a1;
  return result;
}
// 67D050: using guessed type int fbss;
// 67D068: using guessed type int ll_httpd_conn_pty;

//----- (0042C300) --------------------------------------------------------
int httpd_mem_init()
{
  _DWORD *v0; // $v0
  _DWORD *v1; // $v1

  v0 = ll_httpd_conn_hash;
  v1 = &ll_mem_debug_hash;
  ll_mem_debug_list = (int)&ll_mem_debug_list;
  dword_67D064 = (int)&ll_mem_debug_list;
  ll_httpd_conn_used = (int)&ll_httpd_conn_used;
  dword_67D05C = (int)&ll_httpd_conn_used;
  ll_httpd_conn_pty = (int)&ll_httpd_conn_pty;
  dword_67D06C = (int)&ll_httpd_conn_pty;
  fbss = (int)&fbss;
  dword_67D054 = (int)&fbss;
  do
  {
    *v0++ = 0;
    *v1++ = 0;
  }
  while ( v0 != (_DWORD *)&ll_mem_debug_hash );
  return 0;
}
// 67D050: using guessed type int fbss;
// 67D054: using guessed type int dword_67D054;
// 67D058: using guessed type int ll_httpd_conn_used;
// 67D05C: using guessed type int dword_67D05C;
// 67D060: using guessed type int ll_mem_debug_list;
// 67D064: using guessed type int dword_67D064;
// 67D068: using guessed type int ll_httpd_conn_pty;
// 67D06C: using guessed type int dword_67D06C;

//----- (0042C364) --------------------------------------------------------
_DWORD *__fastcall _httpd_enter_hash(int a1, int a2)
{
  int v2; // $a0
  int v3; // $v1
  int v4; // $a2
  _DWORD *result; // $v0

  v2 = a1;
  v3 = ll_httpd_conn_hash[v2];
  v4 = a2 + 24;
  *(_DWORD *)(a2 + 24) = v3;
  if ( v3 )
    *(_DWORD *)(v3 + 4) = v4;
  result = &ll_httpd_conn_hash[v2];
  ll_httpd_conn_hash[v2] = v4;
  *(_DWORD *)(a2 + 28) = &ll_httpd_conn_hash[v2];
  return result;
}

//----- (0042C3A0) --------------------------------------------------------
int __fastcall _httpd_out_hash(int a1)
{
  int v1; // $v0
  _DWORD *v2; // $v1
  int result; // $v0

  v1 = *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD **)(a1 + 28);
  *v2 = v1;
  if ( v1 )
    *(_DWORD *)(v1 + 4) = v2;
  *(_DWORD *)(a1 + 24) = 1048832;
  result = 2097664;
  *(_DWORD *)(a1 + 28) = 2097664;
  return result;
}

//----- (0042C3D0) --------------------------------------------------------
int __fastcall close_socket(int fd)
{
  return close(fd);
}

//----- (0042C3EC) --------------------------------------------------------
void __fastcall __noreturn sub_42C3EC(int a1)
{
  dword_67D0C4 = 1;
  if ( dword_667724 != -1 )
  {
    close_socket(dword_667724);
    dword_667724 = -1;
  }
  if ( dword_667720 != -1 )
  {
    close_socket(dword_667720);
    dword_667720 = -1;
  }
  if ( https_fd != -1 )
    close_socket(https_fd);
  https_ssl_uninit(0);
  printf("\n SignalFunc_SEGV %d\n", a1);
  exit(0);
}
// 667720: using guessed type int dword_667720;
// 667724: using guessed type int dword_667724;
// 67BD44: using guessed type int https_fd;
// 67D0C4: using guessed type int dword_67D0C4;

//----- (0042C4EC) --------------------------------------------------------
void *sub_42C4EC()
{
  void *result; // $v0

  result = &unk_680000;
  dword_67D0C4 = 1;
  return result;
}
// 67D0C4: using guessed type int dword_67D0C4;

//----- (0042C508) --------------------------------------------------------
int __fastcall sub_42C508(int a1)
{
  int *v1; // $v0
  int v2; // $s0
  bool v3; // dc

  v1 = &dword_6997E8;
  v2 = 1;
  while ( 1 )
  {
    v3 = *v1 >= 0;
    v1 += 2;
    if ( !v3 )
      break;
    if ( ++v2 == 5120 )
    {
      fprintf(stderr, "socket '%d' add  poll false\n", a1);
      return -1;
    }
  }
  v3 = debug_level <= 0;
  *(&array_conn.fd + 2 * v2) = a1;
  if ( !v3 )
    printf("%s:%d %s[%d]: add sockfd:%d, poll_i:%d\n", "httpd_epoll_add", 837, "httpd_epoll_add", 837, a1, v2);
  v3 = v2 < curfds;
  *(&array_conn.events + 4 * v2) = 1;
  if ( !v3 )
    curfds = v2 + 1;
  return v2;
}
// 67D0A4: using guessed type int curfds;
// 67D0BC: using guessed type int debug_level;
// 6997E8: using guessed type int dword_6997E8;

//----- (0042C640) --------------------------------------------------------
int __fastcall sub_42C640(int a1, int a2)
{
  bool v2; // dc

  v2 = debug_level <= 0;
  *(&array_conn.fd + 2 * a2) = -1;
  if ( !v2 )
    printf("%s:%d %s[%d]: del sockfd:%d, poll_i:%d\n", "httpd_epoll_del", 858, "httpd_epoll_del", 858, a1, a2);
  return 0;
}
// 67D0BC: using guessed type int debug_level;

//----- (0042C6B8) --------------------------------------------------------
int __fastcall httpd_conn_epoll_add_pty(_DWORD *a1)
{
  int *v1; // $v1
  int v2; // $v0
  bool v3; // dc
  int v4; // $a1
  int v5; // $t3
  int v6; // $t0
  struct pollfd *v7; // $a3

  v1 = &dword_6997E8;
  v2 = 1;
  while ( 1 )
  {
    v3 = *v1 >= 0;
    v1 += 2;
    if ( !v3 )
      break;
    if ( ++v2 == 5120 )
    {
      fprintf(stderr, "socket '%d' add  poll false\n", a1[51355]);
      return -1;
    }
  }
  v4 = curfds;
  v5 = a1[51355];
  v6 = ll_httpd_conn_pty;
  a1[51358] = v2;
  v7 = &array_conn + v2;
  v7->fd = v5;
  ll_httpd_conn_pty = (int)(a1 + 2);
  *(_DWORD *)(v6 + 4) = a1 + 2;
  a1[2] = v6;
  a1[3] = &ll_httpd_conn_pty;
  v7->events = 1;
  if ( v2 >= v4 )
    curfds = v2 + 1;
  return 0;
}
// 67D068: using guessed type int ll_httpd_conn_pty;
// 67D0A4: using guessed type int curfds;
// 6997E8: using guessed type int dword_6997E8;

//----- (0042C79C) --------------------------------------------------------
int __fastcall httpd_conn_epoll_read_pty(int a1)
{
  *(&array_conn.events + 4 * *(_DWORD *)(a1 + 205432)) = 1;
  return 0;
}

//----- (0042C7D8) --------------------------------------------------------
int __fastcall httpd_conn_epoll_write_pty(int a1)
{
  *(&array_conn.events + 4 * *(_DWORD *)(a1 + 205432)) = 5;
  return 0;
}

//----- (0042C814) --------------------------------------------------------
int __fastcall httpd_conn_epoll_del_pty(int a1)
{
  *(&array_conn.fd + 2 * *(_DWORD *)(a1 + 205432)) = -1;
  return 0;
}

//----- (0042C850) --------------------------------------------------------
int __fastcall httpd_conn_epoll_add_proxy(_DWORD *a1)
{
  int *v1; // $v1
  int v2; // $v0
  bool v3; // dc
  int v4; // $a1
  int v5; // $t3
  int v6; // $t0
  struct pollfd *v7; // $a3

  v1 = &dword_6997E8;
  v2 = 1;
  while ( 1 )
  {
    v3 = *v1 >= 0;
    v1 += 2;
    if ( !v3 )
      break;
    if ( ++v2 == 5120 )
    {
      fprintf(stderr, "socket '%d' add  poll false\n", a1[51356]);
      return -1;
    }
  }
  v4 = curfds;
  v5 = a1[51356];
  v6 = fbss;
  a1[51359] = v2;
  v7 = &array_conn + v2;
  v7->fd = v5;
  fbss = (int)(a1 + 4);
  *(_DWORD *)(v6 + 4) = a1 + 4;
  a1[4] = v6;
  a1[5] = &fbss;
  v7->events = 1;
  if ( v2 >= v4 )
    curfds = v2 + 1;
  return 0;
}
// 67D050: using guessed type int fbss;
// 67D0A4: using guessed type int curfds;
// 6997E8: using guessed type int dword_6997E8;

//----- (0042C934) --------------------------------------------------------
int __fastcall httpd_conn_epoll_read_proxy(int a1)
{
  *(&array_conn.events + 4 * *(_DWORD *)(a1 + 205436)) = 1;
  return 0;
}

//----- (0042C970) --------------------------------------------------------
int __fastcall httpd_conn_epoll_write_proxy(int a1)
{
  *(&array_conn.events + 4 * *(_DWORD *)(a1 + 205436)) = 5;
  return 0;
}

//----- (0042C9AC) --------------------------------------------------------
int __fastcall httpd_conn_epoll_del_proxy(int a1)
{
  *(&array_conn.fd + 2 * *(_DWORD *)(a1 + 205436)) = -1;
  return 0;
}

//----- (0042C9E8) --------------------------------------------------------
int __fastcall httpd_conn_epoll_add(int a1)
{
  int *v1; // $v1
  int v2; // $v0
  bool v3; // dc
  int v4; // $a0
  int v5; // $v1
  int v6; // $a2
  struct pollfd *v7; // $a3

  v1 = &dword_6997E8;
  v2 = 1;
  while ( 1 )
  {
    v3 = *v1 >= 0;
    v1 += 2;
    if ( !v3 )
      break;
    if ( ++v2 == 5120 )
    {
      fprintf(stderr, "socket '%d' add  poll false\n", *(_DWORD *)(a1 + 205416));
      return -1;
    }
  }
  v4 = a1 + 196608;
  v5 = curfds;
  v6 = *(_DWORD *)(v4 + 8808);
  v7 = &array_conn + v2;
  *(_DWORD *)(v4 + 8820) = v2;
  v7->fd = v6;
  v7->events = 1;
  if ( v2 >= v5 )
    curfds = v2 + 1;
  return 0;
}
// 67D0A4: using guessed type int curfds;
// 6997E8: using guessed type int dword_6997E8;

//----- (0042CAB0) --------------------------------------------------------
int __fastcall httpd_conn_epoll_read(int a1)
{
  *(&array_conn.events + 4 * *(_DWORD *)(a1 + 205428)) = 1;
  return 0;
}

//----- (0042CAEC) --------------------------------------------------------
int __fastcall sub_42CAEC(int a1, int a2)
{
  *(&array_conn.events + 4 * a2) = 1;
  return 0;
}

//----- (0042CB14) --------------------------------------------------------
int __fastcall httpd_conn_epoll_write(int a1)
{
  int v1; // $v0

  *(&array_conn.events + 4 * *(_DWORD *)(a1 + 205428)) = 5;
  v1 = jiffies_get();
  mod_timer(a1 + 205540, v1 + 5000);
  return 0;
}
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (0042CB90) --------------------------------------------------------
int __fastcall sub_42CB90(int a1, int a2)
{
  *(&array_conn.events + 4 * a2) = 5;
  return 0;
}

//----- (0042CBB8) --------------------------------------------------------
int __fastcall httpd_conn_epoll_del(int a1)
{
  *(&array_conn.fd + 2 * *(_DWORD *)(a1 + 205428)) = -1;
  return 0;
}

//----- (0042CBF4) --------------------------------------------------------
int _httpd_conn_all_close_socket()
{
  int *v0; // $s0
  int *v1; // $s6
  int result; // $v0

  v0 = (int *)ll_httpd_conn_used;
  if ( (int *)ll_httpd_conn_used != &ll_httpd_conn_used )
  {
    do
    {
      v1 = (int *)*v0;
      if ( v0[51354] != -1 )
      {
        httpd_conn_epoll_del((int)v0);
        close_socket(v0[51354]);
        v0[51354] = -1;
      }
      if ( v0[51355] != -1 )
      {
        httpd_conn_epoll_del_pty((int)v0);
        close_socket(v0[51355]);
        v0[51355] = -1;
      }
      result = v0[51356];
      if ( result != -1 )
      {
        httpd_conn_epoll_del_proxy((int)v0);
        result = close_socket(v0[51356]);
        v0[51356] = -1;
      }
      v0 = v1;
    }
    while ( v1 != &ll_httpd_conn_used );
  }
  return result;
}
// 67D058: using guessed type int ll_httpd_conn_used;

//----- (0042CD2C) --------------------------------------------------------
int exit_clean()
{
  if ( dword_667724 != -1 )
  {
    close_socket(dword_667724);
    dword_667724 = -1;
  }
  if ( dword_667720 != -1 )
  {
    close_socket(dword_667720);
    dword_667720 = -1;
  }
  if ( https_fd != -1 )
  {
    close_socket(https_fd);
    https_fd = -1;
  }
  https_ssl_uninit(0);
  _httpd_conn_all_close_socket();
  return _httpd_mem_clean();
}
// 667720: using guessed type int dword_667720;
// 667724: using guessed type int dword_667724;
// 67BD44: using guessed type int https_fd;

//----- (0042CE20) --------------------------------------------------------
void __fastcall __noreturn sub_42CE20(int a1)
{
  dword_67D0C4 = 1;
  printf("SignalFunc %d\n", a1);
  exit_clean();
  exit(0);
}
// 67D0C4: using guessed type int dword_67D0C4;

//----- (0042CE88) --------------------------------------------------------
int httpd_poll_init()
{
  int v0; // $a2
  int v1; // $a1
  int v2; // $v1
  int v3; // $a0
  struct pollfd *v4; // $a0
  int v5; // $t0
  struct pollfd *v6; // $v1
  char *v7; // $v0

  array_conn.fd = dword_667724;
  array_conn.events = 1;
  if ( dword_667720 == -1 )
  {
    v0 = https_fd;
    v1 = 3;
    v2 = 2;
    v3 = 1;
    if ( https_fd != -1 )
      goto LABEL_3;
LABEL_8:
    v1 = v2;
    v5 = v2;
    v2 = v3;
    goto LABEL_4;
  }
  v0 = https_fd;
  dword_6997E8 = dword_667720;
  word_6997EC = 1;
  v1 = 4;
  v2 = 3;
  v3 = 2;
  if ( https_fd == -1 )
    goto LABEL_8;
LABEL_3:
  v4 = &array_conn + v3;
  v4->fd = v0;
  v4->events = 1;
  v5 = v2 + 1;
LABEL_4:
  v6 = &array_conn + v2;
  v6->fd = gl_httpd_unix_fd;
  v6->events = 1;
  curfds = v5;
  v7 = (char *)(&array_conn + v1);
  do
  {
    *(_DWORD *)v7 = -1;
    v7 += 8;
  }
  while ( httpd_set_cookie != v7 );
  return 0;
}
// 667720: using guessed type int dword_667720;
// 667724: using guessed type int dword_667724;
// 66B5F0: using guessed type int gl_httpd_unix_fd;
// 67BD44: using guessed type int https_fd;
// 67D0A4: using guessed type int curfds;
// 6997E8: using guessed type int dword_6997E8;
// 6997EC: using guessed type __int16 word_6997EC;

//----- (0042CF74) --------------------------------------------------------
int __fastcall httpd_sever_init(int a1, uint16_t a2, int a3)
{
  int v5; // $v0
  uint16_t v6; // $v0
  uint32_t v7; // $t1
  uint32_t v8; // $t0
  uint32_t v9; // $v1
  int v10; // $s0
  int result; // $v0
  struct sockaddr v12; // [sp+20h] [-28h] BYREF
  uint32_t v13; // [sp+30h] [-18h]
  uint32_t v14; // [sp+34h] [-14h]
  int v15; // [sp+38h] [-10h]
  int v16; // [sp+3Ch] [-Ch] BYREF
  int v17; // [sp+40h] [-8h]

  v16 = 1;
  v5 = socket(10, 2, 0);
  dword_667724 = v5;
  if ( v5 == -1 )
  {
    perror("socket");
    result = -1;
  }
  else
  {
    setnonblocking(v5);
    *(_DWORD *)&v12.sa_data[2] = 0;
    *(_DWORD *)&v12.sa_data[6] = 0;
    *(_DWORD *)&v12.sa_data[10] = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    *(_DWORD *)&v12.sa_family = 10;
    v6 = htons(a2);
    v7 = in6addr_any.in6_u.u6_addr32[1];
    v8 = in6addr_any.in6_u.u6_addr32[2];
    v9 = in6addr_any.in6_u.u6_addr32[3];
    v17 = dword_667724;
    *(_DWORD *)&v12.sa_data[6] = in6addr_any.in6_u.u6_addr32[0];
    *(_DWORD *)&v12.sa_data[10] = v7;
    v13 = v8;
    v14 = v9;
    v16 = 1;
    *(_WORD *)v12.sa_data = v6;
    setsockopt(dword_667724, 0xFFFF, 4, &v16, 4u);
    v10 = 10;
    if ( bind(dword_667724, &v12, 0x1Cu) == -1 )
    {
      while ( 1 )
      {
        --v10;
        if ( bind(dword_667724, &v12, 0x1Cu) != -1 )
          break;
        if ( !v10 )
        {
          v17 = -1;
          perror("bind");
          return v17;
        }
      }
    }
    if ( listen(dword_667724, a3) == -1 )
    {
      v17 = -1;
      perror("listen");
      result = v17;
    }
    else
    {
      puts("httpd_sever_init ipv6 ok");
      result = 0;
    }
  }
  return result;
}
// 667724: using guessed type int dword_667724;

//----- (0042D198) --------------------------------------------------------
int __fastcall httpd_tggl_init(int a1, uint16_t a2, int a3)
{
  int v5; // $v0
  uint16_t v6; // $v0
  uint32_t v7; // $t1
  uint32_t v8; // $t0
  uint32_t v9; // $v1
  int v10; // $s0
  int result; // $v0
  struct sockaddr v12; // [sp+20h] [-28h] BYREF
  uint32_t v13; // [sp+30h] [-18h]
  uint32_t v14; // [sp+34h] [-14h]
  int v15; // [sp+38h] [-10h]
  int v16; // [sp+3Ch] [-Ch] BYREF
  int v17; // [sp+40h] [-8h]

  v16 = 1;
  v5 = socket(10, 2, 0);
  dword_667720 = v5;
  if ( v5 == -1 )
  {
    perror("socket");
    result = -1;
  }
  else
  {
    setnonblocking(v5);
    *(_DWORD *)&v12.sa_data[2] = 0;
    *(_DWORD *)&v12.sa_data[6] = 0;
    *(_DWORD *)&v12.sa_data[10] = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    *(_DWORD *)&v12.sa_family = 10;
    v6 = htons(a2);
    v7 = in6addr_any.in6_u.u6_addr32[1];
    v8 = in6addr_any.in6_u.u6_addr32[2];
    v9 = in6addr_any.in6_u.u6_addr32[3];
    v17 = dword_667720;
    *(_DWORD *)&v12.sa_data[6] = in6addr_any.in6_u.u6_addr32[0];
    *(_DWORD *)&v12.sa_data[10] = v7;
    v13 = v8;
    v14 = v9;
    v16 = 1;
    *(_WORD *)v12.sa_data = v6;
    setsockopt(dword_667720, 0xFFFF, 4, &v16, 4u);
    v10 = 10;
    if ( bind(dword_667720, &v12, 0x1Cu) == -1 )
    {
      while ( 1 )
      {
        --v10;
        if ( bind(dword_667720, &v12, 0x1Cu) != -1 )
          break;
        if ( !v10 )
        {
          v17 = -1;
          perror("bind");
          return v17;
        }
      }
    }
    if ( listen(dword_667720, a3) == -1 )
    {
      v17 = -1;
      perror("listen");
      result = v17;
    }
    else
    {
      if ( debug_level > 0 )
        printf("%s:%d httpd_tggl_init ok\n", "httpd_tggl_init", 1137);
      result = 0;
    }
  }
  return result;
}
// 667720: using guessed type int dword_667720;
// 67D0BC: using guessed type int debug_level;

//----- (0042D3FC) --------------------------------------------------------
int __fastcall ip_allow_to_access_jhttpd(uint32_t a1)
{
  char *v2; // $s2
  int v4; // $s5
  int v5; // $s3
  char *v6; // $v0
  char *v7; // $s1
  char v8[1024]; // [sp+18h] [-54Ch] BYREF
  char v9[256]; // [sp+418h] [-14Ch] BYREF
  char v10[64]; // [sp+518h] [-4Ch] BYREF
  uint32_t v11; // [sp+558h] [-Ch] BYREF
  uint32_t netlong[2]; // [sp+55Ch] [-8h] BYREF

  memset(v8, 0, sizeof(v8));
  memset(v10, 0, sizeof(v10));
  jhl_parm_get("allow_ips", v8, 1024);
  v2 = v9;
  if ( v8[0] )
  {
    v4 = split_string(v8, 44, v9, 64);
    if ( v4 <= 0 )
      return 0;
    v5 = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        netlong[0] = 0;
        v11 = 0;
        memset(v10, 0, sizeof(v10));
        strlcpy(v10, *(_DWORD *)v2, 64);
        v6 = strchr(v10, 45);
        v7 = v6;
        if ( v6 )
        {
          *v6 = 0;
          inet_aton(v10, (struct in_addr *)netlong);
          inet_aton(v7 + 1, (struct in_addr *)&v11);
        }
        else
        {
          inet_aton(v10, (struct in_addr *)netlong);
          inet_aton(v10, (struct in_addr *)&v11);
        }
        ++v5;
        if ( a1 >= ntohl(netlong[0]) )
          break;
        v2 += 4;
        if ( v4 == v5 )
          return 0;
      }
      if ( ntohl(v11) >= a1 )
        break;
      v2 += 4;
      if ( v4 == v5 )
        return 0;
    }
  }
  return 1;
}
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0042D610) --------------------------------------------------------
bool __fastcall ip_allow_to_access(_DWORD *a1)
{
  int v1; // $s0
  int v3; // $s2
  uint32_t v4; // $s0
  uint32_t v6; // $v0
  __int64 v7; // $s0

  v1 = a1[4];
  v3 = a1[2] | a1[3];
  if ( v1 ^ htonl(0xFFFFu) | v3 )
  {
    LODWORD(v7) = a1[5];
    HIDWORD(v7) = a1[2] | a1[3] | a1[4];
    if ( v7 != htonl(1u) )
      return 1;
    v4 = htonl(0x7F000001u);
    if ( !v4 )
      return 1;
  }
  else
  {
    v4 = a1[5];
    if ( !v4 )
      return 1;
  }
  if ( v4 == htonl(0x7F000001u) )
    return 1;
  v6 = ntohl(v4);
  return ip_allow_to_access_jhttpd(v6) != 0;
}

//----- (0042D750) --------------------------------------------------------
int mem_init_fun()
{
  jiffies_init();
  init_timers_cpu();
  httpd_mem_init();
  httpd_file_init();
  httpd_file_ext_init();
  httpd_cgi_ext_init();
  return 0;
}
// 6A81C4: using guessed type int jiffies_init(void);
// 6A834C: using guessed type int init_timers_cpu(void);

//----- (0042D7FC) --------------------------------------------------------
int __fastcall set_jhttpd_info(int a1, int a2, _WORD *a3, int a4, int a5, _WORD *a6, _WORD *a7)
{
  char *v7; // $s4
  const char *v8; // $s6
  const char *v9; // $s2
  const char *v10; // $fp
  const char *v11; // $s7
  const char *v12; // $s1
  char *v13; // $s5
  const char *v14; // $s0
  const char *v15; // $v0
  const char *v16; // $v0
  _BYTE *v17; // $v0
  int v18; // $s3
  const char *v19; // $s6
  int v20; // $v0
  int v21; // $a1
  int v22; // $s3
  int v23; // $s4
  const char *v24; // $s2
  int v25; // $v0
  int v26; // $a1
  int v27; // $s4
  char v29[256]; // [sp+18h] [-100h] BYREF

  memset(v29, 0, sizeof(v29));
  v7 = (char *)nvram_get("http_gname_en");
  v8 = (const char *)nvram_get("http_gname");
  v9 = (const char *)nvram_get("http_gpwd");
  v10 = (const char *)nvram_get("http_lanport");
  v11 = (const char *)nvram_get("https_lanport");
  v12 = (const char *)nvram_get("http_username");
  v13 = (char *)nvram_get("http_username_en");
  v14 = (const char *)nvram_get("http_passwd");
  if ( !v12 || !*v12 )
    v12 = "root";
  if ( !v13 || !*v13 )
    v13 = "1";
  if ( !v7 || !*v7 )
    v7 = "0";
  if ( !v8 || !*v8 )
    v8 = "guest";
  if ( !v9 || !*v9 )
    v9 = "guest";
  if ( !v10 || !*v10 )
    v10 = "80";
  if ( !v11 || !*v11 )
    v11 = "443";
  if ( !v14 || !*v14 )
    v14 = "admin";
  v15 = (const char *)jhl_nv_get_def("usb_username");
  sprintf(v29, "echo \"%s = %s\" > /etc/smbusers", "smbguest", v15);
  system(v29);
  v16 = (const char *)jhl_nv_get_def("usb_husername");
  sprintf(v29, "echo \"%s = %s\" >> /etc/smbusers", "smbadmin", v16);
  system(v29);
  strlcpy(a4, v12, 32);
  strlcpy(a5, v14, 32);
  strlcpy(a1, v8, 32);
  strlcpy(a2, v9, 32);
  *a3 = J_atoi(v10);
  *a7 = J_atoi(v11);
  v17 = (_BYTE *)nvram_get("tggl_port");
  if ( v17 && *v17 )
    *a6 = J_atoi(v17);
  else
    *a6 = *a3;
  v18 = jhl_nv_get_def("http_hadmin");
  v19 = (const char *)jhl_nv_get_def("http_hadminpwd");
  v20 = jhl_nv_get_def("http_hadmin_en");
  v21 = v18;
  v22 = v20;
  strlcpy(gl_httpd_high_admin, v21, 32);
  strlcpy(gl_httpd_high_adminpwd, v19, 32);
  gl_httpd_high_admin_en = J_atoi(v22);
  gl_httpd_admin_en = J_atoi(v13);
  gl_httpd_user_en = J_atoi(v7);
  memset(gl_httpd_adminpwd_md5, 0, sizeof(gl_httpd_adminpwd_md5));
  memset(gl_httpd_password_md5, 0, sizeof(gl_httpd_password_md5));
  memset(gl_httpd_high_adminpwd_md5, 0, sizeof(gl_httpd_high_adminpwd_md5));
  httpd_passwd_md5(gl_httpd_adminpwd_md5, v14);
  httpd_passwd_md5(gl_httpd_password_md5, v9);
  httpd_passwd_md5(gl_httpd_high_adminpwd_md5, v19);
  v23 = jhl_nv_get_def("http_guest_user");
  v24 = (const char *)jhl_nv_get_def("http_guest_pwd");
  v25 = jhl_nv_get_def("http_guest_en");
  v26 = v23;
  v27 = v25;
  strlcpy(gl_httpd_guest_user, v26, 32);
  strlcpy(gl_httpd_guest_pwd, v24, 32);
  gl_httpd_guest_user_en = J_atoi(v27);
  memset(gl_httpd_guest_pwd_md5, 0, sizeof(gl_httpd_guest_pwd_md5));
  httpd_passwd_md5(gl_httpd_guest_pwd_md5, v24);
  if ( gl_httpd_high_admin_en )
    nvram_set("httpd_pwd_md5", gl_httpd_high_adminpwd_md5);
  else
    nvram_set("httpd_pwd_md5", gl_httpd_adminpwd_md5);
  pppoe_bridge_user_md5(gl_httpd_pppoe_br_md5, v12, v14);
  return 0;
}
// 666170: using guessed type int gl_httpd_admin_en;
// 67D090: using guessed type int gl_httpd_guest_user_en;
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 67D098: using guessed type int gl_httpd_user_en;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0042DED8) --------------------------------------------------------
int jhl_httpd_reset_user()
{
  nvram_unset("http_user_lock");
  set_jhttpd_info(
    (int)gl_httpd_user,
    (int)gl_httpd_password,
    &gl_httpd_port,
    (int)gl_httpd_admin,
    (int)gl_httpd_adminpwd,
    &gl_httpd_tggl_port,
    &gl_httpd_https_port);
  return killall("ac_server", 17);
}
// 666174: using guessed type __int16 gl_httpd_https_port;
// 666176: using guessed type __int16 gl_httpd_tggl_port;
// 666178: using guessed type __int16 gl_httpd_port;
// 6A8178: using guessed type int __fastcall killall(_DWORD, _DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);

//----- (0042DF58) --------------------------------------------------------
int cpu_rate_set()
{
  bool v0; // dc
  int result; // $v0
  int v2; // $v0
  int v3; // $s0
  __int64 v4; // $v0
  int v5[8]; // [sp+20h] [-30h] BYREF
  int v6; // [sp+40h] [-10h] BYREF
  int v7; // [sp+44h] [-Ch]
  int v8; // [sp+48h] [-8h]

  v5[0] = 0;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = 0;
  v5[4] = 0;
  v5[5] = 0;
  v5[6] = 0;
  v5[7] = 0;
  v0 = _get_cpu_uptime(&v6) != 0;
  result = -1;
  if ( !v0 )
  {
    v2 = v6;
    if ( v6 != dword_67D0C8 )
    {
      v3 = 20 * (v7 - dword_67D0CC);
      if ( _ltsf2(v3, 1065353216) < 0 )
      {
        v4 = 0x3FF0000000000000LL;
      }
      else
      {
        LODWORD(v4) = _gtsf2(v3, 1120272384);
        if ( (int)v4 > 0 )
          v4 = 0x4058C00000000000LL;
      }
      snprintf((char *)v5, 32, "%.1f", *(double *)&v4);
      nvram_set("device_cpu_rate", v5);
      v2 = v6;
    }
    dword_67D0C8 = v2;
    dword_67D0CC = v7;
    result = 0;
    dword_67D0D0 = v8;
  }
  return result;
}
// 42E09C: variable 'v4' is possibly undefined
// 67D0C8: using guessed type int dword_67D0C8;
// 67D0CC: using guessed type int dword_67D0CC;
// 67D0D0: using guessed type int dword_67D0D0;
// 6A8400: using guessed type int __fastcall _get_cpu_uptime(_DWORD);
// 6A8638: using guessed type int __fastcall _ltsf2(_DWORD, _DWORD);
// 6A8798: using guessed type int __fastcall _gtsf2(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0042E128) --------------------------------------------------------
__pid_t __fastcall safe_waitpid(__pid_t a1, int *a2, int a3)
{
  __pid_t v6; // $s0

  do
    v6 = waitpid(a1, a2, a3);
  while ( v6 == -1 && *_errno_location() == 4 );
  return v6;
}

//----- (0042E1D8) --------------------------------------------------------
__pid_t __fastcall wait_any_nohang(int *a1)
{
  return safe_waitpid(-1, a1, 1);
}

//----- (0042E1F8) --------------------------------------------------------
__sighandler_t unregister_signal()
{
  signal(15, (__sighandler_t)1);
  signal(2, (__sighandler_t)1);
  signal(1, (__sighandler_t)1);
  signal(3, (__sighandler_t)1);
  signal(13, (__sighandler_t)1);
  signal(11, (__sighandler_t)1);
  signal(18, (__sighandler_t)1);
  signal(17, (__sighandler_t)1);
  return signal(20, (__sighandler_t)1);
}

//----- (0042E2E4) --------------------------------------------------------
__sighandler_t register_signal()
{
  struct sigaction v1; // [sp+18h] [-90h] BYREF

  v1.sa_handler = (__sighandler_t)1;
  sigaction(13, &v1, 0);
  signal(2, (__sighandler_t)sub_42CE20);
  signal(9, (__sighandler_t)sub_42CE20);
  signal(15, (__sighandler_t)sub_42CE20);
  signal(11, (__sighandler_t)sub_42C3EC);
  signal(18, (__sighandler_t)sub_42FB54);
  return signal(17, jhl_httpd_just_debug_signal);
}

//----- (0042E3C8) --------------------------------------------------------
void __fastcall mem_list_del(int a1)
{
  _DWORD *v1; // $v0
  _DWORD *v2; // $v1
  _DWORD *v3; // $a1
  bool v4; // dc
  _DWORD *v5; // $a2
  int v6; // $a3

  v1 = (_DWORD *)((char *)&ll_mem_debug_hash + 4 * (a1 & 0xFFF));
  while ( 1 )
  {
    v1 = (_DWORD *)*v1;
    if ( !v1 )
      break;
    if ( a1 == v1[2] )
    {
      v2 = (_DWORD *)*v1;
      v3 = (_DWORD *)v1[1];
      v4 = *v1 == 0;
      *v3 = *v1;
      if ( !v4 )
        v2[1] = v3;
      v5 = (_DWORD *)*(v1 - 1);
      v6 = *(v1 - 2);
      *v1 = 1048832;
      v1[1] = 2097664;
      *(_DWORD *)(v6 + 4) = v5;
      *v5 = v6;
      *(v1 - 2) = 1048832;
      *(v1 - 1) = 2097664;
      free(v1 - 2);
      return;
    }
  }
}

//----- (0042E460) --------------------------------------------------------
char *__fastcall mem_list_add(int a1, const char *a2, int a3, int a4)
{
  char *result; // $v0
  char *v9; // $s0
  int v10; // $v0
  int v11; // $a0
  char *v12; // $a1
  int v13; // $v1

  result = (char *)calloc(0x5Cu, 1u);
  v9 = result;
  if ( result )
  {
    *(_DWORD *)result = result;
    *((_DWORD *)result + 1) = result;
    *((_DWORD *)result + 2) = 0;
    *((_DWORD *)result + 3) = 0;
    snprintf(result + 20, 64, "%s", a2);
    v10 = 4 * (a1 & 0xFFF);
    v11 = *(_DWORD *)((char *)&ll_mem_debug_hash + v10);
    *((_DWORD *)v9 + 21) = a3;
    *((_DWORD *)v9 + 22) = a4;
    *((_DWORD *)v9 + 4) = a1;
    v12 = v9 + 8;
    *((_DWORD *)v9 + 2) = v11;
    if ( v11 )
      *(_DWORD *)(v11 + 4) = v12;
    result = (char *)&ll_mem_debug_hash + v10;
    v13 = ll_mem_debug_list;
    *(_DWORD *)result = v12;
    *((_DWORD *)v9 + 3) = result;
    ll_mem_debug_list = (int)v9;
    *(_DWORD *)(v13 + 4) = v9;
    *(_DWORD *)v9 = v13;
    *((_DWORD *)v9 + 1) = &ll_mem_debug_list;
  }
  return result;
}
// 67D060: using guessed type int ll_mem_debug_list;

//----- (0042E564) --------------------------------------------------------
void mem_list_show()
{
  int v0; // $s0
  int v1; // $v0
  int v2; // $s1

  v0 = ll_mem_debug_list;
  if ( (int *)ll_mem_debug_list != &ll_mem_debug_list )
  {
    v1 = 1;
    do
    {
      v2 = v1 + 1;
      syslog(7, "%d %s[%d] len:%d", v1, (const char *)(v0 + 20), *(_DWORD *)(v0 + 84), *(_DWORD *)(v0 + 88));
      v0 = *(_DWORD *)v0;
      v1 = v2;
    }
    while ( (int *)v0 != &ll_mem_debug_list );
  }
}
// 67D060: using guessed type int ll_mem_debug_list;

//----- (0042E600) --------------------------------------------------------
void __fastcall jhl_httpd_just_debug_signal(int a1)
{
  syslog(7, "ll_httpd_conn_dd_num:%d\n", ll_httpd_conn_dd_num);
  syslog(7, "ll_httpd_conn_all_num:%d\n", ll_httpd_conn_all_num);
  syslog(7, "all_mem_malloc_num:%d\n", all_mem_malloc_num);
  mem_list_show();
}
// 67D0A8: using guessed type int all_mem_malloc_num;
// 67D0AC: using guessed type int ll_httpd_conn_all_num;
// 67D0B0: using guessed type int ll_httpd_conn_dd_num;

//----- (0042E68C) --------------------------------------------------------
void __fastcall _mem_malloc(int a1, const char *a2, int a3)
{
  _BYTE *v6; // $v0
  _BYTE *v7; // $v1

  if ( a1 > 0 && !httpd_check_sys_freemem2() )
  {
    v6 = malloc(a1);
    if ( v6 )
    {
      v7 = v6;
      ++all_mem_malloc_num;
      do
        *v7++ = 0;
      while ( v7 != &v6[a1] );
      mem_list_add((int)v6, a2, a3, a1);
    }
  }
}
// 67D0A8: using guessed type int all_mem_malloc_num;
// 6A88E8: using guessed type int httpd_check_sys_freemem2(void);

//----- (0042E77C) --------------------------------------------------------
_DWORD *_httpd_conn_m_alloc()
{
  _DWORD *v0; // $v0
  _DWORD *v1; // $s0
  _DWORD *v2; // $v1
  _DWORD *v3; // $v0

  if ( httpd_check_sys_freemem() )
    return 0;
  _mem_malloc(210104, "__httpd_conn_m_alloc", 128);
  v1 = v0;
  if ( !v0 )
    return 0;
  v2 = v0 + 2;
  v3 = v0 + 4;
  v1[2] = v2;
  v1[3] = v2;
  v1[4] = v3;
  v1[5] = v3;
  v1[6] = 0;
  v1[7] = 0;
  *v1 = v1;
  v1[1] = v1;
  init_timer(v1 + 51385);
  return v1;
}
// 42E7D4: variable 'v0' is possibly undefined
// 6A8368: using guessed type int __fastcall init_timer(_DWORD);
// 6A877C: using guessed type int httpd_check_sys_freemem(void);

//----- (0042E840) --------------------------------------------------------
void __fastcall _mem_free(void *a1)
{
  if ( a1 )
  {
    mem_list_del((int)a1);
    --all_mem_malloc_num;
    free(a1);
  }
}
// 67D0A8: using guessed type int all_mem_malloc_num;

//----- (0042E8A4) --------------------------------------------------------
void __fastcall _httpd_conn_m_free(void *a1)
{
  if ( a1 )
    _mem_free(a1);
}

//----- (0042E8D4) --------------------------------------------------------
int __fastcall httpd_conn_add(int a1, int a2, int a3)
{
  _DWORD *v6; // $s0
  int v7; // $a0
  int v8; // $a0
  int v9; // $s3
  int v10; // $s6
  int v11; // $s3
  int v12; // $s2
  int v13; // $a2
  int v14; // $v1
  int v15; // $v0
  int v17; // $s3
  int v18; // $a0
  int v19; // $a2
  int v20; // $a1
  int v21; // $a0
  int v22; // $v0
  int v23; // $v0
  int v24; // $v0
  int v25; // [sp+20h] [-10h] BYREF
  unsigned int v26; // [sp+24h] [-Ch]
  int v27; // [sp+28h] [-8h]
  int v28; // [sp+2Ch] [-4h]

  v6 = _httpd_conn_m_alloc();
  if ( !v6 )
    return -1;
  v7 = https_fd;
  v6[51355] = -1;
  v6[51356] = -1;
  v6[51354] = a1;
  v6[51352] = a3;
  *((_BYTE *)v6 + 210100) = 0;
  if ( a3 == v7 )
  {
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
    get_memory(&v25);
    if ( v26 < 0x1400000 || !https_ssl_ctx )
    {
      https_ssl_uninit(1);
      if ( https_ssl_init() )
      {
LABEL_25:
        _mem_free(v6);
        return -1;
      }
      https_accept_num = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      v28 = 0;
    }
    setnonblocking(v6[51354]);
    v21 = https_ssl_ctx;
    v6[52497] = 0;
    v22 = SSL_new(v21);
    v6[52496] = v22;
    SSL_set_fd(v22, a1);
    v23 = SSL_accept(v6[52496]);
    if ( v23 > 0 )
    {
      v24 = https_accept_num;
      v6[52497] = 1;
      https_accept_num = v24 + 1;
LABEL_19:
      v8 = v6[51354];
      goto LABEL_4;
    }
    if ( SSL_get_error(v6[52496], v23) == 2 )
      goto LABEL_19;
    SSL_shutdown(v6[52496]);
    SSL_free(v6[52496]);
    v6[52496] = 0;
    goto LABEL_25;
  }
  v8 = a1;
LABEL_4:
  setnonblocking(v8);
  memset(v6 + 51365, 0, 0x14u);
  v9 = *(_DWORD *)(a2 + 16);
  v10 = *(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 12);
  if ( v9 ^ htonl(0xFFFFu) | v10 )
  {
    *((_BYTE *)v6 + 205460) = 1;
    v18 = *(_DWORD *)(a2 + 20);
    v19 = *(_DWORD *)(a2 + 12);
    v20 = *(_DWORD *)(a2 + 16);
    v6[51366] = *(_DWORD *)(a2 + 8);
    v6[51367] = v19;
    v6[51368] = v20;
    v6[51369] = v18;
    v6[51369] = v18;
  }
  else
  {
    v6[51366] = *(_DWORD *)(a2 + 20);
  }
  v11 = gl_hs_speed;
  *((_WORD *)v6 + 102740) = *(_WORD *)(a2 + 2);
  v12 = a1 & 0xFFF;
  *((_BYTE *)v6 + 40) = 0;
  *((_BYTE *)v6 + 41) = 0;
  v6[11] = 0;
  v6[12] = 0;
  v6[13] = 0;
  v6[51343] = 0;
  v6[51391] = 0;
  *((_BYTE *)v6 + 42) = 0;
  v6[51345] = 0;
  v6[51342] = 0;
  *((_BYTE *)v6 + 43) = 0;
  v6[51341] = 0;
  v6[51398] = 0;
  v6[52423] = 0;
  v6[52424] = 0;
  v6[52425] = 0;
  v6[52426] = 0;
  v6[52459] = 0;
  if ( v11 )
  {
    v6[52495] = jiffies_get();
    if ( v11 >= 100001 )
      v17 = (v11 / 1000) << 10;
    else
      v17 = (v11 << 10) / 1000;
    v6[52493] = v17;
    v6[52494] = v17;
  }
  httpd_conn_epoll_add((int)v6);
  _httpd_enter_hash(v12, (int)v6);
  v13 = ll_httpd_conn_used;
  v14 = ll_httpd_conn_dd_num + 1;
  v15 = ll_httpd_conn_all_num + 1;
  *(_DWORD *)(ll_httpd_conn_used + 4) = v6;
  *v6 = v13;
  v6[1] = &ll_httpd_conn_used;
  ll_httpd_conn_used = (int)v6;
  ll_httpd_conn_dd_num = v14;
  ll_httpd_conn_all_num = v15;
  v6[51389] = v6;
  v6[51387] = jiffies_get() + 10000;
  v6[51388] = httpd_keep_alive_timeout;
  add_timer(v6 + 51385);
  if ( debug_level > 0 )
    printf("%s:%d httpd_conn_add  conn all = %d fd =%d\n", "httpd_conn_add", 401, ll_httpd_conn_dd_num, v6[51354]);
  return 0;
}
// 67BD44: using guessed type int https_fd;
// 67D058: using guessed type int ll_httpd_conn_used;
// 67D0A0: using guessed type int gl_hs_speed;
// 67D0AC: using guessed type int ll_httpd_conn_all_num;
// 67D0B0: using guessed type int ll_httpd_conn_dd_num;
// 67D0BC: using guessed type int debug_level;
// 681500: using guessed type int https_accept_num;
// 681504: using guessed type int https_ssl_ctx;
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8570: using guessed type int __fastcall SSL_accept(_DWORD);
// 6A85CC: using guessed type int __fastcall get_memory(_DWORD);
// 6A8618: using guessed type int __fastcall SSL_shutdown(_DWORD);
// 6A8658: using guessed type int __fastcall SSL_new(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8860: using guessed type int __fastcall SSL_set_fd(_DWORD, _DWORD);
// 6A88A0: using guessed type int __fastcall SSL_free(_DWORD);
// 6A8990: using guessed type int __fastcall SSL_get_error(_DWORD, _DWORD);

//----- (0042EDC0) --------------------------------------------------------
int __fastcall httpd_conn_send_finish(int a1)
{
  int v2; // $a0
  int v3; // $v0
  int v4; // $s1
  void *v5; // $a0
  FILE *v6; // $a0
  void *v7; // $a0
  int v8; // $a0
  int v10; // $s2
  FILE *v11; // $a0

  if ( (*(_DWORD *)(a1 + 36) & 1) == 0 )
  {
    v10 = a1 + 196608;
    *(_DWORD *)(a1 + 205556) = a1;
    *(_BYTE *)(a1 + 210101) = 1;
    *(_DWORD *)(a1 + 205548) = jiffies_get() + 10;
    *(_DWORD *)(v10 + 8944) = httpd_keep_alive_timeout;
    v8 = a1 + 205540;
    goto LABEL_15;
  }
  v2 = *(_DWORD *)(a1 + 48);
  if ( v2 )
  {
    cJSON_Delete(v2);
    *(_DWORD *)(a1 + 48) = 0;
  }
  v3 = *(unsigned __int8 *)(a1 + 42);
  if ( v3 == 1 )
  {
    _mem_free(*(void **)(a1 + 205372));
    *(_DWORD *)(a1 + 205372) = 0;
  }
  else if ( v3 == 2 )
  {
    v11 = *(FILE **)(a1 + 205592);
    if ( v11 )
    {
      fclose(v11);
      *(_DWORD *)(a1 + 205592) = 0;
      *(_DWORD *)(a1 + 209692) = 0;
      v4 = a1 + 196608;
      httpd_release_caches();
      v5 = *(void **)(a1 + 205564);
      if ( !v5 )
        goto LABEL_8;
      goto LABEL_7;
    }
  }
  v4 = a1 + 196608;
  v5 = *(void **)(a1 + 205564);
  if ( v5 )
  {
LABEL_7:
    _mem_free(v5);
    *(_DWORD *)(v4 + 8956) = 0;
  }
LABEL_8:
  if ( *(_DWORD *)(a1 + 205540) )
    del_timer(a1 + 205540);
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 41) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 205492) = 0;
  *(_DWORD *)(a1 + 205488) = 0;
  *(_DWORD *)(a1 + 205512) = 0;
  *(_DWORD *)(a1 + 205516) = 0;
  *(_DWORD *)(a1 + 205496) = 0;
  *(_DWORD *)(a1 + 205400) = 0;
  *(_DWORD *)(a1 + 205372) = 0;
  *(_BYTE *)(a1 + 42) = 0;
  *(_DWORD *)(a1 + 205388) = 0;
  *(_DWORD *)(a1 + 205376) = 0;
  *(_DWORD *)(a1 + 205380) = 0;
  *(_DWORD *)(a1 + 205384) = 0;
  *(_DWORD *)(a1 + 205368) = 0;
  *(_BYTE *)(a1 + 43) = 0;
  *(_DWORD *)(a1 + 205396) = 0;
  *(_DWORD *)(a1 + 205392) = 0;
  memset((void *)(a1 + 564), 0, 0x19000u);
  *(_DWORD *)(a1 + 205364) = 0;
  memset((void *)(a1 + 52), 0, 0x200u);
  v6 = *(FILE **)(a1 + 209696);
  *(_DWORD *)(a1 + 205560) = 0;
  *(_DWORD *)(a1 + 209692) = 0;
  if ( v6 )
  {
    fclose(v6);
    *(_DWORD *)(a1 + 209696) = 0;
    httpd_release_caches();
  }
  v7 = *(void **)(a1 + 209700);
  if ( v7 )
  {
    _mem_free(v7);
    *(_DWORD *)(a1 + 209700) = 0;
  }
  *(_DWORD *)(a1 + 209704) = 0;
  memset((void *)(a1 + 209708), 0, 0x80u);
  *(_DWORD *)(a1 + 205556) = a1;
  *(_DWORD *)(a1 + 209836) = 0;
  *(_DWORD *)(a1 + 205548) = jiffies_get() + 30000;
  v8 = a1 + 205540;
  *(_DWORD *)(a1 + 205552) = httpd_keep_alive_timeout;
LABEL_15:
  add_timer(v8);
  httpd_conn_epoll_read(a1);
  return 0;
}
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A896C: using guessed type int __fastcall del_timer(_DWORD);

//----- (0042F0F8) --------------------------------------------------------
int __fastcall httpd_conn_close(int *a1)
{
  int *v1; // $s1
  int v3; // $a0
  int v4; // $a0
  void *v5; // $a0
  FILE *v6; // $a0
  FILE *v7; // $a0
  void *v8; // $a0
  void *v9; // $a0
  void *v10; // $a0
  void *v11; // $a0
  void *v12; // $a0
  int *v13; // $v0
  int v14; // $v1
  int *v15; // $a0
  int v16; // $a1
  int v17; // $a2
  int *v18; // $a1
  int v19; // $a3

  v1 = a1 + 49152;
  v3 = a1[52496];
  if ( v3 )
  {
    SSL_shutdown(v3);
    SSL_free(v1[3344]);
    v1[3344] = 0;
  }
  if ( a1[51385] )
    del_timer(a1 + 51385);
  if ( a1[51354] != -1 )
  {
    httpd_conn_epoll_del((int)a1);
    close_socket(a1[51354]);
    a1[51354] = -1;
  }
  if ( a1[51355] != -1 )
  {
    httpd_conn_epoll_del_pty((int)a1);
    close_socket(a1[51355]);
    a1[51355] = -1;
  }
  if ( a1[51356] != -1 )
  {
    httpd_conn_epoll_del_proxy((int)a1);
    close_socket(a1[51356]);
    a1[51356] = -1;
  }
  if ( *((_BYTE *)a1 + 42) == 1 )
  {
    _mem_free((void *)a1[51343]);
    a1[51343] = 0;
  }
  v4 = a1[12];
  if ( v4 )
  {
    cJSON_Delete(v4);
    a1[12] = 0;
  }
  v5 = (void *)a1[51391];
  if ( v5 )
  {
    _mem_free(v5);
    a1[51391] = 0;
  }
  v6 = (FILE *)a1[51398];
  if ( v6 )
  {
    fclose(v6);
    a1[51398] = 0;
    a1[52423] = 0;
    httpd_release_caches();
  }
  v7 = (FILE *)a1[52424];
  if ( v7 )
  {
    fclose(v7);
    a1[52424] = 0;
    httpd_release_caches();
  }
  v8 = (void *)a1[52425];
  if ( v8 )
  {
    _mem_free(v8);
    a1[52425] = 0;
  }
  v9 = (void *)a1[52504];
  a1[52426] = 0;
  a1[52423] = 0;
  a1[51345] = 0;
  if ( v9 )
  {
    _mem_free(v9);
    a1[52504] = 0;
  }
  v10 = (void *)a1[52505];
  a1[52506] = 0;
  if ( v10 )
  {
    _mem_free(v10);
    a1[52505] = 0;
  }
  v11 = (void *)a1[51360];
  a1[52507] = 0;
  if ( v11 )
  {
    _mem_free(v11);
    a1[51360] = 0;
  }
  v12 = (void *)a1[51361];
  if ( v12 )
  {
    _mem_free(v12);
    a1[51361] = 0;
  }
  *((_BYTE *)a1 + 210100) = 0;
  a1[51363] = 0;
  *((_WORD *)a1 + 102724) = 0;
  _httpd_out_hash((int)a1);
  v13 = (int *)a1[1];
  v14 = *a1;
  *(_DWORD *)(v14 + 4) = v13;
  *v13 = v14;
  v15 = (int *)a1[3];
  v16 = a1[2];
  *a1 = 1048832;
  a1[1] = 2097664;
  *(_DWORD *)(v16 + 4) = v15;
  *v15 = v16;
  v17 = a1[4];
  v18 = (int *)a1[5];
  a1[2] = 1048832;
  a1[3] = 2097664;
  *(_DWORD *)(v17 + 4) = v18;
  *v18 = v17;
  a1[4] = 1048832;
  a1[5] = 2097664;
  _httpd_conn_m_free(a1);
  v19 = --ll_httpd_conn_dd_num;
  if ( debug_level > 0 )
    printf("%s:%d httpd_conn_close end conn all = %d\n", "httpd_conn_close", 642, v19);
  return 0;
}
// 67D0B0: using guessed type int ll_httpd_conn_dd_num;
// 67D0BC: using guessed type int debug_level;
// 6A8618: using guessed type int __fastcall SSL_shutdown(_DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A88A0: using guessed type int __fastcall SSL_free(_DWORD);
// 6A896C: using guessed type int __fastcall del_timer(_DWORD);

//----- (0042F56C) --------------------------------------------------------
int sub_42F56C()
{
  int *v0; // $a0
  int *v1; // $s0
  int result; // $v0

  v0 = (int *)ll_httpd_conn_used;
  if ( (int *)ll_httpd_conn_used != &ll_httpd_conn_used )
  {
    do
    {
      v1 = (int *)*v0;
      result = httpd_conn_close(v0);
      v0 = v1;
    }
    while ( v1 != &ll_httpd_conn_used );
  }
  return result;
}
// 67D058: using guessed type int ll_httpd_conn_used;

//----- (0042F5CC) --------------------------------------------------------
int __fastcall httpd_keep_alive_timeout(int *a1)
{
  int result; // $v0

  if ( a1 )
    result = httpd_conn_close(a1);
  return result;
}

//----- (0042F5F8) --------------------------------------------------------
int https_conn_clear()
{
  int *v0; // $a0
  int *v1; // $s0

  v0 = (int *)ll_httpd_conn_used;
  v1 = *(int **)ll_httpd_conn_used;
  if ( (int *)ll_httpd_conn_used != &ll_httpd_conn_used )
  {
    while ( 1 )
    {
      if ( v0[52496] )
        httpd_conn_close(v0);
      v0 = v1;
      if ( v1 == &ll_httpd_conn_used )
        break;
      v1 = (int *)*v1;
    }
  }
  return 0;
}
// 67D058: using guessed type int ll_httpd_conn_used;

//----- (0042F684) --------------------------------------------------------
int __fastcall httpd_poll(int timeout)
{
  int v1; // $s4
  int v2; // $s2
  int v3; // $a0
  int v4; // $s2
  int v5; // $a0
  int v6; // $s5
  struct pollfd *v7; // $s0
  int v8; // $a0
  __int16 v9; // $v0
  int v10; // $v0
  int *v11; // $s7
  __int16 v12; // $v0
  bool v13; // dc
  int v14; // $v0
  int v16; // $v0
  int v17; // $s2
  struct sockaddr v18; // [sp+18h] [-28h] BYREF
  socklen_t v19; // [sp+34h] [-Ch] BYREF
  struct pollfd *v20; // [sp+38h] [-8h]

  v1 = poll(&array_conn, curfds, timeout);
  if ( v1 <= 0 )
    return 0;
  v20 = &array_conn;
  if ( (array_conn.revents & 1) == 0 )
    goto LABEL_9;
  while ( 1 )
  {
    v19 = 28;
    v2 = accept(dword_667724, &v18, &v19);
    if ( v2 < 0 )
    {
      if ( --v1 )
        goto LABEL_9;
      return 0;
    }
    if ( !ip_allow_to_access(&v18) )
      break;
    if ( httpd_conn_add(v2, (int)&v18, 0) )
      close(v2);
  }
  --v1;
  close(v2);
  if ( !v1 )
    return 0;
LABEL_9:
  v3 = dword_667720;
  v4 = 1;
  if ( dword_667720 == -1 )
    goto LABEL_12;
  if ( (v20[1].revents & 1) == 0 )
  {
    v4 = 2;
    goto LABEL_12;
  }
  while ( 1 )
  {
    v19 = 28;
    v16 = accept(v3, &v18, &v19);
    v17 = v16;
    if ( v16 < 0 )
      break;
    if ( httpd_conn_add(v16, (int)&v18, dword_667720) )
      close(v17);
    v3 = dword_667720;
  }
  --v1;
  v4 = 2;
  if ( v1 )
  {
LABEL_12:
    v5 = https_fd;
    if ( https_fd == -1 )
      goto LABEL_22;
    if ( (v20[v4].revents & 1) != 0 )
    {
      while ( 1 )
      {
        v19 = 28;
        v6 = accept(v5, &v18, &v19);
        if ( v6 < 0 )
          break;
        if ( !ip_allow_to_access(&v18) )
        {
          --v1;
          close(v6);
          ++v4;
          if ( !v1 )
            return 0;
LABEL_22:
          if ( v4 >= curfds )
            return 0;
          v7 = &v20[v4];
          while ( 2 )
          {
            v8 = v7->fd;
            if ( v7->fd >= 0 )
            {
              v9 = v7->revents;
              if ( (v9 & 0xD) != 0 )
              {
                v10 = v9 & 1;
                if ( v8 == gl_httpd_unix_fd )
                {
                  if ( v10 )
                    httpd_unix_recv();
                }
                else
                {
                  v11 = _httpd_conn_find(v8);
                  if ( v11 )
                  {
                    v12 = v7->revents;
                    v13 = (v12 & 1) == 0;
                    v14 = v12 & 4;
                    if ( v13 )
                    {
                      if ( !v14 )
                        goto LABEL_48;
                      httpd_enable_write((int)v11);
                      --v1;
                    }
                    else
                    {
                      if ( !v11[52496] || v11[52497] )
                      {
                        httpd_do_recv((int)v11);
                        goto LABEL_35;
                      }
                      if ( https_do_accept_recv((int)v11) )
                      {
LABEL_48:
                        httpd_conn_close(v11);
                        --v1;
                      }
                      else
                      {
LABEL_35:
                        --v1;
                      }
                    }
                  }
                  else
                  {
                    --v1;
                    close(v7->fd);
                    v7->fd = -1;
                  }
                  if ( !v1 )
                    return 0;
                }
              }
            }
            ++v4;
            ++v7;
            if ( v4 >= curfds )
              return 0;
            continue;
          }
        }
        if ( httpd_conn_add(v6, (int)&v18, https_fd) )
          close(v6);
        v5 = https_fd;
      }
      if ( !--v1 )
        return 0;
    }
    ++v4;
    goto LABEL_22;
  }
  return 0;
}
// 667720: using guessed type int dword_667720;
// 667724: using guessed type int dword_667724;
// 66B5F0: using guessed type int gl_httpd_unix_fd;
// 67BD44: using guessed type int https_fd;
// 67D0A4: using guessed type int curfds;

//----- (0042FB54) --------------------------------------------------------
__pid_t sub_42FB54()
{
  __pid_t result; // $v0
  int *v1; // $v1

LABEL_1:
  while ( 1 )
  {
    result = wait_any_nohang(0);
    if ( result <= 0 )
      return result;
    while ( 1 )
    {
      v1 = (int *)ll_httpd_conn_pty;
      if ( (int *)ll_httpd_conn_pty == &ll_httpd_conn_pty )
        break;
      if ( result != *(_DWORD *)(ll_httpd_conn_pty + 205448) )
      {
        do
        {
          v1 = (int *)*v1;
          if ( v1 == &ll_httpd_conn_pty )
            goto LABEL_1;
        }
        while ( result != v1[51362] );
      }
      v1[51362] = -1;
      if ( v1 == (int *)8 )
        goto LABEL_1;
      httpd_conn_close(v1 - 2);
      result = wait_any_nohang(0);
      if ( result <= 0 )
        return result;
    }
  }
}
// 67D068: using guessed type int ll_httpd_conn_pty;

//----- (0042FC40) --------------------------------------------------------
int __fastcall get_name_hash(unsigned __int8 *a1)
{
  int v1; // $v0
  int v2; // $v1
  int v3; // $a1
  unsigned int v4; // $v1
  int v5; // $a1
  int v6; // $a2

  v1 = 0;
  while ( 1 )
  {
    v2 = *a1;
    v3 = 16 * v1;
    ++a1;
    if ( !v2 )
      break;
    while ( 1 )
    {
      v1 = v2 + v3;
      v4 = (v2 + v3) & 0xF0000000;
      v5 = HIBYTE(v4) ^ v1;
      v6 = ~v4;
      if ( !v4 )
        break;
      v2 = *a1;
      LOWORD(v1) = v6 & v5;
      v3 = 16 * (v6 & v5);
      ++a1;
      if ( !v2 )
        return v1 & 0xFFF;
    }
  }
  return v1 & 0xFFF;
}

//----- (0042FC8C) --------------------------------------------------------
int *__fastcall httpd_find_ext_file(const char *a1, int a2)
{
  int **v2; // $s0
  bool v4; // dc
  int *result; // $v0

  v2 = (int **)gl_vfile_ext_hash[a2];
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    v4 = strcmp((const char *)v2[3], a1) != 0;
    result = (int *)(v2 - 2);
    if ( !v4 )
      break;
    v2 = (int **)*v2;
    if ( !v2 )
      return 0;
  }
  return result;
}

//----- (0042FD24) --------------------------------------------------------
int __fastcall httpd_file_ext_add(int a1)
{
  int *v2; // $v0
  int v3; // $s1
  int v4; // $s1
  int v5; // $v1
  int v6; // $a0
  _DWORD *v7; // $s1
  int result; // $v0

  v3 = get_name_hash(*(unsigned __int8 **)(a1 + 20));
  v2 = httpd_find_ext_file(*(const char **)(a1 + 20), v3);
  v4 = v3;
  if ( v2 )
    return -1;
  v5 = gl_vfile_ext_hash[v4];
  v6 = a1 + 8;
  *(_DWORD *)(a1 + 8) = v5;
  if ( v5 )
    *(_DWORD *)(v5 + 4) = v6;
  v7 = &gl_vfile_ext_hash[v4];
  *v7 = v6;
  result = 0;
  *(_DWORD *)(a1 + 12) = v7;
  return result;
}

//----- (0042FDD8) --------------------------------------------------------
int *__fastcall httpd_find_ext_cgi(const char *a1, int a2)
{
  return httpd_find_ext_file(a1, a2);
}

//----- (0042FDF4) --------------------------------------------------------
int __fastcall sub_42FDF4(int a1)
{
  return httpd_file_ext_add(a1);
}

//----- (0042FE10) --------------------------------------------------------
int httpd_file_ext_init()
{
  void **v0; // $s0

  v0 = (void **)_httpd_cgi_all_fun;
  if ( _httpd_cgi_all_fun != &_httpd_cgi_all_fun )
  {
    do
    {
      httpd_file_ext_add((int)v0);
      v0 = (void **)*v0;
    }
    while ( v0 != &_httpd_cgi_all_fun );
  }
  return 0;
}
// 66B580: using guessed type void *_httpd_cgi_all_fun;

//----- (0042FE78) --------------------------------------------------------
int httpd_cgi_ext_init()
{
  return 0;
}

//----- (00430B14) --------------------------------------------------------
int __fastcall FBR_MD5Init(_DWORD *a1)
{
  int result; // $v0

  a1[2] = -2025512191;
  a1[3] = -808604791;
  a1[4] = 683334910;
  result = 808604790;
  a1[1] = 0;
  *a1 = 0;
  a1[5] = 808604790;
  return result;
}

//----- (00430B50) --------------------------------------------------------
int __fastcall FBR_MD5Update(unsigned int *a1, int a2, unsigned int a3)
{
  unsigned int v3; // $v1
  unsigned int v5; // $a0
  int result; // $v0
  int v8; // $a1
  int v9; // $s5
  char *v10; // $v1
  unsigned __int8 *v11; // $a1
  char *v12; // $a3
  char v13[64]; // [sp+18h] [-44h] BYREF
  char v14; // [sp+58h] [-4h] BYREF

  v3 = *a1;
  v5 = 8 * a3 + *a1;
  result = (v3 >> 3) & 0x3F;
  if ( v5 < v3 )
    v8 = a1[1] + 1;
  else
    v8 = a1[1];
  *a1 = v5;
  a1[1] = (a3 >> 29) + v8;
  v9 = a2 + a3;
  while ( a2 != v9 )
  {
    while ( 1 )
    {
      ++a2;
      v10 = (char *)a1 + result++;
      v10[24] = *(_BYTE *)(a2 - 1);
      if ( result != 64 )
        break;
      v11 = (unsigned __int8 *)a1 + 26;
      v12 = v13;
      do
      {
        *(_DWORD *)v12 = (v11[1] << 24) | (*v11 << 16) | *(v11 - 2) | (*(v11 - 1) << 8);
        v12 += 4;
        v11 += 4;
      }
      while ( &v14 != v12 );
      ((void (__fastcall *)(unsigned int *, char *))loc_42FE80)(a1 + 2, v13);
      result = 0;
      if ( a2 == v9 )
        return result;
    }
  }
  return result;
}

//----- (00430C88) --------------------------------------------------------
unsigned int __fastcall FBR_MD5Final(unsigned int *a1)
{
  int v1; // $a1
  unsigned int v2; // $v0
  unsigned int v4; // $a2
  unsigned __int8 *v5; // $a2
  int *v6; // $a3
  unsigned int *v7; // $s0
  unsigned int *v8; // $s1
  unsigned int *v9; // $a0
  unsigned int result; // $v0
  char v11; // [sp+18h] [-44h] BYREF
  int v12[3]; // [sp+50h] [-Ch] BYREF

  v1 = a1[1];
  v2 = (*a1 >> 3) & 0x3F;
  v12[0] = *a1;
  v12[1] = v1;
  if ( v2 >= 0x38 )
    v4 = 120 - v2;
  else
    v4 = 56 - v2;
  FBR_MD5Update(a1, (int)&unk_66B5A0, v4);
  v5 = (unsigned __int8 *)a1 + 26;
  v6 = (int *)&v11;
  do
  {
    *v6++ = (v5[1] << 24) | (*v5 << 16) | *(v5 - 2) | (*(v5 - 1) << 8);
    v5 += 4;
  }
  while ( v6 != v12 );
  v7 = a1 + 2;
  ((void (__fastcall *)(unsigned int *))loc_42FE80)(a1 + 2);
  v8 = a1 + 6;
  v9 = v7;
  do
  {
    result = *v9++;
    v9[19] = result;
  }
  while ( v8 != v9 );
  return result;
}

//----- (00430D98) --------------------------------------------------------
int __fastcall httpd_passwd_md5(char *a1, const char *a2)
{
  const char *v4; // $v0
  int v5; // $s2
  char v7[512]; // [sp+50h] [-26Ch] BYREF
  unsigned int v8[22]; // [sp+250h] [-6Ch] BYREF
  char v9[20]; // [sp+2A8h] [-14h] BYREF

  memset(v7, 0, sizeof(v7));
  v4 = (const char *)get_sn();
  v5 = snprintf(v7, 512, "%s%s%sjhttpd", "fja285dri9&cii386&$", a2, v4);
  FBR_MD5Init(v8);
  FBR_MD5Update(v8, (int)v7, v5);
  FBR_MD5Final(v8);
  if ( !dword_67D2EC )
  {
    dword_67D2EC = 1;
    byte_66B592 = 68;
    byte_66B597 = 50;
    byte_66B59D = 73;
    aes_set_key(&unk_67D2F0, &unk_66B590, 16);
  }
  aes_aes(&unk_67D2F0, v9, v5, v7, 0);
  return sprintf(
           a1,
           "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
           (unsigned __int8)v7[0],
           (unsigned __int8)v7[3],
           (unsigned __int8)v7[2],
           (unsigned __int8)v7[1],
           (unsigned __int8)v7[4],
           (unsigned __int8)v7[7],
           (unsigned __int8)v7[6],
           (unsigned __int8)v7[5],
           (unsigned __int8)v7[10],
           (unsigned __int8)v7[9],
           (unsigned __int8)v7[8],
           (unsigned __int8)v7[11],
           (unsigned __int8)v7[15],
           (unsigned __int8)v7[13],
           (unsigned __int8)v7[14],
           (unsigned __int8)v7[12]);
}
// 66B592: using guessed type char byte_66B592;
// 66B597: using guessed type char byte_66B597;
// 66B59D: using guessed type char byte_66B59D;
// 67D2EC: using guessed type int dword_67D2EC;
// 6A81D8: using guessed type int get_sn(void);
// 6A8464: using guessed type int __fastcall aes_aes(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8854: using guessed type int __fastcall aes_set_key(_DWORD, _DWORD, _DWORD);

//----- (00430F98) --------------------------------------------------------
int jhl_user_login_init()
{
  char *v0; // $v0
  const char *v1; // $s0
  char *v2; // $v0
  const char *v3; // $s1
  char *v5; // $v0
  char *v6; // $s0
  int v7; // $v0
  const char *v8; // $s7
  uint32_t v9; // $fp
  int v10; // $v0
  int v11; // $a0
  int v12; // $v0
  const char *v13; // $a3
  char v14; // $v0
  _DWORD *v15; // $a1
  int v16; // $v1
  char *v17; // $v0
  char v18[102400]; // [sp+18h] [-19040h] BYREF
  _DWORD v19[5]; // [sp+19018h] [-40h] BYREF
  const char *v20; // [sp+1902Ch] [-2Ch]

  v0 = (char *)nvram_get("jhluser_login");
  if ( !v0 )
    v0 = " ";
  if ( !*v0 )
    v0 = " ";
  strlcpy(v18, v0, 102400);
  v1 = v18;
  while ( *v1 )
  {
    v2 = strchr(v1, 60);
    if ( !v2 )
    {
      if ( split_string(v1, 124, v19, 6) < 5 )
        break;
      _mem_malloc(72, "jhl_user_login_init", 455);
      v6 = v17;
      if ( !v17 )
        break;
      v3 = 0;
      goto LABEL_12;
    }
    *v2 = 0;
    v3 = v2 + 1;
    if ( split_string(v1, 124, v19, 6) >= 5 && (_mem_malloc(72, "jhl_user_login_init", 455), (v6 = v5) != 0) )
    {
LABEL_12:
      v7 = J_atohx16(v19[0]);
      v8 = v20;
      v9 = v7;
      if ( v20 && (strchr(v20, 46) || strchr(v8, 58)) )
        StrToIpaddr(v8, v6 + 8);
      else
        *((_DWORD *)v6 + 3) = htonl(v9);
      v10 = J_atohx16(v19[1]);
      v11 = v19[2];
      *((_DWORD *)v6 + 7) = v10;
      v12 = J_atohx16(v11);
      v13 = (const char *)v19[3];
      *((_DWORD *)v6 + 8) = v12;
      snprintf(v6 + 40, 31, "%s", v13);
      v14 = J_atoi(v19[4]);
      v15 = user_login_list;
      v6[36] = v14;
      v16 = user_login_num;
      v15[1] = v6;
      *(_DWORD *)v6 = v15;
      *((_DWORD *)v6 + 1) = &user_login_list;
      user_login_list = v6;
      user_login_num = v16 + 1;
      v1 = v3;
      if ( !v3 )
        break;
    }
    else
    {
      v1 = v3;
      if ( !v3 )
        break;
    }
  }
  user_login_init = 1;
  return 0;
}
// 43111C: variable 'v5' is possibly undefined
// 431254: variable 'v17' is possibly undefined
// 66B5E0: using guessed type void *user_login_list;
// 67D2E4: using guessed type int user_login_init;
// 67D2E8: using guessed type int user_login_num;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8244: using guessed type int __fastcall J_atohx16(_DWORD);
// 6A8284: using guessed type int __fastcall StrToIpaddr(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004312A4) --------------------------------------------------------
int jhl_user_login_save()
{
  void ***v0; // $s0
  char *v1; // $s2
  int v2; // $s1
  void **v3; // $s7
  uint32_t v4; // $v0
  void **v5; // $s3
  int v6; // $s5
  int v7; // $v0
  _DWORD v9[25600]; // [sp+10h] [-18FE0h] BYREF
  char v10[64]; // [sp+19018h] [+28h] BYREF
  uint32_t v11; // [sp+19058h] [+68h]
  void **v12; // [sp+1905Ch] [+6Ch]
  char *format; // [sp+19060h] [+70h]
  int v14; // [sp+19064h] [+74h]
  void **v15; // [sp+19068h] [+78h]

  v15 = &user_login_list;
  memset(v9, 0, sizeof(v9));
  v0 = (void ***)user_login_list;
  LOWORD(v9[0]) = 32;
  if ( user_login_list != &user_login_list )
  {
    v1 = (char *)v9;
    format = "%x|%x|%x|%s|%u|%s<";
    v2 = 0;
    v14 = 102369;
    do
    {
      v3 = *v0;
      v4 = ntohl((uint32_t)v0[3]);
      v12 = v0[7];
      v11 = v4;
      v5 = v0[8];
      v6 = *((unsigned __int8 *)v0 + 36);
      v7 = IpaddrToStr(v10, v0 + 2);
      v2 += sprintf(v1, format, v11, v12, v5, v0 + 10, v6, v7, v9[0]);
      v0 = (void ***)v3;
      v1 = (char *)v9 + v2;
    }
    while ( v2 < v14 && v3 != v15 );
  }
  nvram_set("jhluser_login", v9);
  nvram_commit();
  return 0;
}
// 66B5E0: using guessed type void *user_login_list;
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A87C4: using guessed type int nvram_commit(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00431458) --------------------------------------------------------
int __fastcall jhl_user_login_add(_DWORD *a1, void *a2, const char *a3, char a4)
{
  unsigned int v7; // $s5
  void **v8; // $s1
  void **v9; // $s0
  int v10; // $s6
  int v11; // $v0
  int v13; // $v0
  void *v14; // $v0
  void *v15; // $s0
  int v16; // $v1
  int v17; // $a0
  int v18; // $a2
  int v19; // $a1
  void *v20; // $v1
  int v21; // $v0
  void **v22; // $v1
  int v23; // $a2
  _DWORD *v24; // $a1
  void *v25; // $v0

  v7 = get_sys_time();
  if ( v7 >= 0x4DB659DC && a3 )
  {
    if ( !user_login_init )
      jhl_user_login_init();
    v8 = (void **)user_login_list;
    if ( user_login_list != &user_login_list )
    {
      v9 = *(void ***)user_login_list;
      if ( v7 - *((_DWORD *)user_login_list + 7) < 0xE11 )
      {
        v10 = *(unsigned __int8 *)a1;
        if ( *((unsigned __int8 *)user_login_list + 8) == v10 )
          goto LABEL_11;
        while ( v9 != &user_login_list )
        {
          v8 = v9;
          if ( v7 - (unsigned int)v9[7] >= 0xE11 )
            break;
          v11 = *((unsigned __int8 *)v9 + 8);
          v9 = (void **)*v9;
          if ( v11 == v10 )
          {
LABEL_11:
            if ( v10 )
            {
              if ( !memcmp(v8 + 3, a1 + 1, 0x10u) && v8[8] == a2 )
                return 0;
            }
            else if ( v8[3] == (void *)a1[1] && v8[8] == a2 )
            {
              return 0;
            }
          }
        }
      }
    }
    v13 = user_login_num;
    if ( user_login_num >= 100 )
    {
      v22 = off_66B5E4;
      v23 = (int)*off_66B5E4;
      v24 = off_66B5E4[1];
      *(_DWORD *)(v23 + 4) = v24;
      *v24 = v23;
      *v22 = (void *)1048832;
      v22[1] = (void *)2097664;
      user_login_num = v13 - 1;
      _mem_free(v22);
      _mem_malloc(72, "jhl_user_login_add", 566);
      v15 = v25;
      if ( !v25 )
        goto LABEL_21;
      goto LABEL_20;
    }
    _mem_malloc(72, "jhl_user_login_add", 566);
    v15 = v14;
    if ( v14 )
    {
LABEL_20:
      v16 = a1[4];
      v17 = a1[3];
      v18 = a1[1];
      v19 = a1[2];
      *((_DWORD *)v15 + 2) = *a1;
      *((_DWORD *)v15 + 3) = v18;
      *((_DWORD *)v15 + 4) = v19;
      *((_DWORD *)v15 + 5) = v17;
      *((_DWORD *)v15 + 6) = v16;
      *((_DWORD *)v15 + 7) = v7;
      *((_DWORD *)v15 + 8) = a2;
      *((_BYTE *)v15 + 36) = a4;
      snprintf((char *)v15 + 40, 32, "%s", a3);
      v20 = user_login_list;
      v21 = user_login_num + 1;
      *((_DWORD *)user_login_list + 1) = v15;
      *(_DWORD *)v15 = v20;
      *((_DWORD *)v15 + 1) = &user_login_list;
      user_login_list = v15;
      user_login_num = v21;
LABEL_21:
      jhl_user_login_save();
      return 0;
    }
  }
  return 0;
}
// 43162C: variable 'v14' is possibly undefined
// 431778: variable 'v25' is possibly undefined
// 66B5E0: using guessed type void *user_login_list;
// 66B5E4: using guessed type void **off_66B5E4;
// 67D2E4: using guessed type int user_login_init;
// 67D2E8: using guessed type int user_login_num;

//----- (00431784) --------------------------------------------------------
int __fastcall sub_431784(_DWORD *a1, int a2, const char *a3, char a4)
{
  unsigned int v8; // $s5
  int v9; // $v0
  void *v10; // $v0
  void *v11; // $s1
  int v12; // $v1
  int v13; // $a0
  int v14; // $a2
  int v15; // $a1
  void *v16; // $v1
  int v17; // $v0
  void **v19; // $v1
  int v20; // $a2
  _DWORD *v21; // $a1
  void *v22; // $v0

  v8 = get_sys_time();
  if ( v8 < 0x4DB659DC || !a3 )
    return 0;
  if ( user_login_init )
  {
    v9 = user_login_num;
    if ( user_login_num < 100 )
      goto LABEL_5;
LABEL_9:
    v19 = off_66B5E4;
    v20 = (int)*off_66B5E4;
    v21 = off_66B5E4[1];
    *(_DWORD *)(v20 + 4) = v21;
    *v21 = v20;
    *v19 = (void *)1048832;
    v19[1] = (void *)2097664;
    user_login_num = v9 - 1;
    _mem_free(v19);
    _mem_malloc(72, "jhl_user_json_add", 660);
    v11 = v22;
    if ( !v22 )
      goto LABEL_7;
    goto LABEL_6;
  }
  jhl_user_login_init();
  v9 = user_login_num;
  if ( user_login_num >= 100 )
    goto LABEL_9;
LABEL_5:
  _mem_malloc(72, "jhl_user_json_add", 660);
  v11 = v10;
  if ( v10 )
  {
LABEL_6:
    v12 = a1[4];
    v13 = a1[3];
    v14 = a1[1];
    v15 = a1[2];
    *((_DWORD *)v11 + 2) = *a1;
    *((_DWORD *)v11 + 3) = v14;
    *((_DWORD *)v11 + 4) = v15;
    *((_DWORD *)v11 + 5) = v13;
    *((_DWORD *)v11 + 6) = v12;
    *((_DWORD *)v11 + 6) = v12;
    *((_DWORD *)v11 + 7) = v8;
    *((_DWORD *)v11 + 8) = a2;
    *((_BYTE *)v11 + 36) = a4;
    snprintf((char *)v11 + 40, 32, "%s", a3);
    v16 = user_login_list;
    v17 = user_login_num + 1;
    *((_DWORD *)user_login_list + 1) = v11;
    *(_DWORD *)v11 = v16;
    *((_DWORD *)v11 + 1) = &user_login_list;
    user_login_list = v11;
    user_login_num = v17;
LABEL_7:
    jhl_user_login_save();
  }
  return 0;
}
// 43184C: variable 'v10' is possibly undefined
// 4319A4: variable 'v22' is possibly undefined
// 66B5E0: using guessed type void *user_login_list;
// 66B5E4: using guessed type void **off_66B5E4;
// 67D2E4: using guessed type int user_login_init;
// 67D2E8: using guessed type int user_login_num;

//----- (004319EC) --------------------------------------------------------
int __fastcall httpd_user_check(int a1, const char *a2, const char *a3)
{
  _DWORD *v6; // $a0
  int v7; // $s0
  int result; // $v0

  if ( gl_httpd_high_admin_en && !strcmp(a2, gl_httpd_high_admin) && !strcmp(a3, gl_httpd_high_adminpwd) )
  {
    jhl_user_login_add((_DWORD *)(a1 + 205460), (void *)3, a2, 1);
    result = 5;
  }
  else if ( gl_httpd_admin_en && !strcmp(a2, gl_httpd_admin) && !strcmp(a3, gl_httpd_adminpwd) )
  {
    jhl_user_login_add((_DWORD *)(a1 + 205460), (void *)1, a2, 1);
    result = 4;
  }
  else
  {
    if ( gl_httpd_user_en && !strcmp(a2, gl_httpd_user) && !strcmp(a3, gl_httpd_password) )
    {
      v6 = (_DWORD *)(a1 + 205460);
      v7 = 3;
      jhl_user_login_add(v6, (void *)2, a2, 1);
      return v7;
    }
    v7 = gl_httpd_guest_user_en;
    if ( !gl_httpd_guest_user_en )
      return v7;
    v7 = strcmp(a2, gl_httpd_guest_user);
    if ( v7 )
    {
      result = 0;
    }
    else
    {
      if ( strcmp(a3, gl_httpd_guest_pwd) )
        return v7;
      result = 2;
    }
  }
  return result;
}
// 666170: using guessed type int gl_httpd_admin_en;
// 67D090: using guessed type int gl_httpd_guest_user_en;
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 67D098: using guessed type int gl_httpd_user_en;

//----- (00431C40) --------------------------------------------------------
int __fastcall httpd_send_realm(int a1)
{
  const char *v2; // $v0
  const char *v3; // $s1
  size_t v4; // $v0
  int v5; // $v0
  int v6; // $v0
  int v7; // $v0
  int result; // $v0
  char v9[512]; // [sp+18h] [-200h] BYREF

  v2 = (const char *)nvram_get("router_name");
  if ( !v2 || (v3 = v2, !*v2) )
    v3 = "WAYOS";
  sprintf(v9, httpd_errtok[0], 401, "");
  v4 = strlen(v9);
  v5 = stpcpy(&v9[v4], httpd_servertok[0]);
  v6 = stpcpy(v5, httpd_ctclose[0]);
  strcpy((char *)v6, "WWW-Authenticate: Basic realm=\"");
  qmemcpy((void *)v6, "WWW-Authenticate: Ba", 20);
  *(_DWORD *)(v6 + 28) = 2243949;
  v7 = stpcpy(v6 + 31, v3);
  *(_DWORD *)v7 = 218762530;
  *(_DWORD *)v7 = 218762530;
  *(_BYTE *)(a1 + 41) = 2;
  *(_BYTE *)(v7 + 4) = 10;
  *(_BYTE *)(v7 + 5) = 0;
  *(_DWORD *)(a1 + 205392) = 0;
  result = httpd_send_data_alloc(a1, v9, v7 - (_DWORD)v9 + 5);
  if ( !result )
  {
    result = *(_DWORD *)(a1 + 205380);
    if ( !result )
      result = httpd_conn_close((int *)a1);
  }
  return result;
}
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D4: using guessed type char *httpd_errtok[15];
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A86C8: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);

//----- (00431E48) --------------------------------------------------------
int __fastcall httpd_send_realm_admin(int a1)
{
  time_t v2; // $v0
  size_t v3; // $v0
  int v4; // $v0
  int v5; // $v0
  int v6; // $v0
  int result; // $v0
  char v8[1024]; // [sp+50h] [-670h] BYREF
  char v9[512]; // [sp+450h] [-270h] BYREF
  unsigned int v10[22]; // [sp+650h] [-70h] BYREF
  int v11; // [sp+6A8h] [-18h]
  int v12; // [sp+6ACh] [-14h]
  int v13; // [sp+6B0h] [-10h]
  int v14; // [sp+6B4h] [-Ch]
  time_t v15; // [sp+6B8h] [-8h]

  v2 = time(0);
  v15 = v2;
  if ( !jhl_realm_init )
  {
    jhl_realm_str = v2;
    *(_DWORD *)&byte_6A38E4 = v2;
    *(_DWORD *)&byte_6A38E8 = v2;
    jhl_realm_init = 1;
    dword_6A38EC = v2;
  }
  FBR_MD5Init(v10);
  FBR_MD5Update(v10, (int)&jhl_realm_str, 0x10u);
  FBR_MD5Final(v10);
  jhl_realm_str = v11;
  *(_DWORD *)&byte_6A38E4 = v12;
  *(_DWORD *)&byte_6A38E8 = v13;
  dword_6A38EC = v14;
  sprintf(
    v9,
    "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
    (unsigned __int8)v11,
    BYTE1(v11),
    BYTE2(v11),
    HIBYTE(v11),
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14));
  sprintf(v8, httpd_errtok[0], 401, "");
  v3 = strlen(v8);
  v4 = stpcpy(&v8[v3], httpd_servertok[0]);
  v5 = stpcpy(v4, httpd_ctclose[0]);
  strcpy((char *)v5, "WWW-Authenticate: Basic realm=\"");
  qmemcpy((void *)v5, "WWW-Authenticate: Ba", 20);
  *(_DWORD *)(v5 + 28) = 2243949;
  v6 = stpcpy(v5 + 31, v9);
  *(_DWORD *)v6 = 218762530;
  *(_DWORD *)v6 = 218762530;
  *(_BYTE *)(a1 + 41) = 2;
  *(_BYTE *)(v6 + 4) = 10;
  *(_BYTE *)(v6 + 5) = 0;
  *(_DWORD *)(a1 + 205392) = 0;
  result = httpd_send_data_alloc(a1, v8, v6 - (_DWORD)v8 + 5);
  if ( !result )
  {
    result = *(_DWORD *)(a1 + 205380);
    if ( !result )
      result = httpd_conn_close((int *)a1);
  }
  return result;
}
// 6676C4: using guessed type char *httpd_ctclose[19];
// 6676CC: using guessed type char *httpd_servertok[17];
// 6676D4: using guessed type char *httpd_errtok[15];
// 67D2E0: using guessed type int jhl_realm_init;
// 6A38E0: using guessed type int jhl_realm_str;
// 6A38E4: using guessed type char byte_6A38E4;
// 6A38E8: using guessed type char byte_6A38E8;
// 6A38EC: using guessed type int dword_6A38EC;
// 6A86C8: using guessed type int __fastcall stpcpy(_DWORD, _DWORD);

//----- (0043217C) --------------------------------------------------------
int __fastcall sub_43217C(int a1)
{
  const char *v2; // $s1
  size_t v3; // $v0
  char *v4; // $v0
  int v5; // $v0
  int result; // $v0
  char v7[128]; // [sp+18h] [-80h] BYREF

  if ( (*(_DWORD *)(a1 + 32) & 0x200) == 0 )
    goto LABEL_9;
  v2 = (const char *)(*(_DWORD *)(a1 + 205508) + 6);
  if ( !strstr(*(const char **)(a1 + 205508), "Basic") )
    goto LABEL_9;
  v3 = strlen(v2);
  v7[base64_decode(v2, v7, v3)] = 0;
  v4 = strchr(v7, 58);
  if ( v4 )
    *v4++ = 0;
  v5 = httpd_user_check(a1, v7, v4);
  if ( v5 < 0 )
  {
    *(_BYTE *)(a1 + 43) = 3;
    httpd_send_realm_admin(a1);
    return -1;
  }
  if ( !v5 )
  {
LABEL_9:
    *(_BYTE *)(a1 + 43) = 3;
    httpd_send_realm(a1);
    return -1;
  }
  *(_DWORD *)(a1 + 205588) = v5;
  result = 0;
  *(_BYTE *)(a1 + 43) = 1;
  return result;
}
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);

//----- (004322C4) --------------------------------------------------------
int __fastcall httpd_user_check_cookie(int a1, const char *a2, const char *a3)
{
  int v6; // $s0
  int result; // $v0

  strlcpy(a1 + 210032, a2, 64);
  if ( gl_httpd_high_admin_en && !strcmp(a2, gl_httpd_high_admin) && !strcmp(a3, gl_httpd_high_adminpwd_md5) )
  {
    jhl_user_login_add((_DWORD *)(a1 + 205460), (void *)3, a2, 1);
    result = 5;
  }
  else if ( !gl_httpd_admin_en || (v6 = strcmp(a2, gl_httpd_admin)) != 0 )
  {
    if ( gl_httpd_user_en )
    {
      v6 = strcmp(a2, gl_httpd_user);
      if ( !v6 )
      {
        if ( !strcmp(a3, gl_httpd_password_md5) )
        {
          jhl_user_login_add((_DWORD *)(a1 + 205460), (void *)2, a2, 1);
          v6 = 3;
        }
        return v6;
      }
    }
    v6 = gl_httpd_guest_user_en;
    if ( !gl_httpd_guest_user_en )
      return v6;
    v6 = strcmp(a2, gl_httpd_guest_user);
    if ( !v6 )
    {
      if ( !strcmp(a3, gl_httpd_guest_pwd_md5) )
        v6 = 2;
      return v6;
    }
    result = 0;
  }
  else
  {
    if ( strcmp(a3, gl_httpd_adminpwd_md5) )
      return v6;
    jhl_user_login_add((_DWORD *)(a1 + 205460), (void *)1, a2, 1);
    result = 4;
  }
  return result;
}
// 666170: using guessed type int gl_httpd_admin_en;
// 67D090: using guessed type int gl_httpd_guest_user_en;
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 67D098: using guessed type int gl_httpd_user_en;
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);

//----- (00432540) --------------------------------------------------------
void __fastcall sub_432540(int a1)
{
  int v1; // $v0
  const char *v3; // $s0
  size_t v4; // $v0
  char *v5; // $v0
  int v6; // $v0
  char *v7; // $a1
  const char **v8; // $fp
  int v9; // $v0
  bool v10; // dc
  int v11; // $v0
  char *v12; // $s2
  const char *v13; // $s6
  const char *v14; // $s4
  const char *v15; // $s7
  const char *i; // $v0
  char v17[1024]; // [sp+8h] [-448h] BYREF
  char v18[32]; // [sp+408h] [-48h] BYREF

  if ( !*(_BYTE *)(a1 + 43) )
  {
    v1 = *(_DWORD *)(a1 + 32);
    if ( (v1 & 0x200) != 0 )
    {
      v3 = (const char *)(*(_DWORD *)(a1 + 205508) + 6);
      if ( !strstr(*(const char **)(a1 + 205508), "Basic") )
        goto LABEL_7;
      v4 = strlen(v3);
      v17[base64_decode(v3, v17, v4)] = 0;
      v5 = strchr(v17, 58);
      if ( v5 )
        *v5++ = 0;
      v6 = httpd_user_check(a1, v17, v5);
      if ( v6 <= 0 )
      {
LABEL_7:
        *(_BYTE *)(a1 + 43) = 3;
        return;
      }
    }
    else
    {
      if ( (v1 & 0x800) == 0 )
        goto LABEL_7;
      memset(v17, 0, sizeof(v17));
      v7 = strstr(*(const char **)(a1 + 205524), "vue_userid=");
      if ( !v7 )
        goto LABEL_7;
      strlcpy(v17, v7, 1024);
      v8 = (const char **)v18;
      v9 = split_string(v17, 44, v18, 6);
      v10 = v9 <= 0;
      v11 = 4 * v9;
      if ( v10 )
        goto LABEL_7;
      v12 = &v18[v11];
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = *v8;
        if ( **v8 )
        {
          i = *v8;
          if ( **v8 == 59 )
          {
LABEL_28:
            *i = 0;
            v15 = *v8;
          }
          else
          {
            for ( i = *v8 + 1; ; ++i )
            {
              v15 = *v8;
              if ( !*i )
                break;
              if ( *i == 59 )
                goto LABEL_28;
            }
          }
        }
        if ( !strncmp(v15, "vue_userid=", 0xBu) )
        {
          v14 = v15 + 11;
        }
        else if ( !strncmp(v15, "vue_passwd=", 0xBu) )
        {
          v13 = v15 + 11;
        }
        ++v8;
      }
      while ( v8 != (const char **)v12 );
      if ( !v14 )
        goto LABEL_7;
      if ( !v13 )
        goto LABEL_7;
      v6 = httpd_user_check_cookie(a1, v14, v13);
      if ( v6 <= 0 )
        goto LABEL_7;
    }
    *(_DWORD *)(a1 + 205588) = v6;
    *(_BYTE *)(a1 + 43) = 1;
  }
}
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043280C) --------------------------------------------------------
int __fastcall httpd_send_login_html(int a1)
{
  unsigned int v2; // $v0
  unsigned __int8 *v3; // $s0
  char *v4; // $v0
  int v5; // $s1
  const char *v6; // $a0
  int v7; // $a2
  const char *v8; // $s0
  const char *v9; // $v0
  unsigned int v10; // $v0
  int result; // $v0
  const char *v12; // $s0
  int v13; // $v0
  int v14; // $s0
  const char *v15; // $a3
  int i; // $s1
  int v17; // $v0
  int v18; // $v0
  char v19[1028]; // [sp+20h] [-404h] BYREF

  v2 = *(_DWORD *)(a1 + 36) & 0xFFFFFFFE;
  *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
  *(_DWORD *)(a1 + 36) = v2;
  memset(v19, 0, 0x400u);
  v3 = (unsigned __int8 *)(*(_DWORD *)(a1 + 44) + 1);
  v5 = get_name_hash(v3);
  v4 = httpd_find_ext_name(*(const char **)(a1 + 44));
  v6 = (const char *)v3;
  v8 = v4;
  if ( httpd_find_ext_file(v6, v5)
    || v8
    && (!strcmp(v8, "data")
     || !strcmp(v8, "asp")
     || !strcmp(v8, (const char *)&off_4CFE60)
     || !strcmp(v8, "txt")
     || !strcmp(v8, (const char *)&off_641118)) )
  {
    v9 = (const char *)_GET_LANG_TEXT(2, *(unsigned __int8 *)(a1 + 210102), v7);
    v10 = snprintf(v19, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 2, v9);
    if ( v10 >= 0x400 )
      v10 = 1023;
    result = httpd_cgi_ret(a1, v19, v10, 4);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 209984) )
    {
      v12 = *(const char **)(a1 + 205504);
      v13 = nvram_get_int("https_lanport");
      v14 = snprintf(v19, 1024, "https://%s:%d%s?", v12, v13, "/login.html");
    }
    else
    {
      v14 = snprintf(v19, 1024, "%s%s?", *(const char **)(a1 + 205504), "/login.html");
    }
    v15 = *(const char **)(a1 + 52);
    for ( i = a1 + 56; v15; v14 += v17 )
    {
      i += 4;
      v17 = snprintf(&v19[v14], 1024 - v14, "%s&", v15);
      v15 = *(const char **)(i - 4);
    }
    v18 = jiffies_get();
    snprintf(&v19[v14], 1024 - v14, "_t=%lu", v18);
    result = httpd_send_redirect(a1, v19);
  }
  return result;
}
// 4328DC: variable 'v7' is possibly undefined
// 4CFE60: using guessed type void *off_4CFE60;
// 641118: using guessed type void *off_641118;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00432B2C) --------------------------------------------------------
int __fastcall httpd_user_auth_cookie(int a1)
{
  char *v2; // $a1
  const char **v3; // $fp
  int v4; // $v0
  const char *v5; // $s6
  const char **v6; // $s1
  const char *v7; // $s4
  const char *v8; // $s7
  const char *i; // $v0
  int v10; // $v0
  int result; // $v0
  char v12[1024]; // [sp+18h] [-420h] BYREF
  _DWORD v13[8]; // [sp+418h] [-20h] BYREF

  if ( (*(_DWORD *)(a1 + 32) & 0x800) == 0 )
    goto LABEL_22;
  memset(v12, 0, sizeof(v12));
  v2 = strstr(*(const char **)(a1 + 205524), "vue_userid=");
  if ( !v2 )
    goto LABEL_22;
  strlcpy(v12, v2, 1024);
  v3 = (const char **)v13;
  v4 = split_string(v12, 44, v13, 6);
  v5 = 0;
  if ( v4 <= 0 )
    goto LABEL_22;
  v6 = (const char **)&v13[v4];
  v7 = 0;
  do
  {
    v8 = *v3;
    if ( **v3 )
    {
      i = *v3;
      if ( **v3 == 59 )
      {
LABEL_21:
        *i = 0;
        v8 = *v3;
      }
      else
      {
        for ( i = *v3 + 1; ; ++i )
        {
          v8 = *v3;
          if ( !*i )
            break;
          if ( *i == 59 )
            goto LABEL_21;
        }
      }
    }
    if ( !strncmp(v8, "vue_userid=", 0xBu) )
    {
      v7 = v8 + 11;
    }
    else if ( !strncmp(v8, "vue_passwd=", 0xBu) )
    {
      v5 = v8 + 11;
    }
    ++v3;
  }
  while ( v3 != v6 );
  if ( v7 && v5 && (v10 = httpd_user_check_cookie(a1, v7, v5), v10 > 0) )
  {
    *(_DWORD *)(a1 + 205588) = v10;
    result = 0;
    *(_BYTE *)(a1 + 43) = 1;
  }
  else
  {
LABEL_22:
    *(_BYTE *)(a1 + 43) = 3;
    httpd_send_login_html(a1);
    result = -1;
  }
  return result;
}
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00432D4C) --------------------------------------------------------
int __fastcall httpd_cgi_user_check(const char *a1, const char *a2, _DWORD *a3)
{
  int v6; // $s0

  memset(httpd_set_cookie, 0, sizeof(httpd_set_cookie));
  if ( gl_httpd_high_admin_en && !strcmp(a1, gl_httpd_high_admin) && !strcmp(a2, gl_httpd_high_adminpwd) )
  {
    sprintf(httpd_set_cookie, "vue_userid=%s,vue_passwd=%s", a1, gl_httpd_high_adminpwd_md5);
    *a3 = 5;
    return 1;
  }
  if ( gl_httpd_admin_en )
  {
    v6 = strcmp(a1, gl_httpd_admin);
    if ( !v6 )
    {
      if ( !strcmp(a2, gl_httpd_adminpwd) )
      {
        sprintf(httpd_set_cookie, "vue_userid=%s,vue_passwd=%s", a1, gl_httpd_adminpwd_md5);
        *a3 = 4;
        v6 = 1;
      }
      return v6;
    }
  }
  if ( gl_httpd_user_en )
  {
    v6 = strcmp(a1, gl_httpd_user);
    if ( !v6 )
    {
      if ( !strcmp(a2, gl_httpd_password) )
      {
        sprintf(httpd_set_cookie, "vue_userid=%s,vue_passwd=%s", a1, gl_httpd_password_md5);
        *a3 = 3;
        v6 = 1;
      }
      return v6;
    }
  }
  v6 = gl_httpd_guest_user_en;
  if ( !gl_httpd_guest_user_en )
    return v6;
  v6 = strcmp(a1, gl_httpd_guest_user);
  if ( !v6 )
  {
    if ( !strcmp(a2, gl_httpd_guest_pwd) )
    {
      sprintf(httpd_set_cookie, "vue_userid=%s,vue_passwd=%s", a1, gl_httpd_guest_pwd_md5);
      *a3 = 2;
      v6 = 1;
    }
    return v6;
  }
  return 0;
}
// 666170: using guessed type int gl_httpd_admin_en;
// 67D090: using guessed type int gl_httpd_guest_user_en;
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 67D098: using guessed type int gl_httpd_user_en;

//----- (00432FC0) --------------------------------------------------------
char *__fastcall httpd_cgi_user_check_admin(int a1, int a2, int a3)
{
  unsigned int v4; // $v0
  unsigned int v5[22]; // [sp+50h] [-6Ch] BYREF
  int v6; // [sp+A8h] [-14h]
  int v7; // [sp+ACh] [-10h]
  int v8; // [sp+B0h] [-Ch]
  int v9; // [sp+B4h] [-8h]

  if ( !jhl_realm_init )
  {
    v4 = get_random_seed(a1, a2, a3);
    srand(v4);
    jhl_realm_init = 1;
    jhl_realm_str = rand();
    *(_DWORD *)&byte_6A38E4 = rand();
    *(_DWORD *)&byte_6A38E8 = rand();
    v5[0] = rand();
    dword_6A38EC = v5[0];
  }
  FBR_MD5Init(v5);
  FBR_MD5Update(v5, (int)&jhl_realm_str, 0x10u);
  FBR_MD5Final(v5);
  jhl_realm_str = v6;
  *(_DWORD *)&byte_6A38E4 = v7;
  *(_DWORD *)&byte_6A38E8 = v8;
  dword_6A38EC = v9;
  sprintf(
    cookie_realm,
    "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
    (unsigned __int8)v6,
    BYTE1(v6),
    BYTE2(v6),
    HIBYTE(v6),
    (unsigned __int8)v7,
    BYTE1(v7),
    BYTE2(v7),
    HIBYTE(v7),
    (unsigned __int8)v8,
    BYTE1(v8),
    BYTE2(v8),
    HIBYTE(v8),
    (unsigned __int8)v9,
    BYTE1(v9),
    BYTE2(v9),
    HIBYTE(v9));
  return cookie_realm;
}
// 67D2E0: using guessed type int jhl_realm_init;
// 6A38E0: using guessed type int jhl_realm_str;
// 6A38E4: using guessed type char byte_6A38E4;
// 6A38E8: using guessed type char byte_6A38E8;
// 6A38EC: using guessed type int dword_6A38EC;
// 6A845C: using guessed type int __fastcall get_random_seed(_DWORD, _DWORD, _DWORD);

//----- (004331C0) --------------------------------------------------------
int __fastcall sub_4331C0(int a1, char *a2)
{
  unsigned int v4; // $v0
  unsigned int v6[22]; // [sp+50h] [-90h] BYREF
  unsigned __int8 v7; // [sp+A8h] [-38h]
  unsigned __int8 v8; // [sp+A9h] [-37h]
  unsigned __int8 v9; // [sp+AAh] [-36h]
  unsigned __int8 v10; // [sp+ABh] [-35h]
  unsigned __int8 v11; // [sp+ACh] [-34h]
  unsigned __int8 v12; // [sp+ADh] [-33h]
  unsigned __int8 v13; // [sp+AEh] [-32h]
  unsigned __int8 v14; // [sp+AFh] [-31h]
  unsigned __int8 v15; // [sp+B0h] [-30h]
  unsigned __int8 v16; // [sp+B1h] [-2Fh]
  unsigned __int8 v17; // [sp+B2h] [-2Eh]
  unsigned __int8 v18; // [sp+B3h] [-2Dh]
  unsigned __int8 v19; // [sp+B4h] [-2Ch]
  unsigned __int8 v20; // [sp+B5h] [-2Bh]
  unsigned __int8 v21; // [sp+B6h] [-2Ah]
  unsigned __int8 v22; // [sp+B7h] [-29h]
  int v23[8]; // [sp+B8h] [-28h] BYREF
  int v24; // [sp+D8h] [-8h] BYREF

  v23[0] = 0;
  v23[1] = 0;
  v23[2] = 0;
  v23[3] = 0;
  v23[4] = 0;
  v23[5] = 0;
  v23[6] = 0;
  v23[7] = 0;
  v24 = jiffies_get();
  IpToStr(v23, a1);
  FBR_MD5Init(v6);
  v4 = strlen((const char *)v23);
  FBR_MD5Update(v6, (int)v23, v4);
  FBR_MD5Update(v6, (int)&v24, 4u);
  FBR_MD5Final(v6);
  return sprintf(
           a2,
           "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
           v7,
           v10,
           v9,
           v8,
           v11,
           v14,
           v13,
           v12,
           v17,
           v16,
           v15,
           v18,
           v22,
           v20,
           v21,
           v19);
}
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00433350) --------------------------------------------------------
int __fastcall usb_httpd_passwd_md5(char *a1, const char *a2)
{
  const char *v4; // $v0
  const char *v5; // $s3
  int v6; // $s3
  char v8[256]; // [sp+50h] [-16Ch] BYREF
  unsigned int v9[22]; // [sp+150h] [-6Ch] BYREF
  unsigned __int8 v10; // [sp+1A8h] [-14h]
  unsigned __int8 v11; // [sp+1A9h] [-13h]
  unsigned __int8 v12; // [sp+1AAh] [-12h]
  unsigned __int8 v13; // [sp+1ABh] [-11h]
  unsigned __int8 v14; // [sp+1ACh] [-10h]
  unsigned __int8 v15; // [sp+1ADh] [-Fh]
  unsigned __int8 v16; // [sp+1AEh] [-Eh]
  unsigned __int8 v17; // [sp+1AFh] [-Dh]
  unsigned __int8 v18; // [sp+1B0h] [-Ch]
  unsigned __int8 v19; // [sp+1B1h] [-Bh]
  unsigned __int8 v20; // [sp+1B2h] [-Ah]
  unsigned __int8 v21; // [sp+1B3h] [-9h]
  unsigned __int8 v22; // [sp+1B4h] [-8h]
  unsigned __int8 v23; // [sp+1B5h] [-7h]
  unsigned __int8 v24; // [sp+1B6h] [-6h]
  unsigned __int8 v25; // [sp+1B7h] [-5h]

  memset(v8, 0, sizeof(v8));
  v5 = (const char *)custom_device_name();
  v4 = (const char *)get_sn();
  v6 = snprintf(v8, 256, "%s%s%susb", v5, a2, v4);
  FBR_MD5Init(v9);
  FBR_MD5Update(v9, (int)v8, v6);
  FBR_MD5Final(v9);
  return sprintf(
           a1,
           "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
           v10,
           v13,
           v12,
           v11,
           v14,
           v17,
           v16,
           v15,
           v20,
           v19,
           v18,
           v21,
           v25,
           v23,
           v24,
           v22);
}
// 6A81D8: using guessed type int get_sn(void);
// 6A86E4: using guessed type int custom_device_name(void);

//----- (004334E4) --------------------------------------------------------
void __fastcall httpd_set_cookie_language(int a1)
{
  const char *v2; // $a0
  char *v3; // $v0
  char *v4; // $v0
  char *v5; // $v0
  char *v6; // $v0
  int v7[9]; // [sp+8h] [-30h] BYREF

  *(_BYTE *)(a1 + 210102) = 0;
  *(_BYTE *)(a1 + 210103) = 1;
  if ( (*(_DWORD *)(a1 + 32) & 0x800) != 0 )
  {
    v2 = *(const char **)(a1 + 205524);
    v7[0] = 0;
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = 0;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    v3 = strstr(v2, "language=");
    if ( v3 )
    {
      strlcpy(v7, v3 + 9, 32);
      v4 = strchr((const char *)v7, 44);
      if ( v4 )
        *v4 = 0;
      v5 = strchr((const char *)v7, 59);
      if ( v5 )
        *v5 = 0;
      v6 = strchr((const char *)v7, 32);
      if ( v6 )
        *v6 = 0;
    }
    *(_BYTE *)(a1 + 210102) = get_lang_type(v7);
    *(_BYTE *)(a1 + 210103) = 0;
  }
}
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8608: using guessed type int __fastcall get_lang_type(_DWORD);

//----- (00433630) --------------------------------------------------------
int httpd_unix_init()
{
  int v0; // $v0
  int v1; // $s1
  const char *v2; // $v1
  char *v3; // $v0
  int v4; // $a0
  int v5; // $a1
  int v6; // $a0
  int result; // $v0
  struct sockaddr v8[7]; // [sp+20h] [-8Ch] BYREF
  int v9[2]; // [sp+90h] [-1Ch] BYREF
  int v10; // [sp+98h] [-14h] BYREF
  int v11; // [sp+9Ch] [-10h] BYREF
  socklen_t optlen; // [sp+A0h] [-Ch] BYREF
  int v13[2]; // [sp+A4h] [-8h] BYREF

  v13[0] = 1;
  optlen = 0;
  v11 = 0x100000;
  v10 = 0x100000;
  v0 = socket(1, 1, 0);
  if ( v0 < 0 )
  {
    printf("%s[%d]: httpd_unix_init socket fialed\n", "httpd_unix_init", 21);
    result = -1;
  }
  else
  {
    v8[0].sa_family = 1;
    v1 = v0;
    setsockopt(v0, 0xFFFF, 4097, &v10, 4u);
    setsockopt(v1, 0xFFFF, 4098, &v11, 4u);
    optlen = 4;
    v13[0] = 0;
    getsockopt(v1, 0xFFFF, 4097, v13, &optlen);
    optlen = 4;
    v13[0] = 0;
    getsockopt(v1, 0xFFFF, 4098, v13, &optlen);
    v9[0] = 3;
    v9[1] = 0;
    setsockopt(v1, 0xFFFF, 4101, v9, 8u);
    setsockopt(v1, 0xFFFF, 4102, v9, 8u);
    create_dir2("/tmp/ac_server/jhttpd_local.sock");
    unlink("/tmp/ac_server/jhttpd_local.sock");
    v2 = "/tmp/ac_server/jhttpd_local.sock";
    v3 = v8[0].sa_data;
    do
    {
      v4 = *((_DWORD *)v2 + 1);
      *(_DWORD *)v3 = *(_DWORD *)v2;
      *((_DWORD *)v3 + 1) = v4;
      v5 = *((_DWORD *)v2 + 2);
      *((_DWORD *)v3 + 1) = v4;
      *((_DWORD *)v3 + 2) = v5;
      v6 = *((_DWORD *)v2 + 3);
      *((_DWORD *)v3 + 2) = v5;
      *((_DWORD *)v3 + 3) = v6;
      v2 += 16;
      *((_DWORD *)v3 + 3) = v6;
      v3 += 16;
    }
    while ( v2 != "" );
    *v3 = *v2;
    if ( bind(v1, v8, 0x6Eu) < 0 )
    {
      printf("%s[%d]: httpd_unix_init bind fialed\n", "httpd_unix_init", 46);
      result = -1;
    }
    else
    {
      setnonblocking(v1);
      result = 0;
      gl_httpd_unix_fd = v1;
    }
  }
  return result;
}
// 66B5F0: using guessed type int gl_httpd_unix_fd;
// 6A8584: using guessed type int __fastcall create_dir2(_DWORD);

//----- (004338AC) --------------------------------------------------------
int __fastcall httpd_unix_send_to_ai(void *buf, size_t a2)
{
  struct sockaddr addr[7]; // [sp+20h] [-70h] BYREF

  addr[0].sa_family = 1;
  strcpy(addr[0].sa_data, "/tmp/mqtt_ai/ac_local.sock");
  return -(a2 != sendto(gl_httpd_unix_fd, buf, a2, 0, addr, 0x6Eu));
}
// 66B5F0: using guessed type int gl_httpd_unix_fd;

//----- (00433984) --------------------------------------------------------
int __fastcall httpd_unix_send_to_ac_server(void *buf, size_t a2)
{
  struct sockaddr addr[7]; // [sp+20h] [-70h] BYREF

  addr[0].sa_family = 1;
  strcpy(addr[0].sa_data, "/tmp/ac_server/ac_local.sock");
  return -(a2 != sendto(gl_httpd_unix_fd, buf, a2, 0, addr, 0x6Eu));
}
// 66B5F0: using guessed type int gl_httpd_unix_fd;

//----- (00433A60) --------------------------------------------------------
void __fastcall sub_433A60(uint32_t a1, uint32_t a2, void *a3, int a4)
{
  uint32_t v4; // $s1
  uint32_t *v8; // $v0
  uint32_t *v10; // $s0

  v4 = a4 + 12;
  _mem_malloc(a4 + 12, "httpd_unix_cgi_send_to_ac_server", 89);
  if ( v8 )
  {
    v10 = v8;
    *v8 = htonl(a1);
    v10[2] = a2;
    v10[1] = htonl(v4);
    if ( a3 )
    {
      if ( a4 )
        memcpy(v10 + 3, a3, a4);
    }
    httpd_unix_send_to_ac_server(v10, v4);
    _mem_free(v10);
  }
}
// 433AC4: variable 'v8' is possibly undefined

//----- (00433B98) --------------------------------------------------------
int httpd_unix_ac_cmd_do()
{
  return 0;
}

//----- (00433BA0) --------------------------------------------------------
int __fastcall httpd_unix_cmd_do(int a1, int a2, const char *a3, int a4)
{
  int *v6; // $v0
  int *v8; // $s0
  int v9; // $s2
  int v10; // $s1
  int v12; // $s5
  char *v13; // $v0
  char *v14; // $s7
  int v15; // $s0
  int v16; // $v0
  int v17; // $s3
  int v18; // $s5
  int v19; // $a2
  const char *v20; // $v0
  unsigned int v21; // $a2
  char v22[260]; // [sp+20h] [-104h] BYREF

  v6 = _httpd_conn_find(a2);
  if ( v6 )
  {
    v8 = v6 + 49152;
    v9 = v6[52524];
    v10 = (int)v6;
    if ( v9 == a1 )
    {
      v12 = a4 + 1024;
      v6[52524] = 0;
      _mem_malloc(a4 + 1024, "httpd_unix_cmd_do", 201);
      v14 = v13;
      if ( v13 )
      {
        switch ( v9 )
        {
          case 10021:
          case 10022:
          case 10024:
          case 10025:
          case 10028:
            v15 = snprintf(v13, a4 + 1024, "{\"code\":0,\"error\":\"\",\"data\":");
            if ( v15 >= v12 )
              v15 = a4 + 1023;
            v16 = snprintf(&v14[v15], v12 - v15, "%s", a3);
            if ( v16 >= v12 - v15 )
              v16 = v12 - v15 - 1;
            v17 = v15 + v16;
            v18 = v12 - (v15 + v16);
            v19 = snprintf(&v14[v15 + v16], v18, "}");
            if ( v19 >= v18 )
              v19 = v18 - 1;
            httpd_cgi_ret(v10, v14, v19 + v17, 4);
            break;
          case 10023:
            ai_check_upgrade_data(v10);
            break;
          default:
            break;
        }
        _mem_free(v14);
      }
      else
      {
        v20 = (const char *)_GET_LANG_TEXT(4, *((unsigned __int8 *)v8 + 13494), a4 + 1024);
        v21 = snprintf(v22, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v20);
        if ( v21 >= 0x100 )
          v21 = 255;
        httpd_cgi_ret(v10, v22, v21, 4);
      }
    }
  }
  return 0;
}
// 433C68: variable 'v13' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00433E04) --------------------------------------------------------
int httpd_unix_recv()
{
  char *v0; // $v0
  char *v1; // $s0
  int v2; // $s1
  ssize_t v3; // $v0
  ssize_t v4; // $s7
  uint32_t v5; // $v0
  unsigned int v6; // $s6
  struct sockaddr addr; // [sp+20h] [-80h] BYREF
  socklen_t addr_len[2]; // [sp+90h] [-10h] BYREF
  char *format; // [sp+98h] [-8h]
  char *v11; // [sp+9Ch] [-4h]

  addr_len[0] = 110;
  _mem_malloc(0x200000, "httpd_unix_recv", 119);
  v1 = v0;
  if ( v0 )
  {
    format = "%s:%d datalen is %d != %d\n";
    v2 = 10;
    v11 = "%s:%d cmdid:%d do error\n";
    while ( 1 )
    {
      while ( 1 )
      {
        addr_len[0] = 110;
        v3 = recvfrom(gl_httpd_unix_fd, v1, 0x1FFFFFu, 0, &addr, addr_len);
        v4 = v3;
        if ( v3 <= 0 )
        {
          if ( debug_level > 0 )
            printf("%s:%d recvfrom ret = %d\n", "httpd_unix_recv", 132, v3);
          _mem_free(v1);
          return -1;
        }
        v1[v3] = 0;
        v6 = ntohl(*(_DWORD *)v1);
        v5 = ntohl(*((_DWORD *)v1 + 1));
        if ( v6 >= 0x7539 )
        {
          if ( debug_level > 0 )
            printf("%s:%d cmdid > AC_UNIX_CMD_max is %d\n", "httpd_unix_recv", 144, v6);
          goto LABEL_5;
        }
        if ( !v5 || v4 != v5 )
          break;
        if ( v6 < 0x2725 )
        {
          if ( httpd_unix_ac_cmd_do() == -1 && debug_level > 0 )
          {
            printf(v11, "httpd_unix_recv", 169, v6);
            --v2;
            goto LABEL_6;
          }
        }
        else if ( httpd_unix_cmd_do(v6, *((_DWORD *)v1 + 2), v1 + 12, v4 - 12) == -1 && debug_level > 0 )
        {
          printf(v11, "httpd_unix_recv", 160, v6);
          --v2;
          goto LABEL_6;
        }
LABEL_5:
        --v2;
LABEL_6:
        if ( !v2 )
          goto LABEL_13;
      }
      if ( debug_level <= 0 )
        goto LABEL_5;
      --v2;
      printf(format, "httpd_unix_recv", 151, v5, v4);
      if ( !v2 )
      {
LABEL_13:
        _mem_free(v1);
        return 0;
      }
    }
  }
  if ( debug_level > 0 )
    printf("%s:%d buf malloc failed\n", "httpd_unix_recv", 122);
  return -1;
}
// 433E68: variable 'v0' is possibly undefined
// 66B5F0: using guessed type int gl_httpd_unix_fd;
// 67D0BC: using guessed type int debug_level;

//----- (00434140) --------------------------------------------------------
int _retset_timer_fun()
{
  return kill(1, 1);
}

//----- (0043415C) --------------------------------------------------------
int _reboot_timer_fun()
{
  system("echo \"upgrade re_boot, System will reboot!\" >/dev/console");
  return re_boot();
}
// 6A86A0: using guessed type int re_boot(void);

//----- (0043419C) --------------------------------------------------------
int _poweroff_timer_fun()
{
  return power_off();
}
// 6A8424: using guessed type int power_off(void);

//----- (004341B8) --------------------------------------------------------
int _net_restart_fun()
{
  return exec_service("net-restart");
}

//----- (004341D8) --------------------------------------------------------
int _lan_restart_fun()
{
  return exec_service("lan-restart");
}

//----- (004341F8) --------------------------------------------------------
int _restart_jhttpd_fun()
{
  return exec_service(gl_exec_service_name);
}
// 4341F8: using guessed type int _restart_jhttpd_fun();

//----- (00434218) --------------------------------------------------------
int sub_434218()
{
  init_timer(&gl_reset_timer);
  init_timer(&net_restart_timer);
  init_timer(&lan_restart_timer);
  return 0;
}
// 6A3900: using guessed type int lan_restart_timer;
// 6A3A14: using guessed type int net_restart_timer;
// 6A3A28: using guessed type int gl_reset_timer;
// 6A8368: using guessed type int __fastcall init_timer(_DWORD);

//----- (00434288) --------------------------------------------------------
int __fastcall sub_434288(int a1)
{
  int result; // $v0

  result = 1;
  if ( !gl_reset_timer )
  {
    dword_6A3A38 = 0;
    dword_6A3A34 = (int)_retset_timer_fun;
    dword_6A3A30 = a1 + jiffies_get();
    add_timer(&gl_reset_timer);
    result = 0;
  }
  return result;
}
// 6A3A28: using guessed type int gl_reset_timer;
// 6A3A30: using guessed type int dword_6A3A30;
// 6A3A34: using guessed type int dword_6A3A34;
// 6A3A38: using guessed type int dword_6A3A38;
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00434314) --------------------------------------------------------
int __fastcall jhl_gl_reboot_timer(int a1)
{
  int result; // $v0

  result = 1;
  if ( !gl_reset_timer )
  {
    dword_6A3A38 = 0;
    dword_6A3A34 = (int)_reboot_timer_fun;
    dword_6A3A30 = a1 + jiffies_get();
    killall("wys_billing", 17);
    killall("wys_billing_new", 17);
    killall("mqtt_ai", 17);
    killall("mqtt_ai_new", 17);
    add_timer(&gl_reset_timer);
    result = 0;
  }
  return result;
}
// 6A3A28: using guessed type int gl_reset_timer;
// 6A3A30: using guessed type int dword_6A3A30;
// 6A3A34: using guessed type int dword_6A3A34;
// 6A3A38: using guessed type int dword_6A3A38;
// 6A8178: using guessed type int __fastcall killall(_DWORD, _DWORD);
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00434414) --------------------------------------------------------
int __fastcall jhl_gl_poweroff_timer(int a1)
{
  int result; // $v0

  result = 1;
  if ( !gl_reset_timer )
  {
    dword_6A3A38 = 0;
    dword_6A3A34 = (int)_poweroff_timer_fun;
    dword_6A3A30 = a1 + jiffies_get();
    killall("wys_billing", 17);
    killall("wys_billing_new", 17);
    killall("mqtt_ai", 17);
    killall("mqtt_ai_new", 17);
    add_timer(&gl_reset_timer);
    result = 0;
  }
  return result;
}
// 6A3A28: using guessed type int gl_reset_timer;
// 6A3A30: using guessed type int dword_6A3A30;
// 6A3A34: using guessed type int dword_6A3A34;
// 6A3A38: using guessed type int dword_6A3A38;
// 6A8178: using guessed type int __fastcall killall(_DWORD, _DWORD);
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00434514) --------------------------------------------------------
int __fastcall sub_434514(int a1, int a2, int a3)
{
  int result; // $v0

  result = 1;
  if ( !gl_reset_timer )
  {
    dword_6A3A38 = a3;
    dword_6A3A34 = a2;
    dword_6A3A30 = a1 + jiffies_get();
    add_timer(&gl_reset_timer);
    result = 0;
  }
  return result;
}
// 6A3A28: using guessed type int gl_reset_timer;
// 6A3A30: using guessed type int dword_6A3A30;
// 6A3A34: using guessed type int dword_6A3A34;
// 6A3A38: using guessed type int dword_6A3A38;
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (0043459C) --------------------------------------------------------
int __fastcall jhl_gl_net_restart_timer(int a1)
{
  int result; // $v0

  result = 1;
  if ( !net_restart_timer )
  {
    dword_6A3A24 = 0;
    dword_6A3A20 = (int)_net_restart_fun;
    dword_6A3A1C = a1 + jiffies_get();
    add_timer(&net_restart_timer);
    result = 0;
  }
  return result;
}
// 6A3A14: using guessed type int net_restart_timer;
// 6A3A1C: using guessed type int dword_6A3A1C;
// 6A3A20: using guessed type int dword_6A3A20;
// 6A3A24: using guessed type int dword_6A3A24;
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00434628) --------------------------------------------------------
int __fastcall jhl_gl_lan_restart_timer(int a1)
{
  int result; // $v0

  result = 1;
  if ( !lan_restart_timer )
  {
    dword_6A3910 = 0;
    dword_6A390C = (int)_lan_restart_fun;
    dword_6A3908 = a1 + jiffies_get();
    add_timer(&lan_restart_timer);
    result = 0;
  }
  return result;
}
// 6A3900: using guessed type int lan_restart_timer;
// 6A3908: using guessed type int dword_6A3908;
// 6A390C: using guessed type int dword_6A390C;
// 6A3910: using guessed type int dword_6A3910;
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (004346B4) --------------------------------------------------------
int __fastcall jhl_gl_restart_jhttpd(char *src, int a2)
{
  int result; // $v0

  result = 1;
  if ( !gl_reset_timer )
  {
    strcpy(gl_exec_service_name, src);
    dword_6A3A38 = 0;
    dword_6A3A34 = (int)_restart_jhttpd_fun;
    dword_6A3A30 = a2 + jiffies_get();
    add_timer(&gl_reset_timer);
    result = 0;
  }
  return result;
}
// 4341F8: using guessed type int _restart_jhttpd_fun();
// 6A3A28: using guessed type int gl_reset_timer;
// 6A3A30: using guessed type int dword_6A3A30;
// 6A3A34: using guessed type int dword_6A3A34;
// 6A3A38: using guessed type int dword_6A3A38;
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (0043475C) --------------------------------------------------------
char *resmsg_get()
{
  return msg_buf;
}

//----- (00434774) --------------------------------------------------------
char *__fastcall resmsg_set(char *src)
{
  return strcpy(msg_buf, src);
}

//----- (00434794) --------------------------------------------------------
int __fastcall save_variables_json(int a1, int a2)
{
  char *v4; // $a1
  int v5; // $s5
  char **v6; // $s0
  char *v7; // $v0
  char *v8; // $s1
  unsigned int v9; // $fp
  int result; // $v0
  signed int v11; // $v0
  const char *v12; // $v0
  char v13[256]; // [sp+28h] [-120h] BYREF
  unsigned int v14; // [sp+128h] [-20h] BYREF
  unsigned int v15; // [sp+12Ch] [-1Ch] BYREF
  unsigned int v16; // [sp+130h] [-18h] BYREF
  unsigned int v17; // [sp+134h] [-14h] BYREF
  unsigned int v18; // [sp+138h] [-10h] BYREF
  unsigned int v19; // [sp+13Ch] [-Ch] BYREF
  char *v20; // [sp+140h] [-8h] BYREF

  if ( a2 )
    wan_webset_json(a1);
  v4 = "router_name";
  v5 = 0;
  v6 = &off_665620;
  do
  {
    v7 = httpd_get_parm(a1, v4);
    v8 = v7;
    if ( !v7 || !strcmp(v7, "undefined") )
      goto LABEL_26;
    v9 = (unsigned int)v6[1];
    if ( v9 == 3 )
    {
      v11 = strtol(v8, &v20, 10);
      if ( v8 == v20 || *v20 || v11 < (int)v6[2] )
      {
LABEL_16:
        sprintf(v13, "The field '%s' is invalid. Please report this problem.", *v6);
        resmsg_set(v13);
        return 0;
      }
      goto LABEL_19;
    }
    if ( v9 < 4 )
    {
      if ( v9 != 1 )
        goto LABEL_20;
      v11 = strlen(v8);
      if ( v11 < (int)v6[2] )
        goto LABEL_16;
LABEL_19:
      if ( (int)v6[3] < v11 )
        goto LABEL_16;
LABEL_20:
      if ( !a2 )
        goto LABEL_26;
LABEL_21:
      v12 = (const char *)nvram_get(*v6);
      if ( !v12 || strcmp(v12, v8) )
      {
        if ( v6[1] != (char *)6 )
          v5 = 1;
        nvram_set(*v6, v8);
      }
      goto LABEL_26;
    }
    if ( v9 == 4 )
    {
      if ( sscanf(v8, "%3u.%3u.%3u.%3u", &v14, &v15, &v16, &v17) != 4
        || v14 >= 0x100
        || v15 >= 0x100
        || v16 >= 0x100
        || v17 >= 0x100 )
      {
        goto LABEL_16;
      }
      if ( a2 )
        goto LABEL_21;
    }
    else
    {
      if ( v9 != 5 )
        goto LABEL_20;
      if ( sscanf(v8, "%2x:%2x:%2x:%2x:%2x:%2x", &v14, &v15, &v16, &v17, &v18, &v19) != 6
        || v14 >= 0x100
        || v15 >= 0x100
        || v16 >= 0x100
        || v17 >= 0x100
        || v18 >= 0x100
        || v19 >= 0x100 )
      {
        goto LABEL_16;
      }
      if ( a2 )
        goto LABEL_21;
    }
LABEL_26:
    v6 += 4;
    v4 = *v6;
  }
  while ( *v6 );
  if ( a2 )
    result = v5;
  else
    result = 1;
  return result;
}
// 665620: using guessed type char *off_665620;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00434B70) --------------------------------------------------------
int __fastcall save_variables(int a1, int a2)
{
  return save_variables_json(a1, a2);
}

//----- (00434B8C) --------------------------------------------------------
int __fastcall sub_434B8C(int a1, int a2)
{
  char *v4; // $a1
  int v5; // $s4
  char **v6; // $s0
  char *v7; // $v0
  char *v8; // $s1
  unsigned int v9; // $fp
  int result; // $v0
  signed int v11; // $v0
  const char *v12; // $v0
  char v13[256]; // [sp+28h] [-120h] BYREF
  unsigned int v14; // [sp+128h] [-20h] BYREF
  unsigned int v15; // [sp+12Ch] [-1Ch] BYREF
  unsigned int v16; // [sp+130h] [-18h] BYREF
  unsigned int v17; // [sp+134h] [-14h] BYREF
  unsigned int v18; // [sp+138h] [-10h] BYREF
  unsigned int v19; // [sp+13Ch] [-Ch] BYREF
  char *v20; // [sp+140h] [-8h] BYREF

  v4 = "router_name";
  v5 = 0;
  v6 = &off_665620;
  do
  {
    v7 = httpd_get_parm(a1, v4);
    v8 = v7;
    if ( !v7 || !strcmp(v7, "undefined") )
      goto LABEL_25;
    v9 = (unsigned int)v6[1];
    if ( v9 == 3 )
    {
      v11 = strtol(v8, &v20, 10);
      if ( v8 == v20 || *v20 || v11 < (int)v6[2] )
      {
LABEL_14:
        sprintf(v13, "The field \"%s\" is invalid. Please report this problem.", *v6);
        resmsg_set(v13);
        return 0;
      }
      goto LABEL_18;
    }
    if ( v9 < 4 )
    {
      if ( v9 != 1 )
        goto LABEL_19;
      v11 = strlen(v8);
      if ( v11 < (int)v6[2] )
        goto LABEL_14;
LABEL_18:
      if ( (int)v6[3] < v11 )
        goto LABEL_14;
LABEL_19:
      if ( !a2 )
        goto LABEL_25;
LABEL_20:
      v12 = (const char *)nvram_get(*v6);
      if ( !v12 || strcmp(v12, v8) )
      {
        if ( v6[1] != (char *)6 )
          v5 = 1;
        nvram_set(*v6, v8);
      }
      goto LABEL_25;
    }
    if ( v9 == 4 )
    {
      if ( sscanf(v8, "%3u.%3u.%3u.%3u", &v14, &v15, &v16, &v17) != 4
        || v14 >= 0x100
        || v15 >= 0x100
        || v16 >= 0x100
        || v17 >= 0x100 )
      {
        goto LABEL_14;
      }
      if ( a2 )
        goto LABEL_20;
    }
    else
    {
      if ( v9 != 5 )
        goto LABEL_19;
      if ( sscanf(v8, "%2x:%2x:%2x:%2x:%2x:%2x", &v14, &v15, &v16, &v17, &v18, &v19) != 6
        || v14 >= 0x100
        || v15 >= 0x100
        || v16 >= 0x100
        || v17 >= 0x100
        || v18 >= 0x100
        || v19 >= 0x100 )
      {
        goto LABEL_14;
      }
      if ( a2 )
        goto LABEL_20;
    }
LABEL_25:
    v6 += 4;
    v4 = *v6;
  }
  while ( *v6 );
  if ( a2 )
    result = v5;
  else
    result = 1;
  return result;
}
// 665620: using guessed type char *off_665620;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00434F48) --------------------------------------------------------
int __fastcall sub_434F48(int a1, int a2)
{
  char *v4; // $a1
  int v5; // $s4
  char **v6; // $s0
  char *v7; // $v0
  char *v8; // $s1
  unsigned int v9; // $fp
  int result; // $v0
  signed int v11; // $v0
  const char *v12; // $v0
  char v13[256]; // [sp+28h] [-120h] BYREF
  unsigned int v14; // [sp+128h] [-20h] BYREF
  unsigned int v15; // [sp+12Ch] [-1Ch] BYREF
  unsigned int v16; // [sp+130h] [-18h] BYREF
  unsigned int v17; // [sp+134h] [-14h] BYREF
  unsigned int v18; // [sp+138h] [-10h] BYREF
  unsigned int v19; // [sp+13Ch] [-Ch] BYREF
  char *v20; // [sp+140h] [-8h] BYREF

  v4 = "tm_tz";
  v5 = 0;
  v6 = &off_665ED0;
  do
  {
    v7 = httpd_get_parm(a1, v4);
    v8 = v7;
    if ( !v7 || !strcmp(v7, "undefined") )
      goto LABEL_25;
    v9 = (unsigned int)v6[1];
    if ( v9 == 3 )
    {
      v11 = strtol(v8, &v20, 10);
      if ( v8 == v20 || *v20 || v11 < (int)v6[2] )
      {
LABEL_14:
        sprintf(v13, "The field \"%s\" is invalid. Please report this problem.", *v6);
        resmsg_set(v13);
        return 0;
      }
      goto LABEL_18;
    }
    if ( v9 < 4 )
    {
      if ( v9 != 1 )
        goto LABEL_19;
      v11 = strlen(v8);
      if ( v11 < (int)v6[2] )
        goto LABEL_14;
LABEL_18:
      if ( (int)v6[3] < v11 )
        goto LABEL_14;
LABEL_19:
      if ( !a2 )
        goto LABEL_25;
LABEL_20:
      v12 = (const char *)nvram_get(*v6);
      if ( !v12 || strcmp(v12, v8) )
      {
        if ( v6[1] != (char *)6 )
          v5 = 1;
        nvram_set(*v6, v8);
      }
      goto LABEL_25;
    }
    if ( v9 == 4 )
    {
      if ( sscanf(v8, "%3u.%3u.%3u.%3u", &v14, &v15, &v16, &v17) != 4
        || v14 >= 0x100
        || v15 >= 0x100
        || v16 >= 0x100
        || v17 >= 0x100 )
      {
        goto LABEL_14;
      }
      if ( a2 )
        goto LABEL_20;
    }
    else
    {
      if ( v9 != 5 )
        goto LABEL_19;
      if ( sscanf(v8, "%2x:%2x:%2x:%2x:%2x:%2x", &v14, &v15, &v16, &v17, &v18, &v19) != 6
        || v14 >= 0x100
        || v15 >= 0x100
        || v16 >= 0x100
        || v17 >= 0x100
        || v18 >= 0x100
        || v19 >= 0x100 )
      {
        goto LABEL_14;
      }
      if ( a2 )
        goto LABEL_20;
    }
LABEL_25:
    v6 += 4;
    v4 = *v6;
  }
  while ( *v6 );
  if ( a2 )
    result = v5;
  else
    result = 1;
  return result;
}
// 665ED0: using guessed type char *off_665ED0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00435310) --------------------------------------------------------
ssize_t __fastcall sub_435310(void *a1, size_t a2, char **a3)
{
  __pid_t v6; // $v0
  __pid_t v7; // $s0
  ssize_t v9; // $s1
  int fd; // [sp+18h] [-14h] BYREF
  int v11; // [sp+1Ch] [-10h]
  int v12[3]; // [sp+20h] [-Ch] BYREF

  if ( pipe(&fd) < 0 )
    perror("myexec: open pipe fd1 error");
  v6 = fork();
  v7 = v6;
  if ( v6 < 0 )
  {
    perror("myexec: fork error");
    return 0;
  }
  if ( v6 )
  {
    close(v11);
    if ( a1 )
    {
      v9 = read(fd, a1, a2);
      if ( v9 < 0 )
        perror("myexec: read from fd[0] error");
    }
    else
    {
      v9 = 0;
    }
    close(fd);
    waitpid(v7, v12, 0);
    return v9;
  }
  close(fd);
  if ( dup2(v11, 1) != 1 )
    perror("myexec: dup fd[1] to stdout error in child process");
  if ( execvp(*a3, a3) < 0 )
  {
    close(v11);
    perror("myexec: execvp error in child process");
    exit(1);
  }
  close(v11);
  return 0;
}

//----- (00435548) --------------------------------------------------------
int __fastcall sub_435548(int *a1, char **a2)
{
  __pid_t v4; // $v0
  __pid_t v5; // $s0
  int v7; // [sp+18h] [-10h] BYREF
  int fd; // [sp+1Ch] [-Ch]
  int v9; // [sp+20h] [-8h] BYREF

  if ( pipe(&v7) < 0 )
    perror("myexec: open pipe fd1 error");
  v4 = fork();
  v5 = v4;
  if ( v4 < 0 )
  {
    perror("myexec: fork error");
  }
  else if ( !v4 )
  {
    close(v7);
    if ( dup2(fd, 1) != 1 )
      perror("myexec: dup fd[1] to stdout error in child process");
    if ( execvp(*a2, a2) < 0 )
    {
      perror("myexec: execvp error in child process");
      exit(1);
    }
  }
  close(fd);
  waitpid(v5, &v9, 0);
  *a1 = v7;
  return 0;
}

//----- (004356D8) --------------------------------------------------------
int __fastcall sub_4356D8(int *a1, char **a2)
{
  __pid_t v4; // $v0
  int v5; // $s0
  int fd; // [sp+18h] [-8h] BYREF
  int v8; // [sp+1Ch] [-4h]

  if ( pipe(&fd) < 0 )
    perror("myexec: open pipe fd1 error");
  v4 = fork();
  v5 = v4;
  if ( v4 < 0 )
  {
    perror("myexec: fork error");
    v5 = -1;
    close(fd);
    close(v8);
  }
  else if ( v4 )
  {
    close(v8);
    *a1 = fd;
  }
  else
  {
    close(fd);
    if ( dup2(v8, 1) != 1 )
      perror("myexec: dup fd[1] to stdout error in child process");
    v5 = -1;
    if ( execvp(*a2, a2) < 0 )
    {
      perror("myexec: execvp error in child process");
      exit(1);
    }
  }
  return v5;
}

//----- (00435880) --------------------------------------------------------
int __fastcall sub_435880(__pid_t a1, int *a2)
{
  __pid_t v3; // $v0
  bool v4; // dc
  int result; // $v0
  int v6; // [sp+18h] [-8h] BYREF

  *a2 = 0;
  v6 = 0;
  v3 = waitpid(a1, &v6, 1);
  if ( !v3 )
    return 0;
  v4 = v3 < 0;
  result = -1;
  if ( !v4 )
  {
    if ( (v6 & 0x7F) != 0 )
    {
      result = -1;
    }
    else
    {
      *a2 = (v6 & 0xFF00) >> 8;
      result = 1;
    }
  }
  return result;
}

//----- (00435920) --------------------------------------------------------
int __fastcall httpd_proxy_is_self(int a1)
{
  int v1; // $v0
  bool v2; // dc
  int result; // $v0
  int v4; // $s0
  int v5; // $s1
  int v6; // $v0
  int v7; // $v0
  char v8[36]; // [sp+18h] [-24h] BYREF

  v1 = *(unsigned __int16 *)(a1 + 205448);
  if ( (unsigned __int16)gl_httpd_port == v1 || (v2 = (unsigned __int16)gl_httpd_https_port == v1, result = 0, v2) )
  {
    v4 = a1 + 196608;
    v5 = *(_DWORD *)(a1 + 205452);
    if ( v5 == htonl(0x7F000001u) || (v6 = IpToStr(v8, *(_DWORD *)(v4 + 8844)), check_ip_is_lanip(v6)) )
    {
      result = 1;
    }
    else
    {
      v7 = IpToStr(v8, *(_DWORD *)(v4 + 8844));
      result = check_ip_is_wanip(v7);
      if ( result )
        result = 1;
    }
  }
  return result;
}
// 666174: using guessed type __int16 gl_httpd_https_port;
// 666178: using guessed type __int16 gl_httpd_port;
// 6A8188: using guessed type int __fastcall check_ip_is_wanip(_DWORD);
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A88D4: using guessed type int __fastcall check_ip_is_lanip(_DWORD);

//----- (00435A30) --------------------------------------------------------
int __fastcall httdp_proxy_check_user(int a1)
{
  char *v1; // $s0
  char *v3; // $v0
  int *v4; // $v0
  int v5; // $s2
  unsigned int v6; // $a1
  int *v8; // $v0
  char *v9; // $v0
  const char *v10; // $s0
  int v11; // $v0
  int v12; // $v0
  int v13; // $v0
  int v14; // $v0
  int v15; // $v0
  int v16; // $v0
  int v17; // $v0
  int v18; // $v0
  int v19; // $v0
  int v20; // $v0
  int v21; // $v0

  v1 = (char *)(*(_DWORD *)(a1 + 44) + 1);
  v3 = strchr(v1, 47);
  if ( v3 )
    v1 = v3 + 1;
  v5 = get_name_hash((unsigned __int8 *)v1);
  v4 = httpd_get_file(v1, v5);
  if ( v4 )
  {
    v6 = v4[3];
    return httpd_check_user(a1, v6);
  }
  v8 = httpd_find_ext_file(v1, v5);
  if ( v8 )
  {
    v6 = v8[4];
    return httpd_check_user(a1, v6);
  }
  v9 = strrchr(v1, 46);
  v10 = v9;
  if ( v9 )
  {
    v11 = strcmp(v9, ".asp");
    v6 = 4;
    if ( !v11 )
      return httpd_check_user(a1, v6);
    v12 = strcmp(v10, ".cgi");
    v6 = 4;
    if ( !v12 )
      return httpd_check_user(a1, v6);
    if ( !strcmp(v10, ".cfg") )
    {
      v6 = 4;
      return httpd_check_user(a1, v6);
    }
    v13 = strcmp(v10, ".csv");
    v6 = 4;
    if ( !v13 )
      return httpd_check_user(a1, v6);
  }
  else
  {
    v10 = "";
  }
  v14 = strcmp(v10, ".key");
  v6 = 4;
  if ( v14 )
  {
    v15 = strcmp(v10, ".crt");
    v6 = 4;
    if ( v15 )
    {
      v16 = strcmp(v10, ".pem");
      v6 = 4;
      if ( v16 )
      {
        v17 = strcmp(v10, ".txt");
        v6 = 4;
        if ( v17 )
        {
          v18 = strcmp(v10, ".data");
          v6 = 3;
          if ( v18 )
          {
            v19 = strcmp(v10, ".cap");
            v6 = 3;
            if ( v19 )
            {
              v20 = strcmp(v10, ".js");
              v6 = 0;
              if ( v20 )
              {
                v21 = strcmp(v10, ".htm");
                v6 = 0;
                if ( v21 )
                {
                  if ( !strcmp(v10, ".html") )
                    v6 = 0;
                  else
                    v6 = strcmp(v10, ".trx") != 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return httpd_check_user(a1, v6);
}

//----- (00435CF8) --------------------------------------------------------
int __fastcall httpd_proxy_check(int a1, _DWORD *a2)
{
  const void *v2; // $s1
  bool v4; // dc
  int result; // $v0

  v2 = *(const void **)(a1 + 44);
  *a2 = 0;
  v4 = memcmp(v2, "/ac/", 4u) == 0;
  result = 1;
  if ( v4 )
    goto LABEL_4;
  if ( !memcmp(v2, "/rt/", 4u) )
    goto LABEL_3;
  v4 = memcmp(v2, "/ap/", 4u) == 0;
  result = 1;
  if ( v4 )
    goto LABEL_4;
  v4 = memcmp(v2, "/acs/", 5u) == 0;
  result = 0;
  if ( v4 )
  {
LABEL_3:
    result = 1;
LABEL_4:
    *a2 = 1;
  }
  return result;
}

//----- (00435DD0) --------------------------------------------------------
int __fastcall httpd_proxy_xconnect(const struct sockaddr *a1)
{
  int v2; // $v0
  int v3; // $a0
  int v4; // $s0
  int v5; // $v0
  int v7[3]; // [sp+20h] [-Ch] BYREF

  v2 = socket(2, 2, 0);
  v3 = -1;
  if ( v2 >= 0 )
  {
    v4 = v2;
    if ( setblocking(v2) < 0 )
    {
      close(v4);
      v3 = -1;
    }
    else
    {
      v7[0] = 1;
      v7[1] = 0;
      setsockopt(v4, 0xFFFF, 4101, v7, 8u);
      setsockopt(v4, 0xFFFF, 4102, v7, 8u);
      v5 = connect(v4, a1, 0x10u);
      v3 = v4;
      if ( v5 < 0 )
      {
        close(v4);
        v3 = -1;
      }
    }
  }
  return v3;
}

//----- (00435EF8) --------------------------------------------------------
int __fastcall httpd_proxy_client_close(int a1)
{
  int v1; // $s0

  v1 = a1 + 196608;
  if ( !**(_DWORD **)(a1 + 205440) )
    return httpd_conn_close((int *)a1);
  if ( *(_DWORD *)(a1 + 205424) != -1 )
  {
    httpd_conn_epoll_del_proxy(a1);
    close_socket(*(_DWORD *)(v1 + 8816));
    *(_DWORD *)(v1 + 8816) = -1;
  }
  httpd_conn_epoll_write(a1);
  return 0;
}

//----- (00435FC0) --------------------------------------------------------
int __fastcall httpd_proxy_server_close(int a1)
{
  int v1; // $s0

  v1 = a1 + 196608;
  if ( !**(_DWORD **)(a1 + 205444) )
    return httpd_conn_close((int *)a1);
  if ( *(_DWORD *)(a1 + 205416) != -1 )
  {
    httpd_conn_epoll_del(a1);
    close_socket(*(_DWORD *)(v1 + 8808));
    *(_DWORD *)(v1 + 8808) = -1;
  }
  httpd_conn_epoll_write_proxy(a1);
  return 0;
}

//----- (00436088) --------------------------------------------------------
int __fastcall httpd_proxy_do_rcv(int a1)
{
  int v2; // $v1
  int (__fastcall *v3)(int); // $t9
  int v5; // $s1
  int v6; // $v0
  int v7; // $v0
  int *v8; // $v1
  int v9; // $a1
  size_t v10; // $a2
  _DWORD *v11; // $v1
  ssize_t v12; // $v0
  int *v13; // $v1
  int v14; // $a1
  size_t v15; // $a2
  _DWORD *v16; // $v1
  int v17; // $v0

  if ( *(_BYTE *)(a1 + 41) != 10 )
    goto LABEL_2;
  v5 = a1 + 196608;
  v6 = *(_DWORD *)(a1 + 205412);
  if ( v6 == *(_DWORD *)(a1 + 205416) )
  {
    v13 = *(int **)(a1 + 205444);
    v14 = *v13;
    v15 = 102400 - *v13;
    if ( *v13 == 102400 )
      return 0;
    v16 = v13 + 1;
    if ( *(_DWORD *)(a1 + 209984) )
    {
      v17 = https_ssl_read(a1);
      if ( v17 != -2 )
      {
        if ( v17 <= 0 )
          goto LABEL_2;
        goto LABEL_19;
      }
    }
    else
    {
      v17 = recv(*(_DWORD *)(a1 + 205412), (char *)v16 + v14, v15, 0);
      if ( v17 > 0 )
      {
LABEL_19:
        **(_DWORD **)(v5 + 8836) += v17;
        goto LABEL_20;
      }
      if ( !v17 || *_errno_location() != 11 )
        goto LABEL_2;
    }
LABEL_20:
    httpd_conn_epoll_write_proxy(a1);
    goto LABEL_8;
  }
  if ( v6 != *(_DWORD *)(a1 + 205424) )
  {
LABEL_8:
    v7 = jiffies_get();
    mod_timer(a1 + 205540, v7 + 900000);
    return 0;
  }
  v8 = *(int **)(a1 + 205440);
  v9 = *v8;
  v10 = 102400 - *v8;
  v11 = v8 + 1;
  if ( !v10 )
    return 0;
  v12 = recv(*(_DWORD *)(a1 + 205412), (char *)v11 + v9, v10, 0);
  if ( v12 > 0 )
  {
    **(_DWORD **)(v5 + 8832) += v12;
LABEL_13:
    httpd_conn_epoll_write(a1);
    goto LABEL_8;
  }
  if ( v12 && *_errno_location() == 11 )
    goto LABEL_13;
LABEL_2:
  v2 = *(_DWORD *)(a1 + 205412);
  if ( v2 == *(_DWORD *)(a1 + 205424) )
  {
    v3 = httpd_proxy_client_close;
    return v3(a1);
  }
  if ( v2 != *(_DWORD *)(a1 + 205416) )
  {
    v3 = (int (__fastcall *)(int))httpd_conn_close;
    return v3(a1);
  }
  return httpd_proxy_server_close(a1);
}
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (0043631C) --------------------------------------------------------
int __fastcall httpd_proxy_buf_init(int a1)
{
  int v1; // $s1
  void *v3; // $a0
  void *v4; // $a0
  int v5; // $s0
  int v6; // $v0
  int v7; // $v0
  int v9; // $a2

  v1 = a1 + 196608;
  v3 = *(void **)(a1 + 205440);
  if ( v3 )
  {
    _mem_free(v3);
    *(_DWORD *)(v1 + 8832) = 0;
  }
  v4 = *(void **)(a1 + 205444);
  if ( v4 )
  {
    _mem_free(v4);
    *(_DWORD *)(a1 + 205444) = 0;
  }
  _mem_malloc(102404, "httpd_proxy_buf_init", 302);
  v5 = a1 + 196608;
  *(_DWORD *)(v5 + 8832) = v6;
  if ( v6 )
  {
    _mem_malloc(102404, "httpd_proxy_buf_init", 308);
    *(_DWORD *)(v5 + 8836) = v7;
    if ( v7 )
      return 0;
    v9 = 311;
    if ( debug_level > 0 )
      goto LABEL_9;
  }
  else
  {
    v9 = 305;
    if ( debug_level > 0 )
    {
LABEL_9:
      printf("%s:%d malloc mem error\n", "httpd_proxy_buf_init", v9);
      return -1;
    }
  }
  return -1;
}
// 4363CC: variable 'v6' is possibly undefined
// 4363EC: variable 'v7' is possibly undefined
// 67D0BC: using guessed type int debug_level;

//----- (00436478) --------------------------------------------------------
int __fastcall httpd_proxy_cgi(int a1)
{
  int v1; // $s0
  int v2; // $v0
  int v5; // $v0
  uint16_t v6; // $a0
  int v7; // $v0
  struct sockaddr v8; // [sp+18h] [-10h] BYREF

  v1 = a1 + 196608;
  v2 = *(_DWORD *)(a1 + 205452);
  *(_DWORD *)&v8.sa_family = 0;
  *(_DWORD *)&v8.sa_data[2] = 0;
  *(_DWORD *)&v8.sa_data[6] = 0;
  *(_DWORD *)&v8.sa_data[10] = 0;
  if ( !v2 )
    return httpd_conn_close((int *)a1);
  if ( !*(_WORD *)(a1 + 205448) )
    return httpd_conn_close((int *)a1);
  if ( httpd_proxy_buf_init(a1) )
    return httpd_conn_close((int *)a1);
  memcpy((void *)(*(_DWORD *)(v1 + 8836) + 4), (void *)(a1 + 102964), *(_DWORD *)(v1 + 8756));
  v5 = *(_DWORD *)(v1 + 8844);
  v6 = *(_WORD *)(v1 + 8840);
  **(_DWORD **)(v1 + 8836) = *(_DWORD *)(v1 + 8756);
  v8.sa_family = 2;
  *(_DWORD *)&v8.sa_data[2] = v5;
  *(_WORD *)v8.sa_data = htons(v6);
  v7 = httpd_proxy_xconnect(&v8);
  *(_DWORD *)(v1 + 8816) = v7;
  if ( v7 < 0 )
    return httpd_conn_close((int *)a1);
  httpd_conn_epoll_add_proxy((_DWORD *)a1);
  httpd_conn_epoll_write_proxy(a1);
  setnonblocking(*(_DWORD *)(v1 + 8816));
  *(_DWORD *)(v1 + 8952) = httpd_proxy_do_rcv;
  *(_BYTE *)(a1 + 41) = 10;
  return 0;
}

//----- (00436610) --------------------------------------------------------
int __fastcall mr_list_index_get(int a1, int a2, int a3)
{
  int v3; // $s1
  int v6; // $s0
  int v7; // $s2
  int v8; // $s5
  int v9; // $v0

  if ( *(int *)(a1 + 4) <= 0 )
    return 0;
  v3 = a3;
  if ( a3 < 100 )
    return 0;
  v6 = a1 + 8;
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = snprintf(
           (char *)(a2 + v7),
           v3,
           "{\"iface\":%d,\"status\":%d,\"status_v6\":%d,\"jh_en\":%d,\"jh_val\":%lu,\"zc_en\":%d,\"host\":%d,\"ct_num\":%d},",
           *(unsigned __int16 *)(v6 + 8) - 1,
           *(unsigned __int8 *)(v6 + 2),
           *(unsigned __int8 *)(v6 + 7),
           *(unsigned __int8 *)(v6 + 1),
           *(_DWORD *)(v6 + 20),
           *(unsigned __int8 *)(v6 + 120),
           *(_DWORD *)(v6 + 12),
           *(_DWORD *)(v6 + 16));
    if ( v9 >= v3 )
      v9 = v3 - 1;
    ++v8;
    v3 -= v9;
    v7 += v9;
    v6 += 340;
  }
  while ( v8 < *(_DWORD *)(a1 + 4) && v3 >= 100 );
  return v7;
}

//----- (0043673C) --------------------------------------------------------
bool __fastcall sub_43673C(int a1)
{
  _BYTE *v2; // $v0
  _BOOL4 v3; // $s2
  _BYTE *v4; // $v0
  int v5; // $s1
  int v7[6]; // [sp+18h] [-18h] BYREF

  v2 = (_BYTE *)jhl_nv_get_def("router_domain");
  if ( v2 && *v2 )
    dns_url_del(v2);
  v3 = jhl_web_save_parms(a1, base_ident_nvarms, 1) != 0;
  if ( nvram_get_int("billing_en") == 1 && nvram_get_int("mqtt_cbg_settlement_mode") == 1 )
  {
    nvram_reset_def("router_domain");
    puts("billing enabled and settlement_mode is 1, can not modify router domain");
  }
  v4 = (_BYTE *)jhl_nv_get_def("router_domain");
  v5 = (int)v4;
  if ( v4 && *v4 )
    dns_url_add(v4, 0, 1);
  v7[0] = (int)"wys";
  v7[1] = (int)"router_domain";
  v7[3] = v5;
  v7[2] = (int)"set";
  v7[4] = 0;
  eval(v7, 0, 0, 0);
  return v3;
}
// 66D240: using guessed type char *base_ident_nvarms[5];
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83E0: using guessed type int __fastcall nvram_reset_def(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8548: using guessed type int __fastcall dns_url_add(_DWORD, _DWORD, _DWORD);
// 6A8884: using guessed type int __fastcall dns_url_del(_DWORD);

//----- (004368E8) --------------------------------------------------------
int __fastcall sub_4368E8(int a1)
{
  int v2; // $s0
  const char *v3; // $s1
  const char *v4; // $v0
  int v5; // $s0
  unsigned int v6; // $v0
  char v8[2052]; // [sp+18h] [-804h] BYREF

  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = get_nvarms((const char **)base_ident_nvarms, (int)&v8[29], 2019) + 29;
  v3 = (const char *)jhl_nv_get_def("h323_enable");
  v4 = (const char *)jhl_nv_get_def("sip_enable");
  v5 = v2 + sprintf(&v8[v2], "H323_en:'%s',sip_en:'%s'", v3, v4);
  v6 = snprintf(&v8[v5], 2048 - v5, "}}");
  if ( v6 >= 2048 - v5 )
    v6 = 2047 - v5;
  return httpd_cgi_ret(a1, v8, v6 + v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 66D240: using guessed type char *base_ident_nvarms[5];
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (00436A40) --------------------------------------------------------
int __fastcall sub_436A40(int a1)
{
  char *v2; // $s2
  char *v3; // $s1
  int v4; // $s2
  _BYTE *v5; // $v0
  int v6; // $a0
  _BYTE *v7; // $v0
  int v8; // $s3
  int *v9; // $v1
  const char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  unsigned int v15; // $a2
  int v17; // $s1
  char *v18; // $v0
  const char *v19; // $v0
  int v20[257]; // [sp+20h] [-404h] BYREF

  v2 = httpd_get_parm(a1, "H323_en");
  v3 = httpd_get_parm(a1, "sip_en");
  if ( v2 && strcmp(v2, "undefined") )
  {
    nvram_set("h323_enable", v2);
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  if ( v3 && strcmp(v3, "undefined") )
  {
    nvram_set("sip_enable", v3);
    v4 = 1;
  }
  if ( save_variables(a1, 0) )
  {
    v5 = (_BYTE *)jhl_nv_get_def("router_domain");
    if ( v5 && *v5 )
    {
      dns_url_del(v5);
      if ( !save_variables(a1, 1) )
      {
LABEL_11:
        if ( !v4 )
          goto LABEL_12;
        goto LABEL_21;
      }
    }
    else if ( !save_variables(a1, 1) )
    {
      goto LABEL_11;
    }
LABEL_21:
    jhl_parm_commit(v6);
    set_host_domain_name();
LABEL_12:
    if ( nvram_get_int("billing_en") == 1 && nvram_get_int("mqtt_cbg_settlement_mode") == 1 )
    {
      nvram_reset_def("router_domain");
      puts("billing enabled and settlement_mode is 1, can not modify router domain");
    }
    v7 = (_BYTE *)jhl_nv_get_def("router_domain");
    v8 = (int)v7;
    if ( v7 && *v7 )
      dns_url_add(v7, 0, 1);
    v20[0] = (int)"wys";
    v20[1] = (int)"router_domain";
    v20[2] = (int)"set";
    v20[3] = v8;
    v20[4] = 0;
    eval(v20, 0, 0, 0);
    v9 = v20;
    v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v11 = *(_DWORD *)v10;
      v12 = *((_DWORD *)v10 + 1);
      v13 = *((_DWORD *)v10 + 2);
      v14 = *((_DWORD *)v10 + 3);
      v10 += 16;
      *v9 = v11;
      v9[1] = v12;
      v9[2] = v13;
      v9[3] = v14;
      v9 += 4;
    }
    while ( v10 != "}" );
    v15 = 33;
    *(_WORD *)v9 = *(_WORD *)v10;
    return httpd_cgi_ret(a1, (char *)v20, v15, 4);
  }
  v17 = *(unsigned __int8 *)(a1 + 210102);
  v18 = resmsg_get();
  v19 = (const char *)_GET_LANG_TEXT(12, v17, v18);
  v15 = snprintf((char *)v20, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
  if ( v15 >= 0x400 )
    v15 = 1023;
  return httpd_cgi_ret(a1, (char *)v20, v15, 4);
}
// 436CA0: variable 'v6' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83E0: using guessed type int __fastcall nvram_reset_def(_DWORD);
// 6A8410: using guessed type int set_host_domain_name(void);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8548: using guessed type int __fastcall dns_url_add(_DWORD, _DWORD, _DWORD);
// 6A8884: using guessed type int __fastcall dns_url_del(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00436E0C) --------------------------------------------------------
int __fastcall sub_436E0C(int a1)
{
  char *v2; // $v0
  int v3; // $v0
  char *v4; // $s0
  const char *v5; // $v0
  int v6; // $v0
  bool v7; // dc
  char *v8; // $v0
  char *v9; // $v0
  uint32_t v10; // $v0
  uint32_t v11; // $v0
  int v12; // $s4
  const char *v13; // $v0
  const char *v14; // $s4
  const char *v15; // $s5
  const char *v16; // $s7
  const char *v17; // $fp
  const char *v18; // $a2
  int v19; // $v0
  int v20; // $v0
  int v21; // $v0
  int v22; // $s2
  int v23; // $s1
  int v24; // $v0
  int v25; // $s2
  int v26; // $v0
  int v27; // $s2
  int v28; // $v0
  int v29; // $s2
  int v30; // $v0
  int v31; // $s1
  int v32; // $v0
  int v33; // $s1
  int v34; // $v0
  int v35; // $s1
  char *v36; // $a0
  int v37; // $v0
  int v38; // $s1
  int v39; // $v0
  int v40; // $a2
  int result; // $v0
  const char *v42; // $v0
  unsigned int v43; // $v0
  const char *v44; // [sp+68h] [-350h]
  char v45[256]; // [sp+C8h] [-2F0h] BYREF
  char v46[128]; // [sp+1C8h] [-1F0h] BYREF
  char v47[128]; // [sp+248h] [-170h] BYREF
  char v48[64]; // [sp+2C8h] [-F0h] BYREF
  int v49[10]; // [sp+308h] [-B0h] BYREF
  int v50[8]; // [sp+330h] [-88h] BYREF
  int v51[4]; // [sp+350h] [-68h] BYREF
  unsigned int v52; // [sp+360h] [-58h]
  char *v53; // [sp+364h] [-54h]
  char *v54; // [sp+368h] [-50h]
  const char *v55; // [sp+36Ch] [-4Ch]
  const char *v56; // [sp+370h] [-48h]
  const char *v57; // [sp+374h] [-44h]
  const char *v58; // [sp+378h] [-40h]
  time_t v59; // [sp+37Ch] [-3Ch]
  int v60; // [sp+380h] [-38h]
  int v61; // [sp+384h] [-34h]
  int v62; // [sp+388h] [-30h]
  const char *v63; // [sp+38Ch] [-2Ch]
  const char *v64; // [sp+390h] [-28h]
  int v65; // [sp+394h] [-24h]
  int v66; // [sp+398h] [-20h]
  int v67; // [sp+39Ch] [-1Ch]
  int v68; // [sp+3A0h] [-18h]
  int v69; // [sp+3A4h] [-14h]
  int v70; // [sp+3A8h] [-10h]
  int v71; // [sp+3ACh] [-Ch]
  int v72; // [sp+3B0h] [-8h]
  const char *v73; // [sp+3B4h] [-4h]

  memset(v46, 0, sizeof(v46));
  v50[0] = 0;
  v50[1] = 0;
  v50[2] = 0;
  v50[3] = 0;
  v50[4] = 0;
  v50[5] = 0;
  v50[6] = 0;
  v50[7] = 0;
  memset(v48, 0, sizeof(v48));
  memset(v45, 0, sizeof(v45));
  _mem_malloc(0x200000, "base_data", 460);
  if ( v2 )
  {
    v4 = v2;
    v3 = get_web_language_type(a1);
    if ( v3 == 1 || v3 == 99 )
      sq_file_get_ssid_en(v46, 128);
    else
      sq_file_get_id(v46, 128);
    v53 = v47;
    get_uptime_sys(v47);
    get_memory(v51);
    sys_runinfo_get(v49);
    v5 = (const char *)custom_tb_version();
    v6 = sprintf(v48, "%s", v5);
    v7 = v6 <= 0;
    v8 = &v45[v6];
    if ( !v7 )
      v8[511] = 0;
    v9 = (char *)jhl_nv_get_def("lan_netmask");
    if ( !v9 )
      v9 = "";
    v52 = (unsigned int)"";
    v10 = StrToIp(v9);
    v11 = htonl(v10);
    v12 = get_netmask_wei(v11);
    v13 = (const char *)jhl_nv_get_def("lan_ipaddr");
    if ( !v13 )
      v13 = (const char *)v52;
    v64 = (const char *)v50;
    snprintf((char *)v50, 32, "%s/%d", v13, v12);
    strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v4, "{\"code\":0,\"error\":\"\"", 20);
    v55 = (const char *)wayos_version;
    v56 = (const char *)tomato_buildtime;
    v57 = (const char *)wys_svn_info;
    v58 = (const char *)jhl_nv_get_def("http_hadmin_en");
    v59 = time(0);
    v60 = v51[0];
    v61 = v51[1];
    v14 = (const char *)nvram_get("lan_hwaddr");
    v54 = v4 + 29;
    if ( !v14 )
      v14 = "00:00:00:00:00:00";
    v62 = user_num_get();
    v15 = (const char *)nvram_get("device_cpu_rate");
    if ( !v15 )
      v15 = "1";
    v63 = (const char *)nvram_get("tm_sel");
    v16 = (const char *)nvram_get("vue_health_score");
    v54 = "0";
    if ( !v16 )
      v16 = "0";
    v17 = (const char *)nvram_get("acserver_http_port");
    if ( !v17 )
      v17 = v54;
    v18 = (const char *)nvram_get("http_lanport");
    if ( !v18 )
      v18 = (const char *)v52;
    v73 = v18;
    v72 = v49[2];
    v71 = v49[3];
    v70 = v49[0];
    v69 = v49[1];
    v68 = v49[4];
    v67 = v49[5];
    v65 = get_devmg_lan_id();
    v19 = nvram_get_int("mqttvpn_sdwan_total_node");
    v66 = v65 - v19;
    v65 = get_devmg_lan_id();
    v20 = nvram_get_int("tr069_httpd_port");
    v44 = (const char *)v52;
    v52 = 2031616;
    v21 = snprintf(
            v4 + 29,
            2097123,
            "\"sn\":\"%s\",\"tbv\":\"%s\",\"pt\":\"%s\",\"ver\":\"%s\",\"vtm\":\"%s\",\"svn\":\"%s\",\"isap\":%s,\"ap_fla"
            "g\":%d,\"http_hadmin_en\":%s,\"rttm\":\"%u\",\"atime\":\"%s\",\"memall\":\"%lu\",\"memfree\":\"%lu\",\"lanip"
            "\":\"%s\",\"lanmac\":\"%s\",\"usernum\":\"%d\",\"cpurate\":\"%s\",\"tm_sel\":\"%s\",\"wififlag\":\"%d\",\"he"
            "alth_score\":\"%s\",\"dev_type\":%d,\"acport\":%s,\"acstate\":%d,\"apname\":\"%s\",\"gwsn\":\"%s\",\"gwip\":"
            "\"%s\",\"gwport\":%s,\"user_2g\":%d,\"user_5g\":%d,\"vpn_port\":%d,\"ct_max\":%u,\"ct_num\":%u,\"rt_max\":%u"
            ",\"rt_num\":%u,\"skb_zong\":%u,\"skb_data\":%u,\"ipv6\":%d,\"cpu_temp\":\"%s\",\"sdwan_port\":%d,\"lan_port\""
            ":%d,\"ai\":%d,\"tr069_acsport\":%d,\"bill\":%d,\"show_port\":%d",
            v46,
            v48,
            "ralink",
            v55,
            v56,
            v57,
            v54,
            0,
            v58,
            v59,
            v53,
            v60,
            v61,
            v64,
            v14,
            v62,
            v15,
            v63,
            0,
            v16,
            1,
            v17,
            0,
            v44,
            v46,
            "127.0.0.1",
            v73,
            0,
            0,
            101,
            v72,
            v71,
            v70,
            v69,
            v68,
            v67,
            1,
            v45,
            v66,
            v65,
            3,
            v20,
            2,
            1);
    if ( v21 >= (int)(v52 | 0xFFE3) )
      v21 = v52 | 0xFFE2;
    v22 = v21 + 29;
    v23 = 0x200000 - (v21 + 29);
    v24 = snprintf(&v4[v21 + 29], v23, &byte_643D4C);
    if ( v24 >= v23 )
      v24 = 0x1FFFFF - v22;
    v25 = v24 + v22 + get_nvarms((const char **)base_ident_nvarms, (int)&v4[v24 + v22], 0x200000 - (v24 + v22));
    v26 = snprintf(&v4[v25], 0x200000 - v25, "\"wans\":");
    if ( v26 >= 0x200000 - v25 )
      v26 = 0x1FFFFF - v25;
    v27 = v26 + v25 + get_wans_data(&v4[v26 + v25], 0x200000 - (v26 + v25));
    v28 = snprintf(&v4[v27], 0x200000 - v27, ",\"link_stat\":");
    if ( v28 >= 0x200000 - v27 )
      v28 = 0x1FFFFF - v27;
    v29 = v28 + v27 + miitool_data_buf(&v4[v28 + v27], 0x200000 - (v28 + v27));
    v30 = snprintf(&v4[v29], 0x200000 - v29, ",\"x86\":%d,\"common\":%d", 0, 0);
    if ( v30 >= 0x200000 - v29 )
      v30 = 0x1FFFFF - v29;
    v31 = v30 + v29;
    v32 = snprintf(&v4[v30 + v29], 0x200000 - (v30 + v29), ",\"oem\":%d,\"oem_type\":%d", 0, 10);
    if ( v32 >= 0x200000 - v31 )
      v32 = 0x1FFFFF - v31;
    v33 = v32 + v31;
    v34 = snprintf(&v4[v33], 0x200000 - v33, ",\"mr\":[");
    if ( v34 >= 0x200000 - v33 )
      v34 = 0x1FFFFF - v33;
    v35 = v34 + v33 + cgi_signal_to_kernel(10, 5, 1024000);
    v36 = &v4[v35];
    if ( v35 > 0 && *(v36 - 1) == 44 )
      v36 = &v4[--v35];
    *v36 = 0;
    v37 = snprintf(v36, 0x200000 - v35, &byte_6445A0);
    if ( v37 >= 0x200000 - v35 )
      v37 = 0x1FFFFF - v35;
    v38 = v35 + v37;
    v39 = snprintf(&v4[v38], 0x200000 - v38, "}}");
    if ( v39 >= 0x200000 - v38 )
      v40 = 0x1FFFFF - v38;
    else
      v40 = v39;
    result = httpd_cgi_ret(a1, v4, v40 + v38, 8);
  }
  else
  {
    v42 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v53 = v47;
    v43 = snprintf(v47, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v42);
    if ( v43 >= 0x80 )
      v43 = 127;
    result = httpd_cgi_ret(a1, v53, v43, 4);
  }
  return result;
}
// 436EDC: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 643D4C: using guessed type char byte_643D4C;
// 6445A0: using guessed type char byte_6445A0;
// 66D240: using guessed type char *base_ident_nvarms[5];
// 6A81AC: using guessed type int __fastcall get_netmask_wei(_DWORD);
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81E4: using guessed type int __fastcall sys_runinfo_get(_DWORD);
// 6A82D0: using guessed type int __fastcall miitool_data_buf(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83F8: using guessed type int get_devmg_lan_id(void);
// 6A8444: using guessed type int __fastcall get_uptime_sys(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A84E4: using guessed type int __fastcall sq_file_get_id(_DWORD, _DWORD);
// 6A85CC: using guessed type int __fastcall get_memory(_DWORD);
// 6A862C: using guessed type int __fastcall StrToIp(_DWORD);
// 6A8764: using guessed type int __fastcall cgi_signal_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A8788: using guessed type int custom_tb_version(void);
// 6A87CC: using guessed type int user_num_get(void);
// 6A8800: using guessed type int __fastcall sq_file_get_ssid_en(_DWORD, _DWORD);

//----- (00437810) --------------------------------------------------------
int __fastcall sub_437810(int a1)
{
  char *v2; // $s0
  const char *v3; // $v0
  int v4; // $s5
  char *v5; // $v0
  int v6; // $a0
  char *v7; // $s4
  const char *v8; // $s0
  const char *v9; // $v0
  int v10; // $s3
  const char *v11; // $v0
  int v12; // $a0
  int v13; // $a3
  unsigned int v14; // $v0
  int v15; // $s0
  unsigned int v16; // $v0
  char v18[516]; // [sp+18h] [-204h] BYREF

  v2 = httpd_get_parm(a1, "tz");
  set_nvrams(a1, base_ident_nvarms, 1);
  if ( v2 )
  {
    v3 = (const char *)nvram_get("tm_sel");
    if ( !v3 || strcmp(v3, v2) )
      nvram_set("tm_sel", v2);
  }
  v4 = wan_webset_json(a1);
  v7 = httpd_get_parm(a1, "http_passwd");
  v5 = httpd_get_parm(a1, "http_username");
  v8 = v5;
  if ( v7 )
  {
    v9 = (const char *)nvram_get("http_passwd");
    if ( v9 && !strcmp(v9, v7) )
    {
      v10 = 0;
      if ( !v8 )
        goto LABEL_21;
    }
    else
    {
      nvram_set("http_passwd", v7);
      v10 = 1;
      if ( !v8 )
      {
LABEL_12:
        nvram_set("user_pwd_mod", "0");
        jhl_parm_commit(v12);
        jhl_setwanxx();
        jhl_httpd_reset_user();
        jhl_gl_restart_jhttpd("admin-restart", 200);
        v13 = 1;
        goto LABEL_13;
      }
    }
  }
  else
  {
    v10 = 0;
    if ( !v5 )
    {
      if ( !v4 )
        goto LABEL_22;
      goto LABEL_25;
    }
  }
  v11 = (const char *)nvram_get("http_username");
  if ( !v11 || strcmp(v11, v8) )
  {
    nvram_set("http_username", v8);
    goto LABEL_12;
  }
  if ( v10 )
    goto LABEL_12;
LABEL_21:
  if ( !v4 )
  {
LABEL_22:
    v13 = 0;
    goto LABEL_13;
  }
LABEL_25:
  jhl_parm_commit(v6);
  v13 = 0;
LABEL_13:
  strcpy(v18, "{\"code\":0,\"error\":\"\",\"data\":{");
  v14 = snprintf(&v18[29], 483, "\"relogin\":%d", v13);
  v15 = v14 + 29;
  if ( v14 >= 0x1E3 )
    v15 = 511;
  v16 = snprintf(&v18[v15], 512 - v15, "}}");
  if ( v16 >= 512 - v15 )
    v16 = 511 - v15;
  return httpd_cgi_ret(a1, v18, v16 + v15, 4);
}
// 4379EC: variable 'v12' is possibly undefined
// 437B78: variable 'v6' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 66D240: using guessed type char *base_ident_nvarms[5];
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82B8: using guessed type int jhl_setwanxx(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00437B8C) --------------------------------------------------------
int __fastcall sub_437B8C(int a1)
{
  _DWORD *v1; // $v0
  int v2; // $a2
  char *v3; // $v0
  char *v4; // $s1
  _DWORD *v5; // $s5
  const char *v6; // $v0
  int v7; // $v0
  int v8; // $a0
  int v9; // $s0
  _DWORD *v10; // $fp
  int v11; // $s2
  int v12; // $s3
  _BOOL4 v13; // $v0
  uint32_t v14; // $a0
  int v15; // $v0
  int v16; // $v0
  int v17; // $v0
  int v18; // $s0
  _BYTE *v19; // $v0
  char *v20; // $a0
  const char *v21; // $t0
  int v22; // $t2
  char *v23; // $a0
  int v24; // $s2
  int v25; // $v0
  int v26; // $t1
  int v27; // $v0
  int v28; // $s0
  int v29; // $v0
  int v30; // $s0
  int v31; // $v0
  int v32; // $s0
  int v33; // $v0
  int v34; // $s4
  int v35; // $s2
  int v36; // $v0
  bool v37; // dc
  int v38; // $s2
  int v39; // $v0
  int v40; // $s0
  int v41; // $v0
  int v42; // $s4
  int v43; // $v0
  int v44; // $s0
  int v45; // $s4
  int v46; // $v0
  int v47; // $s4
  int v48; // $v0
  int v49; // $s2
  int v50; // $v0
  int v51; // $s2
  int v52; // $v0
  int v53; // $s2
  char *v54; // $a0
  int v55; // $v0
  int v56; // $s0
  int v57; // $v0
  unsigned int v59; // $v0
  int v60; // $a1
  const char *v61; // $a3
  const char *v62; // $v0
  unsigned int v63; // $a2
  const char *v64; // $v0
  int v65; // $s0
  int v66; // $a2
  char v67[1024]; // [sp+60h] [-8D0h] BYREF
  char v68[1024]; // [sp+460h] [-4D0h] BYREF
  char v69[128]; // [sp+860h] [-D0h] BYREF
  char v70[20]; // [sp+8E0h] [-50h] BYREF
  const char *v71; // [sp+8F4h] [-3Ch] BYREF
  int v72; // [sp+8F8h] [-38h]
  int v73; // [sp+8FCh] [-34h]
  int v74; // [sp+900h] [-30h] BYREF
  __int16 v75; // [sp+904h] [-2Ch]
  uint32_t v76; // [sp+908h] [-28h]
  char *v77; // [sp+90Ch] [-24h]
  int v78; // [sp+910h] [-20h]
  char *v79; // [sp+914h] [-1Ch]
  char *format; // [sp+918h] [-18h]
  char *v81; // [sp+91Ch] [-14h]
  char *v82; // [sp+920h] [-10h]
  const char *v83; // [sp+924h] [-Ch]
  char *v84; // [sp+928h] [-8h]

  v74 = 0;
  v75 = 0;
  memset(v68, 0, sizeof(v68));
  memset(v67, 0, sizeof(v67));
  v84 = "a";
  v78 = ai_hi_mem_json_get();
  _mem_malloc(0x200000, "hilist_data", 839);
  v4 = v3;
  _mem_malloc(0x100000, "hilist_data", 840);
  v5 = v1;
  if ( !v4 || !v1 )
  {
    _mem_free(v4);
    _mem_free(v5);
    if ( *(_BYTE *)(a1 + 210100) == 2 )
    {
      strcpy(v69, "{\"err\":\"mem_malloc err\"}");
      v63 = 24;
    }
    else
    {
      v62 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
      v63 = snprintf(v69, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v62);
      if ( v63 >= 0x80 )
        return httpd_cgi_ret(a1, v69, 127, 4);
    }
    return httpd_cgi_ret(a1, v69, v63, 4);
  }
  *v1 = 13;
  v1[3] = 72;
  v1[1] = 0x100000;
  if ( !jianhl_order_opt_fun(v1, 0x100000, v2) )
  {
    if ( *(_BYTE *)(a1 + 210100) == 2 )
    {
      *(_WORD *)v4 = 91;
      v8 = v5[5];
      v10 = v5 + 6;
      if ( v8 > 0 )
      {
        v11 = 0x1FFFFF;
        v9 = 1;
LABEL_9:
        v12 = 1;
        v81 = "a";
        v83 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
        format = "{\"no\":%d,\"ip\":%u,\"ip6\":\"%s\",\"mac\":\"%s\",\"ctm\":%lu,\"ct\":%lu,\"ctt\":%lu,\"ctu\":%lu,\"cti"
                 "\":%lu,\"cto\":%lu,\"zup\":%llu,\"zdw\":%llu,\"up\":%lu,\"qup\":%lu,\"auth_tm\":%lu,";
        v79 = "%s";
        v82 = "\"dw\":%lu,\"qdw\":%lu,\"n_user\":\"%s\",\"n_user2\":\"%s\",\"n_name\":\"%s\",\"n_phone\":\"%s\",\"thd\":%"
              "d,\"block\":%d,\"thd_enable\":%d,\"t_init\":%d,\"rzgl\":%d,\"tas\":%d,\"mrid\":%d";
        while ( 1 )
        {
          v13 = v12 < v8;
          if ( !*((_BYTE *)v10 + 1031) )
            break;
LABEL_47:
          v10 += 268;
          if ( v13 )
          {
            v11 = 0x200000 - v9;
            ++v12;
            if ( 0x200000 - v9 >= 200 )
              continue;
          }
          goto LABEL_49;
        }
        v76 = (uint32_t)v10 + 78;
        if ( !memcmp((char *)v10 + 78, &v74, 6u) )
          MacToStr(v70, v10 + 18);
        else
          MacToStr(v70, v76);
        v14 = v10[8];
        v77 = &v4[v9];
        v76 = ntohl(v14);
        v15 = IpaddrToStr(v69, v10 + 7);
        v16 = snprintf(v77, v11, format, v12, v76, v15, v70, v10[1], v10[25], v10[30], v10[35], v10[40], v10[45]);
        if ( v16 >= v11 )
          v16 = 0x1FFFFF - v9;
        v18 = v16 + v9;
        v17 = get_json_data(v10 + 68);
        snprintf(v68, 1024, v79, v17);
        memset(v67, 0, sizeof(v67));
        split_string2(v68, v81 + 9684, &v71, 3);
        if ( !v71 )
          v71 = v83 - 1556;
        v19 = (_BYTE *)GetJSONItemValueAsString(v78, v70);
        v20 = v67;
        if ( *v19 )
        {
          v59 = snprintf(v67, 1024, v79, v19);
          if ( v59 >= 0x400 )
            v59 = 1023;
          v21 = v71;
          v20 = &v67[v59];
          if ( !*v71 )
            goto LABEL_19;
          v60 = 1024 - v59;
          if ( v59 )
          {
            v61 = " ";
            goto LABEL_67;
          }
        }
        else
        {
          v21 = v71;
          if ( !*v71 )
          {
LABEL_19:
            v22 = v10[6];
            v23 = &v4[v18];
            v24 = 0x200000 - v18;
            goto LABEL_20;
          }
          v60 = 1024;
        }
        v61 = v83 - 1556;
LABEL_67:
        snprintf(v20, v60, "%s%s", v61, v21);
        v21 = v71;
        v23 = &v4[v18];
        v22 = v10[6];
        v24 = 0x200000 - v18;
        if ( !v71 )
        {
          v21 = v83 - 1556;
          v25 = v72;
          if ( v72 )
          {
LABEL_21:
            v26 = v73;
            if ( v73 )
              goto LABEL_22;
LABEL_70:
            v26 = (int)(v83 - 1556);
LABEL_22:
            v27 = snprintf(
                    v23,
                    v24,
                    v82,
                    v22,
                    v22,
                    v67,
                    v21,
                    v25,
                    v26,
                    *((unsigned __int8 *)v10 + 85),
                    *((unsigned __int8 *)v10 + 84),
                    0,
                    *((unsigned __int8 *)v10 + 400),
                    *((unsigned __int8 *)v10 + 401),
                    *((unsigned __int8 *)v10 + 402),
                    *((unsigned __int16 *)v10 + 48));
            if ( v27 >= v24 )
              v27 = 0x1FFFFF - v18;
            v28 = v27 + v18;
            v29 = snprintf(&v4[v28], 0x200000 - v28, ",\"dnsmore\":\"%s\"", (const char *)v10 + 836);
            if ( v29 >= 0x200000 - v28 )
              v29 = 0x1FFFFF - v28;
            v30 = v29 + v28;
            v31 = snprintf(&v4[v30], 0x200000 - v30, ",\"device_type\":\"%d\"", *((unsigned __int8 *)v10 + 868));
            if ( v31 >= 0x200000 - v30 )
              v31 = 0x1FFFFF - v30;
            v32 = v31 + v30;
            v33 = snprintf(&v4[v32], 0x200000 - v32, ",\"dtype\":\"%d\"", *((unsigned __int8 *)v10 + 904));
            if ( v33 >= 0x200000 - v32 )
              v33 = 0x1FFFFF - v32;
            v34 = v33 + v32;
            v35 = 0x200000 - (v33 + v32);
            v36 = snprintf(&v4[v33 + v32], v35, ",\"os\":\"%d\"", v10[225]);
            v37 = v36 < v35;
            v38 = v36 + v34;
            if ( !v37 )
              v38 = 0x1FFFFF;
            v39 = snprintf(&v4[v38], 0x200000 - v38, ",\"tmp_spd\":\"%d|%d\"", v10[16], v10[17]);
            if ( v39 >= 0x200000 - v38 )
              v39 = 0x1FFFFF - v38;
            v40 = v39 + v38;
            v41 = snprintf(
                    &v4[v39 + v38],
                    0x200000 - (v39 + v38),
                    ",\"wififlag\":%d,\"flag_5g\":%d",
                    *((unsigned __int8 *)v10 + 91),
                    *((unsigned __int8 *)v10 + 92));
            if ( v41 >= 0x200000 - v40 )
              v41 = 0x1FFFFF - v40;
            v42 = v41 + v40;
            v43 = snprintf(
                    &v4[v41 + v40],
                    0x200000 - (v41 + v40),
                    ",\"shenji_account\":\"%s\"",
                    (const char *)v10 + 908);
            if ( v43 >= 0x200000 - v42 )
              v43 = 0x1FFFFF - v42;
            v44 = v43 + v42;
            v45 = 0x200000 - (v43 + v42);
            v46 = snprintf(&v4[v44], v45, ",\"auth_type\":\"%d\"", *((unsigned __int8 *)v10 + 905));
            v37 = v46 < v45;
            v47 = v46 + v44;
            if ( !v37 )
              v47 = 0x1FFFFF;
            v48 = snprintf(&v4[v47], 0x200000 - v47, ",\"host_wan_id\":%u", *((unsigned __int16 *)v10 + 453));
            if ( v48 >= 0x200000 - v47 )
              v48 = 0x1FFFFF - v47;
            v49 = v48 + v47;
            if ( *((_WORD *)v10 + 509) )
            {
              v50 = snprintf(
                      &v4[v49],
                      0x200000 - v49,
                      ",\"vlanid\":\"%d.%d\"",
                      *((unsigned __int16 *)v10 + 49),
                      *((unsigned __int16 *)v10 + 509));
              if ( v50 < 0x200000 - v49 )
              {
LABEL_44:
                v51 = v50 + v49;
                v52 = snprintf(&v4[v51], 0x200000 - v51, &byte_65078C);
                if ( v52 >= 0x200000 - v51 )
                  v52 = 0x1FFFFF - v51;
                v8 = v5[5];
                v9 = v51 + v52;
                v13 = v12 < v8;
                goto LABEL_47;
              }
            }
            else
            {
              v50 = snprintf(&v4[v49], 0x200000 - v49, ",\"vlanid\":\"%d\"", *((unsigned __int16 *)v10 + 49));
              if ( v50 < 0x200000 - v49 )
                goto LABEL_44;
            }
            v50 = 0x1FFFFF - v49;
            goto LABEL_44;
          }
LABEL_69:
          v26 = v73;
          v25 = (int)(v83 - 1556);
          if ( v73 )
            goto LABEL_22;
          goto LABEL_70;
        }
LABEL_20:
        v25 = v72;
        if ( v72 )
          goto LABEL_21;
        goto LABEL_69;
      }
      _mem_free(v5);
      v53 = 1;
      v9 = 1;
    }
    else
    {
      strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":{");
      qmemcpy(v4, "{\"code\":0,\"error\":\"\"", 20);
      *((_DWORD *)v4 + 6) = 975331700;
      v6 = (const char *)IpaddrToStr(v69, a1 + 205460);
      v7 = snprintf(v4 + 29, 2097123, "\"selfip\":\"%s\",\"list\":[", v6);
      if ( v7 >= 2097123 )
        v7 = 2097122;
      v8 = v5[5];
      v9 = v7 + 29;
      v10 = v5 + 6;
      if ( v8 > 0 )
      {
        v11 = 0x200000 - v9;
        if ( 0x200000 - v9 >= 200 )
          goto LABEL_9;
      }
LABEL_49:
      _mem_free(v5);
      v53 = v9;
      if ( v9 <= 0 )
        goto LABEL_77;
    }
    v54 = &v4[v53];
    if ( v4[v53 - 1] != 44 )
    {
LABEL_51:
      *v54 = 0;
      v55 = snprintf(v54, 0x200000 - v9, &byte_6445A0);
      if ( v55 >= 0x200000 - v9 )
        v55 = 0x1FFFFF - v9;
      v56 = v9 + v55;
      if ( *(_BYTE *)(a1 + 210100) != 2 )
      {
        v57 = snprintf(&v4[v56], 0x200000 - v56, "}}");
        if ( v57 >= 0x200000 - v56 )
          v57 = 0x1FFFFF - v56;
        v56 += v57;
      }
      cJSON_Delete(v78);
      return jhl_data_giz(a1, v4, v56, 0x200000);
    }
    --v9;
LABEL_77:
    v54 = &v4[v9];
    goto LABEL_51;
  }
  v64 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
  v65 = snprintf(v4, 0x200000, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v64);
  _mem_free(v5);
  cJSON_Delete(v78);
  v66 = v65;
  if ( v65 >= 0x200000 )
    v66 = 0x1FFFFF;
  return httpd_cgi_ret(a1, v4, v66, 8);
}
// 437C58: variable 'v3' is possibly undefined
// 437C64: variable 'v1' is possibly undefined
// 437C8C: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 65078C: using guessed type char byte_65078C;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A8834: using guessed type int __fastcall split_string2(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A887C: using guessed type int __fastcall GetJSONItemValueAsString(_DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A8938: using guessed type int ai_hi_mem_json_get(void);

//----- (00438814) --------------------------------------------------------
void *sdwan_get_ac_dev_list()
{
  int v0; // $v0
  int v1; // $s3
  const char *v2; // $v1
  char *v3; // $v0
  int v4; // $a0
  int v5; // $a1
  int v6; // $a0
  size_t v7; // $v0
  void *v8; // $s0
  int v10; // $s1
  void *v11; // $v0
  int v12[25600]; // [sp+20h] [-19560h] BYREF
  uint32_t v13; // [sp+19020h] [-560h] BYREF
  uint32_t v14; // [sp+19024h] [-55Ch]
  struct sockaddr v15; // [sp+19420h] [-160h] BYREF
  struct sockaddr v16[7]; // [sp+19490h] [-F0h] BYREF
  struct sockaddr v17[7]; // [sp+19500h] [-80h] BYREF
  _DWORD v18[2]; // [sp+19570h] [-10h] BYREF
  socklen_t addr_len[2]; // [sp+19578h] [-8h] BYREF

  strcpy(v17[0].sa_data, "/tmp/ac_server/ac_local.sock");
  addr_len[0] = 110;
  v17[0].sa_family = 1;
  v16[0].sa_family = 1;
  v18[0] = 1;
  v18[1] = 0;
  v0 = socket(1, 1, 0);
  if ( v0 < 0 )
    return 0;
  v1 = v0;
  create_dir2("/tmp/ac_server/jhttpd_local.sock");
  unlink("/tmp/ac_server/jhttpd_local.sock");
  v2 = "/tmp/ac_server/jhttpd_local.sock";
  v3 = v16[0].sa_data;
  do
  {
    v4 = *((_DWORD *)v2 + 1);
    *(_DWORD *)v3 = *(_DWORD *)v2;
    *((_DWORD *)v3 + 1) = v4;
    v5 = *((_DWORD *)v2 + 2);
    *((_DWORD *)v3 + 1) = v4;
    *((_DWORD *)v3 + 2) = v5;
    v6 = *((_DWORD *)v2 + 3);
    *((_DWORD *)v3 + 2) = v5;
    *((_DWORD *)v3 + 3) = v6;
    v2 += 16;
    *((_DWORD *)v3 + 3) = v6;
    v3 += 16;
  }
  while ( v2 != "" );
  *v3 = *v2;
  if ( bind(v1, v16, 0x6Eu) < 0 )
    return 0;
  setsockopt(v1, 0xFFFF, 4101, v18, 8u);
  setsockopt(v1, 0xFFFF, 4102, v18, 8u);
  v13 = htonl(0xFu);
  v14 = htonl(8u);
  v7 = ntohl(v14);
  sendto(v1, &v13, v7, 0, v17, 0x6Eu);
  usleep(0x186A0u);
  if ( recvfrom(v1, v12, 0x19000u, 0, &v15, addr_len) > 0 && v12[0] )
  {
    v10 = 20 * v12[0] + 4;
    _mem_malloc(v10, "sdwan_get_ac_dev_list", 1083);
    v8 = v11;
    if ( v11 )
      memcpy(v11, v12, v10);
  }
  else
  {
    v8 = 0;
  }
  close(v1);
  return v8;
}
// 438B4C: variable 'v11' is possibly undefined
// 6A8584: using guessed type int __fastcall create_dir2(_DWORD);

//----- (00438B78) --------------------------------------------------------
void __fastcall sdwan_check_in_ac(int *a1, unsigned __int8 *a2)
{
  int v2; // $s3
  int v4; // $s2
  int *v5; // $s0
  int v6; // $s1
  unsigned __int8 *v7; // $s5

  if ( a1 )
  {
    v2 = *a1;
    if ( *a1 )
    {
      v4 = *a2;
      v5 = a1 + 2;
      v6 = 0;
      v7 = a2 + 4;
      while ( 1 )
      {
        ++v6;
        if ( *((unsigned __int8 *)v5 - 4) != v4 )
          goto LABEL_4;
        if ( v4 )
        {
          if ( !memcmp(v5, v7, 0x10u) )
            return;
          v5 += 5;
          if ( v2 == v6 )
            return;
        }
        else
        {
          if ( *v5 == *((_DWORD *)a2 + 1) )
            return;
LABEL_4:
          v5 += 5;
          if ( v2 == v6 )
            return;
        }
      }
    }
  }
}

//----- (00438C60) --------------------------------------------------------
int __fastcall sdwan_id_init_get(int a1)
{
  int v1; // $v1
  int result; // $v0
  int v3; // $a0
  int v4; // $v0
  int v5; // $s0
  int v6; // $s0
  int v7; // $v0
  int v8; // $a0
  _WORD v9[51200]; // [sp+18h] [-19000h] BYREF

  if ( a1 == 1 )
  {
    v9[0] = 91;
    v5 = shared_get_sdwans_data((char *)v9 + 1, 102399) + 1;
    v6 = v5 + shared_get_sd_vpns_data((char *)v9 + v5, 102400 - v5);
    v7 = v6 + shared_get_sd_wans_data((char *)v9 + v6, 102400 - v6);
    v8 = v7 - 1;
    if ( *((_BYTE *)v9 + v7 - 1) != 44 )
      v8 = v7;
    snprintf((char *)v9 + v8, 102400 - v8, &byte_6445A0);
    dword_67D4E4 = cJSON_Parse(v9);
    result = 0xFFFF;
  }
  else if ( a1 == 2 )
  {
    if ( dword_67D4E4 )
    {
      cJSON_Delete(dword_67D4E4);
      dword_67D4E4 = 0;
    }
    dword_67D4E0 = 0;
    result = 0xFFFF;
  }
  else
  {
    if ( a1 || !dword_67D4E4 )
      goto LABEL_4;
    if ( !dword_67D4E0 || (v3 = *(_DWORD *)dword_67D4E0, (dword_67D4E0 = v3) == 0) )
    {
      v3 = *(_DWORD *)(dword_67D4E4 + 8);
      dword_67D4E0 = v3;
    }
    v4 = cJSON_GetObjectItem(v3, "id");
    if ( v4 )
      v1 = (unsigned __int16)cJSON_GetIntvalue(v4);
    else
LABEL_4:
      v1 = 0xFFFF;
    result = v1;
  }
  return result;
}
// 6445A0: using guessed type char byte_6445A0;
// 67D4E0: using guessed type int dword_67D4E0;
// 67D4E4: using guessed type int dword_67D4E4;
// 6A817C: using guessed type int __fastcall shared_get_sd_vpns_data(_DWORD, _DWORD);
// 6A8314: using guessed type int __fastcall shared_get_sd_wans_data(_DWORD, _DWORD);
// 6A8380: using guessed type int __fastcall shared_get_sdwans_data(_DWORD, _DWORD);
// 6A8744: using guessed type int __fastcall cJSON_GetIntvalue(_DWORD);
// 6A8780: using guessed type int __fastcall cJSON_Parse(_DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (00438EA8) --------------------------------------------------------
int __fastcall sub_438EA8(int a1)
{
  char *v1; // $v0
  char *v2; // $s1
  char *v3; // $v0
  char *v4; // $s4
  char *v5; // $v0
  char *v6; // $s2
  char *v7; // $v0
  int *v8; // $v0
  int v9; // $a2
  int *v10; // $s3
  const char *v11; // $v0
  char *v12; // $v1
  int v13; // $t1
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  char *v18; // $s5
  _BOOL4 v19; // $v0
  char *v20; // $fp
  int v21; // $v0
  int v22; // $v0
  char *v23; // $a1
  int v24; // $fp
  size_t v25; // $v0
  int v26; // $t3
  int v27; // $fp
  int v28; // $v0
  int v29; // $a0
  char v30[64]; // [sp+28h] [-88h] BYREF
  char v31[32]; // [sp+68h] [-48h] BYREF
  int v32; // [sp+88h] [-28h] BYREF
  __int16 v33; // [sp+8Ch] [-24h]
  int v34; // [sp+90h] [-20h]
  char *v35; // [sp+94h] [-1Ch]
  int v36; // [sp+98h] [-18h]
  int v37; // [sp+9Ch] [-14h]
  char *format; // [sp+A0h] [-10h]
  char *v39; // [sp+A4h] [-Ch]
  char *v40; // [sp+A8h] [-8h]

  v32 = 0;
  v33 = 0;
  _mem_malloc(0x80000, "sdwan_hi_auto_asp", 1192);
  if ( v1 )
  {
    v2 = v1;
    _mem_malloc(0x80000, "sdwan_hi_auto_asp", 1198);
    v4 = v3;
    if ( v3 )
    {
      _mem_malloc(0x80000, "sdwan_hi_auto_asp", 1204);
      v6 = v5;
      if ( v5 )
      {
        _mem_malloc(0x80000, "sdwan_hi_auto_asp", 1210);
        v35 = v7;
        if ( v7 )
        {
          v8 = (int *)sdwan_get_ac_dev_list();
          *(_DWORD *)v2 = 13;
          *((_DWORD *)v2 + 3) = 1;
          *((_DWORD *)v2 + 1) = 0x80000;
          v10 = v8;
          if ( !jianhl_order_opt_fun(v2, 0x80000, v9) )
          {
            v40 = "a";
            jhl_parm_get("wysz_wan_out_rule", v6, 0x80000);
            sdwan_id_init_get(1);
            v18 = v2 + 102;
            if ( *((int *)v2 + 5) > 0 )
            {
              format = "%s";
              v36 = 0;
              v34 = 0;
              v39 = "%s|%d;";
              do
              {
                v20 = v18;
                if ( !memcmp(v18, &v32, 6u) )
                  v20 = v18 - 6;
                sdwan_check_in_ac(v10, (unsigned __int8 *)v18 - 50);
                if ( !v21 )
                {
                  v22 = sdwan_id_init_get(0);
                  v23 = v20;
                  v24 = v22;
                  MacToStr(v31, v23);
                  snprintf(v4, 0x80000, format, v6);
                  nvparm_del_str_too_too_long(v4, 59, 0, v31, 124, 0, v6);
                  v25 = strlen(v6);
                  if ( v24 == 0xFFFF )
                  {
                    v26 = 0xFFFF;
                  }
                  else
                  {
                    v37 = v24;
                    snprintf(&v6[v25], 0x80000 - v25, v39, v31, v24);
                    v26 = v37;
                  }
                  v27 = 0x80000 - v36;
                  v37 = 0x80000;
                  v28 = snprintf(&v35[v36], 0x80000 - v36, "%s|%d;", v31, v26);
                  if ( v28 >= v27 )
                    v28 = v37 - 1 - v36;
                  v36 += v28;
                }
                v19 = ++v34 < *((_DWORD *)v2 + 5);
                v18 += 976;
              }
              while ( v19 );
            }
            sdwan_id_init_get(2);
            wyaos_z_wan_out_set_macs(v35);
            nvram_set(v40 + 10056, v6);
            jhl_parm_commit(v29);
          }
        }
        else
        {
          v10 = 0;
        }
      }
      else
      {
        v35 = 0;
        v10 = 0;
      }
      _mem_free(v2);
      _mem_free(v4);
      if ( v6 )
        _mem_free(v6);
      if ( v35 )
        _mem_free(v35);
      if ( v10 )
        _mem_free(v10);
    }
    else
    {
      _mem_free(v2);
    }
  }
  v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v12 = v30;
  do
  {
    v13 = *(_DWORD *)v11;
    v14 = *((_DWORD *)v11 + 1);
    v15 = *((_DWORD *)v11 + 2);
    v16 = *((_DWORD *)v11 + 3);
    v11 += 16;
    *(_DWORD *)v12 = v13;
    *((_DWORD *)v12 + 1) = v14;
    *((_DWORD *)v12 + 2) = v15;
    *((_DWORD *)v12 + 3) = v16;
    v12 += 16;
  }
  while ( v11 != "}" );
  *(_WORD *)v12 = *(_WORD *)v11;
  return httpd_cgi_ret(a1, v30, 33, 4);
}
// 438F0C: variable 'v1' is possibly undefined
// 438F30: variable 'v3' is possibly undefined
// 438F50: variable 'v5' is possibly undefined
// 438F68: variable 'v7' is possibly undefined
// 438FB0: variable 'v9' is possibly undefined
// 4391C8: variable 'v21' is possibly undefined
// 439368: variable 'v29' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8500: using guessed type int __fastcall wyaos_z_wan_out_set_macs(_DWORD);
// 6A8560: using guessed type int __fastcall nvparm_del_str_too_too_long(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0043937C) --------------------------------------------------------
int __fastcall sub_43937C(int a1)
{
  int v1; // $v0
  int v2; // $s0
  char *v3; // $s1
  char *v4; // $v0
  char *v5; // $s6
  char *v6; // $v0
  char *v7; // $s5
  void *v8; // $v0
  void *v9; // $v0
  int v10; // $a0
  _BYTE *v11; // $v0
  _BYTE *v12; // $s7
  int **v13; // $fp
  int i; // $s0
  int v15; // $v0
  char *v16; // $v1
  const char *v17; // $v0
  int v18; // $t0
  int v19; // $a3
  int v20; // $a2
  int v21; // $a1
  unsigned int v22; // $s0
  const char *v24; // $v0
  int v25; // $a1
  const char *v26; // $a2
  int v27; // $a0
  const char *v28; // $v0
  void *v29; // $s2
  char *v30; // $s1
  int v31; // $s4
  int v32; // $s2
  int v33; // $v0
  void *v34; // $s0
  const char *v35; // $v0
  const char *v36; // $v0
  int v37; // $s2
  void *v38; // $s3
  int v39; // $v0
  char v40[8000]; // [sp+28h] [-1FE8h] BYREF
  char v41[128]; // [sp+1F68h] [-A8h] BYREF
  int v42; // [sp+1FE8h] [-28h] BYREF
  int v43; // [sp+1FECh] [-24h]
  void *v44; // [sp+1FF0h] [-20h]
  char *v45; // [sp+1FF4h] [-1Ch]
  char *format; // [sp+1FF8h] [-18h]
  char *s; // [sp+1FFCh] [-14h]
  void *v48; // [sp+2000h] [-10h]
  char *v49; // [sp+2004h] [-Ch]
  char *v50; // [sp+2008h] [-8h]

  s = v41;
  memset(v41, 0, sizeof(v41));
  v1 = httpd_get_json_parm(a1, (int)"mac_arr");
  v49 = "a";
  v2 = v1;
  v3 = httpd_get_parm(a1, "wan_id");
  format = (char *)nvram_get("wysz_wan_out_rule");
  if ( v2 )
  {
    if ( v3 )
    {
      v45 = "a";
      _mem_malloc(0x80000, "sdwan_hi_asp", 1325);
      v5 = v4;
      if ( v4 )
      {
        _mem_malloc(0x80000, v45 + 11232, 1332);
        v7 = v6;
        if ( !v6 )
        {
          v35 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x80000);
          v22 = snprintf(s, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v35);
          if ( v22 >= 0x80 )
            v22 = 127;
          v48 = 0;
          v44 = 0;
          v12 = 0;
          goto LABEL_16;
        }
        _mem_malloc(0x80000, v45 + 11232, 1339);
        v44 = v8;
        if ( v8 )
        {
          _mem_malloc(0x80000, v45 + 11232, 1346);
          v48 = v9;
          if ( v9 )
          {
            _mem_malloc(0x80000, v45 + 11232, 1353);
            v12 = v11;
            if ( v11 )
            {
              v13 = *(int ***)(v2 + 8);
              for ( i = 0; v13; i += v15 )
              {
                v15 = snprintf(&v12[i], 0x80000 - i, "%s|%s;", (const char *)v13[4], v3);
                if ( v15 >= 0x80000 - i )
                  v15 = 0x7FFFF - i;
                v13 = (int **)*v13;
              }
              if ( *v12 )
              {
                v29 = v48;
                strlcpy(v48, v12, 0x80000);
                v30 = v40;
                v31 = split_string(v29, 59, v40, 2000);
                if ( format && *format )
                {
                  v50 = "1\"";
                  snprintf(v7, 0x80000, "%s", format);
                  if ( v31 > 0 )
                  {
                    v37 = 0;
                    format = "%s|%s;";
                    do
                    {
                      if ( split_string(*(_DWORD *)v30, 124, &v42, 2) > 0 )
                      {
                        v38 = v44;
                        nvparm_del_str_too_too_long(v7, 59, 0, v42, 124, 0, v44);
                        memset(v7, 0, 0x80000u);
                        v44 = v38;
                        strlcpy(v7, v38, 0x80000);
                        memset(v44, 0, 0x80000u);
                        if ( J_atoi(v43) != 0xFFFF )
                        {
                          v39 = snprintf(&v5[i], 0x80000 - i, format, v42, v43);
                          if ( v39 >= 0x80000 - i )
                            v39 = 0x7FFFF - i;
                          i += v39;
                        }
                      }
                      ++v37;
                      v30 += 4;
                    }
                    while ( v31 != v37 );
                  }
                  snprintf(&v5[i], 0x80000 - i, v50 - 26268, v7);
                }
                else if ( v31 > 0 )
                {
                  v32 = 0;
                  format = "%s|%s;";
                  do
                  {
                    if ( split_string(*(_DWORD *)v30, 124, &v42, 2) > 0 && J_atoi(v43) != 0xFFFF )
                    {
                      v33 = snprintf(&v5[i], 0x80000 - i, format, v42, v43);
                      if ( v33 >= 0x80000 - i )
                        v33 = 0x7FFFF - i;
                      i += v33;
                    }
                    ++v32;
                    v30 += 4;
                  }
                  while ( v31 != v32 );
                }
                v34 = v48;
                memset(v48, 0, 0x80000u);
                strlcpy(v34, v12, 0x80000);
                wyaos_z_wan_out_set_macs(v34);
                nvram_set(v49 + 10056, v5);
              }
              jhl_parm_commit(v10);
              v16 = s;
              v17 = "{\"code\":0,\"error\":\"\",\"data\":null}";
              do
              {
                v18 = *(_DWORD *)v17;
                v19 = *((_DWORD *)v17 + 1);
                v20 = *((_DWORD *)v17 + 2);
                v21 = *((_DWORD *)v17 + 3);
                v17 += 16;
                *(_DWORD *)v16 = v18;
                *((_DWORD *)v16 + 1) = v19;
                *((_DWORD *)v16 + 2) = v20;
                *((_DWORD *)v16 + 3) = v21;
                v16 += 16;
              }
              while ( v17 != "}" );
              v22 = 33;
              *(_WORD *)v16 = *(_WORD *)v17;
              goto LABEL_16;
            }
          }
          v36 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x80000);
          v22 = snprintf(s, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v36);
          if ( v22 >= 0x80 )
          {
            v22 = 127;
            v12 = 0;
            goto LABEL_16;
          }
        }
        else
        {
          v24 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x80000);
          v22 = snprintf(s, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
          if ( v22 >= 0x80 )
            v22 = 127;
          v48 = 0;
        }
        v12 = 0;
LABEL_16:
        _mem_free(v5);
        if ( v7 )
          _mem_free(v7);
        if ( v44 )
          _mem_free(v44);
        if ( v48 )
          _mem_free(v48);
        if ( v12 )
          _mem_free(v12);
        return httpd_cgi_ret(a1, s, v22, 4);
      }
      v25 = *(unsigned __int8 *)(a1 + 210102);
      v26 = (const char *)0x80000;
      v27 = 4;
    }
    else
    {
      v25 = *(unsigned __int8 *)(a1 + 210102);
      v26 = "wan_id";
      v27 = 12;
    }
  }
  else
  {
    v25 = *(unsigned __int8 *)(a1 + 210102);
    v26 = "mac_arr";
    v27 = 12;
  }
  v28 = (const char *)_GET_LANG_TEXT(v27, v25, v26);
  v22 = snprintf(s, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v28);
  if ( v22 >= 0x80 )
    v22 = 127;
  return httpd_cgi_ret(a1, s, v22, 4);
}
// 439468: variable 'v4' is possibly undefined
// 43948C: variable 'v6' is possibly undefined
// 4394A8: variable 'v8' is possibly undefined
// 4394CC: variable 'v9' is possibly undefined
// 4394F8: variable 'v11' is possibly undefined
// 439580: variable 'v10' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8500: using guessed type int __fastcall wyaos_z_wan_out_set_macs(_DWORD);
// 6A8560: using guessed type int __fastcall nvparm_del_str_too_too_long(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00439B9C) --------------------------------------------------------
int __fastcall sub_439B9C(int a1)
{
  int v2; // $s5
  _BOOL4 v3; // $s2
  int v4; // $v0
  char *v5; // $s0
  int v6; // $v0
  int v7; // $s4
  int v8; // $s1
  int v9; // $v0
  int v10; // $s4
  int v11; // $v0
  int v12; // $s2
  int v13; // $s1
  int v14; // $v0
  const char *v15; // $v0
  int v16; // $v0
  _BYTE *v17; // $v0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $v0
  int v21; // $s1
  int v22; // $s2
  int v23; // $v0
  int v24; // $s1
  char *v25; // $a0
  int v26; // $v0
  int v27; // $s1
  const char *v28; // $v0
  int v29; // $v0
  int v30; // $s1
  const char *v31; // $v0
  int v32; // $v0
  int v33; // $s1
  int v34; // $v0
  int v35; // $a2
  int result; // $v0
  const char *v37; // $v0
  unsigned int v38; // $v0
  char v39[128]; // [sp+20h] [-88h] BYREF
  int v40; // [sp+A0h] [-8h]

  memset(v39, 0, sizeof(v39));
  v2 = sq_file_get_max_wan();
  if ( nvram_get_int("mqtt_cli_enable") || nvram_get_int("wysz_wan_out_en") )
    v3 = 1;
  else
    v3 = nvram_get_int("ac_server_128_en") != 0;
  _mem_malloc(0x200000, "sdwan_hi_data", 1462);
  v5 = (char *)v4;
  if ( v4 )
  {
    strcpy((char *)v4, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v4, "{\"code\":0,\"error", 16);
    *(_DWORD *)(v4 + 24) = 975331700;
    v6 = snprintf((char *)(v4 + 29), 2097123, "\"en\":\"%d\"", v3);
    if ( v6 >= 2097123 )
      v6 = 2097122;
    v7 = v6 + 29;
    v8 = 0x200000 - (v6 + 29);
    v9 = snprintf(&v5[v6 + 29], v8, (char *)&dword_6448E0);
    if ( v9 >= v8 )
      v9 = 0x1FFFFF - v7;
    v10 = v9 + v7 + get_wans_data(&v5[v9 + v7], 0x200000 - (v9 + v7));
    v11 = snprintf(&v5[v10], 0x200000 - v10, ",\"vpns\":[ ");
    if ( v11 >= 0x200000 - v10 )
      v11 = 0x1FFFFF - v10;
    v12 = v11 + v10;
    if ( v2 > 0 )
    {
      v13 = 0;
      do
      {
        v14 = jhl_vpnget("vpn_proto", v13);
        v15 = (const char *)nvram_get(v14);
        if ( !v15 || strcmp(v15, (const char *)&off_63F984) )
        {
          v16 = jhl_vpnget("vpn_proto", v13);
          v17 = (_BYTE *)nvram_get(v16);
          if ( !v17 || *v17 )
          {
            v40 = 0x200000;
            v18 = snprintf(&v5[v12], 0x200000 - v12, "{\"iface\":%d,\"id\":%d},", v13, v13 + 101);
            if ( v18 >= 0x200000 - v12 )
              v18 = v40 - 1 - v12;
            v12 += v18;
          }
        }
        ++v13;
      }
      while ( v13 != 5 && v2 != v13 );
    }
    v19 = &v5[v12];
    if ( v5[v12 - 1] == 44 )
      v19 = &v5[--v12];
    v20 = snprintf(v19, 0x200000 - v12, &byte_6445A0);
    if ( v20 >= 0x200000 - v12 )
      v20 = 0x1FFFFF - v12;
    v21 = v12 + v20;
    v22 = 0x200000 - (v12 + v20);
    v23 = snprintf(&v5[v21], v22, ",\"sdwans\":[");
    if ( v23 >= v22 )
      v23 = 0x1FFFFF - v21;
    v24 = v23 + v21 + shared_get_sdwans_data(&v5[v23 + v21], 0x200000 - (v23 + v21));
    v25 = &v5[v24];
    if ( v5[v24 - 1] == 44 )
      v25 = &v5[--v24];
    v26 = snprintf(v25, 0x200000 - v24, &byte_6445A0);
    if ( v26 >= 0x200000 - v24 )
      v26 = 0x1FFFFF - v24;
    v27 = v24 + v26;
    v28 = (const char *)nvram_get("ssid_mr_rule");
    if ( !v28 )
      v28 = "[]";
    v29 = snprintf(&v5[v27], 0x200000 - v27, ",\"ssid_mr_rule\":%s", v28);
    if ( v29 >= 0x200000 - v27 )
      v29 = 0x1FFFFF - v27;
    v30 = v29 + v27;
    v31 = (const char *)nvram_get("ssid_mr_rule_5g");
    if ( !v31 )
      v31 = "[]";
    v32 = snprintf(&v5[v30], 0x200000 - v30, ",\"ssid_mr_rule_5g\":%s", v31);
    if ( v32 >= 0x200000 - v30 )
      v32 = 0x1FFFFF - v30;
    v33 = v32 + v30;
    v34 = snprintf(&v5[v33], 0x200000 - v33, "}}");
    if ( v34 >= 0x200000 - v33 )
      v35 = 0x1FFFFF - v33;
    else
      v35 = v34;
    result = httpd_cgi_ret(a1, v5, v35 + v33, 8);
  }
  else
  {
    v37 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v38 = snprintf(v39, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v37);
    if ( v38 >= 0x80 )
      v38 = 127;
    result = httpd_cgi_ret(a1, v39, v38, 4);
  }
  return result;
}
// 439C58: variable 'v4' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6448E0: using guessed type int dword_6448E0;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8380: using guessed type int __fastcall shared_get_sdwans_data(_DWORD, _DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (0043A1CC) --------------------------------------------------------
int __fastcall sub_43A1CC(int a1)
{
  const char *v2; // $v0
  int v3; // $v0
  const char *v4; // $s6
  const char *v5; // $v0
  unsigned int v6; // $v0
  size_t v7; // $v0
  size_t v8; // $v0
  unsigned int v9; // $s0
  unsigned int v10; // $v0
  size_t v11; // $s2
  char v13[4096]; // [sp+48h] [-3100h] BYREF
  char v14[4096]; // [sp+1048h] [-2100h] BYREF
  char v15[4096]; // [sp+2048h] [-1100h] BYREF
  char v16[128]; // [sp+3048h] [-100h] BYREF
  char v17[128]; // [sp+30C8h] [-80h] BYREF

  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  memset(v13, 0, sizeof(v13));
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  sq_file_get_id(v17, 128);
  v2 = (const char *)custom_tb_version();
  v3 = sprintf(v16, "%s", v2);
  if ( v3 > 0 && v16[v3 - 1] == 45 )
    --v3;
  v16[v3] = 0;
  v4 = (const char *)wayos_version;
  v5 = (const char *)nvram_get("http_lanport");
  if ( !v5 )
    v5 = "";
  v6 = snprintf(
         v14,
         4096,
         "{\"tbv\":\"%s\",\"ver\":\"%s\",\"isap\":%s,\"acstate\":%d,\"apname\":\"%s\",\"gwsn\":\"%s\",\"gwip\":\"%s\",\"g"
         "wport\":%s,\"x86\":%d,\"common\":%d,\"oem\":%d,\"oem_type\":%d,\"ai\":%d",
         v16,
         v4,
         "0",
         0,
         "",
         v17,
         "127.0.0.1",
         v5,
         0,
         0,
         0,
         10,
         3);
  if ( v6 >= 0x1000 )
    v6 = 4095;
  snprintf(&v14[v6], 4096 - v6, "}");
  strcpy(v13, "{\"code\":0,\"error\":\"\",\"data\":\"");
  gbk_to_utf8(v14, v15, 4095);
  v7 = strlen(v15);
  base64_encode(v15, &v13[29], v7);
  v8 = strlen(v13);
  v9 = 4096 - v8;
  v11 = v8;
  v10 = snprintf(&v13[v8], 4096 - v8, "\"}");
  if ( v10 >= v9 )
    v10 = 4095 - v11;
  return httpd_cgi_ret(a1, v13, v10 + v11, 4);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8474: using guessed type int __fastcall base64_encode(_DWORD, _DWORD, _DWORD);
// 6A84E4: using guessed type int __fastcall sq_file_get_id(_DWORD, _DWORD);
// 6A85C8: using guessed type int __fastcall gbk_to_utf8(_DWORD, _DWORD, _DWORD);
// 6A8788: using guessed type int custom_tb_version(void);

//----- (0043A4FC) --------------------------------------------------------
int __fastcall sub_43A4FC(int a1)
{
  char *v2; // $v0
  char *v3; // $v0
  char *v4; // $s1
  const char *v5; // $s2
  const char *v6; // $s6
  int v7; // $v0
  int v8; // $a2
  int v9; // $s7
  unsigned int v10; // $v0
  unsigned int v11; // $s3
  unsigned int v12; // $s5
  unsigned int v13; // $v0
  unsigned int v14; // $s2
  int result; // $v0
  const char *v16; // $v0
  char v17[2048]; // [sp+20h] [-80Ch] BYREF
  int v18; // [sp+820h] [-Ch]
  int v19; // [sp+824h] [-8h] BYREF

  memset(v17, 0, sizeof(v17));
  v18 = 0;
  v2 = httpd_get_parm(a1, "sdfwv23s");
  if ( v2 && !strcmp(v2, "df234") || *(_BYTE *)(a1 + 40) == 2 )
  {
    v4 = httpd_get_parm(a1, "user");
    v3 = httpd_get_parm(a1, "password");
    v5 = v3;
    if ( v3 )
      v6 = v3;
    else
      v6 = "";
    if ( !v4 || !*v4 )
    {
      if ( gl_httpd_high_admin_en && !strcmp(v3, gl_httpd_high_adminpwd) )
      {
        v4 = gl_httpd_high_admin;
      }
      else if ( gl_httpd_admin_en && !strcmp(v5, gl_httpd_adminpwd) )
      {
        v4 = gl_httpd_admin;
      }
      else if ( gl_httpd_user_en && !strcmp(v5, gl_httpd_password) )
      {
        v4 = gl_httpd_user;
      }
      else if ( gl_httpd_guest_user_en && !strcmp(v5, gl_httpd_guest_pwd) )
      {
        v4 = gl_httpd_guest_user;
      }
      else
      {
        v4 = "";
      }
    }
    v7 = httpd_cgi_user_check(v4, v6, &v19);
    v9 = v7;
    if ( v7 <= 0 )
    {
      v14 = 0;
      if ( !v7 )
      {
        v16 = (const char *)_GET_LANG_TEXT(10, *(unsigned __int8 *)(a1 + 210102), v8);
        v14 = snprintf(v17, 2048, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v16);
        if ( v14 >= 0x800 )
          v14 = 2047;
      }
      jhl_user_login_add((_DWORD *)(a1 + 205460), (void *)0x64, v4, 1);
    }
    else
    {
      strcpy(v17, "{\"code\":0,\"error\":\"\",\"data\":{");
      v10 = snprintf(&v17[29], 2019, "\"token\":\"%s\"", "");
      if ( v10 >= 0x7E3 )
        v10 = 2018;
      v11 = v10 + 29;
      v12 = 2048 - (v10 + 29);
      v13 = snprintf(&v17[v10 + 29], v12, "}}");
      if ( v13 >= v12 )
        v13 = 2047 - v11;
      v14 = v13 + v11;
      *(_DWORD *)(a1 + 36) |= 0x1000u;
    }
    ai_send_router_login(a1, v4, v6, v9 > 0, "web");
    result = httpd_cgi_ret(a1, v17, v14, 4);
  }
  else
  {
    httpd_conn_close((int *)a1);
    result = -1;
  }
  return result;
}
// 43A8D4: variable 'v8' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 666170: using guessed type int gl_httpd_admin_en;
// 67D090: using guessed type int gl_httpd_guest_user_en;
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 67D098: using guessed type int gl_httpd_user_en;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0043A91C) --------------------------------------------------------
int __fastcall sub_43A91C(int a1)
{
  char *v1; // $v0
  int v2; // $a2
  const char *v4; // $s0
  int v5; // $a2
  int v6; // $a2
  int v7; // $a1
  char *v8; // $a2
  uint32_t v9; // $v0
  const char *v10; // $v0
  unsigned int v11; // $a2
  unsigned int v13; // $v0
  int v14; // $s2
  unsigned int v15; // $v0
  const char *v16; // $v0
  unsigned int v17; // $v0
  char v18[2048]; // [sp+48h] [-D94h] BYREF
  int v19[256]; // [sp+848h] [-594h] BYREF
  char v20[200]; // [sp+C48h] [-194h] BYREF
  char v21[204]; // [sp+D10h] [-CCh] BYREF

  v1 = httpd_get_parm(a1, "hi");
  if ( v1 )
  {
    v4 = v1;
    memset(v19, 0, sizeof(v19));
    v19[0] = 13;
    v19[3] = 4;
    v19[1] = 1024;
    if ( strchr(v4, 46) || strchr(v4, 58) )
    {
      StrToIpaddr(v4, &v19[4]);
    }
    else
    {
      v9 = J_atoi(v4);
      v19[5] = htonl(v9);
    }
    if ( jianhl_order_opt_fun(v19, v19[1], v5) )
    {
      v7 = *(unsigned __int8 *)(a1 + 210102);
      v8 = "";
    }
    else
    {
      if ( !v19[2] )
      {
        snprintf(v21, 200, "ALL:%u; TCP:%u; UDP:%u; ICMP:%u; OTHER:%u", v19[12], v19[13], v19[14], v19[15], v19[16]);
        snprintf(v20, 200, "ALL:%u; TCP:%u; UDP:%u; ICMP:%u; OTHER:%u", v19[41], v19[42], v19[43], v19[44], v19[45]);
        strcpy(v18, "{\"code\":0,\"error\":\"\",\"data\":{");
        v13 = snprintf(
                &v18[29],
                2019,
                "\"ctm\":%u,\"ct\":%u,\"zct\":%u,\"ct_max\":\"%s\",\"ddos\":\"%s\",\"totqup\":%u,\"totqupk\":%u,\"totqdw\""
                ":%u,\"totqdwk\":%u,\"zup\":%u,\"qzup\":%u,\"zdw\":%u,\"qzdw\":%u",
                v19[10],
                v19[11],
                v19[19],
                v21,
                v20,
                v19[20],
                v19[22],
                v19[21],
                v19[23],
                v19[24],
                v19[25],
                v19[26],
                v19[27]);
        v14 = v13 + 29;
        if ( v13 >= 0x7E3 )
          v14 = 2047;
        v15 = snprintf(&v18[v14], 2048 - v14, "}}");
        if ( v15 >= 2048 - v14 )
          v15 = 2047 - v14;
        v11 = v15 + v14;
        return httpd_cgi_ret(a1, v18, v11, 4);
      }
      if ( v19[2] == 3 )
      {
        v10 = (const char *)_GET_LANG_TEXT(16, *(unsigned __int8 *)(a1 + 210102), v6);
LABEL_14:
        v11 = snprintf(v18, 2048, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
        if ( v11 >= 0x800 )
          v11 = 2047;
        return httpd_cgi_ret(a1, v18, v11, 4);
      }
      v7 = *(unsigned __int8 *)(a1 + 210102);
      if ( v19[2] >= 0x33u || (v8 = (char *)jhlret_err_str[v19[2]]) == 0 )
        v8 = "not find err!";
    }
    v10 = (const char *)_GET_LANG_TEXT(3, v7, v8);
    goto LABEL_14;
  }
  v16 = (const char *)_GET_LANG_TEXT(16, *(unsigned __int8 *)(a1 + 210102), v2);
  v17 = snprintf(v18, 2048, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v16);
  if ( v17 >= 0x800 )
    v17 = 2047;
  return httpd_cgi_ret(a1, v18, v17, 4);
}
// 43A9D4: variable 'v5' is possibly undefined
// 43ACE0: variable 'v2' is possibly undefined
// 43AD68: variable 'v6' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8284: using guessed type int __fastcall StrToIpaddr(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0043AD7C) --------------------------------------------------------
int __fastcall sub_43AD7C(int a1)
{
  char *v1; // $v0
  const char *v2; // $s0
  _DWORD *v3; // $v0
  char *v4; // $v0
  char *v5; // $s2
  _DWORD *v6; // $s3
  int v7; // $a2
  unsigned int v8; // $v0
  int v9; // $a1
  bool v10; // dc
  unsigned int v11; // $v0
  char *v12; // $a2
  uint32_t v13; // $v0
  const char *v14; // $v0
  int v15; // $s0
  _DWORD *v17; // $s0
  int v18; // $s7
  int v19; // $s1
  uint32_t v20; // $a0
  uint32_t v21; // $v0
  uint32_t v22; // $a0
  uint32_t v23; // $s5
  int v24; // $v0
  int v25; // $fp
  uint16_t v26; // $a0
  int v27; // $v0
  uint16_t v28; // $a0
  int v29; // $v0
  uint16_t v30; // $a0
  int v31; // $v0
  uint32_t v32; // $v0
  int v33; // $s1
  int v34; // $t6
  int v35; // $t1
  int v36; // $t2
  int v37; // $t3
  int v38; // $t5
  int v39; // $t7
  int v40; // $s5
  int v41; // $v0
  int v42; // $a0
  int v43; // $v0
  char *v44; // $a0
  int v45; // $v0
  int v46; // $s1
  const char *v47; // $v0
  unsigned int v48; // $v0
  const char *v49; // $v0
  char v50[128]; // [sp+48h] [-E0h] BYREF
  char v51[48]; // [sp+C8h] [-60h] BYREF
  int v52; // [sp+F8h] [-30h]
  int v53; // [sp+FCh] [-2Ch]
  int v54; // [sp+100h] [-28h]
  int v55; // [sp+104h] [-24h]
  int v56; // [sp+108h] [-20h]
  int v57; // [sp+10Ch] [-1Ch]
  int v58; // [sp+110h] [-18h]
  int v59; // [sp+114h] [-14h]
  char *v60; // [sp+118h] [-10h]
  char *format; // [sp+11Ch] [-Ch]
  const char *v62; // [sp+120h] [-8h]
  char *v63; // [sp+124h] [-4h]

  v1 = httpd_get_parm(a1, "hi");
  if ( v1 )
  {
    v2 = v1;
    _mem_malloc(0x200000, "hictlistxx2_data", 1847);
    v5 = v4;
    _mem_malloc(0x100000, "hictlistxx2_data", 1848);
    v6 = v3;
    if ( v5 && v3 )
    {
      *v3 = 13;
      v3[3] = 28;
      v3[1] = 0x100000;
      if ( strchr(v2, 46) || strchr(v2, 58) )
      {
        StrToIpaddr(v2, v6 + 9);
      }
      else
      {
        v13 = J_atoi(v2);
        v6[10] = htonl(v13);
      }
      if ( jianhl_order_opt_fun(v6, v6[1], v7) )
      {
        v9 = *(unsigned __int8 *)(a1 + 210102);
        v12 = "";
        goto LABEL_15;
      }
      v8 = v6[2];
      if ( v8 )
      {
        if ( v8 == 3 )
        {
          v49 = (const char *)_GET_LANG_TEXT(16, *(unsigned __int8 *)(a1 + 210102), "");
          v15 = snprintf(v50, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v49);
          if ( (unsigned int)v15 >= 0x80 )
            v15 = 127;
          goto LABEL_17;
        }
        v9 = *(unsigned __int8 *)(a1 + 210102);
        v10 = v8 >= 0x33;
        v11 = v8;
        if ( v10 || (v12 = (char *)jhlret_err_str[v11]) == 0 )
          v12 = "not find err!";
LABEL_15:
        v14 = (const char *)_GET_LANG_TEXT(3, v9, v12);
        v15 = snprintf(v5, 0x200000, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
        if ( v15 >= 0x200000 )
          v15 = 0x1FFFFF;
LABEL_17:
        _mem_free(v6);
        return httpd_cgi_ret(a1, v5, v15, 8);
      }
      strcpy(v5, "{\"code\":0,\"error\":\"\",\"data\":[");
      qmemcpy(v5, "{\"code\":0,\"error", 16);
      v17 = v6 + 6;
      if ( (int)v6[5] <= 0 )
      {
        v43 = 28;
        v42 = 29;
        v19 = 29;
      }
      else
      {
        v60 = v50;
        format = "{\"mid\":%d,\"nip\":%u,\"fip\":%u,\"nip6\":\"%s\",\"fip6\":\"%s\",\"iport\":%u,\"nport\":%u,\"fport\":%"
                 "u,\"prot\":%d,\"dir\":%d,\"tm\":%u,\"act\":%d,\"ptr\":%lu,";
        v18 = 0;
        v62 = "mr_ct_rule_name";
        v19 = 29;
        v63 = "\"id\":\"%08X\",\"z0\":%u,\"z1\":%u,\"pri0\":%d,\"pri1\":%d,\"n\":\"%s\",\"prif\":%d,\"clt\":%d,\"flag\":%"
              "lu,\"dns\":\"%s\",\"mr_rule\":\"%s\",\"sb_re\":\"%d\",\"show_mr\":\"%d\"},";
        do
        {
          v20 = v17[4];
          v56 = *((unsigned __int16 *)v17 + 29);
          v21 = ntohl(v20);
          v22 = v17[9];
          v55 = v21;
          v23 = ntohl(v22);
          v25 = IpaddrToStr(v51, v17 + 3);
          v24 = IpaddrToStr(v60, v17 + 8);
          v26 = *((_WORD *)v17 + 28);
          v54 = v24;
          v27 = ntohs(v26);
          v28 = *((_WORD *)v17 + 26);
          v53 = v27;
          v29 = ntohs(v28);
          v30 = *((_WORD *)v17 + 27);
          v52 = v29;
          v31 = ntohs(v30);
          v33 = sprintf(
                  &v5[v19],
                  format,
                  v56,
                  v55,
                  v23,
                  v25,
                  v54,
                  v53,
                  v52,
                  v31,
                  *((unsigned __int8 *)v17 + 60),
                  *((unsigned __int8 *)v17 + 61),
                  v17[2],
                  *((unsigned __int8 *)v17 + 64),
                  *v17)
              + v19;
          v32 = ntohl(v17[17]);
          v34 = v17[66];
          v35 = *((unsigned __int8 *)v17 + 62);
          v36 = *((unsigned __int8 *)v17 + 63);
          v37 = *((unsigned __int8 *)v17 + 65);
          v38 = *((unsigned __int8 *)v17 + 66);
          v39 = *((unsigned __int8 *)v17 + 67);
          v59 = v17[26];
          v58 = v34;
          v57 = v35;
          v56 = v36;
          v55 = v37;
          v54 = v38;
          v53 = v39;
          v52 = v32;
          v40 = v17[27];
          v41 = nvram_get_int(v62);
          ++v18;
          v19 = v33
              + sprintf(&v5[v33], v63, v52, v59, v40, v57, v56, v17 + 18, v55, v54, v58, v17 + 34, v17 + 50, v53, v41);
          v17 += 67;
        }
        while ( v18 < v6[5] && 0x200000 - v19 >= 500 );
        v42 = v19;
        if ( v19 <= 0 )
        {
LABEL_28:
          v44 = &v5[v42];
          *v44 = 0;
          v45 = snprintf(v44, 0x200000 - v19, "]}");
          if ( v45 >= 0x200000 - v19 )
            v45 = 0x1FFFFF - v19;
          v46 = v19 + v45;
          _mem_free(v6);
          return jhl_data_giz(a1, v5, v46, 0x200000);
        }
        v43 = v19 - 1;
      }
      if ( v5[v43] == 44 )
        v42 = --v19;
      goto LABEL_28;
    }
    _mem_free(v5);
    _mem_free(v6);
    v47 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  }
  else
  {
    v47 = (const char *)_GET_LANG_TEXT(16, *(unsigned __int8 *)(a1 + 210102), 1847);
  }
  v60 = v50;
  v48 = snprintf(v50, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v47);
  if ( v48 >= 0x80 )
    v48 = 127;
  return httpd_cgi_ret(a1, v60, v48, 4);
}
// 43AE08: variable 'v4' is possibly undefined
// 43AE14: variable 'v3' is possibly undefined
// 43AE70: variable 'v7' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A8284: using guessed type int __fastcall StrToIpaddr(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0043B4C8) --------------------------------------------------------
int __fastcall sub_43B4C8(int a1)
{
  char *v2; // $s3
  char *v3; // $s4
  char *v4; // $s1
  int *v5; // $a2
  const char *v6; // $v0
  char *v7; // $v1
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  int v11; // $a1
  unsigned int v12; // $a2
  const char *v14; // $v0
  uint32_t v15; // $v0
  char v16[1024]; // [sp+20h] [-600h] BYREF
  int v17[128]; // [sp+420h] [-200h] BYREF

  v2 = httpd_get_parm(a1, "ptr");
  v3 = httpd_get_parm(a1, "type");
  v4 = httpd_get_parm(a1, "hi");
  memset(v17, 0, sizeof(v17));
  v17[0] = 13;
  v17[3] = 7;
  v17[1] = 512;
  if ( v3 )
    v17[9] = atoi(v3);
  if ( v4 )
  {
    if ( strchr(v4, 46) || strchr(v4, 58) )
    {
      StrToIpaddr(v4, &v17[4]);
    }
    else
    {
      v15 = J_atoi(v4);
      v17[5] = htonl(v15);
    }
  }
  v5 = &v17[10];
  if ( v2 )
    sscanf(v2, "%lu");
  if ( jianhl_order_opt_fun(v17, v17[1], v5) )
  {
    v14 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
    v12 = snprintf(v16, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v12 >= 0x400 )
      v12 = 1023;
  }
  else
  {
    v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v7 = v16;
    do
    {
      v8 = *(_DWORD *)v6;
      v9 = *((_DWORD *)v6 + 1);
      v10 = *((_DWORD *)v6 + 2);
      v11 = *((_DWORD *)v6 + 3);
      v6 += 16;
      *(_DWORD *)v7 = v8;
      *((_DWORD *)v7 + 1) = v9;
      *((_DWORD *)v7 + 2) = v10;
      *((_DWORD *)v7 + 3) = v11;
      v7 += 16;
    }
    while ( v6 != "}" );
    v12 = 33;
    *(_WORD *)v7 = *(_WORD *)v6;
  }
  return httpd_cgi_ret(a1, v16, v12, 4);
}
// 43B5FC: variable 'v5' is possibly undefined
// 6A8284: using guessed type int __fastcall StrToIpaddr(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0043B748) --------------------------------------------------------
int __fastcall sub_43B748(int a1)
{
  int *v1; // $v0
  int v2; // $a2
  char *v3; // $v0
  char *v4; // $s1
  int *v5; // $fp
  int *v6; // $s0
  int v7; // $s7
  int v8; // $s2
  const char *v9; // $v0
  int v10; // $a0
  int v11; // $v0
  char *v12; // $a0
  int v13; // $v0
  int v14; // $s2
  int result; // $v0
  const char *v16; // $v0
  int v17; // $s0
  const char *v18; // $v0
  unsigned int v19; // $v0
  char v20[128]; // [sp+20h] [-88h] BYREF
  uint32_t v21; // [sp+A0h] [-8h]

  _mem_malloc(0x200000, "qqlist_data", 2036);
  v4 = v3;
  _mem_malloc(0x100000, "qqlist_data", 2037);
  v5 = v1;
  if ( !v4 || !v1 )
  {
    _mem_free(v4);
    _mem_free(v5);
    v18 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v19 = snprintf(v20, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v18);
    if ( v19 >= 0x80 )
      result = httpd_cgi_ret(a1, v20, 127, 4);
    else
      result = httpd_cgi_ret(a1, v20, v19, 4);
    return result;
  }
  *v1 = 13;
  v1[3] = 15;
  v1[1] = 0x100000;
  if ( jianhl_order_opt_fun(v1, 0x100000, v2) )
  {
    v16 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
    v17 = snprintf(v4, 0x200000, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v16);
    _mem_free(v5);
    if ( v17 >= 0x200000 )
      result = httpd_cgi_ret(a1, v4, 0x1FFFFF, 8);
    else
      result = httpd_cgi_ret(a1, v4, v17, 8);
    return result;
  }
  strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":[");
  qmemcpy(v4, "{\"code\":0,\"error", 16);
  v6 = v5 + 6;
  if ( v5[5] <= 0 )
  {
    v11 = 28;
    v10 = 29;
    v8 = 29;
LABEL_9:
    if ( v4[v11] == 44 )
      v10 = --v8;
    goto LABEL_11;
  }
  v7 = 0;
  v8 = 29;
  do
  {
    v21 = ntohl(v6[1]);
    v9 = (const char *)IpaddrToStr(v20, v6);
    ++v7;
    v8 += sprintf(
            &v4[v8],
            "{\"ip\":%u,\"ip6\":\"%s\",\"tp\":\"%s\",\"dt\":\"%s\"},",
            v21,
            v9,
            (const char *)v6 + 20,
            (const char *)v6 + 36);
    v6 += 25;
  }
  while ( v7 < v5[5] );
  v10 = v8;
  if ( v8 > 0 )
  {
    v11 = v8 - 1;
    goto LABEL_9;
  }
LABEL_11:
  v12 = &v4[v10];
  *v12 = 0;
  v13 = snprintf(v12, 0x200000 - v8, "]}");
  if ( v13 >= 0x200000 - v8 )
    v13 = 0x1FFFFF - v8;
  v14 = v8 + v13;
  _mem_free(v5);
  return jhl_data_giz(a1, v4, v14, 0x200000);
}
// 43B7B8: variable 'v3' is possibly undefined
// 43B7C4: variable 'v1' is possibly undefined
// 43B7EC: variable 'v2' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0043BB5C) --------------------------------------------------------
int __fastcall sub_43BB5C(int a1)
{
  void **v1; // $v0
  void **v3; // $s0
  void ***v4; // $v1
  char *v5; // $v1
  const char *v6; // $v0
  int v7; // $t1
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  char v12[516]; // [sp+18h] [-204h] BYREF

  v1 = (void **)user_login_list;
  if ( user_login_list != &user_login_list )
  {
    do
    {
      v3 = (void **)*v1;
      v4 = (void ***)v1[1];
      v3[1] = v4;
      *v4 = v3;
      *v1 = (void *)1048832;
      v1[1] = (void *)2097664;
      _mem_free(v1);
      v1 = v3;
    }
    while ( v3 != &user_login_list );
  }
  user_login_num = 0;
  nvram_set("jhluser_login", " ");
  nvram_commit();
  v5 = v12;
  v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v7 = *(_DWORD *)v6;
    v8 = *((_DWORD *)v6 + 1);
    v9 = *((_DWORD *)v6 + 2);
    v10 = *((_DWORD *)v6 + 3);
    v6 += 16;
    *(_DWORD *)v5 = v7;
    *((_DWORD *)v5 + 1) = v8;
    *((_DWORD *)v5 + 2) = v9;
    *((_DWORD *)v5 + 3) = v10;
    v5 += 16;
  }
  while ( v6 != "}" );
  *(_WORD *)v5 = *(_WORD *)v6;
  return httpd_cgi_ret(a1, v12, 33, 4);
}
// 66B5E0: using guessed type void *user_login_list;
// 67D2E8: using guessed type int user_login_num;
// 6A87C4: using guessed type int nvram_commit(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0043BCA8) --------------------------------------------------------
int __fastcall sub_43BCA8(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  void **v4; // $s0
  int v5; // $s2
  void **v6; // $fp
  const char *v7; // $v0
  int v8; // $a0
  int v9; // $v0
  char *v10; // $a0
  int v11; // $a2
  const char *v13; // $v0
  unsigned int v14; // $a2
  char v15[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(102400, "weblogin_data", 2123);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy(v2, "{\"code\":0,\"error", 16);
    v4 = (void **)user_login_list;
    if ( user_login_list == &user_login_list )
    {
      v9 = 28;
      v8 = 29;
      v5 = 29;
LABEL_7:
      if ( v3[v9] != 44 )
        goto LABEL_8;
    }
    else
    {
      v5 = 29;
      do
      {
        v6 = (void **)*v4;
        v7 = (const char *)IpaddrToStr(v15, v4 + 2);
        v5 += sprintf(&v3[v5], "{\"ip\":\"%s\",\"tm\":%u,\"user\":%u},", v7, v4[7], v4[8]);
        v4 = v6;
        if ( v5 >= 102337 )
        {
          v8 = v5;
          v9 = v5 - 1;
          goto LABEL_7;
        }
      }
      while ( v6 != &user_login_list );
      v8 = v5;
      if ( v5 <= 0 || v3[v5 - 1] != 44 )
        goto LABEL_8;
    }
    v8 = --v5;
LABEL_8:
    v10 = &v3[v8];
    *v10 = 0;
    v11 = snprintf(v10, 102400 - v5, "]}");
    if ( v11 >= 102400 - v5 )
      v11 = 102399 - v5;
    return httpd_cgi_ret(a1, v3, v5 + v11, 8);
  }
  v13 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v14 = snprintf(v15, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
  if ( v14 >= 0x100 )
    v14 = 255;
  return httpd_cgi_ret(a1, v15, v14, 4);
}
// 43BD0C: variable 'v2' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 66B5E0: using guessed type void *user_login_list;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);

//----- (0043BF50) --------------------------------------------------------
int __fastcall sub_43BF50(int a1)
{
  char *v1; // $v0
  char *v3; // $s0
  int v4; // $s4
  char *v5; // $v0
  char *v6; // $s0
  int v7; // $a2
  const char *v8; // $v0
  unsigned int v9; // $a2
  int result; // $v0
  int v11; // $v0
  int v12; // $s1
  int v13; // $s4
  int v14; // $v0
  const char *v15; // $v0
  unsigned int v16; // $v0
  _QWORD v17[128]; // [sp+58h] [-400h] BYREF

  v1 = httpd_get_parm(a1, "iface");
  if ( v1 )
  {
    v3 = v1;
    LOWORD(v4) = 0;
    if ( strcmp(v1, "all") )
    {
      v4 = J_atoi(v3);
      if ( v4 < 101 )
        LOWORD(v4) = v4 + 1;
    }
  }
  else
  {
    LOWORD(v4) = 2;
  }
  _mem_malloc(102400, "wanll_tu_data", 364);
  v6 = v5;
  if ( v5 )
  {
    memset(v17, 0, sizeof(v17));
    v17[0] = 0x4000000000ELL;
    HIDWORD(v17[1]) = 4;
    LOWORD(v17[4]) = v4;
    if ( jianhl_order_opt_fun(v17, 1024, v7) )
    {
      v8 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
      v9 = snprintf((char *)v17, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
      if ( v9 >= 0x400 )
        v9 = 1023;
    }
    else
    {
      strcpy(v6, "{\"code\":0,\"error\":\"\",\"data\":{");
      qmemcpy(v6, "{\"code\":0,\"error", 16);
      v11 = snprintf(
              v6 + 29,
              102371,
              "\"totup\":%llu,\"totqup\":%llu,\"totupk\":%lu,\"totqupk\":%lu,\"totdw\":%llu,\"totqdw\":%llu,\"totdwk\":%l"
              "u,\"totqdwk\":%lu,\"zup\":%lu,\"zdw\":%lu,\"qzup\":%lu,\"qzdw\":%lu",
              v17[8],
              v17[16],
              LODWORD(v17[9]),
              LODWORD(v17[17]),
              v17[10],
              v17[18],
              LODWORD(v17[11]),
              LODWORD(v17[19]),
              LODWORD(v17[5]),
              HIDWORD(v17[5]),
              LODWORD(v17[7]),
              HIDWORD(v17[7]));
      if ( v11 >= 102371 )
        v11 = 102370;
      v12 = v11 + 29;
      v13 = 102400 - (v11 + 29);
      v14 = snprintf(&v6[v11 + 29], v13, "}}");
      if ( v14 >= v13 )
        v14 = 102399 - v12;
      v9 = v14 + v12;
    }
    result = httpd_cgi_ret(a1, v6, v9, 8);
  }
  else
  {
    v15 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v16 = snprintf((char *)v17, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v15);
    if ( v16 >= 0x400 )
      v16 = 1023;
    result = httpd_cgi_ret(a1, (char *)v17, v16, 4);
  }
  return result;
}
// 43BFE0: variable 'v5' is possibly undefined
// 43C024: variable 'v7' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0043C2EC) --------------------------------------------------------
int __fastcall sub_43C2EC(int a1)
{
  char *v1; // $s6
  int v2; // $v0
  int v3; // $s3
  int v4; // $s7
  int v5; // $fp
  const char *v6; // $v0
  unsigned int v7; // $v0
  int v8; // $v0
  unsigned int v9; // $v0
  char v11[1024]; // [sp+18h] [-C08h] BYREF
  char v12[1024]; // [sp+418h] [-808h] BYREF
  char v13[1024]; // [sp+818h] [-408h] BYREF
  char *v14; // [sp+C18h] [-8h]

  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  jhl_parm_get_def("port_desc", v12, 1024);
  v1 = v11;
  v14 = v11;
  strcpy(v13, "{\"code\":0,\"error\":\"\",\"data\":[");
  v2 = split_string(v12, 124, v11, 256);
  if ( v2 <= 0 )
  {
    v8 = 28;
    v5 = 29;
LABEL_7:
    if ( v14[v8 + 2048] == 44 )
      v5 = v8;
    goto LABEL_9;
  }
  v3 = v2;
  v4 = 0;
  v5 = 29;
  do
  {
    v6 = (const char *)get_json_data(*(_DWORD *)v1);
    v7 = snprintf(&v13[v5], 1024 - v5, "\"%s\",", v6);
    ++v4;
    if ( v7 >= 1024 - v5 )
      v7 = 1023 - v5;
    v5 += v7;
    v1 += 4;
  }
  while ( v3 != v4 );
  v8 = v5 - 1;
  if ( v5 > 0 )
    goto LABEL_7;
LABEL_9:
  v14[v5 + 2048] = 0;
  v9 = snprintf(&v13[v5], 1024 - v5, "]}");
  if ( v9 >= 1024 - v5 )
    v9 = 1023 - v5;
  return httpd_cgi_ret(a1, v13, v9 + v5, 4);
}
// 642A04: using guessed type __int16 word_642A04;
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8988: using guessed type int __fastcall jhl_parm_get_def(_DWORD, _DWORD, _DWORD);

//----- (0043C524) --------------------------------------------------------
int __fastcall sub_43C524(int a1)
{
  char *v1; // $s2
  int v2; // $s3
  int v3; // $s0
  int v4; // $s7
  const char **v5; // $s6
  int v6; // $fp
  const char *v7; // $a3
  char *v8; // $a0
  unsigned int v9; // $v0
  char *v10; // $a0
  int v11; // $a0
  char *v12; // $v1
  const char *v13; // $v0
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  unsigned int v18; // $a2
  int v20; // $a1
  void *v21; // $a2
  const char *v22; // $v0
  char *v23; // $v0
  char v24[1024]; // [sp+20h] [-1018h] BYREF
  char v25[1024]; // [sp+420h] [-C18h] BYREF
  char v26[1024]; // [sp+820h] [-818h] BYREF
  char v27[1024]; // [sp+C20h] [-418h] BYREF
  const char *v28; // [sp+1020h] [-18h]
  char *v29; // [sp+1024h] [-14h]
  char *s; // [sp+1028h] [-10h]
  char *v31; // [sp+102Ch] [-Ch]
  char *v32; // [sp+1030h] [-8h]

  s = v27;
  memset(v27, 0, sizeof(v27));
  memset(v26, 0, sizeof(v26));
  memset(v25, 0, sizeof(v25));
  v1 = httpd_get_parm(a1, "mod_vid");
  v31 = httpd_get_parm(a1, "desc");
  if ( v1 )
  {
    if ( v31 )
    {
      v32 = "a";
      v2 = atoi(v1);
      v29 = v24;
      jhl_parm_get_def("port_desc", v26, 1024);
      v3 = split_string(v26, 124, v24, 256);
      if ( v2 >= v3 )
        v3 = v2 + 1;
      v4 = 0;
      if ( v3 > 0 )
      {
        v5 = (const char **)v29;
        v28 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
        v6 = 0;
        do
        {
          if ( v2 == v6 )
          {
            v23 = v31;
            *v5 = v31;
            v8 = &v25[v4];
            v7 = v23;
          }
          else
          {
            v7 = *v5;
            v8 = &v25[v4];
            if ( !*v5 )
              v7 = v28 - 1556;
          }
          v9 = snprintf(v8, 1024 - v4, "%s|", v7);
          ++v6;
          if ( v9 >= 1024 - v4 )
            v9 = 1023 - v4;
          v4 += v9;
          ++v5;
        }
        while ( v3 != v6 );
        if ( v4 > 0 && v29[v4 + 1023] == 124 )
          --v4;
      }
      v10 = v32 + 11480;
      v29[v4 + 1024] = 0;
      nvram_set(v10, v25);
      jhl_parm_commit(v11);
      v12 = s;
      v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v14 = *(_DWORD *)v13;
        v15 = *((_DWORD *)v13 + 1);
        v16 = *((_DWORD *)v13 + 2);
        v17 = *((_DWORD *)v13 + 3);
        v13 += 16;
        *(_DWORD *)v12 = v14;
        *((_DWORD *)v12 + 1) = v15;
        *((_DWORD *)v12 + 2) = v16;
        *((_DWORD *)v12 + 3) = v17;
        v12 += 16;
      }
      while ( v13 != "}" );
      v18 = 33;
      *(_WORD *)v12 = *(_WORD *)v13;
      return httpd_cgi_ret(a1, s, v18, 4);
    }
    v20 = *(unsigned __int8 *)(a1 + 210102);
    v21 = &unk_642CF0;
  }
  else
  {
    v20 = *(unsigned __int8 *)(a1 + 210102);
    v21 = &unk_642CE4;
  }
  v22 = (const char *)_GET_LANG_TEXT(12, v20, v21);
  v18 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v22);
  if ( v18 >= 0x400 )
    v18 = 1023;
  return httpd_cgi_ret(a1, s, v18, 4);
}
// 43C740: variable 'v11' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8988: using guessed type int __fastcall jhl_parm_get_def(_DWORD, _DWORD, _DWORD);

//----- (0043C894) --------------------------------------------------------
int __fastcall sub_43C894(int a1)
{
  char *v1; // $v0
  int v2; // $v0
  int v3; // $s2
  int v4; // $s6
  int v5; // $fp
  int v6; // $s7
  int v7; // $s0
  int v8; // $s4
  int v9; // $s3
  int v10; // $v0
  int v11; // $s5
  unsigned int v12; // $s0
  const char *v13; // $a2
  const char *v14; // $v0
  unsigned int v15; // $v0
  int v16; // $v0
  char *v17; // $s5
  int v18; // $s0
  char *v19; // $v0
  char *v20; // $s6
  int v21; // $v0
  char *v22; // $a0
  char *v23; // $v1
  const char *v24; // $v0
  int v25; // $t0
  int v26; // $a3
  int v27; // $a2
  int v28; // $a1
  int v29; // $a1
  int v30; // $a0
  char v31; // $v0
  int v32; // $s5
  int v33; // $v0
  const char *v34; // $v0
  char *v35; // $a3
  char *v36; // $a0
  const char *v37; // $v1
  int v38; // $a0
  char *v39; // $v1
  const char *v40; // $v0
  int v41; // $t0
  int v42; // $a3
  int v43; // $a2
  int v44; // $a1
  int v46; // $v0
  _DWORD *v47; // $v1
  const char *v48; // $v0
  int v49; // $t0
  int v50; // $a3
  int v51; // $a2
  int v52; // $a1
  int v53; // $a1
  int v54; // $a0
  char v55; // $v0
  char v56[512]; // [sp+28h] [-540h] BYREF
  char v57[512]; // [sp+228h] [-340h] BYREF
  char v58[256]; // [sp+428h] [-140h] BYREF
  char *nptr; // [sp+528h] [-40h] BYREF
  char *v60; // [sp+52Ch] [-3Ch]
  const char *v61; // [sp+530h] [-38h]
  const char *v62; // [sp+534h] [-34h]
  int v63; // [sp+538h] [-30h]
  int v64; // [sp+53Ch] [-2Ch]
  char *v65; // [sp+540h] [-28h]
  const char *v66; // [sp+544h] [-24h]
  const char *v67; // [sp+548h] [-20h]
  char *v68; // [sp+54Ch] [-1Ch]
  char *format; // [sp+550h] [-18h]
  void *s; // [sp+554h] [-14h]
  int v71; // [sp+558h] [-10h]
  const char *v72; // [sp+55Ch] [-Ch]
  char *v73; // [sp+560h] [-8h]

  memset(v57, 0, sizeof(v57));
  s = v56;
  memset(v56, 0, sizeof(v56));
  v73 = v58;
  nptr = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  memset(v58, 0, sizeof(v58));
  v1 = httpd_get_parm(a1, "mod_vid");
  if ( v1 )
    v71 = atoi(v1);
  else
    v71 = -1;
  memset(s, 0, 0x200u);
  v2 = httpd_get_json_parm(a1, (int)"all");
  v3 = v2;
  if ( v2 )
  {
    v4 = cJSON_GetArraySize(v2);
    if ( v4 <= 0 )
    {
LABEL_15:
      v16 = v57[0];
      v17 = v57;
      if ( v57[0] == 48 )
      {
        v18 = 0;
        goto LABEL_17;
      }
    }
    else
    {
      v65 = "1\"";
      v66 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
      v72 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
      v67 = "port";
      v68 = "m";
      v5 = 0;
      v6 = 0;
      format = "%s|%s|%s|%s>";
      while ( 1 )
      {
        v7 = cJSON_GetArrayItem(v3, v5);
        v8 = cJSON_GetObjectItem(v7, v67);
        v9 = cJSON_GetObjectItem(v7, v68);
        v11 = cJSON_GetObjectItem(v7, v65 - 31056);
        v10 = cJSON_GetObjectItem(v7, v66 + 6420);
        if ( !v8 || !v9 )
          break;
        v12 = 512 - v6;
        if ( v11 )
          v13 = *(const char **)(v11 + 16);
        else
          v13 = v72 - 1556;
        if ( v10 )
          v14 = *(const char **)(v10 + 16);
        else
          v14 = v72 - 1556;
        v15 = snprintf(&v57[v6], v12, format, *(_DWORD *)(v8 + 16), *(_DWORD *)(v9 + 16), v13, v14);
        if ( v15 >= v12 )
          v15 = 511 - v6;
        ++v5;
        v6 += v15;
        if ( v4 == v5 )
          goto LABEL_15;
      }
      v57[0] = 0;
    }
  }
  v23 = v73;
  v24 = "0|0>1|0>2|0>3|0>4|0>5|0>6|0>7|0>8|0>9|0>";
  do
  {
    v25 = *(_DWORD *)v24;
    v26 = *((_DWORD *)v24 + 1);
    v27 = *((_DWORD *)v24 + 2);
    v28 = *((_DWORD *)v24 + 3);
    v24 += 16;
    *(_DWORD *)v23 = v25;
    *((_DWORD *)v23 + 1) = v26;
    *((_DWORD *)v23 + 2) = v27;
    *((_DWORD *)v23 + 3) = v28;
    v23 += 16;
  }
  while ( v24 != "8|0>9|0>" );
  v29 = *(_DWORD *)v24;
  v30 = *((_DWORD *)v24 + 1);
  v31 = v24[8];
  *(_DWORD *)v23 = v29;
  *((_DWORD *)v23 + 1) = v30;
  v23[8] = v31;
  v16 = v58[0];
  v17 = v73;
  v18 = 0;
LABEL_17:
  while ( v16 )
  {
    v19 = strchr(v17, 62);
    v20 = v19;
    if ( v19 )
    {
      *v19 = 0;
      v21 = split_string(v17, 124, &nptr, 4);
      v22 = v20 + 1;
      if ( v21 != 4 )
        goto LABEL_20;
      ++v20;
    }
    else if ( split_string(v17, 124, &nptr, 4) != 4 )
    {
      break;
    }
    v32 = atoi(nptr);
    if ( v71 == -1 || (v33 = atoi(nptr), v71 == v33) )
    {
      v46 = atoi(v60);
      set_link_status_by_id(v32, v46);
      v34 = v61;
      v35 = v60;
      v36 = (char *)s + v18;
      if ( v61 )
      {
LABEL_32:
        v37 = v62;
        if ( !v62 )
          goto LABEL_41;
        goto LABEL_33;
      }
    }
    else
    {
      v34 = v61;
      v35 = v60;
      v36 = (char *)s + v18;
      if ( v61 )
        goto LABEL_32;
    }
    v37 = v62;
    v34 = "";
    if ( !v62 )
LABEL_41:
      v37 = "";
LABEL_33:
    v18 += sprintf(v36, "%d|%s|%s|%s>", v32, v35, v34, v37);
    v22 = v20;
LABEL_20:
    if ( !v22 )
      break;
    v16 = *v22;
    v17 = v22;
  }
  if ( !v56[0] )
  {
    v47 = s;
    v48 = "0|0>1|0>2|0>3|0>4|0>5|0>6|0>7|0>8|0>9|0>";
    do
    {
      v49 = *(_DWORD *)v48;
      v50 = *((_DWORD *)v48 + 1);
      v51 = *((_DWORD *)v48 + 2);
      v52 = *((_DWORD *)v48 + 3);
      v48 += 16;
      *v47 = v49;
      v47[1] = v50;
      v47[2] = v51;
      v47[3] = v52;
      v47 += 4;
    }
    while ( v48 != "8|0>9|0>" );
    v53 = *(_DWORD *)v48;
    v54 = *((_DWORD *)v48 + 1);
    v55 = v48[8];
    *v47 = v53;
    v47[1] = v54;
    *((_BYTE *)v47 + 8) = v55;
  }
  nvram_set("port_mode", s);
  jhl_parm_commit(v38);
  v39 = v57;
  v40 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v41 = *(_DWORD *)v40;
    v42 = *((_DWORD *)v40 + 1);
    v43 = *((_DWORD *)v40 + 2);
    v44 = *((_DWORD *)v40 + 3);
    v40 += 16;
    *(_DWORD *)v39 = v41;
    *((_DWORD *)v39 + 1) = v42;
    *((_DWORD *)v39 + 2) = v43;
    *((_DWORD *)v39 + 3) = v44;
    v39 += 16;
  }
  while ( v40 != "}" );
  *(_WORD *)v39 = *(_WORD *)v40;
  return httpd_cgi_ret(a1, v57, 33, 4);
}
// 43CD20: variable 'v38' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8228: using guessed type int __fastcall set_link_status_by_id(_DWORD, _DWORD);
// 6A8518: using guessed type int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD);
// 6A86FC: using guessed type int __fastcall cJSON_GetArraySize(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0043CE78) --------------------------------------------------------
int __fastcall sub_43CE78(int a1)
{
  const char *v1; // $s0
  char *v2; // $v0
  int v3; // $s2
  char *v4; // $v0
  const char *v5; // $s1
  int v6; // $s1
  unsigned int v7; // $v0
  int v9; // $s0
  int v10; // $s7
  int v11; // $s5
  int v12; // $v0
  int v13[1024]; // [sp+28h] [-1170h] BYREF
  char v14[256]; // [sp+1028h] [-170h] BYREF
  char v15[64]; // [sp+1128h] [-70h] BYREF
  char *nptr[2]; // [sp+1168h] [-30h] BYREF
  int v17; // [sp+1170h] [-28h]
  int v18; // [sp+1174h] [-24h]
  int v19; // [sp+1180h] [-18h] BYREF
  char *v20; // [sp+1188h] [-10h]
  char *format; // [sp+118Ch] [-Ch]
  const char *v22; // [sp+1190h] [-8h]

  memset(v13, 0, sizeof(v13));
  v1 = v14;
  memset(v14, 0, sizeof(v14));
  v2 = (char *)nvram_get("port_mode");
  if ( !v2 )
    v2 = "0|0>1|0>2|0>3|0>4|0>5|0>6|0>7|0>8|0>9|0>";
  strcpy(v14, v2);
  v3 = 44;
  qmemcpy(v13, "{\"code\":0,\"error\":\"\",\"data\":{\"poe\":0,\"all", 41);
  *(int *)((char *)&v13[10] + 1) = (int)&unk_5B3A22;
  format = "{\"n\":\"%s\",\"m\":%s,\"s\":%d,\"d\":\"%s\",\"p\":%lu,\"port\":%d},";
  v22 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
  while ( *v1 )
  {
    v4 = strchr(v1, 62);
    if ( !v4 )
    {
      v5 = 0;
      if ( split_string(v1, 124, nptr, 4) < 2 )
        break;
      goto LABEL_15;
    }
    *v4 = 0;
    v5 = v4 + 1;
    if ( split_string(v1, 124, nptr, 4) >= 2 )
    {
LABEL_15:
      v9 = atoi(nptr[0]);
      get_ifname_by_id(v9, v15);
      get_link_status_by_id(v9, &v19);
      v10 = v17;
      v11 = v19;
      if ( !v17 )
        v10 = (int)(v22 - 1556);
      v20 = nptr[1];
      v12 = J_atoi(v18);
      v3 += sprintf((char *)v13 + v3, format, v15, v20, v11, v10, v12, v9);
      v1 = v5;
      if ( !v5 )
        break;
    }
    else
    {
      v1 = v5;
      if ( !v5 )
        break;
    }
  }
  if ( v3 > 0 && *((_BYTE *)v13 + v3 - 1) == 44 )
    --v3;
  v6 = v3 + 1;
  *(_WORD *)((char *)v13 + v3) = 93;
  v7 = snprintf((char *)v13 + v3 + 1, 4096 - (v3 + 1), "}}");
  if ( v7 >= 4096 - (v3 + 1) )
    v7 = 4095 - v6;
  return httpd_cgi_ret(a1, (char *)v13, v7 + v6, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8218: using guessed type int __fastcall get_link_status_by_id(_DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8968: using guessed type int __fastcall get_ifname_by_id(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0043D1CC) --------------------------------------------------------
int __fastcall sub_43D1CC(int a1)
{
  char *v2; // $v1
  const char *v3; // $v0
  int v4; // $t0
  int v5; // $a3
  int v6; // $a2
  int v7; // $a1
  char v9[128]; // [sp+18h] [-94h] BYREF
  int v10[5]; // [sp+98h] [-14h] BYREF

  memset(v9, 0, sizeof(v9));
  v10[0] = (int)"wys";
  v10[1] = (int)"dns";
  v10[2] = (int)"dnsc_clear";
  v10[3] = 0;
  eval(v10, 0, 0, 0);
  v2 = v9;
  v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v4 = *(_DWORD *)v3;
    v5 = *((_DWORD *)v3 + 1);
    v6 = *((_DWORD *)v3 + 2);
    v7 = *((_DWORD *)v3 + 3);
    v3 += 16;
    *(_DWORD *)v2 = v4;
    *((_DWORD *)v2 + 1) = v5;
    *((_DWORD *)v2 + 2) = v6;
    *((_DWORD *)v2 + 3) = v7;
    v2 += 16;
  }
  while ( v3 != "}" );
  *(_WORD *)v2 = *(_WORD *)v3;
  return httpd_cgi_ret(a1, v9, 33, 4);
}
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043D2C4) --------------------------------------------------------
int __fastcall sub_43D2C4(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $s1
  int *v5; // $v1
  const char *v6; // $v0
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  int v10; // $a1
  const char *v12; // $s3
  int v13[33]; // [sp+18h] [-84h] BYREF

  v3 = httpd_get_parm(a1, "act");
  v2 = httpd_get_parm(a1, "action_iface");
  if ( v3 )
  {
    v4 = (int)v2;
    if ( v2 )
    {
      if ( !strcmp(v3, "stop") )
      {
        v12 = "stop";
      }
      else
      {
        if ( strcmp(v3, "restart") )
          goto LABEL_5;
        v12 = "restart";
      }
      v13[0] = (int)"wan_conn";
      v13[1] = (int)v12;
      v13[2] = v4;
      v13[3] = (int)"wan_connect_asp";
      v13[4] = 0;
      eval_nowait(v13, 0, 0, 0);
      goto LABEL_5;
    }
  }
LABEL_5:
  v5 = v13;
  v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v7 = *(_DWORD *)v6;
    v8 = *((_DWORD *)v6 + 1);
    v9 = *((_DWORD *)v6 + 2);
    v10 = *((_DWORD *)v6 + 3);
    v6 += 16;
    *v5 = v7;
    v5[1] = v8;
    v5[2] = v9;
    v5[3] = v10;
    v5 += 4;
  }
  while ( v6 != "}" );
  *(_WORD *)v5 = *(_WORD *)v6;
  return httpd_cgi_ret(a1, (char *)v13, 33, 4);
}
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0043D448) --------------------------------------------------------
int __fastcall sub_43D448(int a1)
{
  const char *v2; // $s0
  const char *v3; // $s1
  const char *v4; // $s2
  const char *v5; // $v0
  unsigned int v6; // $v0
  int v7; // $s0
  unsigned int v8; // $v0
  char v10[2052]; // [sp+28h] [-804h] BYREF

  strcpy(v10, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("wan_itv_en");
  v3 = (const char *)jhl_nv_get_def("wan_itv_vid");
  v4 = (const char *)jhl_nv_get_def("wan_itv_port");
  v5 = (const char *)jhl_nv_get_def("vlan_name");
  v6 = snprintf(&v10[29], 2019, "\"en\":%s,\"vid\":%s,\"port\":%s,\"vlan_name\":\"%s\"", v2, v3, v4, v5);
  v7 = v6 + 29;
  if ( v6 >= 0x7E3 )
    v7 = 2047;
  v8 = snprintf(&v10[v7], 2048 - v7, "}}");
  if ( v8 >= 2048 - v7 )
    v8 = 2047 - v7;
  return httpd_cgi_ret(a1, v10, v8 + v7, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0043D5D4) --------------------------------------------------------
int __fastcall sub_43D5D4(int a1)
{
  const char *v2; // $s0
  const char *v3; // $v0
  unsigned int v4; // $v0
  int v5; // $s0
  unsigned int v6; // $v0
  char v8[1028]; // [sp+20h] [-404h] BYREF

  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("igmp_snooping_mode");
  v3 = (const char *)jhl_nv_get_def("igmp_snooping_ips");
  v4 = snprintf(&v8[29], 995, "\"mode\":\"%s\",\"ips\":\"%s\"", v2, v3);
  v5 = v4 + 29;
  if ( v4 >= 0x3E3 )
    v5 = 1023;
  v6 = snprintf(&v8[v5], 1024 - v5, "}}");
  if ( v6 >= 1024 - v5 )
    v6 = 1023 - v5;
  return httpd_cgi_ret(a1, v8, v6 + v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0043D720) --------------------------------------------------------
int __fastcall sub_43D720(int a1)
{
  int v2; // $v0
  int v3; // $s1
  bool v4; // dc
  int v5; // $v0
  unsigned int v6; // $v0
  char v8[1028]; // [sp+18h] [-404h] BYREF

  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = get_nvarms((const char **)base_network_nvarms_dns, (int)&v8[29], 995);
  v3 = v2 + 29;
  v4 = v2 + 29 <= 0;
  v5 = v2 + 28;
  if ( !v4 && v8[v5] == 44 )
    v3 = v5;
  v8[v3] = 0;
  v6 = snprintf(&v8[v3], 1024 - v3, "}}");
  if ( v6 >= 1024 - v3 )
    v6 = 1023 - v3;
  return httpd_cgi_ret(a1, v8, v6 + v3, 4);
}
// 642164: using guessed type __int16 word_642164;
// 66E2E0: using guessed type char *base_network_nvarms_dns[4];

//----- (0043D854) --------------------------------------------------------
int __fastcall sub_43D854(int a1)
{
  int v2; // $a0
  const char *v3; // $v0
  char *v4; // $v1
  int v5; // $t1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  char v10[256]; // [sp+18h] [-100h] BYREF

  if ( set_nvrams(a1, base_network_nvarms_dns, 1) )
  {
    dns_srv_start();
    jhl_parm_commit(v2);
  }
  v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v4 = v10;
  do
  {
    v5 = *(_DWORD *)v3;
    v6 = *((_DWORD *)v3 + 1);
    v7 = *((_DWORD *)v3 + 2);
    v8 = *((_DWORD *)v3 + 3);
    v3 += 16;
    *(_DWORD *)v4 = v5;
    *((_DWORD *)v4 + 1) = v6;
    *((_DWORD *)v4 + 2) = v7;
    *((_DWORD *)v4 + 3) = v8;
    v4 += 16;
  }
  while ( v3 != "}" );
  *(_WORD *)v4 = *(_WORD *)v3;
  return httpd_cgi_ret(a1, v10, 33, 4);
}
// 43D8B0: variable 'v2' is possibly undefined
// 66E2E0: using guessed type char *base_network_nvarms_dns[4];
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8300: using guessed type int dns_srv_start(void);

//----- (0043D92C) --------------------------------------------------------
int __fastcall sub_43D92C(int a1)
{
  unsigned __int16 *v1; // $v0
  int v2; // $a2
  int v3; // $v0
  int v4; // $s5
  unsigned __int16 *v5; // $s7
  int v6; // $a1
  int v7; // $a2
  int v8; // $a0
  const char *v9; // $v0
  unsigned int v10; // $s0
  char *v11; // $a1
  int v12; // $a3
  int v13; // $a2
  unsigned __int16 *v15; // $s1
  int v16; // $v1
  int v17; // $v0
  unsigned __int16 *v18; // $fp
  int v19; // $s0
  int v20; // $s6
  char *v21; // $s4
  int v22; // $v0
  int v23; // $s6
  char *v24; // $s4
  int v25; // $v0
  int v26; // $s0
  int v27; // $v0
  _BOOL4 v28; // $a0
  _BYTE *v29; // $v0
  int v30; // $s0
  int v31; // $s6
  const char *v32; // $s1
  const char *v33; // $v0
  int v34; // $s6
  int v35; // $v0
  int v36; // $s6
  int v37; // $v0
  int v38; // $v1
  const char *v39; // $v0
  char v40[102400]; // [sp+28h] [-19160h] BYREF
  _BYTE v41[256]; // [sp+19028h] [-160h] BYREF
  _BYTE v42[64]; // [sp+19128h] [-60h] BYREF
  int v43; // [sp+19168h] [-20h]
  char *v44; // [sp+1916Ch] [-1Ch]
  int v45; // [sp+19170h] [-18h]
  unsigned __int16 *v46; // [sp+19174h] [-14h]
  char *v47; // [sp+19178h] [-10h]
  char *v48; // [sp+1917Ch] [-Ch]
  char *v49; // [sp+19180h] [-8h]
  _BYTE *v50; // [sp+19184h] [-4h]

  v48 = "a";
  _mem_malloc(0x200000, "dns_cache_list_data", 2826);
  v4 = v3;
  _mem_malloc(0x100000, "dns_cache_list_data", 2827);
  v5 = v1;
  if ( !v4 )
  {
    v39 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v44 = v40;
    v10 = snprintf(v40, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v39);
    if ( v10 >= 0x80 )
      v10 = 127;
    goto LABEL_8;
  }
  if ( !v1 )
  {
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v7 = 0x200000;
    v8 = 4;
    goto LABEL_5;
  }
  *(_DWORD *)v1 = 4;
  *((_DWORD *)v1 + 3) = 3;
  *((_DWORD *)v1 + 1) = 0x100000;
  if ( jianhl_order_opt_fun(v1, 0x100000, v2) )
  {
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v7 = (int)"";
    v8 = 3;
LABEL_5:
    v9 = (const char *)_GET_LANG_TEXT(v8, v6, v7);
    v44 = v40;
    v10 = snprintf(v40, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 >= 0x80 )
      v10 = 127;
    _mem_free((void *)v4);
LABEL_8:
    if ( v5 )
      _mem_free(v5);
    v11 = v44;
    v12 = 4;
    v13 = v10;
    return httpd_cgi_ret(a1, v11, v13, v12);
  }
  qmemcpy((void *)v4, "{\"code\":0,\"error\":\"\",\"data\":{\"all", 33);
  qmemcpy((void *)v4, "{\"code\":0,\"error", 16);
  *(_DWORD *)(v4 + 24) = 975331700;
  *(_BYTE *)(v4 + 32) = 108;
  *(_DWORD *)(v4 + 33) = &unk_5B3A22;
  if ( !nvram_match_def("dnsEn", "0") )
  {
    v15 = v5 + 12;
    if ( *((int *)v5 + 5) <= 0 )
    {
      v43 = 36;
      v38 = 35;
      v37 = 36;
      v44 = v40;
    }
    else
    {
      v44 = v40;
      v49 = "a";
      v47 = "a";
      v45 = 0;
      v43 = 36;
      v50 = v41;
      do
      {
        v16 = *((_DWORD *)v15 + 1);
        v17 = *v15;
        v46 = v15 + 10;
        v18 = (unsigned __int16 *)((char *)v15 + v16 + 20);
        v19 = 0;
        if ( v17 )
        {
          v20 = 0;
          v21 = v47 + 11868;
          do
          {
            v22 = IpToStr(v42, *(_DWORD *)v18);
            ++v20;
            v19 += sprintf(&v41[v19], v21, v22);
            v18 += 2;
          }
          while ( v20 < *v15 );
        }
        if ( v15[1] )
        {
          v23 = 0;
          v24 = v47 + 11868;
          do
          {
            v25 = Ip6ToStr(v42, v18);
            ++v23;
            v19 += sprintf(&v41[v19], v24, v25);
            v18 += 8;
          }
          while ( v23 < v15[1] );
        }
        v44[v19 + 102399] = 0;
        v26 = v43;
        v27 = sprintf(
                (char *)(v4 + v43),
                v49 + 11872,
                v46,
                v50,
                *((_DWORD *)v15 + 4),
                *((_DWORD *)v15 + 2),
                *((unsigned __int8 *)v15 + 12),
                *((unsigned __int8 *)v15 + 13));
        v28 = ++v45 < *((_DWORD *)v5 + 5);
        v43 = v26 + v27;
        if ( !v28 )
          break;
        v15 = v18;
      }
      while ( 0x200000 - v43 >= 100 );
      if ( v43 <= 0 )
      {
        v37 = v43;
LABEL_33:
        v29 = (_BYTE *)(v4 + v37);
        v31 = v43 + 1;
        *v29 = 0;
        v30 = v31;
        goto LABEL_26;
      }
      v37 = v43;
      v38 = v43 - 1;
    }
    if ( *(_BYTE *)(v4 + v38) == 44 )
      v37 = --v43;
    goto LABEL_33;
  }
  v29 = (_BYTE *)(v4 + 36);
  v30 = 37;
  v31 = 37;
  v44 = v40;
LABEL_26:
  v32 = v44;
  *v29 = 93;
  v29[1] = 0;
  dns_more_dnstype_get(v32, 102400);
  v33 = (const char *)jhl_nv_get_def("dns_more_dnswan");
  v34 = sprintf((char *)(v4 + v30), ",\"dnszu\":\"%s\",\"outzu\":\"%s\"", v32, v33) + v31;
  v35 = snprintf((char *)(v4 + v34), 0x200000 - v34, "}}");
  if ( v35 >= 0x200000 - v34 )
    v35 = 0x1FFFFF - v34;
  v36 = v35 + v34;
  _mem_free(v5);
  v12 = 8;
  v13 = v36;
  v11 = (char *)v4;
  return httpd_cgi_ret(a1, v11, v13, v12);
}
// 43D9CC: variable 'v3' is possibly undefined
// 43D9D8: variable 'v1' is possibly undefined
// 43DA00: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A83E8: using guessed type int __fastcall dns_more_dnstype_get(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A86F8: using guessed type int __fastcall Ip6ToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0043E11C) --------------------------------------------------------
int __fastcall sub_43E11C(int a1)
{
  char *v2; // $s1
  const char *v3; // $v0
  int v4; // $s2
  unsigned int v5; // $v0
  char v7[1024]; // [sp+18h] [-804h] BYREF
  char v8[1028]; // [sp+418h] [-404h] BYREF

  memset(v8, 0, 0x400u);
  memset(v7, 0, sizeof(v7));
  f_read("/proc/modules", v7, 1024);
  v2 = strstr(v7, "wys_sfe");
  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v3 = (const char *)jhl_nv_get_def("sfe_enable");
  v4 = sprintf(&v8[29], "\"en\":\"%s\",\"state\":\"%d\"", v3, v2 != 0) + 29;
  v5 = snprintf(&v8[v4], 1024 - v4, "}}");
  if ( v5 >= 1024 - v4 )
    v5 = 1023 - v4;
  return httpd_cgi_ret(a1, v8, v5 + v4, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);

//----- (0043E2A8) --------------------------------------------------------
int __fastcall sub_43E2A8(int a1)
{
  char *v2; // $s0
  int v3; // $s3
  int v4; // $a2
  _DWORD *v6; // $s2
  int v7; // $v0
  bool v8; // dc
  int v9; // $v0
  int v10; // $s3
  int v11; // $s5
  const char *v12; // $fp
  unsigned int v13; // $s0
  unsigned int v14; // $v0
  int v15; // $a0
  char *v16; // $v1
  const char *v17; // $v0
  int v18; // $t0
  int v19; // $a3
  int v20; // $a2
  int v21; // $a1
  int v22; // $a1
  const char *v23; // $a2
  const char *v24; // $v0
  int **v25; // $s3
  char *v26; // $s0
  int v27; // $v0
  const char *v28; // $s7
  int v29; // $s4
  int v30; // $fp
  int v31; // $s2
  const char *v32; // $s6
  unsigned int v33; // $v0
  int v34; // $t0
  int v35; // $a3
  int v36; // $a2
  int v37; // $a1
  char v38[20480]; // [sp+30h] [-A4D8h] BYREF
  char v39[20480]; // [sp+5030h] [-54D8h] BYREF
  char s[1024]; // [sp+A030h] [-4D8h] BYREF
  _BYTE v41[136]; // [sp+A430h] [-D8h] BYREF
  int v42; // [sp+A4B8h] [-50h] BYREF
  const char *v43; // [sp+A4BCh] [-4Ch]
  int v44; // [sp+A4C0h] [-48h]
  int v45; // [sp+A4C4h] [-44h]
  int v46; // [sp+A4C8h] [-40h]
  int v47; // [sp+A4CCh] [-3Ch]
  int v48; // [sp+A4D0h] [-38h]
  int v49; // [sp+A4D4h] [-34h]
  char *v50; // [sp+A4D8h] [-30h]
  char *v51; // [sp+A4DCh] [-2Ch]
  char *v52; // [sp+A4E0h] [-28h]
  char *v53; // [sp+A4E4h] [-24h]
  char *v54; // [sp+A4E8h] [-20h]
  char *v55; // [sp+A4ECh] [-1Ch]
  char *v56; // [sp+A4F0h] [-18h]
  int v57; // [sp+A4F4h] [-14h]
  int *v58; // [sp+A4F8h] [-10h]
  char *v59; // [sp+A4FCh] [-Ch]
  char *v60; // [sp+A500h] [-8h]
  int v61; // [sp+A530h] [+28h]

  memset(s, 0, sizeof(s));
  v2 = httpd_get_parm(a1, "opt");
  v50 = httpd_get_parm(a1, "name");
  v56 = httpd_get_parm(a1, "mode");
  v59 = httpd_get_parm(a1, "policy");
  v55 = httpd_get_parm(a1, "lanwan");
  v54 = httpd_get_parm(a1, "port");
  v53 = httpd_get_parm(a1, "bond");
  v52 = httpd_get_parm(a1, "old_bond");
  v51 = v39;
  v3 = httpd_get_json_parm(a1, (int)"del_list");
  memset(v39, 0, sizeof(v39));
  memset(v38, 0, sizeof(v38));
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  if ( !v2 || !strcmp(v2, (const char *)&off_646D8C) || !strcmp(v2, (const char *)&off_648DDC) || !strcmp(v2, "del") )
  {
    v60 = "a";
    jhl_parm_get("bond_list", v51, 20480);
    if ( !strcmp(v2, (const char *)&off_646D8C) )
    {
      if ( v53 && v54 && v50 && v55 && v56 && v59 )
      {
        v4 = check_rule_num_limit(a1, 37, (int)(v60 + 12064), 60, s, 0x400u);
        if ( v4 > 0 )
          return httpd_cgi_ret(a1, s, v4, 4);
        snprintf(v38, 20480, "%s%s|%s|%s|%s|%s|%s<", v51, v50, v53, v56, v59, v55, v54);
        goto LABEL_28;
      }
    }
    else
    {
      if ( strcmp(v2, (const char *)&off_648DDC) )
      {
        if ( strcmp(v2, "del") || !v3 || !cJSON_IsArray(v3) || (v25 = *(int ***)(v3 + 8)) == 0 || !v25[4] )
        {
          v17 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          v16 = s;
          do
          {
            v34 = *(_DWORD *)v17;
            v35 = *((_DWORD *)v17 + 1);
            v36 = *((_DWORD *)v17 + 2);
            v37 = *((_DWORD *)v17 + 3);
            v17 += 16;
            *(_DWORD *)v16 = v34;
            *((_DWORD *)v16 + 1) = v35;
            *((_DWORD *)v16 + 2) = v36;
            *((_DWORD *)v16 + 3) = v37;
            v16 += 16;
          }
          while ( v17 != "}" );
          goto LABEL_31;
        }
        v52 = v41;
        v50 = "%s|%s|%s|%s|%s|%s<";
        do
        {
          memset(v38, 0, sizeof(v38));
          v26 = v51;
          jhl_parm_get(v60 + 12064, v51, 20480);
          v27 = split_string(v26, 60, v52, 32);
          if ( v27 >= 2 )
          {
            v28 = v52;
            v29 = v27 - 1;
            v30 = 0;
            v31 = 0;
            do
            {
              while ( 1 )
              {
                split_string(*(_DWORD *)v28, 124, &v42, 6);
                v32 = v43;
                ++v30;
                if ( strcmp((const char *)v25[4], v43) )
                  break;
                v28 += 4;
                if ( v29 == v30 )
                  goto LABEL_48;
              }
              v33 = snprintf(&v38[v31], 20480 - v31, v50, v42, v32, v44, v45, v46, v47);
              if ( v33 >= 20480 - v31 )
                v33 = 20479 - v31;
              v31 += v33;
              v28 += 4;
            }
            while ( v29 != v30 );
          }
LABEL_48:
          nvram_set(v60 + 12064, v38);
          v25 = (int **)*v25;
        }
        while ( v25 && v25[4] );
LABEL_29:
        jhl_parm_commit(v15);
        jhl_gl_net_restart_timer(1000);
        v16 = s;
        v17 = "{\"code\":4,\"error\":\"\",\"data\":null}";
        do
        {
          v18 = *(_DWORD *)v17;
          v19 = *((_DWORD *)v17 + 1);
          v20 = *((_DWORD *)v17 + 2);
          v21 = *((_DWORD *)v17 + 3);
          v17 += 16;
          *(_DWORD *)v16 = v18;
          *((_DWORD *)v16 + 1) = v19;
          *((_DWORD *)v16 + 2) = v20;
          *((_DWORD *)v16 + 3) = v21;
          v16 += 16;
        }
        while ( v17 != "}" );
LABEL_31:
        v4 = 33;
        *(_WORD *)v16 = *(_WORD *)v17;
        return httpd_cgi_ret(a1, s, v4, 4);
      }
      if ( v52 && v53 && v54 && v50 && v55 && v56 )
      {
        memset(v38, 0, sizeof(v38));
        v6 = v41;
        v7 = split_string(v51, 60, v41, 32);
        v8 = v7 < 2;
        v9 = v7 - 1;
        if ( !v8 )
        {
          v57 = v9;
          v58 = &v42;
          v51 = "%s|%s|%s|%s|%s|%s<";
          v61 = a1;
          v10 = 0;
          v11 = 0;
          do
          {
            split_string(*v6, 124, v58, 6);
            v12 = v43;
            v13 = 20480 - v11;
            if ( !strcmp(v52, v43) )
            {
              v14 = snprintf(&v38[v11], 20480 - v11, v51, v50, v53, v56, v59, v55, v54);
              if ( v14 >= v13 )
                v14 = 20479 - v11;
            }
            else
            {
              v14 = snprintf(&v38[v11], 20480 - v11, v51, v42, v12, v44, v45, v46, v47);
              if ( v14 >= v13 )
                v14 = 20479 - v11;
            }
            v11 += v14;
            ++v10;
            ++v6;
          }
          while ( v10 != v57 );
          a1 = v61;
        }
LABEL_28:
        nvram_set(v60 + 12064, v38);
        goto LABEL_29;
      }
    }
    v22 = *(unsigned __int8 *)(a1 + 210102);
    v23 = "param err";
  }
  else
  {
    v22 = *(unsigned __int8 *)(a1 + 210102);
    v23 = "not opt";
  }
  v24 = (const char *)_GET_LANG_TEXT(12, v22, v23);
  v4 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
  if ( (unsigned int)v4 >= 0x400 )
    v4 = 1023;
  return httpd_cgi_ret(a1, s, v4, 4);
}
// 43E8F4: variable 'v15' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0043ED6C) --------------------------------------------------------
int __fastcall sub_43ED6C(int a1)
{
  char *v2; // $s1
  const char *v3; // $v0
  int v4; // $a0
  char *v5; // $v1
  const char *v6; // $v0
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  int v10; // $a1
  char v12[1028]; // [sp+18h] [-404h] BYREF

  v2 = httpd_get_parm(a1, "en");
  memset(v12, 0, 0x400u);
  if ( v2 )
  {
    v3 = (const char *)nvram_get("sfe_enable");
    if ( !v3 || strcmp(v3, v2) )
    {
      nvram_set("sfe_enable", v2);
      restart_sfe();
      jhl_parm_commit(v4);
    }
  }
  v5 = v12;
  v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v7 = *(_DWORD *)v6;
    v8 = *((_DWORD *)v6 + 1);
    v9 = *((_DWORD *)v6 + 2);
    v10 = *((_DWORD *)v6 + 3);
    v6 += 16;
    *(_DWORD *)v5 = v7;
    *((_DWORD *)v5 + 1) = v8;
    *((_DWORD *)v5 + 2) = v9;
    *((_DWORD *)v5 + 3) = v10;
    v5 += 16;
  }
  while ( v6 != "}" );
  *(_WORD *)v5 = *(_WORD *)v6;
  return httpd_cgi_ret(a1, v12, 33, 4);
}
// 43EE48: variable 'v4' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A893C: using guessed type int restart_sfe(void);

//----- (0043EED0) --------------------------------------------------------
int __fastcall sub_43EED0(int a1)
{
  char *v2; // $v0
  char *v3; // $s3
  const char *v4; // $s0
  const char *v5; // $v0
  int v6; // $s4
  const char *v7; // $v0
  int v8; // $a0
  char *v9; // $v1
  const char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  char v16[128]; // [sp+18h] [-80h] BYREF

  memset(v16, 0, sizeof(v16));
  v3 = httpd_get_parm(a1, "mode");
  v2 = httpd_get_parm(a1, "ips");
  v4 = v2;
  if ( !v3 )
  {
    if ( !v2 )
      goto LABEL_9;
    v6 = 0;
    goto LABEL_5;
  }
  v5 = (const char *)nvram_get("igmp_snooping_mode");
  if ( v5 && !strcmp(v5, v3) )
  {
    if ( !v4 )
      goto LABEL_9;
    v6 = 0;
    goto LABEL_5;
  }
  nvram_set("igmp_snooping_mode", v3);
  v6 = 1;
  if ( v4 )
  {
LABEL_5:
    v7 = (const char *)nvram_get("igmp_snooping_ips");
    if ( v7 && !strcmp(v7, v4) )
    {
      if ( !v6 )
        goto LABEL_9;
    }
    else
    {
      nvram_set("igmp_snooping_ips", v4);
    }
  }
  start_igmp_snooping();
  jhl_parm_commit(v8);
LABEL_9:
  v9 = v16;
  v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v11 = *(_DWORD *)v10;
    v12 = *((_DWORD *)v10 + 1);
    v13 = *((_DWORD *)v10 + 2);
    v14 = *((_DWORD *)v10 + 3);
    v10 += 16;
    *(_DWORD *)v9 = v11;
    *((_DWORD *)v9 + 1) = v12;
    *((_DWORD *)v9 + 2) = v13;
    *((_DWORD *)v9 + 3) = v14;
    v9 += 16;
  }
  while ( v10 != "}" );
  *(_WORD *)v9 = *(_WORD *)v10;
  return httpd_cgi_ret(a1, v16, 33, 4);
}
// 43F028: variable 'v8' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8760: using guessed type int start_igmp_snooping(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0043F0E4) --------------------------------------------------------
int __fastcall sub_43F0E4(int a1)
{
  char *v2; // $s4
  char *v3; // $s3
  int v4; // $a0
  char *v5; // $s2
  const char *v6; // $v0
  int v7; // $s4
  const char *v8; // $v0
  const char *v9; // $v0
  unsigned int v10; // $v0
  char v12[1028]; // [sp+18h] [-404h] BYREF

  memset(v12, 0, 0x400u);
  v2 = httpd_get_parm(a1, "en");
  v3 = httpd_get_parm(a1, "vid");
  v5 = httpd_get_parm(a1, "port");
  if ( !v2 || (v6 = (const char *)nvram_get("wan_itv_en")) != 0 && !strcmp(v6, v2) )
  {
    v7 = 0;
  }
  else
  {
    nvram_set("wan_itv_en", v2);
    v7 = 1;
  }
  if ( !v3 || (v8 = (const char *)nvram_get("wan_itv_vid")) != 0 && !strcmp(v8, v3) )
  {
    if ( !v5 )
      goto LABEL_18;
    v9 = (const char *)nvram_get("wan_itv_port");
    if ( !v9 )
      goto LABEL_10;
  }
  else
  {
    nvram_set("wan_itv_vid", v3);
    if ( !v5 )
    {
LABEL_11:
      jhl_parm_commit(v4);
      jhl_gl_net_restart_timer(1000);
      v10 = snprintf(v12, 4, "{\"code\":4,\"error\":\"\",\"data\":null}");
      goto LABEL_12;
    }
    v9 = (const char *)nvram_get("wan_itv_port");
    v7 = 1;
    if ( !v9 )
    {
LABEL_10:
      nvram_set("wan_itv_port", v5);
      goto LABEL_11;
    }
  }
  if ( strcmp(v9, v5) )
    goto LABEL_10;
LABEL_18:
  if ( v7 )
    goto LABEL_11;
  v10 = snprintf(v12, 4, "{\"code\":0,\"error\":\"\",\"data\":null}");
LABEL_12:
  if ( v10 >= 4 )
    v10 = 3;
  return httpd_cgi_ret(a1, v12, v10, 4);
}
// 43F284: variable 'v4' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0043F378) --------------------------------------------------------
int __fastcall sub_43F378(int a1)
{
  int v1; // $s5
  int v2; // $s0
  void *v3; // $v0
  char *v4; // $v0
  void *v5; // $s1
  char *v6; // $s4
  const char *v7; // $v0
  const char *v8; // $s0
  const char *v9; // $v0
  int v10; // $a0
  char *v11; // $v1
  const char *v12; // $v0
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  int v16; // $a1
  unsigned int v17; // $s0
  const char *v19; // $v0
  _DWORD *v20; // $s0
  int v21; // $v0
  int v22; // $s3
  int v23; // $s1
  int v24; // $s2
  int v25; // $s5
  int v26; // $s3
  char *v27; // $s7
  char *v28; // $v0
  char *v29; // $s1
  char *v30; // $v0
  char *v31; // $s2
  char *v32; // $v0
  unsigned int v33; // $v0
  const char *v34; // $v0
  int v35; // $a1
  int v36; // $a2
  int v37; // $a0
  char v38[256]; // [sp+28h] [-168h] BYREF
  char v39[32]; // [sp+128h] [-68h] BYREF
  char *v40; // [sp+148h] [-48h]
  char *v41; // [sp+14Ch] [-44h]
  char *v42; // [sp+150h] [-40h]
  char *v43; // [sp+154h] [-3Ch]
  char *s; // [sp+158h] [-38h]
  void *v45; // [sp+15Ch] [-34h]
  char *v46; // [sp+160h] [-30h]
  char *v47; // [sp+164h] [-2Ch]
  unsigned int v48; // [sp+168h] [-28h]
  char *v49; // [sp+16Ch] [-24h]
  char *v50; // [sp+170h] [-20h]
  char *v51; // [sp+174h] [-1Ch]
  char *v52; // [sp+178h] [-18h]
  char *format; // [sp+17Ch] [-14h]
  char *v54; // [sp+180h] [-10h]
  char *v55; // [sp+184h] [-Ch]
  const char *v56; // [sp+188h] [-8h]
  int v57; // [sp+1B8h] [+28h]

  v50 = "a";
  v1 = a1;
  v49 = "a";
  v2 = httpd_get_json_parm(a1, (int)"list");
  v46 = httpd_get_parm(v1, "increase_wan");
  v47 = httpd_get_parm(v1, "increase_base");
  v48 = sq_file_get_max_wan();
  _mem_malloc(0x200000, "wan_extend_asp", 4012);
  v45 = v3;
  v5 = v3;
  _mem_malloc(0x200000, "wan_extend_asp", 4013);
  v6 = v4;
  if ( !v5 || !v4 )
  {
    v19 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(v1 + 210102), 0x200000);
    s = v38;
    v17 = snprintf(v38, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
    if ( v17 >= 0x100 )
      v17 = 255;
    goto LABEL_17;
  }
  jhl_parm_get("increase_wan_all", v45, 0x200000);
  if ( !v2
    || !cJSON_IsArray(v2)
    || (v56 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n",
        jhl_parm_set("increase_wan_all", ""),
        (v20 = *(_DWORD **)(v2 + 8)) == 0) )
  {
    s = v38;
LABEL_6:
    if ( v46 )
    {
      v7 = (const char *)nvram_get(v50 + 12148);
      if ( !v7 || strcmp(v7, v46) )
        nvram_set(v50 + 12148, v46);
    }
    v8 = v47;
    if ( v47 )
    {
      v9 = (const char *)nvram_get(v49 + 12164);
      if ( !v9 || strcmp(v9, v8) )
        nvram_set(v49 + 12164, v47);
    }
    nvram_set("increase_wan_flag", "1");
    jhl_parm_commit(v10);
    jhl_gl_net_restart_timer(1000);
    v11 = s;
    v12 = "{\"code\":4,\"error\":\"\",\"data\":null}";
    do
    {
      v13 = *(_DWORD *)v12;
      v14 = *((_DWORD *)v12 + 1);
      v15 = *((_DWORD *)v12 + 2);
      v16 = *((_DWORD *)v12 + 3);
      v12 += 16;
      *(_DWORD *)v11 = v13;
      *((_DWORD *)v11 + 1) = v14;
      *((_DWORD *)v11 + 2) = v15;
      *((_DWORD *)v11 + 3) = v16;
      v11 += 16;
    }
    while ( v12 != "}" );
    v17 = 33;
    *(_WORD *)v11 = *(_WORD *)v12;
    goto LABEL_17;
  }
  v52 = "a";
  v42 = "a";
  v57 = v1;
  v43 = "a";
  v40 = "a";
  v41 = "a";
  v55 = "a";
  s = v38;
  format = "%s%s|%s|%s|%s<";
  v54 = "2";
  v51 = "1";
  while ( 1 )
  {
    v22 = cJSON_GetObjectItem(v20, v42 + 12200);
    v23 = cJSON_GetObjectItem(v20, v43 + 12212);
    v24 = cJSON_GetObjectItem(v20, v40 + 12224);
    v25 = cJSON_GetObjectItem(v20, v41 + 12232);
    if ( !v22 )
      goto LABEL_24;
    v26 = *(_DWORD *)(v22 + 16);
    if ( !v26 || !v23 || !*(_DWORD *)(v23 + 16) || !v24 || !*(_DWORD *)(v24 + 16) || !v25 || !*(_DWORD *)(v25 + 16) )
      goto LABEL_24;
    jhl_parm_get("increase_wan_all", v6, 0x200000);
    if ( nvparm_find_str(v6, 60, 6, v26, 124, 0) )
    {
      v1 = v57;
      v35 = *(unsigned __int8 *)(v57 + 210102);
      v36 = (int)"same wan_name";
      v37 = 12;
      goto LABEL_56;
    }
    if ( check_rule_num_limit(v57, 35, (int)(v52 + 12180), 60, s, 0x100u) > 0 )
    {
      v1 = v57;
      v17 = 0;
      goto LABEL_54;
    }
    if ( (unsigned int)J_atoi(*(_DWORD *)(v25 + 16)) >= 0xFF1 || !J_atoi(*(_DWORD *)(v25 + 16)) )
    {
      v1 = v57;
      v34 = (const char *)_GET_LANG_TEXT(168, *(unsigned __int8 *)(v57 + 210102), 1);
      goto LABEL_52;
    }
    v27 = *(char **)(v23 + 16);
    if ( !v27 || !*v27 )
    {
      v28 = v51;
      *(_DWORD *)(v23 + 16) = v51;
      v27 = v28;
    }
    v29 = *(char **)(v24 + 16);
    if ( !v29 || !*v29 )
    {
      v30 = v51;
      *(_DWORD *)(v24 + 16) = v51;
      v29 = v30;
    }
    v31 = *(char **)(v25 + 16);
    if ( !v31 || !*v31 )
    {
      v32 = v54;
      *(_DWORD *)(v25 + 16) = v54;
      v31 = v32;
    }
    if ( (unsigned int)J_atoi(v27) >= 0xFA )
      break;
    v33 = J_atoi(v29);
    if ( v48 >= v33 )
    {
      v21 = nvram_get("increase_wan_all");
      if ( !v21 )
        goto LABEL_49;
    }
    else
    {
      v29 = v39;
      sprintf(v39, v55 + 24872, v48);
      v21 = nvram_get("increase_wan_all");
      if ( !v21 )
      {
LABEL_49:
        v21 = (int)(v56 - 1556);
        goto LABEL_23;
      }
    }
LABEL_23:
    snprintf(v6, 0x200000, format, v21, v26, v27, v29, v31);
    jhl_parm_set("increase_wan_all", v6);
LABEL_24:
    v20 = (_DWORD *)*v20;
    if ( !v20 )
    {
      v1 = v57;
      goto LABEL_6;
    }
  }
  v1 = v57;
  v35 = *(unsigned __int8 *)(v57 + 210102);
  v36 = 249;
  v37 = 167;
LABEL_56:
  v34 = (const char *)_GET_LANG_TEXT(v37, v35, v36);
LABEL_52:
  v17 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v34);
  if ( v17 >= 0x100 )
    v17 = 255;
LABEL_54:
  jhl_parm_set("increase_wan_all", v45);
LABEL_17:
  _mem_free(v45);
  _mem_free(v6);
  return httpd_cgi_ret(v1, s, v17, 4);
}
// 43F458: variable 'v3' is possibly undefined
// 43F46C: variable 'v4' is possibly undefined
// 43F5AC: variable 'v10' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0043FB90) --------------------------------------------------------
int __fastcall get_iface_increase_data(int a1, char *a2, int a3)
{
  const char *v5; // $v0
  int v7; // $s0
  int v9; // $v0
  _BYTE *v10; // $v0
  int v11; // $v0
  char v12[64]; // [sp+20h] [-54h] BYREF
  const char *v13[5]; // [sp+60h] [-14h] BYREF

  v5 = (const char *)nvram_get("increase_wan");
  v7 = 0;
  if ( v5 )
  {
    v7 = strcmp(v5, "enable");
    if ( v7 )
    {
      v7 = 0;
    }
    else
    {
      v9 = jhl_nvget("wan_increase", a1);
      v10 = (_BYTE *)nvram_get(v9);
      if ( v10 )
      {
        if ( *v10 )
        {
          strlcpy(v12, v10, 64);
          if ( split_string(v12, 124, v13, 2) >= 2 )
          {
            v11 = snprintf(a2, a3, ",\"ex_type\":\"ex\",\"org_iface\":%s,\"ex_vid\":%s", v13[0], v13[1]);
            if ( v11 < a3 )
              v7 = v11;
            else
              v7 = a3 - 1;
          }
        }
      }
    }
  }
  return v7;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (0043FCE8) --------------------------------------------------------
int __fastcall get_iface_pppoe_br_data(int a1, char *a2, int a3)
{
  const char *v5; // $v0
  int v7; // $s0
  int v9; // $v0
  _BYTE *v10; // $v0
  int v11; // $v0
  int v12; // $s0
  _BYTE *v13; // $v0
  int v14; // $v0
  int v15; // $v0
  char v16[64]; // [sp+20h] [-50h] BYREF
  int v17[4]; // [sp+60h] [-10h] BYREF

  v5 = (const char *)nvram_get("pppoe_br_more_enable");
  v7 = 0;
  if ( v5 )
  {
    v7 = strcmp(v5, "1");
    if ( v7 )
    {
      v7 = 0;
    }
    else
    {
      v9 = jhl_nvget("wan_pppoebr", a1);
      v10 = (_BYTE *)nvram_get(v9);
      if ( v10 )
      {
        if ( *v10 )
        {
          strlcpy(v16, v10, 64);
          if ( split_string(v16, 124, v17, 2) >= 2 )
          {
            v12 = J_atoi(v17[0]);
            v11 = jhl_nvget("wan_increase", v12);
            v13 = (_BYTE *)nvram_get(v11);
            if ( v13 && *v13 && (strlcpy(v16, v13, 64), split_string(v16, 124, v17, 2) >= 2) )
              v14 = J_atoi(v17[1]);
            else
              v14 = 0;
            v15 = snprintf(a2, a3, ",\"ex_type\":\"br\",\"org_iface\":%d,\"ex_vid\":%d", v12, v14);
            if ( v15 < a3 )
              v7 = v15;
            else
              v7 = a3 - 1;
          }
        }
      }
    }
  }
  return v7;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0043FF08) --------------------------------------------------------
int __fastcall get_wans_data(char *a1, int a2)
{
  int v3; // $s6
  int v4; // $fp
  int v5; // $s1
  int v6; // $v0
  const char *v7; // $s3
  int v8; // $v0
  const char *v9; // $v0
  bool v10; // dc
  _BOOL4 v11; // $v0
  int v12; // $v0
  const char *v13; // $v0
  int v14; // $v0
  const char *v15; // $v0
  int v16; // $v0
  const char *v17; // $v0
  int v18; // $v0
  const char *v19; // $s2
  char *v20; // $a0
  int v21; // $v0
  int v23; // $v0
  const char *v24; // $s2
  int v25; // $v0
  int v26; // $a1
  int v27; // $v0
  int v28; // $v0
  int v29; // $v0
  int v30; // $v0
  int v31; // $v0
  int v32; // $v0
  int v33; // $v0
  const char *v34; // $v0
  int v35; // $v0
  int v36; // $fp
  int v37; // $s2
  const char *v38; // $v0
  const char *v39; // $v1
  int v40; // $v0
  int v41; // $v0
  int v42; // $s2
  int v43; // $s3
  const char *v44; // $fp
  int v45; // $v0
  char *v46; // $v0
  int v47; // $v0
  const char *v48; // $v0
  int v49; // $v0
  int v50; // $s3
  int v51; // $s2
  int v52; // $v0
  int v53; // $s2
  int v54; // $fp
  int v55; // $v0
  int v56; // $fp
  int v57; // $s0
  int v58; // $v0
  int v59; // $v0
  const char *v60; // $v0
  int v61; // $v0
  int v62; // $v0
  const char *v63; // $v0
  int v64; // $v0
  int v65; // $v0
  int v66; // $v0
  char v67[128]; // [sp+38h] [-148h] BYREF
  char v68[128]; // [sp+B8h] [-C8h] BYREF
  char *v69; // [sp+138h] [-48h]
  const char *v70; // [sp+13Ch] [-44h]
  const char *v71; // [sp+140h] [-40h]
  int v72; // [sp+144h] [-3Ch]
  char *v73; // [sp+148h] [-38h]
  const char *v74; // [sp+14Ch] [-34h]
  const char *v75; // [sp+150h] [-30h]
  char *v76; // [sp+154h] [-2Ch]
  int v77; // [sp+158h] [-28h]
  const char *v78; // [sp+15Ch] [-24h]
  const char *v79; // [sp+160h] [-20h]
  const char *v80; // [sp+164h] [-1Ch]
  char *v81; // [sp+168h] [-18h]
  int v82; // [sp+16Ch] [-14h]
  const char *v83; // [sp+170h] [-10h]
  const char *v84; // [sp+174h] [-Ch]
  char *v85; // [sp+178h] [-8h]

  v3 = sq_file_get_max_wan();
  v4 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v4 >= a2 )
    v4 = a2 - 1;
  if ( v3 > 0 && v4 < a2 - 99 )
  {
    v5 = 1;
    v69 = "a";
    v71 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
    v70 = "wan_down";
    v74 = "ipv6.wan_proto";
    v85 = "a";
    v84 = "0.0.0.0";
    while ( 1 )
    {
      v6 = jhl_nvget(v69 + 12484, v5 - 1);
      v7 = (const char *)nvram_get(v6);
      if ( v7 )
      {
        if ( !*v7 )
          break;
      }
      else
      {
        v7 = v71 - 1556;
        if ( !*(v71 - 1556) )
          break;
      }
      v8 = jhl_nvget(v70, v5 - 1);
      v9 = (const char *)nvram_get(v8);
      if ( v9 )
      {
        v10 = strcmp(v9, "1") == 0;
        v11 = v5 < v3;
        if ( v10 )
          goto LABEL_6;
      }
      v10 = jhl_iface_link_up_check(v7, v5 - 1) != 0;
      v11 = v5 < v3;
      if ( v10 )
        goto LABEL_6;
      v77 = jhl_get_wan_proto(v5 - 1);
      if ( v77 == 4
        && (v62 = jhl_nvget("ppp_demand_run", v5 - 1), (v63 = (const char *)nvram_get(v62)) != 0)
        && !strcmp(v63, "1") )
      {
        v72 = 0;
      }
      else
      {
        v72 = jhl_check_wanup(v5 - 1);
      }
      v12 = jhl_nvget(v74, v5 - 1);
      v13 = (const char *)nvram_get(v12);
      if ( v13 && !strcmp(v13, "staticv6") )
      {
        v23 = jhl_nvget("ipv6.wan_static_ip6", v5 - 1);
        v73 = (char *)nvram_get(v23);
        v24 = v71 - 1556;
        if ( !v73 )
          v73 = (char *)(v71 - 1556);
        v25 = jhl_nvget("ipv6.wan_static_gw6", v5 - 1);
        v75 = (const char *)nvram_get(v25);
        v83 = v24;
        if ( !v75 )
          v75 = v24;
      }
      else
      {
        v14 = jhl_nvget(v74, v5 - 1);
        v15 = (const char *)nvram_get(v14);
        if ( v15 && !strcmp(v15, "6in4") )
        {
          v61 = jhl_nvget("ipv6.wan_local_ip6", v5 - 1);
          v73 = (char *)nvram_get(v61);
          if ( !v73 )
            goto LABEL_21;
          v83 = v71 - 1556;
          v75 = v71 - 1556;
        }
        else
        {
          v16 = jhl_nvget(v74, v5 - 1);
          v17 = (const char *)nvram_get(v16);
          if ( !v17 || strcmp(v17, v85 + 12580) )
          {
LABEL_21:
            v83 = v71 - 1556;
            v75 = v71 - 1556;
            v73 = (char *)(v71 - 1556);
            if ( v72 )
              goto LABEL_36;
            goto LABEL_22;
          }
          v64 = jhl_nvget("ipv6.wan_get_ip", v5 - 1);
          v73 = (char *)nvram_get(v64);
          if ( !v73 )
            v73 = (char *)(v71 - 1556);
          v65 = jhl_nvget("ipv6.wan_get_gw", v5 - 1);
          v75 = (const char *)nvram_get(v65);
          if ( !v75 )
            v75 = v71 - 1556;
          v66 = jhl_nvget("ipv6.wan_get_dns", v5 - 1);
          v83 = (const char *)nvram_get(v66);
          if ( !v83 )
            v83 = v71 - 1556;
        }
      }
      if ( v72 )
      {
LABEL_36:
        v26 = v5 - 1;
        if ( v77 == 4 || v77 == 10 )
        {
          v30 = jhl_nvget("ppp_get_ip", v26);
          v78 = (const char *)nvram_get(v30);
          if ( !v78 )
            v78 = v84;
          v31 = jhl_nvget("ppp_gw", v5 - 1);
          v79 = (const char *)nvram_get(v31);
          if ( !v79 )
            v79 = v78;
          v80 = "255.255.255.255";
        }
        else
        {
          v27 = jhl_nvget("wan_ipaddr", v26);
          v78 = (const char *)nvram_get(v27);
          if ( !v78 )
            v78 = v84;
          v28 = jhl_nvget("wan_netmask", v5 - 1);
          v80 = (const char *)nvram_get(v28);
          if ( !v80 )
            v80 = v84;
          v29 = jhl_nvget("wan_gateway", v5 - 1);
          v79 = (const char *)nvram_get(v29);
          if ( !v79 )
            v79 = v84;
        }
        v32 = jhl_nvget("wan_proto", v5 - 1);
        v19 = (const char *)nvram_get(v32);
        if ( !v19 )
        {
          v76 = v67;
          memset(v67, 0, sizeof(v67));
          v19 = "disabled";
LABEL_53:
          asp_jhl_dns(v76, v5 - 1);
          goto LABEL_54;
        }
        goto LABEL_50;
      }
LABEL_22:
      v18 = jhl_nvget("wan_proto", v5 - 1);
      v19 = (const char *)nvram_get(v18);
      if ( !v19 )
      {
        v76 = v67;
        memset(v67, 0, sizeof(v67));
        v79 = v84;
        v19 = "disabled";
        v80 = v84;
        v78 = v84;
        goto LABEL_88;
      }
      v79 = v84;
      v80 = v84;
      v78 = v84;
LABEL_50:
      if ( !strncmp(v19, "3G", 2u) )
      {
        v19 = "4G";
      }
      else
      {
        v76 = "a";
        if ( !strncmp(v19, "4G", 2u) )
          v19 = v76 + 12444;
      }
      v76 = v67;
      memset(v67, 0, sizeof(v67));
      if ( v72 )
        goto LABEL_53;
LABEL_88:
      strcpy(v67, "[]");
LABEL_54:
      v81 = v68;
      jhl_link_uptime(v68, v5 - 1, v72);
      v33 = jhl_nvget("wan_name", v5 - 1);
      v34 = (const char *)nvram_get(v33);
      if ( !v34 )
        v34 = v71 - 1556;
      v82 = a2 - v4;
      v35 = snprintf(
              &a1[v4],
              a2 - v4,
              "{\"iface\":%d,\"wan_type\":\"%s\",\"wan_ifname\":\"%s\",\"wan_name\":\"%s\",",
              v5 - 1,
              v19,
              v7,
              v34);
      if ( v35 >= v82 )
        v35 = v82 - 1;
      v36 = v35 + v4;
      v37 = a2 - v36;
      if ( *v73 )
        v38 = "<br/>";
      else
        v38 = v71 - 1556;
      if ( *v75 )
        v39 = "<br/>";
      else
        v39 = v71 - 1556;
      v40 = snprintf(
              &a1[v36],
              a2 - v36,
              "\"wan_ipaddr\":\"%s%s%s\",\"wan_netmask\":\"%s%s\",\"wan_gw\":\"%s%s%s\",\"dns6\":[\"%s\"],",
              v78,
              v38,
              v73,
              v80,
              v38,
              v79,
              v39,
              v75,
              v83);
      if ( v40 >= v37 )
        v40 = v37 - 1;
      v42 = v40 + v36;
      v41 = jhl_nvget("wan_hwaddr", v5 - 1);
      v43 = a2 - v42;
      v44 = (const char *)nvram_get(v41);
      v73 = &a1[v42];
      if ( !v44 )
        v44 = "00:00:00:00:00:00";
      v73 = (char *)jhl_get_wanstatus(v5 - 1);
      v45 = jhl_nvget("wan_run_mtu", v5 - 1);
      v46 = (char *)nvram_get(v45);
      if ( !v46 )
        v46 = "0";
      v75 = (const char *)J_atoi(v46);
      v47 = jhl_nvget("wan_mem", v5 - 1);
      v48 = (const char *)nvram_get(v47);
      if ( !v48 )
        v48 = v71 - 1556;
      v49 = snprintf(
              &a1[v42],
              a2 - v42,
              "\"wan_mac\":\"%s\",\"wan_up\":%d,\"wan_state\":\"%s\",\"wan_time\":\"%s\",\"dns\":%s,\"wan_mtu\":%d,\"wan_mem\":\"%s\"",
              v44,
              v72,
              v73,
              v81,
              v76,
              v75,
              v48);
      if ( v49 >= v43 )
        v49 = v43 - 1;
      v50 = v49 + v42;
      if ( (unsigned int)(v77 - 10) >= 3 )
      {
        v59 = jhl_nvget("wan_group", v5 - 1);
        v51 = a2 - v50;
        v60 = (const char *)nvram_get(v59);
        if ( !v60 )
          v60 = v71 - 1556;
        v52 = snprintf(&a1[v50], a2 - v50, ",\"wan_group\":\"%s\"", v60);
        if ( v52 < v51 )
          goto LABEL_74;
LABEL_82:
        v52 = v51 - 1;
        goto LABEL_74;
      }
      v51 = a2 - v50;
      v52 = snprintf(&a1[v50], a2 - v50, ",\"wan_group\":\"\"");
      if ( v52 >= a2 - v50 )
        goto LABEL_82;
LABEL_74:
      v53 = v52 + v50;
      v54 = a2 - (v52 + v50);
      v55 = snprintf(&a1[v52 + v50], v54, ",\"n\":\"WAN%d\"", v5);
      if ( v55 >= v54 )
        v55 = v54 - 1;
      v56 = v53 + v55 + get_iface_increase_data(v5 - 1, &a1[v53 + v55], a2 - (v53 + v55));
      v57 = v56 + get_iface_pppoe_br_data(v5 - 1, &a1[v56], a2 - v56);
      v58 = snprintf(&a1[v57], a2 - v57, &byte_65078C);
      if ( v58 >= a2 - v57 )
        v58 = a2 - v57 - 1;
      v4 = v58 + v57;
      v11 = v5 < v3;
LABEL_6:
      if ( v11 )
      {
        ++v5;
        if ( v4 < a2 - 99 )
          continue;
      }
      break;
    }
  }
  v20 = &a1[v4];
  if ( v4 > 0 && *(v20 - 1) == 44 )
    v20 = &a1[--v4];
  *v20 = 0;
  v21 = snprintf(v20, a2 - v4, &byte_6445A0);
  if ( v21 >= a2 - v4 )
    v21 = a2 - v4 - 1;
  return v4 + v21;
}
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 65078C: using guessed type char byte_65078C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A84E0: using guessed type int __fastcall jhl_get_wanstatus(_DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00440C94) --------------------------------------------------------
int __fastcall sub_440C94(int a1)
{
  int v2; // $v0
  int v3; // $s4
  char *v4; // $s0
  int v5; // $v0
  char *v6; // $v1
  int v7; // $s2
  int v8; // $s1
  int v9; // $v0
  const char *v10; // $v0
  char *v11; // $s1
  const char *v12; // $v0
  int v13; // $s2
  int v14; // $v0
  int v15; // $a2
  int result; // $v0
  const char *v17; // $v0
  unsigned int v18; // $v0
  char v19[260]; // [sp+20h] [-104h] BYREF

  v3 = sq_file_get_max_wan();
  _mem_malloc(0x200000, "wansvpns_data", 3382);
  v4 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{\"wans\":");
    qmemcpy((void *)v2, "{\"code\":0,\"error", 16);
    *(_DWORD *)(v2 + 24) = 975331700;
    strcpy((char *)(v2 + 32), "ns\":");
    v5 = get_wans_data((char *)(v2 + 36), 2097116);
    v6 = &v4[v5 + 36];
    strcpy(v6, ",\"vpns\":[ ");
    *(_DWORD *)v6 = *(_DWORD *)",\"vpns\":[ ";
    v7 = v5 + 46;
    if ( v3 > 0 )
    {
      v8 = 0;
      do
      {
        v9 = jhl_vpnget("vpn_proto", v8);
        v10 = (const char *)nvram_get(v9);
        if ( !v10 || strcmp(v10, (const char *)&off_63F984) )
          v7 += sprintf(&v4[v7], "{\"iface\":%d},", v8);
        ++v8;
      }
      while ( v8 != 5 && v3 != v8 );
    }
    v11 = &v4[v7];
    if ( v7 > 0 && *(v11 - 1) == 44 )
      v11 = &v4[--v7];
    *v11 = 0;
    v12 = (const char *)jhl_nv_get_def("mr_mode");
    v13 = v7 + sprintf(v11, "],\"mr_mode\":\"%s\"", v12);
    v14 = snprintf(&v4[v13], 0x200000 - v13, "}}");
    if ( v14 >= 0x200000 - v13 )
      v15 = 0x1FFFFF - v13;
    else
      v15 = v14;
    result = httpd_cgi_ret(a1, v4, v15 + v13, 8);
  }
  else
  {
    v17 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v18 = snprintf(v19, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
    if ( v18 >= 0x100 )
      v18 = 255;
    result = httpd_cgi_ret(a1, v19, v18, 4);
  }
  return result;
}
// 440D00: variable 'v2' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (00440FE4) --------------------------------------------------------
int __fastcall sub_440FE4(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $s4
  int v5; // $a0
  int v6; // $s3
  int v7; // $v0
  int v8; // $s1
  int v9; // $s1
  int v10; // $v0
  int v11; // $s1
  int v12; // $v0
  int v13; // $s1
  int v14; // $s3
  int v15; // $v0
  unsigned int v17; // $a2
  const char *v18; // $v0
  char v19[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(0x200000, "state_view_data", 3569);
  v3 = v2;
  if ( v2 )
  {
    if ( *(_BYTE *)(a1 + 210100) == 2 )
    {
      *(_WORD *)v2 = 123;
      v4 = 0x1FFFFF;
      v5 = 1;
      v6 = 1;
    }
    else
    {
      strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
      qmemcpy(v2, "{\"code\":0,\"error", 16);
      v4 = 2097123;
      v5 = 29;
      v6 = 29;
    }
    v7 = snprintf(&v2[v5], v4, "\"wans\":");
    v8 = v6 + v7;
    if ( v7 >= v4 )
      v8 = 0x1FFFFF;
    v9 = v8 + get_wans_data(&v3[v8], 0x200000 - v8);
    v10 = snprintf(&v3[v9], 0x200000 - v9, (char *)&dword_64331C);
    if ( v10 >= 0x200000 - v9 )
      v10 = 0x1FFFFF - v9;
    v11 = v10 + v9 + get_vpns_iface(&v3[v10 + v9]);
    v12 = snprintf(&v3[v11], 0x200000 - v11, ",\"x86\":%d", 0);
    if ( v12 >= 0x200000 - v11 )
    {
      v13 = 0x1FFFFF;
      v14 = 1;
      if ( *(_BYTE *)(a1 + 210100) != 2 )
        goto LABEL_10;
    }
    else
    {
      v13 = v12 + v11;
      v14 = 0x200000 - v13;
      if ( *(_BYTE *)(a1 + 210100) != 2 )
      {
LABEL_10:
        v15 = snprintf(&v3[v13], v14, "}}");
LABEL_11:
        if ( v15 >= v14 )
          v15 = 0x1FFFFF - v13;
        return httpd_cgi_ret(a1, v3, v15 + v13, 8);
      }
    }
    v15 = snprintf(&v3[v13], v14, "}");
    goto LABEL_11;
  }
  v17 = 2;
  if ( *(_BYTE *)(a1 + 210100) == 2 )
  {
    strcpy(v19, "{}");
  }
  else
  {
    v18 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v17 = snprintf(v19, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v18);
    if ( v17 >= 0x100 )
      v17 = 255;
  }
  return httpd_cgi_ret(a1, v19, v17, 4);
}
// 441034: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 64331C: using guessed type int dword_64331C;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00441334) --------------------------------------------------------
void __fastcall format_wanll_history_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 2 )
    snprintf(a3, a4, "{\"u\":\"%s\",\"d\":\"%s\"},", *a1, a1[1]);
}

//----- (004413B0) --------------------------------------------------------
int __fastcall sub_4413B0(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s1
  int v5; // $v0
  int v6; // $v0
  char *v7; // $s6
  int v8; // $v0
  int v9; // $v0
  char *v10; // $s0
  char *v11; // $v0
  char *v12; // $fp
  int v13; // $v0
  int v14; // $v0
  int v15; // $s3
  int v16; // $s1
  char *v17; // $s4
  int v18; // $s0
  const char **v19; // $s2
  void *v20; // $v0
  void *v21; // $s7
  void *v22; // $s7
  _DWORD *v23; // $s6
  int i; // $s7
  int v25; // $v0
  int v26; // $v0
  char *v27; // $a0
  int v28; // $s1
  int v29; // $v0
  int v30; // $s3
  int v31; // $a2
  int v33; // $a1
  int v34; // $a2
  int v35; // $a0
  const char *v36; // $v0
  unsigned int v37; // $v0
  char v38[1024]; // [sp+20h] [-450h] BYREF
  int v39[8]; // [sp+420h] [-50h] BYREF
  int v40[8]; // [sp+440h] [-30h] BYREF
  int v41; // [sp+460h] [-10h]
  void *v42; // [sp+464h] [-Ch]
  void *ptr; // [sp+468h] [-8h]

  v40[0] = 0;
  v40[1] = 0;
  v40[2] = 0;
  v40[3] = 0;
  v40[4] = 0;
  v40[5] = 0;
  v40[6] = 0;
  v40[7] = 0;
  v39[0] = 0;
  v39[1] = 0;
  v39[2] = 0;
  v39[3] = 0;
  v39[4] = 0;
  v39[5] = 0;
  v39[6] = 0;
  v39[7] = 0;
  v3 = httpd_get_parm(a1, "type");
  v2 = httpd_get_parm(a1, "iface");
  if ( !v3 || (v4 = v2, strcmp(v3, "m")) && strcmp(v3, "h") && strcmp(v3, "d") )
  {
    v33 = *(unsigned __int8 *)(a1 + 210102);
    v34 = (int)&unk_64334C;
    v35 = 12;
    goto LABEL_39;
  }
  if ( !v4 )
  {
    v33 = *(unsigned __int8 *)(a1 + 210102);
    v34 = (int)&unk_643358;
    v35 = 12;
    goto LABEL_39;
  }
  if ( !strcmp(v4, "all") )
  {
    sprintf((char *)v40, "wan_flow_a_%s_l", v3);
    sprintf((char *)v39, "wan_flow_a_%s_t", v3);
    v7 = (char *)nvram_get(v40);
    if ( !v7 )
      v7 = "";
    v10 = (char *)nvram_get(v39);
    if ( v10 )
      goto LABEL_10;
  }
  else
  {
    sprintf((char *)v40, "wan_flow_%s_l", v3);
    sprintf((char *)v39, "wan_flow_%s_t", v3);
    v5 = J_atoi(v4);
    v6 = jhl_nvget(v40, v5);
    v7 = (char *)nvram_get(v6);
    if ( !v7 )
      v7 = "";
    v8 = J_atoi(v4);
    v9 = jhl_nvget(v39, v8);
    v10 = (char *)nvram_get(v9);
    if ( v10 )
      goto LABEL_10;
  }
  v10 = "";
LABEL_10:
  _mem_malloc(102400, "wanll_history_data", 471);
  v12 = v11;
  if ( v11 )
  {
    strcpy(v11, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v11, "{\"code\":0,\"error\":\"\"", 20);
    v13 = J_atoi(v10);
    v14 = snprintf(v12 + 29, 102371, "\"time\":%lu,\"all\":", v13);
    if ( v14 >= 102371 )
      v14 = 102370;
    v15 = v14 + 29;
    v16 = 102400 - (v14 + 29);
    v17 = &v12[v14 + 29];
    v18 = snprintf(v17, v16, (char *)&word_642A04);
    if ( v18 >= v16 )
      v18 = 102399 - v15;
    v19 = (const char **)malloc(0x10u);
    v42 = malloc(0x808u);
    v21 = v42;
    v20 = malloc(0x200000u);
    ptr = v20;
    if ( v20 )
    {
      if ( v19 )
      {
        v42 = v21;
        if ( v21 )
        {
          v22 = v20;
          strlcpy(v20, v7, 0x200000);
          v23 = v42;
          v41 = split_string(v22, 60, v42, 512);
          if ( v41 > 0 )
          {
            for ( i = 0; i != v41; ++i )
            {
              v25 = split_string(*v23, 124, v19, 2);
              format_wanll_history_data(v19, v25, &v17[v18], v16 - v18);
              v18 += v26;
              ++v23;
            }
          }
        }
      }
      free(ptr);
    }
    if ( v19 )
      free(v19);
    if ( v42 )
      free(v42);
    v27 = &v17[v18];
    if ( v18 > 0 && *(v27 - 1) == 44 )
      v27 = &v17[--v18];
    v28 = v16 - v18;
    *v27 = 0;
    v29 = snprintf(v27, v28, &byte_6445A0);
    if ( v29 >= v28 )
      v29 = v28 - 1;
    v30 = v18 + v29 + v15;
    v31 = snprintf(&v12[v30], 102400 - v30, "}}");
    if ( v31 >= 102400 - v30 )
      v31 = 102399 - v30;
    return httpd_cgi_ret(a1, v12, v31 + v30, 8);
  }
  v33 = *(unsigned __int8 *)(a1 + 210102);
  v34 = 102400;
  v35 = 4;
LABEL_39:
  v36 = (const char *)_GET_LANG_TEXT(v35, v33, v34);
  v37 = snprintf(v38, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v36);
  if ( v37 >= 0x400 )
    v37 = 1023;
  return httpd_cgi_ret(a1, v38, v37, 4);
}
// 4415F4: variable 'v11' is possibly undefined
// 4417CC: variable 'v26' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00441A68) --------------------------------------------------------
void __fastcall format_hi_history_data(_DWORD *a1, int a2, char *a3, int a4)
{
  int v5; // $v0

  if ( a2 > 0 )
  {
    v5 = J_atoi(*a1);
    snprintf(a3, a4, "%lu,", v5);
  }
}
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00441AF0) --------------------------------------------------------
int __fastcall sub_441AF0(int a1)
{
  char *v1; // $v0
  const char *v2; // $s0
  char *v3; // $v0
  char *v4; // $fp
  char *v5; // $v0
  int v6; // $v0
  int v7; // $v0
  int v8; // $s3
  char *v9; // $s5
  int v10; // $s1
  char *v11; // $s4
  int v12; // $s0
  _DWORD *v13; // $s2
  void *v14; // $v0
  _DWORD *v15; // $s6
  char *v16; // $a1
  void *v17; // $s5
  int v18; // $s5
  int i; // $s7
  int v20; // $v0
  int v21; // $v0
  char *v22; // $a0
  int v23; // $s1
  int v24; // $v0
  int v25; // $s3
  int v26; // $v0
  int v27; // $a2
  const char *v29; // $v0
  unsigned int v30; // $a2
  const char *v31; // $v0
  unsigned int v32; // $v0
  char v33[1024]; // [sp+20h] [-448h] BYREF
  int v34[8]; // [sp+420h] [-48h] BYREF
  int v35[8]; // [sp+440h] [-28h] BYREF
  _DWORD *v36; // [sp+460h] [-8h]
  void *ptr; // [sp+464h] [-4h]

  v35[0] = 0;
  v35[1] = 0;
  v35[2] = 0;
  v35[3] = 0;
  v35[4] = 0;
  v35[5] = 0;
  v35[6] = 0;
  v35[7] = 0;
  v34[0] = 0;
  v34[1] = 0;
  v34[2] = 0;
  v34[3] = 0;
  v34[4] = 0;
  v34[5] = 0;
  v34[6] = 0;
  v34[7] = 0;
  v1 = httpd_get_parm(a1, "type");
  if ( !v1 || (v2 = v1, strcmp(v1, "m")) && strcmp(v2, "h") && strcmp(v2, "d") )
  {
    v29 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_64334C);
    v30 = snprintf(v33, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v29);
    if ( v30 >= 0x400 )
      v30 = 1023;
    return httpd_cgi_ret(a1, v33, v30, 4);
  }
  sprintf((char *)v35, "host_num_%s_l", v2);
  sprintf((char *)v34, "host_num_%s_t", v2);
  _mem_malloc(102400, "hi_history_data", 519);
  v4 = v3;
  if ( v3 )
  {
    strcpy(v3, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v3, "{\"code\":0,\"error", 16);
    v5 = (char *)nvram_get(v34);
    if ( !v5 )
      v5 = "";
    v6 = J_atoi(v5);
    v7 = snprintf(v4 + 29, 102371, "\"time\":%lu,\"all\":", v6);
    if ( v7 >= 102371 )
    {
      v8 = 102399;
      v9 = (char *)nvram_get(v35);
      if ( v9 )
        goto LABEL_9;
    }
    else
    {
      v8 = v7 + 29;
      v9 = (char *)nvram_get(v35);
      if ( v9 )
      {
LABEL_9:
        v10 = 102400 - v8;
        v11 = &v4[v8];
        v12 = snprintf(&v4[v8], 102400 - v8, (char *)&word_642A04);
        if ( v12 >= 102400 - v8 )
          v12 = 102399 - v8;
        v13 = malloc(0xCu);
        v36 = malloc(0x808u);
        v15 = v36;
        v14 = malloc(0x200000u);
        ptr = v14;
        if ( v14 )
        {
          if ( v13 )
          {
            v16 = v9;
            if ( v15 )
            {
              v17 = v14;
              strlcpy(v14, v16, 0x200000);
              v18 = split_string(v17, 60, v15, 512);
              if ( v18 > 0 )
              {
                for ( i = 0; i != v18; ++i )
                {
                  v20 = split_string(*v15, 124, v13, 1);
                  format_hi_history_data(v13, v20, &v11[v12], v10 - v12);
                  v12 += v21;
                  ++v15;
                }
              }
            }
          }
          free(ptr);
        }
        if ( v13 )
          free(v13);
        if ( v36 )
          free(v36);
        v22 = &v11[v12];
        if ( v12 > 0 && *(v22 - 1) == 44 )
          v22 = &v11[--v12];
        v23 = v10 - v12;
        *v22 = 0;
        v24 = snprintf(v22, v23, &byte_6445A0);
        if ( v24 >= v23 )
          v24 = v23 - 1;
        v25 = v12 + v24 + v8;
        v26 = snprintf(&v4[v25], 102400 - v25, "}}");
        if ( v26 >= 102400 - v25 )
          v27 = 102399 - v25;
        else
          v27 = v26;
        return httpd_cgi_ret(a1, v4, v27 + v25, 8);
      }
    }
    v9 = "";
    goto LABEL_9;
  }
  v31 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v32 = snprintf(v33, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
  if ( v32 >= 0x400 )
    v32 = 1023;
  return httpd_cgi_ret(a1, v33, v32, 4);
}
// 441C30: variable 'v3' is possibly undefined
// 441E34: variable 'v21' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004420D8) --------------------------------------------------------
int __fastcall get_wan_nvarms(const char **a1, char *a2, int a3)
{
  int v5; // $s5
  int v6; // $s3
  int v7; // $s0
  int v8; // $s7
  int v9; // $v0
  const char *v10; // $s1
  int v11; // $s2
  int v12; // $v0
  const char *v13; // $v0
  int v14; // $v0
  const char *v15; // $v0
  int v16; // $v0
  const char *v17; // $v1
  int v18; // $s3
  const char **v19; // $s1
  int v20; // $v0
  int v21; // $v0
  int v22; // $v0
  int v23; // $a3
  int v24; // $v0
  int v25; // $v1
  int v26; // $v0
  char *v27; // $v0
  int v28; // $v0
  int v29; // $v0
  int v30; // $s3
  int v31; // $v0
  int v32; // $s1
  int v33; // $s3
  int v34; // $v0
  const char *v35; // $v0
  int v36; // $s3
  int v37; // $v0
  int v38; // $s3
  int v39; // $v0
  int v40; // $v0
  int v41; // $s3
  int v42; // $v0
  int v43; // $s3
  int v44; // $s1
  int v45; // $v0
  char *v46; // $a0
  int v47; // $s4
  int v48; // $v0
  char *v50; // $a0
  int v51; // $v0
  int v52; // $a3
  int v53; // $v0
  const char *v54; // $s2
  int v55; // $v0
  const char *v56; // $v0
  int v57; // $v0
  char v58[512]; // [sp+20h] [-2E0h] BYREF
  char v59[128]; // [sp+220h] [-E0h] BYREF
  const char *v60[16]; // [sp+2A0h] [-60h] BYREF
  char *v61; // [sp+2E0h] [-20h]
  char *v62; // [sp+2E4h] [-1Ch]
  char *v63; // [sp+2E8h] [-18h]
  char *format; // [sp+2ECh] [-14h]
  const char *v65; // [sp+2F0h] [-10h]
  const char *v66; // [sp+2F4h] [-Ch]
  const char *v67; // [sp+2F8h] [-8h]
  char *v68; // [sp+2FCh] [-4h]

  v5 = sq_file_get_max_wan();
  v6 = snprintf(a2, a3, "\"wans\":[");
  if ( v6 >= a3 )
    v6 = a3 - 1;
  if ( v5 > 0 )
  {
    v65 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
    v7 = 0;
    v62 = "a";
    v67 = "255.255.255.255";
    v63 = "wan_proto";
    format = ",\"%s\":\"%s\"";
    while ( 1 )
    {
      v9 = jhl_nvget("wan_ifname", v7);
      v10 = (const char *)nvram_get(v9);
      if ( !v10 )
        v10 = v65 - 1556;
      v11 = jhl_get_wan_proto(v7);
      if ( v11 == 4 )
      {
        v12 = jhl_nvget("ppp_demand_run", v7);
        v13 = (const char *)nvram_get(v12);
        if ( v13 && !strcmp(v13, "1") )
        {
          if ( !*v10 )
            break;
          v8 = 0;
        }
        else
        {
          v8 = jhl_check_wanup(v7);
          if ( !*v10 )
            break;
        }
      }
      else
      {
        v8 = jhl_check_wanup(v7);
        if ( !*v10 )
          break;
        if ( (unsigned int)(v11 - 10) < 3 )
          goto LABEL_7;
      }
      v14 = jhl_nvget(v62 + 12496, v7);
      v15 = (const char *)nvram_get(v14);
      if ( v15 && !strcmp(v15, "1") || jhl_iface_link_up_check(v10, v7) )
      {
LABEL_7:
        if ( v5 == ++v7 )
          break;
      }
      else
      {
        v61 = (char *)(a3 - v6);
        v16 = snprintf(&a2[v6], a3 - v6, "{\"iface\":%d,\"wan_ifname\":\"%s\"", v7, v10);
        if ( v16 >= (int)v61 )
          v16 = (int)(v61 - 1);
        v17 = *a1;
        v18 = v16 + v6;
        if ( *a1 && *v17 )
        {
          v19 = a1;
          v68 = ",\"%s\":\"\"";
          v66 = "wan_new_proto";
          do
          {
            v61 = (char *)v17;
            if ( !strcmp(v17, v63) )
            {
              v20 = jhl_nvget(v66, v7);
              v21 = nvram_get(v20);
              if ( v21 )
                goto LABEL_24;
              v50 = v63;
            }
            else
            {
              v50 = v61;
            }
            v51 = jhl_nvget(v50, v7);
            v21 = nvram_get(v51);
            if ( !v21 )
            {
              v52 = (int)*v19;
              v61 = (char *)(a3 - v18);
              v24 = snprintf(&a2[v18], a3 - v18, v68, v52);
              v25 = (int)v61;
              if ( v24 < (int)v61 )
                goto LABEL_25;
              goto LABEL_57;
            }
LABEL_24:
            v61 = (char *)*v19;
            v22 = get_json_data(v21);
            v23 = (int)v61;
            v61 = (char *)(a3 - v18);
            v24 = snprintf(&a2[v18], a3 - v18, format, v23, v22);
            v25 = (int)v61;
            if ( v24 < (int)v61 )
              goto LABEL_25;
LABEL_57:
            v24 = v25 - 1;
LABEL_25:
            v17 = *++v19;
            v18 += v24;
          }
          while ( *v19 && *v17 );
        }
        v26 = jhl_nvget("mr_parm", v7);
        v27 = (char *)nvram_get(v26);
        if ( !v27 || !*v27 )
          v27 = " ";
        v61 = v58;
        strlcpy(v58, v27, 512);
        v28 = split_string(v61, 60, v60, 14);
        mr_parm_default(v28, v60, v7);
        v29 = snprintf(&a2[v18], a3 - v18, ",\"mr_zc_en\":\"%s\"", v60[2]);
        if ( v29 >= a3 - v18 )
          v29 = a3 - v18 - 1;
        v30 = v29 + v18;
        v31 = snprintf(&a2[v30], a3 - v30, ",\"mr_jh_en\":\"%s\"", v60[0]);
        if ( v31 >= a3 - v30 )
          v31 = a3 - v30 - 1;
        v32 = v31 + v30;
        v33 = a3 - (v31 + v30);
        v34 = snprintf(&a2[v32], v33, ",\"host\":\"%s\"", v60[12]);
        if ( v34 >= v33 )
          v34 = v33 - 1;
        v36 = v34 + v32;
        v35 = (const char *)jhl_get_wanstatus(v7);
        v37 = snprintf(&a2[v36], a3 - v36, ",\"wan_state\":\"%s\"", v35);
        if ( v37 >= a3 - v36 )
          v37 = a3 - v36 - 1;
        v38 = v37 + v36;
        jhl_link_uptime(v59, v7, v8);
        v61 = (char *)(a3 - v38);
        v39 = snprintf(&a2[v38], a3 - v38, ",\"wan_uptime\":\"%s\"", v59);
        if ( v39 >= (int)v61 )
          v39 = (int)(v61 - 1);
        v41 = v39 + v38;
        v40 = jhl_link_uptime_s(v7, v8);
        v42 = snprintf(&a2[v41], a3 - v41, ",\"connect_time\":%ld", v40);
        if ( v42 >= a3 - v41 )
          v42 = a3 - v41 - 1;
        v43 = v42 + v41 + get_iface_increase_data(v7, &a2[v42 + v41], a3 - (v42 + v41));
        v44 = v43 + get_iface_pppoe_br_data(v7, &a2[v43], a3 - v43);
        if ( v11 == 4 )
        {
          v53 = jhl_nvget("ppp_get_ip", v7);
          v54 = (const char *)nvram_get(v53);
          if ( !v54 )
            v54 = "0.0.0.0";
          v55 = jhl_nvget("ppp_gw", v7);
          v56 = (const char *)nvram_get(v55);
          if ( !v56 )
            v56 = v54;
          v57 = snprintf(
                  &a2[v44],
                  a3 - v44,
                  ",\"ppp_wan_ip\":\"%s\",\"ppp_wan_mask\":\"%s\",\"ppp_wan_gw\":\"%s\"",
                  v54,
                  v67,
                  v56);
          if ( v57 >= a3 - v44 )
            v57 = a3 - v44 - 1;
          v44 += v57;
        }
        v45 = snprintf(&a2[v44], a3 - v44, &byte_65078C);
        if ( v45 >= a3 - v44 )
          v45 = a3 - v44 - 1;
        ++v7;
        v6 = v44 + v45;
        if ( v5 == v7 )
          break;
      }
    }
  }
  v46 = &a2[v6];
  if ( v6 > 0 && *(v46 - 1) == 44 )
    v46 = &a2[--v6];
  v47 = a3 - v6;
  *v46 = 0;
  v48 = snprintf(v46, v47, "],");
  if ( v48 >= v47 )
    v48 = v47 - 1;
  return v6 + v48;
}
// 65078C: using guessed type char byte_65078C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8270: using guessed type int __fastcall mr_parm_default(_DWORD, _DWORD, _DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84E0: using guessed type int __fastcall jhl_get_wanstatus(_DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (0044293C) --------------------------------------------------------
int __fastcall wan_webset_json(int a1)
{
  int v1; // $s0
  int v2; // $s7
  int v3; // $fp
  int v4; // $v0
  int v5; // $s0
  int v6; // $v0
  int v7; // $s2
  int v8; // $v0
  _DWORD *v9; // $s4
  const char *v10; // $s3
  const char *v11; // $s0
  _DWORD *v12; // $s1
  char *v13; // $s4
  const char *v14; // $s1
  char *v15; // $v0
  int v16; // $v0
  const char *v17; // $v0
  int v18; // $v0
  int v19; // $s0
  int v20; // $v0
  const char *v21; // $v0
  int v22; // $v0
  int v23; // $v0
  int v24; // $v0
  char *v25; // $v0
  int v26; // $v0
  char *v27; // $v0
  int v28; // $v0
  const char *v29; // $v0
  int v30; // $v0
  char *v31; // $v0
  int v33; // $v0
  int v34; // $v0
  const char *v35; // $v0
  int v36; // $v0
  const char *v37; // $v0
  int v38; // $v0
  int v39; // $v0
  const char *v40; // $v0
  int v41; // $v0
  const char *v42; // $v0
  int v43; // $v0
  int v44; // $v0
  const char *v45; // $v0
  int v46; // $v0
  const char *v47; // $v0
  int v48; // $v0
  size_t v49; // $v0
  char v50[512]; // [sp+18h] [-290h] BYREF
  const char *v51; // [sp+218h] [-90h] BYREF
  const char *v52; // [sp+21Ch] [-8Ch]
  char *v53; // [sp+220h] [-88h]
  char *v54; // [sp+224h] [-84h]
  char *v55; // [sp+228h] [-80h]
  const char *v56; // [sp+22Ch] [-7Ch]
  char *v57; // [sp+230h] [-78h]
  int v58; // [sp+234h] [-74h]
  int v59[6]; // [sp+238h] [-70h] BYREF
  char *v60; // [sp+250h] [-58h]
  char *v61; // [sp+254h] [-54h]
  char *v62; // [sp+258h] [-50h]
  char *v63; // [sp+25Ch] [-4Ch]
  char *v64; // [sp+260h] [-48h]
  char *v65; // [sp+264h] [-44h]
  char *v66; // [sp+268h] [-40h]
  char *v67; // [sp+26Ch] [-3Ch]
  int v68; // [sp+270h] [-38h]
  char *v69; // [sp+274h] [-34h]
  char *v70; // [sp+278h] [-30h]
  char *v71; // [sp+27Ch] [-2Ch]
  char *v72; // [sp+280h] [-28h]
  char *v73; // [sp+284h] [-24h]
  char *v74; // [sp+288h] [-20h]
  char *v75; // [sp+28Ch] [-1Ch]
  int v76; // [sp+290h] [-18h]
  int v77; // [sp+294h] [-14h]
  int v78; // [sp+298h] [-10h]
  char *v79; // [sp+29Ch] [-Ch]
  char *v80; // [sp+2A0h] [-8h]
  const char *v81; // [sp+2A4h] [-4h]

  v1 = httpd_get_json_parm(a1, (int)"wans");
  v76 = v1;
  if ( v1 )
  {
    v81 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
    nvram_set("wan_webset_run", "1");
    v77 = cJSON_GetArraySize(v1);
    v2 = 0;
    if ( v77 <= 0 )
    {
      v3 = 0;
      goto LABEL_53;
    }
    v72 = "a";
    v80 = "a";
    v65 = "qos_dk";
    v3 = 0;
    v64 = "wan_time";
    v79 = "mr_jh_en";
    while ( 1 )
    {
      v5 = cJSON_GetArrayItem(v76, v2);
      v4 = cJSON_GetObjectItem(v5, "iface");
      v7 = cJSON_GetIntvalue(v4);
      v6 = cJSON_GetObjectItem(v5, "base64");
      v8 = cJSON_GetIntvalue(v6);
      v9 = *(_DWORD **)(v5 + 8);
      v78 = v8;
      if ( !v9 )
      {
        v69 = 0;
        v67 = 0;
        v63 = 0;
        v73 = 0;
        v74 = 0;
        v75 = 0;
        v70 = 0;
        v68 = 0;
        goto LABEL_34;
      }
      v66 = 0;
      v69 = 0;
      v71 = 0;
      v62 = 0;
      v60 = 0;
      v10 = 0;
      v67 = 0;
      v61 = 0;
      v63 = 0;
      v73 = 0;
      v74 = 0;
      v75 = 0;
      v70 = 0;
      v68 = 0;
      do
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
                    while ( 1 )
                    {
                      v11 = (const char *)v9[8];
                      v12 = (_DWORD *)*v9;
                      if ( !strcmp(v11, "iface") || !strcmp(v11, "base64") )
                        goto LABEL_15;
                      v13 = (char *)v9[4];
                      if ( strcmp(v11, v65) )
                        break;
                      v61 = v13;
                      v9 = v12;
                      if ( !v12 )
                        goto LABEL_16;
                    }
                    if ( strcmp(v11, v64) )
                      break;
                    v10 = v13;
                    v9 = v12;
                    if ( !v12 )
                      goto LABEL_16;
                  }
                  if ( strcmp(v11, v72 + 13564) )
                    break;
                  v60 = v13;
                  v9 = v12;
                  if ( !v12 )
                    goto LABEL_16;
                }
                if ( strcmp(v11, v79) )
                  break;
                v62 = v13;
                v9 = v12;
                if ( !v12 )
                  goto LABEL_16;
              }
              if ( strcmp(v11, v80 + 13588) )
                break;
              v66 = v13;
              v9 = v12;
              if ( !v12 )
                goto LABEL_16;
            }
            if ( strcmp(v11, "host") )
              break;
            v71 = v13;
LABEL_15:
            v9 = v12;
            if ( !v12 )
              goto LABEL_16;
          }
          if ( strcmp(v11, "port_speed") )
            break;
          v69 = v13;
          v9 = v12;
          if ( !v12 )
            goto LABEL_16;
        }
        if ( !strcmp(v11, "wan_dns") )
        {
          v70 = v13;
        }
        else if ( !strcmp(v11, "ppp_passwd") )
        {
          if ( !v78 )
            goto LABEL_100;
          v68 = (int)v50;
          memset(v50, 0, sizeof(v50));
          v49 = strlen(v13);
          base64_decode(v13, v68, v49);
          v13 = (char *)v68;
          v68 = 1;
        }
        else if ( !strcmp(v11, "dns_v") )
        {
          v75 = v13;
        }
        else if ( !strcmp(v11, "jb_en") )
        {
          v74 = v13;
        }
        else if ( !strcmp(v11, "wk_mode") )
        {
          v63 = v13;
        }
        else
        {
          if ( strcmp(v11, "wan_isp") )
          {
LABEL_100:
            v68 = 1;
            goto LABEL_110;
          }
          v67 = v13;
        }
LABEL_110:
        if ( strcmp(v11, "wan_proto") )
        {
          v46 = jhl_nvget(v11, v7);
          v47 = (const char *)nvram_get(v46);
          if ( !v47 || !v13 || strcmp(v47, v13) )
          {
            v48 = jhl_nvget(v11, v7);
            nvram_set(v48, v13);
            v3 = 1;
          }
          goto LABEL_15;
        }
        v73 = v13;
        v9 = v12;
      }
      while ( v12 );
LABEL_16:
      v14 = v10;
      if ( v10 )
      {
        if ( *v10 )
        {
          do
          {
            v15 = strchr(v14++, 124);
            if ( v15 )
              *v15 = 44;
          }
          while ( *v14 );
        }
        v16 = jhl_nvget(v64, v7);
        v17 = (const char *)nvram_get(v16);
        if ( v17 && !strcmp(v17, v10) )
        {
          if ( v60 )
          {
            v19 = 0;
            goto LABEL_25;
          }
        }
        else
        {
          v18 = jhl_nvget(v64, v7);
          nvram_set(v18, v10);
          v3 = 1;
          if ( !v60 )
            goto LABEL_28;
          v19 = 1;
LABEL_25:
          v20 = jhl_nvget(v72 + 13564, v7);
          v21 = (const char *)nvram_get(v20);
          if ( v21 && !strcmp(v21, v60) )
          {
            if ( v19 )
              goto LABEL_29;
          }
          else
          {
            v22 = jhl_nvget(v72 + 13564, v7);
            nvram_set(v22, v60);
LABEL_28:
            v3 = 1;
LABEL_29:
            restart_wan_auto_conn(v7);
          }
        }
      }
      else if ( v60 )
      {
        v19 = 0;
        goto LABEL_25;
      }
      if ( v61 )
      {
        qos_parm_apply(v7, (int)v61, 1);
        v3 = 1;
      }
      if ( v62 || v66 || v71 )
      {
        mr_set_by_jh_en(v7, v62, v66, v71);
        v3 = 1;
      }
LABEL_34:
      if ( v69 )
      {
        v23 = J_atoi(v69);
        set_port_mode(v7, 1, v23);
        v3 = 1;
      }
      if ( v67 )
        v3 = 1;
      if ( v70 || v75 )
      {
        jhl_mr_set_dns(v7);
        v3 = 1;
        jhl_ctreate_dmresolv();
      }
      if ( v63 || v74 || v67 )
      {
        v51 = "wys";
        v52 = "devmg";
        v53 = "set";
        v24 = jhl_nvget("wan_name", v7);
        v25 = (char *)nvram_get(v24);
        if ( !v25 )
          v25 = "";
        v54 = v25;
        v26 = jhl_nvget("jb_en", v7);
        v27 = (char *)nvram_get(v26);
        if ( !v27 )
          v27 = "0";
        v55 = v27;
        v28 = jhl_nvget("wk_mode", v7);
        v29 = (const char *)nvram_get(v28);
        if ( !v29 )
          v29 = "gateway";
        v56 = v29;
        v30 = jhl_nvget("wan_isp", v7);
        v31 = (char *)nvram_get(v30);
        if ( !v31 )
          v31 = "0";
        v57 = v31;
        v58 = 0;
        eval(&v51, 0, 0, 0);
        if ( v63 )
        {
          v3 = 1;
          jhl_start_firewall();
          goto LABEL_51;
        }
        v3 = 1;
        if ( v68 )
          goto LABEL_73;
        goto LABEL_52;
      }
LABEL_51:
      if ( !v68 )
        goto LABEL_52;
LABEL_73:
      v51 = 0;
      v52 = 0;
      v53 = 0;
      v54 = 0;
      v55 = 0;
      v56 = 0;
      v57 = 0;
      v58 = 0;
      sprintf((char *)&v51, "%d", v7);
      v33 = jhl_nvget("wan_new_proto", v7);
      nvram_unset(v33);
      if ( !v73 )
      {
        v44 = jhl_nvget("wan_proto", v7);
        v45 = (const char *)nvram_get(v44);
        if ( v45 && !strcmp(v45, "pppoe") )
          goto LABEL_87;
LABEL_80:
        v59[0] = (int)"wan_conn";
        v59[1] = (int)"restart";
        v59[2] = (int)&v51;
        v59[3] = (int)"wan_webset_json";
        v59[4] = 0;
        eval_nowait(v59, 0, 0, 0);
        v3 = 1;
        goto LABEL_52;
      }
      if ( !strcmp(v73, "pppoe") )
      {
        v34 = jhl_nvget("ppp_demand", v7);
        v35 = (const char *)nvram_get(v34);
        if ( !v35 || strcmp(v35, "2") )
          goto LABEL_77;
        jhl_stop_wan(v7);
LABEL_95:
        v43 = jhl_nvget("wan_proto", v7);
        nvram_set(v43, v73);
        v3 = 1;
        goto LABEL_52;
      }
      v39 = jhl_nvget("wan_proto", v7);
      v40 = (const char *)nvram_get(v39);
      if ( !v40 || strcmp(v40, "pppoe") )
        goto LABEL_77;
LABEL_87:
      v41 = jhl_nvget("ppp_demand", v7);
      v42 = (const char *)nvram_get(v41);
      if ( !v42 || strcmp(v42, "2") )
      {
        if ( v73 )
        {
LABEL_77:
          v36 = jhl_nvget("wan_proto", v7);
          v37 = (const char *)nvram_get(v36);
          if ( !v37 || strcmp(v37, v73) )
          {
            v38 = jhl_nvget("wan_new_proto", v7);
            nvram_set(v38, v73);
          }
        }
        goto LABEL_80;
      }
      jhl_stop_wan(v7);
      if ( v73 )
        goto LABEL_95;
      v3 = 1;
LABEL_52:
      if ( v77 == ++v2 )
      {
LABEL_53:
        nvram_unset(v81 + 8180);
        return v3;
      }
    }
  }
  return 0;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81C8: using guessed type int __fastcall jhl_mr_set_dns(_DWORD);
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A81E8: using guessed type int jhl_ctreate_dmresolv(void);
// 6A83A4: using guessed type int __fastcall mr_set_by_jh_en(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8518: using guessed type int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A86FC: using guessed type int __fastcall cJSON_GetArraySize(_DWORD);
// 6A8744: using guessed type int __fastcall cJSON_GetIntvalue(_DWORD);
// 6A87E8: using guessed type int __fastcall jhl_stop_wan(_DWORD);
// 6A889C: using guessed type int __fastcall set_port_mode(_DWORD, _DWORD, _DWORD);
// 6A88F4: using guessed type int __fastcall restart_wan_auto_conn(_DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00443744) --------------------------------------------------------
int __fastcall wan_webset(int a1)
{
  return wan_webset_json(a1);
}

//----- (00443760) --------------------------------------------------------
int __fastcall lan_webset(int a1)
{
  char **v1; // $v0
  char **v3; // $v1
  char *v4; // $t0
  char *v5; // $a3
  char *v6; // $a2
  char *v7; // $a1
  int v8; // $s1
  int v9; // $s1
  int v10; // $s1
  int v11; // $s2
  int v12; // $s1
  int result; // $v0
  char *v14[14]; // [sp+18h] [-38h] BYREF

  v1 = off_66D260;
  v3 = v14;
  do
  {
    v4 = *v1;
    v5 = v1[1];
    v6 = v1[2];
    v7 = v1[3];
    v1 += 4;
    *v3 = v4;
    v3[1] = v5;
    v3[2] = v6;
    v3[3] = v7;
    v3 += 4;
  }
  while ( v1 != (char **)&off_66D290 );
  *v3 = *v1;
  v8 = jhl_web_save_parm(a1, "dnsMaxtm", 1);
  v9 = v8 | jhl_web_save_parm(a1, "dnsMintm", 1);
  v10 = v9 | jhl_web_save_parm(a1, "dnsEn", 1);
  if ( v10 | jhl_web_save_parm(a1, "dnsShowct", 1) )
  {
    v11 = 1;
    dns_srv_start();
  }
  else
  {
    v11 = 0;
  }
  if ( jhl_web_save_parm(a1, "duolanlist", 0) || jhl_web_save_parm(a1, "duolan_enble", 0) )
  {
    v11 = 1;
    duolan_undo();
    jhl_web_save_parm(a1, "duolanlist", 1);
    jhl_web_save_parm(a1, "duolan_enble", 1);
    duolan_do(0);
  }
  v12 = jhl_web_save_parm(a1, "lan_ipaddr", 1);
  if ( v12 | jhl_web_save_parm(a1, "lan_netmask", 1) )
  {
    jhl_web_save_parms(a1, v14, 1);
    lanip_change();
    start_dhcp_server();
    start_rzgl(0);
    start_arp_sys();
    exec_service("ac_server-restart");
    goto LABEL_10;
  }
  if ( jhl_web_save_parms(a1, v14, 1) )
  {
    start_dhcp_server();
    goto LABEL_10;
  }
  result = v11;
  if ( v11 )
  {
LABEL_10:
    jhl_start_firewall();
    result = 1;
  }
  return result;
}
// 66D260: using guessed type char *off_66D260[11];
// 66D290: using guessed type void *off_66D290;
// 6A81EC: using guessed type int start_arp_sys(void);
// 6A8300: using guessed type int dns_srv_start(void);
// 6A8398: using guessed type int duolan_undo(void);
// 6A83CC: using guessed type int __fastcall duolan_do(_DWORD);
// 6A84B8: using guessed type int start_dhcp_server(void);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A86D0: using guessed type int lanip_change(void);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (00443A94) --------------------------------------------------------
int __fastcall get_dual_lan_list_data(char *a1, int a2)
{
  int v4; // $s3
  char *v5; // $s1
  int v6; // $s5
  int v7; // $s2
  char *v8; // $v0
  const char *v9; // $s0
  signed int v10; // $v0
  bool v11; // dc
  int v12; // $v0
  const char *v13; // $v0
  int v14; // $v0
  int v15; // $s4
  int v16; // $v0
  char *v17; // $a0
  int v18; // $s6
  int v19; // $v0
  char v21[8192]; // [sp+50h] [-20E8h] BYREF
  char v22[136]; // [sp+2050h] [-E8h] BYREF
  int v23[3]; // [sp+20D8h] [-60h] BYREF
  char *v24; // [sp+20E4h] [-54h]
  int v25; // [sp+20E8h] [-50h]
  int v26; // [sp+20ECh] [-4Ch]
  int v27; // [sp+20F0h] [-48h]
  int v28; // [sp+20F4h] [-44h]
  int v29; // [sp+20F8h] [-40h]
  int v30; // [sp+20FCh] [-3Ch]
  int v31; // [sp+2100h] [-38h]
  int v32; // [sp+2104h] [-34h]
  const char *v33; // [sp+2108h] [-30h]
  char *haystack; // [sp+210Ch] [-2Ch]
  int v35; // [sp+2110h] [-28h]
  char *v36; // [sp+2120h] [-18h]
  char *v37; // [sp+2124h] [-14h]
  char *format; // [sp+2128h] [-10h]
  char *v39; // [sp+212Ch] [-Ch]
  const char *v40; // [sp+2130h] [-8h]

  memset(v21, 0, sizeof(v21));
  jhl_parm_get("dual_lan_list", v21, 0x2000);
  v4 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v4 >= a2 )
    v4 = a2 - 1;
  v5 = v22;
  v6 = split_string(v21, 60, v22, 32);
  if ( v6 > 0 )
  {
    v7 = 0;
    v37 = "a";
    v40 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
    v36 = (char *)&off_63F984;
    format = "{\"vlanid\":\"%s\",\"lan_ipaddr\":\"%s\",\"lan_netmask\":\"%s\",\"dhcp_type\":\"%s\",\"dhcp_lease\":%s,\"dh"
             "cp_start\":\"%s\",\"dhcp_end\":\"%s\",\"dhcp_gw\":\"%s\",\"dhcp_dns0\":\"%s\",\"dhcp_dns1\":\"%s\",\"dhcp_m"
             "ask\":\"%s\",\"mac_lan\":\"%s\",\"port\":\"%s\",\"mem\":\"%s\",\"dhcp_option43\":\"%s\"},";
    v39 = "admin";
    do
    {
      if ( split_string(*(_DWORD *)v5, 124, v23, 15) >= 13 )
      {
        if ( strcmp(v24, v36) )
          v24 = v39;
        v8 = strstr(haystack, v37 + 9684);
        if ( v8 )
          *v8 = 0;
        v9 = v33;
        v10 = strlen(v33);
        v11 = v10 <= 0;
        v12 = v10 - 1;
        if ( !v11 )
        {
          v13 = &v9[v12];
          if ( *v13 == 44 )
          {
            *v13 = 0;
            v9 = v33;
          }
        }
        v14 = v35;
        v15 = a2 - v4;
        if ( !v35 )
          v14 = (int)(v40 - 1556);
        v16 = snprintf(
                &a1[v4],
                a2 - v4,
                format,
                v23[0],
                v23[1],
                v23[2],
                v24,
                v25,
                v26,
                v27,
                v28,
                v30,
                v31,
                v29,
                v32,
                v9,
                haystack,
                v14);
        if ( v16 >= v15 )
          v16 = v15 - 1;
        v4 += v16;
      }
      ++v7;
      v5 += 4;
    }
    while ( v6 != v7 );
  }
  v17 = &a1[v4];
  if ( v4 > 0 && *(v17 - 1) == 44 )
    v17 = &a1[--v4];
  v18 = a2 - v4;
  *v17 = 0;
  v19 = snprintf(v17, v18, &byte_6445A0);
  if ( v19 >= v18 )
    v19 = v18 - 1;
  return v4 + v19;
}
// 63F984: using guessed type void *off_63F984;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00443DAC) --------------------------------------------------------
void __fastcall dhcp_list_buf(int a1, int a2, int a3)
{
  _DWORD *v6; // $v0
  _DWORD *v7; // $s7
  _DWORD *v8; // $s0
  int v9; // $a2
  int v10; // $s6
  int v11; // $s1
  const char *v12; // $fp
  const char *v13; // $v0
  char v14[32]; // [sp+10h] [-50h] BYREF
  uint32_t v15; // [sp+30h] [-30h]
  char *v16; // [sp+34h] [-2Ch]

  if ( a1 )
  {
    if ( a3 )
    {
      v16 = "a";
      _mem_malloc(0x100000, "dhcp_list_buf", 2949);
      v7 = v6;
      if ( v6 )
      {
        v8 = v6 + 6;
        *v6 = 5;
        v6[3] = 4;
        v6[1] = 0x100000;
        strlcpy(v6 + 6, a3, 64);
        if ( !jianhl_order_opt_fun(v7, v7[1], v9) && (int)v7[5] > 0 )
        {
          v10 = 0;
          if ( a2 >= 100 )
          {
            v11 = 0;
            do
            {
              v12 = (const char *)get_json_data(v8);
              v15 = ntohl(v8[16]);
              v13 = (const char *)MacToStr(v14, v8 + 17);
              ++v10;
              v11 += sprintf(
                       (char *)(a1 + v11),
                       "{\"n\":\"%s\",\"i\":%u,\"m\":\"%s\",\"t\":%lu},",
                       v12,
                       v15,
                       v13,
                       v8[24]);
              v8 += 25;
            }
            while ( v10 < v7[5] && a2 - v11 >= 100 );
          }
        }
        _mem_free(v7);
      }
    }
  }
}
// 443E28: variable 'v6' is possibly undefined
// 443E6C: variable 'v9' is possibly undefined
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00443FA8) --------------------------------------------------------
int __fastcall sub_443FA8(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  const char *v4; // $v0
  int v5; // $v0
  int v6; // $v0
  int i; // $s7
  int v8; // $a0
  char *v9; // $a0
  int v10; // $a2
  int v12; // $v0
  const char *v13; // $a0
  char *v14; // $v0
  char *v15; // $s6
  char *v16; // $v0
  int v17; // $v1
  int v18; // $v0
  int v19; // $v0
  const char *v20; // $v0
  unsigned int v21; // $v0
  char *v22[65]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "dhcp_list_data", 3002);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\"", 20);
    v4 = (const char *)jhl_nv_get_def("dual_lan_mode");
    if ( !strcmp(v4, "1") )
    {
      v12 = nvram_get("lan_ifnames");
      if ( v12 )
        v13 = (const char *)v12;
      else
        v13 = "";
      v14 = strdup(v13);
      v15 = v14;
      if ( v14 )
      {
        v22[0] = v14;
        v16 = strsep(v22, " ");
        for ( i = 29; v16; v16 = strsep(v22, " ") )
        {
          do
            v17 = *v16++;
          while ( v17 == 32 );
          v18 = (int)(v16 - 1);
          if ( !v17 )
            break;
          dhcp_list_buf((int)&v3[i], 0x200000 - i, v18);
          i += v19;
        }
        free(v15);
LABEL_5:
        v8 = i;
        if ( i <= 0 || v3[i - 1] != 44 )
        {
LABEL_7:
          v9 = &v3[v8];
          *v9 = 0;
          v10 = snprintf(v9, 0x200000 - i, "]}");
          if ( v10 >= 0x200000 - i )
            v10 = 0x1FFFFF - i;
          return httpd_cgi_ret(a1, v3, i + v10, 8);
        }
LABEL_20:
        v8 = --i;
        goto LABEL_7;
      }
    }
    else
    {
      v5 = jhl_nv_get_def("lan_ifname");
      dhcp_list_buf((int)(v3 + 29), 2097123, v5);
      if ( v6 )
      {
        i = v6 + 29;
        goto LABEL_5;
      }
    }
    v8 = 29;
    i = 29;
    if ( v3[28] != 44 )
      goto LABEL_7;
    goto LABEL_20;
  }
  v20 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v21 = snprintf((char *)v22, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v20);
  if ( v21 >= 0x100 )
    v21 = 255;
  return httpd_cgi_ret(a1, (char *)v22, v21, 4);
}
// 444004: variable 'v2' is possibly undefined
// 4440E0: variable 'v6' is possibly undefined
// 444240: variable 'v19' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (00444318) --------------------------------------------------------
int __fastcall get_lan_vlan_data(char *a1, int a2)
{
  int v4; // $s2
  char *v5; // $v0
  int result; // $v0
  int v7; // $s1
  char *v8; // $v0
  char v9[64]; // [sp+20h] [-40h] BYREF

  memset(v9, 0, sizeof(v9));
  v4 = get_lans_num();
  v5 = (char *)nvram_get("lan_vlan");
  if ( !v5 )
  {
    v7 = 0;
    if ( v4 > 0 )
    {
      do
      {
        v8 = &v9[strlen(v9)];
        ++v7;
        *v8 = 49;
        v8[1] = 124;
        v8[2] = 0;
      }
      while ( v4 != v7 );
    }
    v5 = v9;
  }
  result = snprintf(a1, a2, "\"lan_num\":\"%d\",\"lan_vlan\":\"%s\"", v4, v5);
  if ( result >= a2 )
    result = a2 - 1;
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A87A0: using guessed type int get_lans_num(void);

//----- (00444448) --------------------------------------------------------
int __fastcall lans_data(int a1)
{
  char *v1; // $v0
  char *v2; // $s5
  char *v3; // $v0
  char *v4; // $v0
  char *v5; // $s6
  char *v6; // $s4
  int v7; // $s2
  const char *v8; // $s3
  const char *v9; // $v0
  int v10; // $s2
  int v11; // $s2
  const char *v12; // $v0
  int v13; // $s2
  int v14; // $v0
  char *v15; // $v1
  char *v16; // $v0
  int v17; // $s7
  char **v18; // $s3
  const char *v19; // $s1
  char *v20; // $s0
  int v21; // $v0
  const char *v22; // $s0
  int v23; // $v0
  const char *v24; // $v0
  const char *v25; // $s3
  int v26; // $v0
  int v27; // $v0
  int v28; // $v0
  int v29; // $v0
  int v30; // $v0
  int v31; // $v0
  int v32; // $v0
  int v33; // $v0
  int v34; // $v0
  int v35; // $v0
  int v36; // $v0
  int v37; // $v0
  int v38; // $v0
  const char *v39; // $v0
  const char *v40; // $fp
  int v41; // $v0
  int v42; // $v0
  const char *v43; // $v0
  char *v44; // $v0
  char *v45; // $v0
  int v46; // $v0
  const char *v47; // $s2
  int v48; // $v0
  const char *v49; // $v0
  char *v50; // $v0
  char *v51; // $v0
  int v52; // $v0
  int v53; // $v0
  const char *v54; // $s4
  int v55; // $v0
  const char *v56; // $s1
  int v57; // $v0
  const char *v58; // $v0
  const char *v59; // $a2
  int v60; // $a3
  int v61; // $v0
  int v62; // $s1
  int v63; // $s0
  int v64; // $v0
  int v65; // $v0
  const char *v66; // $v0
  int v67; // $s0
  int v68; // $v0
  int v69; // $s0
  int v70; // $v0
  int v71; // $s0
  int result; // $v0
  const char *v73; // $v0
  unsigned int v74; // $s0
  char v75[2048]; // [sp+78h] [-CC0h] BYREF
  char v76[1024]; // [sp+878h] [-4C0h] BYREF
  char v77[32]; // [sp+C78h] [-C0h] BYREF
  int v78[8]; // [sp+C98h] [-A0h] BYREF
  char *v79; // [sp+CB8h] [-80h] BYREF
  int v80; // [sp+CC0h] [-78h]
  int v81; // [sp+CC4h] [-74h]
  char *v82; // [sp+CC8h] [-70h]
  char *v83; // [sp+CCCh] [-6Ch]
  const char *v84; // [sp+CD0h] [-68h]
  const char *v85; // [sp+CD4h] [-64h]
  const char *v86; // [sp+CD8h] [-60h]
  const char *v87; // [sp+CDCh] [-5Ch]
  char *v88; // [sp+CE0h] [-58h]
  const char *v89; // [sp+CE4h] [-54h]
  char *v90; // [sp+CE8h] [-50h]
  const char *v91; // [sp+CECh] [-4Ch]
  char *v92; // [sp+CF0h] [-48h]
  char *v93; // [sp+CF4h] [-44h]
  char *v94; // [sp+CF8h] [-40h]
  char *v95; // [sp+CFCh] [-3Ch]
  char *v96; // [sp+D00h] [-38h]
  char *v97; // [sp+D04h] [-34h]
  char *v98; // [sp+D08h] [-30h]
  int v99; // [sp+D0Ch] [-2Ch]
  char *v100; // [sp+D10h] [-28h]
  int *v101; // [sp+D14h] [-24h]
  char *v102; // [sp+D18h] [-20h]
  char *v103; // [sp+D1Ch] [-1Ch]
  char *v104; // [sp+D20h] [-18h]
  char *v105; // [sp+D24h] [-14h]
  char *v106; // [sp+D28h] [-10h]
  const char *v107; // [sp+D2Ch] [-Ch]
  void *ptr; // [sp+D30h] [-8h]

  memset(v75, 0, sizeof(v75));
  v106 = "a";
  memset(v76, 0, sizeof(v76));
  _mem_malloc(10240, "lans_data", 1994);
  v2 = v1;
  _mem_malloc(10240, "lans_data", 1995);
  v5 = v4;
  _mem_malloc(102400, "lans_data", 1996);
  v6 = v3;
  if ( v2 && v5 && v3 )
  {
    strcpy(v3, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v3, "{\"code\":0,\"error\":\"\",\"da", 24);
    v7 = sprintf(v3 + 29, "\"x86\":%d,", 0) + 29;
    v8 = (const char *)jhl_nv_get_def("dual_lan_mode");
    v9 = (const char *)jhl_nv_get_def("dhcp_bind_ipmac_en");
    v10 = v7 + sprintf(&v6[v7], "\"dual_lan_mode\":\"%s\",\"dhcp_bind_ipmac_en\":\"%s\"", v8, v9);
    v11 = v10 + sprintf(&v6[v10], ",\"duolan_en\":\"%d\"", 1);
    v12 = (const char *)jhl_nv_get_def("duolan_enble");
    v13 = v11 + sprintf(&v6[v11], ",\"duolan_enble\":\"%s\",\"duolanlist\":", v12);
    v14 = v13 + get_duolanlist_data(&v6[v13], 102400 - v13);
    v15 = &v6[v14];
    strcpy(&v6[v14], ",\"lans\":[");
    *(_DWORD *)v15 = 1634476588;
    *((_DWORD *)v15 + 1) = 975336302;
    v80 = v14 + 9;
    get_lan_ifnames(v75, 2048);
    v16 = strdup(v75);
    ptr = v16;
    if ( v16 )
    {
      v79 = v16;
      v81 = 1;
      v100 = "1\"";
      v17 = 0;
      v83 = (char *)&unk_643780;
      v82 = v6;
      v103 = (char *)&off_643784;
      v101 = (int *)&v79;
      v105 = "a";
      v104 = "a";
      v107 = "lan_ifacebind";
LABEL_6:
      v18 = (char **)v101;
      v19 = v100 - 10364;
      while ( 1 )
      {
        v20 = strsep(v18, v19);
        if ( !v20 )
          break;
        do
          v21 = *v20++;
        while ( v21 == 32 );
        v22 = v20 - 1;
        if ( !v21 )
          break;
        if ( strncmp(v22, v83, 3u) )
        {
          if ( !strncmp(v22, v103, 3u) )
          {
            v99 = 1;
            if ( v17 )
              goto LABEL_76;
LABEL_13:
            v84 = v104 - 1660;
          }
          else
          {
            v99 = 2 * (strncmp(v22, v105 + 14216, 3u) == 0);
            if ( !v17 )
              goto LABEL_13;
LABEL_76:
            v65 = jhl_langet(v107, v17);
            v66 = (const char *)nvram_get(v65);
            v84 = v66;
            if ( v66 )
            {
              if ( strlen(v66) < 3 )
                v84 = "LAN1";
            }
            else
            {
              v84 = "LAN1";
            }
          }
          v23 = jhl_langet("dhcp_type", v17);
          v24 = (const char *)nvram_get(v23);
          v25 = v24;
          if ( v24 )
          {
            if ( strcmp(v24, (const char *)&off_63F984) )
              v25 = "admin";
          }
          else
          {
            v25 = (const char *)&off_63F984;
          }
          v26 = jhl_langet("dhcp_lease", v17);
          v85 = (const char *)nvram_get(v26);
          if ( !v85 )
            v85 = "3600";
          v27 = jhl_langet("dhcp_start", v17);
          v86 = (const char *)nvram_get(v27);
          if ( !v86 )
            v86 = "0.0.0.0";
          v28 = jhl_langet("dhcp_end", v17);
          v87 = (const char *)nvram_get(v28);
          if ( !v87 )
            v87 = "0.0.0.0";
          v29 = jhl_langet("lan_ipaddr", v17);
          v88 = (char *)nvram_get(v29);
          if ( !v88 )
            v88 = "";
          v30 = jhl_langet("lan_netmask", v17);
          v89 = (const char *)nvram_get(v30);
          if ( !v89 )
            v89 = "255.255.255.0";
          v31 = jhl_langet("dhcp_gw", v17);
          v90 = (char *)nvram_get(v31);
          if ( !v90 )
            v90 = "";
          v32 = jhl_langet("dhcp_mask", v17);
          v91 = (const char *)nvram_get(v32);
          if ( !v91 )
            v91 = "255.255.255.0";
          v33 = jhl_langet("dhcp_dns0", v17);
          v92 = (char *)nvram_get(v33);
          if ( !v92 )
            v92 = "";
          v34 = jhl_langet("dhcp_dns1", v17);
          v93 = (char *)nvram_get(v34);
          if ( !v93 )
            v93 = "";
          v35 = jhl_langet("dhcp_option43", v17);
          v94 = (char *)nvram_get(v35);
          if ( !v94 )
            v94 = "";
          v36 = jhl_langet("dhcp_filter", v17);
          v95 = (char *)nvram_get(v36);
          if ( !v95 )
            v95 = "";
          v37 = jhl_langet("mac_deflan", v17);
          v96 = (char *)nvram_get(v37);
          if ( !v96 )
            v96 = "";
          v38 = jhl_langet("mac_lan", v17);
          v39 = (const char *)nvram_get(v38);
          v40 = v39;
          if ( v39 )
          {
            if ( strlen(v39) >= 5 )
            {
LABEL_43:
              v41 = jhl_langet("dhcp_static_en", v17);
              v97 = (char *)nvram_get(v41);
              if ( !v97 )
                v97 = "0";
              v42 = jhl_langet("dhcp_static_addr", v17);
              v43 = (const char *)nvram_get(v42);
              if ( !v43 )
                v43 = "";
              snprintf(v2, 10240, "%s", v43);
              while ( 1 )
              {
                v44 = strchr(v2, 60);
                if ( !v44 )
                  break;
                *v44 = 62;
              }
              while ( 1 )
              {
                v45 = strchr(v2, 124);
                if ( !v45 )
                  break;
                *v45 = 44;
              }
              v46 = jhl_langet("dhcp_notan_en", v17);
              v47 = (const char *)nvram_get(v46);
              if ( !v47 )
                v47 = "0";
              v48 = jhl_langet("dhcp_notan_addr", v17);
              v49 = (const char *)nvram_get(v48);
              if ( !v49 )
                v49 = "";
              snprintf(v5, 10240, "%s", v49);
              while ( 1 )
              {
                v50 = strchr(v5, 60);
                if ( !v50 )
                  break;
                *v50 = 62;
              }
              while ( 1 )
              {
                v51 = strchr(v5, 124);
                if ( !v51 )
                  break;
                *v51 = 44;
              }
              v52 = jhl_langet("dhcp_pool_en", v17);
              v98 = (char *)nvram_get(v52);
              if ( !v98 )
                v98 = "0";
              v53 = jhl_langet("dhcp_ip_pool", v17);
              v54 = (const char *)nvram_get(v53);
              if ( !v54 )
                v54 = "";
              v55 = jhl_langet("lan_showname", v17);
              v56 = (const char *)nvram_get(v55);
              if ( v56 )
              {
                v102 = v77;
                sprintf(v77, "LAN%d", v81);
                if ( strlen(v56) < 4 )
                  v56 = v102;
              }
              else
              {
                v56 = v77;
                sprintf(v77, "LAN%d", v81);
              }
              v57 = jhl_langet("lan_mem", v17);
              v58 = (const char *)nvram_get(v57);
              if ( !v58 )
                v58 = "";
              if ( v17 )
                v59 = &byte_643D4C;
              else
                v59 = "";
              v60 = v17++;
              v61 = sprintf(
                      &v82[v80],
                      "%s{\"iface\":\"%d\",\"ifname\":\"%s\",\"lan_showname\":\"%s\",\"eth_flag\":\"%d\",\"iface_bind\":\""
                      "%s\",\"lan_ipaddr\":\"%s\",\"lan_netmask\":\"%s\",\"mac_deflan\":\"%s\",\"mac_lan\":\"%s\",\"dhcp_"
                      "type\":\"%s\",\"dhcp_start\":\"%s\",\"dhcp_end\":\"%s\",\"dhcp_lease\":\"%s\",\"dhcp_gw\":\"%s\",\""
                      "dhcp_mask\":\"%s\",\"dhcp_dns0\":\"%s\",\"dhcp_dns1\":\"%s\",\"dhcp_option43\":\"%s\",\"dhcp_stati"
                      "c_en\":\"%s\",\"dhcp_static_addr\":\"%s\",\"dhcp_notan_en\":\"%s\",\"dhcp_notan_addr\":\"%s\",\"dh"
                      "cp_pool_en\":\"%s\",\"dhcp_ip_pool\":\"%s\",\"mem\":\"%s\"",
                      v59,
                      v60,
                      v22,
                      v56,
                      v99,
                      v84,
                      v88,
                      v89,
                      v96,
                      v40,
                      v25,
                      v86,
                      v87,
                      v85,
                      v90,
                      v91,
                      v92,
                      v93,
                      v94,
                      v97,
                      v2,
                      v47,
                      v5,
                      v98,
                      v54,
                      v58);
              v62 = (int)v82;
              v63 = v80 + v61;
              v64 = v63 + sprintf(&v82[v80 + v61], ",\"dhcp_filter\":\"%s\"", v95);
              v80 = v64 + 1;
              ++v81;
              *(_WORD *)(v62 + v64) = 125;
              goto LABEL_6;
            }
          }
          else
          {
            v40 = "";
          }
          if ( !check_ifname_is_wan(v22) )
          {
            v78[0] = 0;
            v78[1] = 0;
            v78[2] = 0;
            v78[3] = 0;
            v78[4] = 0;
            v78[5] = 0;
            v78[6] = 0;
            v78[7] = 0;
            dual_getIfMac(v22, v78);
            v40 = (const char *)v78;
          }
          goto LABEL_43;
        }
      }
      v6 = v82;
      free(ptr);
    }
    strcpy(&v6[v80], "],\"dual_lan_list\":");
    qmemcpy(&v6[v80], "],\"dual_lan_list", 16);
    v67 = v80 + 18;
    v68 = v67 + get_dual_lan_list_data(&v6[v67], 102400 - v67);
    *(_WORD *)&v6[v68] = 44;
    v69 = v68 + 1 + get_lan_vlan_data(&v6[v68 + 1], 102400 - (v68 + 1));
    v70 = snprintf(&v6[v69], 102400 - v69, "}}");
    if ( v70 >= 102400 - v69 )
      v70 = 102399 - v69;
    v71 = v70 + v69;
    _mem_free(v5);
    _mem_free(v2);
    result = httpd_cgi_ret(a1, v6, v71, 8);
  }
  else
  {
    v73 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v74 = snprintf(v76, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v73);
    _mem_free(v5);
    _mem_free(v2);
    _mem_free(v6);
    if ( v74 >= 0x400 )
      result = httpd_cgi_ret(a1, v76, 1023, 4);
    else
      result = httpd_cgi_ret(a1, v76, v74, 4);
  }
  return result;
}
// 4444F8: variable 'v1' is possibly undefined
// 444518: variable 'v4' is possibly undefined
// 444524: variable 'v3' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 643784: using guessed type void *off_643784;
// 643D4C: using guessed type char byte_643D4C;
// 6A8190: using guessed type int __fastcall dual_getIfMac(_DWORD, _DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8440: using guessed type int __fastcall get_lan_ifnames(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8830: using guessed type int __fastcall check_ifname_is_wan(_DWORD);
// 6A8994: using guessed type int __fastcall jhl_langet(_DWORD, _DWORD);

//----- (004454A4) --------------------------------------------------------
int __fastcall sub_4454A4(int a1)
{
  int v2; // $s1
  unsigned int v3; // $v0
  char v5[508]; // [sp+18h] [-1FCh] BYREF

  memset(v5, 0, 0x1F4u);
  strcpy(v5, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = get_lan_vlan_data(&v5[29], 471) + 29;
  v3 = snprintf(&v5[v2], 500 - v2, "}}");
  if ( v3 >= 500 - v2 )
    v3 = 499 - v2;
  return httpd_cgi_ret(a1, v5, v3 + v2, 4);
}
// 642164: using guessed type __int16 word_642164;

//----- (004455B8) --------------------------------------------------------
int __fastcall _lan_vlan_asp(int a1)
{
  const char **v1; // $s2
  int v3; // $s4
  int v4; // $s1
  char *v5; // $a0
  int v6; // $s1
  int v7; // $s0
  int v8; // $s0
  char *v9; // $v0
  char *v11; // $v0
  char v12[500]; // [sp+18h] [-284h] BYREF
  char v13[72]; // [sp+20Ch] [-90h] BYREF
  char v14[72]; // [sp+254h] [-48h] BYREF

  v1 = (const char **)v13;
  memset(v13, 0, sizeof(v13));
  memset(v14, 0, 0x40u);
  v3 = get_lans_num();
  v4 = httpd_get_json_parm(a1, (int)"lan_vlan");
  memset(v12, 0, sizeof(v12));
  if ( v4 )
  {
    v5 = *(char **)(v4 + 16);
  }
  else
  {
    if ( v3 > 0 )
    {
      do
      {
        v11 = &v14[strlen(v14)];
        ++v4;
        *v11 = 49;
        v11[1] = 124;
        v11[2] = 0;
      }
      while ( v3 != v4 );
      if ( split_string(v14, 124, v13, 16) < v3 )
      {
LABEL_7:
        v8 = 0;
        if ( v12[0] )
          goto LABEL_9;
        goto LABEL_8;
      }
LABEL_5:
      v6 = 0;
      v7 = 0;
      do
      {
        ++v6;
        v7 += sprintf(&v12[v7], "%s|", *v1++);
      }
      while ( v6 < v3 );
      goto LABEL_7;
    }
    v5 = v14;
  }
  if ( split_string(v5, 124, v13, 16) >= v3 )
  {
    if ( v3 <= 0 )
      goto LABEL_9;
    goto LABEL_5;
  }
  if ( !v12[0] )
  {
    v8 = 0;
    if ( v3 > 0 )
    {
      do
      {
LABEL_8:
        ++v8;
        v9 = &v12[strlen(v12)];
        *v9 = 49;
        v9[1] = 124;
        v9[2] = 0;
      }
      while ( v8 < v3 );
      goto LABEL_9;
    }
  }
LABEL_9:
  nvram_set("lan_vlan", v12);
  jhl_gl_net_restart_timer(1000);
  return 1;
}
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A87A0: using guessed type int get_lans_num(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044581C) --------------------------------------------------------
int __fastcall sub_44581C(int a1)
{
  char **v1; // $v0
  char *v2; // $v1
  char *v3; // $t0
  char *v4; // $a3
  char *v5; // $a2
  char *v6; // $a1
  char *v7; // $a2
  char *v8; // $a1
  char *v9; // $v0
  const char *v10; // $fp
  int v11; // $v0
  int v12; // $v0
  int v13; // $s0
  int v14; // $s6
  char *v15; // $s0
  const char *v16; // $v0
  const char *v17; // $v0
  const char *v18; // $v0
  int v19; // $a0
  char *v20; // $v1
  const char *v21; // $v0
  int v22; // $t0
  int v23; // $a3
  int v24; // $a2
  int v25; // $a1
  unsigned int v26; // $a2
  int v28; // $s1
  int v29; // $s2
  int v30; // $s0
  int v31; // $s7
  int v32; // $s6
  int v33; // $fp
  int v34; // $s5
  int v35; // $s3
  int v36; // $s4
  int v37; // $v0
  int v38; // $a0
  int v39; // $v0
  int v40; // $s0
  unsigned int v41; // $v0
  const char *v42; // $v0
  const char *v43; // $v0
  int v44; // $s1
  char *v45; // $s4
  int v46; // $s0
  int v47; // $v0
  int v48; // $s2
  _DWORD *v49; // $s3
  int v50; // $s4
  const char *v51; // $s0
  char *v52; // $s1
  int v53; // $v0
  const char *v54; // $v0
  int v55; // $v0
  int v56; // $v0
  const char *v57; // $v0
  int v58; // $v0
  unsigned int v59; // $s0
  char *v60; // $v0
  unsigned int v61; // $v0
  char *v62; // $s3
  char *v63; // $s7
  char *v64; // $s0
  int v65; // $v0
  int v66; // $v0
  unsigned int v67; // $v0
  unsigned int v68; // $v0
  unsigned int v70; // $s1
  unsigned int v71; // $v0
  int v72; // $v0
  const char *v73; // $v0
  int v74; // $v0
  int v75; // $v0
  const char *v76; // $v0
  int v77; // $v0
  int v78; // $v0
  const char *v79; // $v0
  int v80; // $v0
  int v81; // $v0
  const char *v82; // $v0
  int v83; // $v0
  int v84; // $v0
  const char *v85; // $v0
  int v86; // $v0
  int v87; // $v0
  const char *v88; // $v0
  int v89; // $v0
  int v90; // $v0
  const char *v91; // $v0
  char *v92; // $v0
  char *j; // $v0
  int v94; // $v0
  int v95; // $v0
  const char *v96; // $v0
  int v97; // $v0
  int v98; // $v0
  const char *v99; // $v0
  char *v100; // $v0
  char *i; // $v0
  int v102; // $v0
  int v103; // $v0
  const char *v104; // $v0
  int v105; // $v0
  int v106; // $v0
  const char *v107; // $v0
  int v108; // $v0
  int v109; // $v0
  const char *v110; // $v0
  int v111; // $v0
  int v112; // $v0
  const char *v113; // $v0
  int v114; // $v0
  int v115; // $v0
  const char *v116; // $v0
  int v117; // $v0
  int v118; // $v0
  const char *v119; // $v0
  int v120; // $v0
  int v121; // $v0
  const char *v122; // $v0
  int v123; // $v0
  int v124; // $v0
  const char *v125; // $v0
  int v126; // $v0
  int v127; // $v0
  const char *v128; // $v0
  int v129; // $v0
  int v130; // $v0
  const char *v131; // $v0
  int v132; // $v0
  int v133; // $v0
  const char *v134; // $v0
  int v135; // $v0
  const char *v136; // $s2
  const char *v137; // $v0
  int v138; // $a1
  const char *v139; // $a2
  const char *v140; // $v0
  char v141[10240]; // [sp+50h] [-4920h] BYREF
  char v142[8192]; // [sp+2850h] [-2120h] BYREF
  char v143; // [sp+4850h] [-120h] BYREF
  char v144; // [sp+4858h] [-118h] BYREF
  char v145; // [sp+48ACh] [-C4h] BYREF
  char *v146; // [sp+48B0h] [-C0h]
  char *v147; // [sp+48B4h] [-BCh]
  char *v148; // [sp+48B8h] [-B8h]
  char *v149; // [sp+48BCh] [-B4h]
  char *v150; // [sp+48C0h] [-B0h]
  char *v151; // [sp+48C4h] [-ACh]
  char *v152; // [sp+48C8h] [-A8h]
  char *v153; // [sp+48CCh] [-A4h]
  char *v154; // [sp+48D0h] [-A0h]
  char *v155; // [sp+48D4h] [-9Ch]
  char *v156; // [sp+48D8h] [-98h]
  char *v157; // [sp+48DCh] [-94h]
  char *v158; // [sp+48E0h] [-90h]
  char *v159; // [sp+48E4h] [-8Ch]
  char *v160; // [sp+48E8h] [-88h]
  char *v161; // [sp+48ECh] [-84h]
  char *v162; // [sp+48F0h] [-80h]
  char *v163; // [sp+48F4h] [-7Ch]
  char *v164; // [sp+48F8h] [-78h]
  char *v165; // [sp+48FCh] [-74h]
  char *v166; // [sp+4900h] [-70h]
  const char *v167; // [sp+4904h] [-6Ch]
  const char *v168; // [sp+4908h] [-68h]
  const char *v169; // [sp+490Ch] [-64h]
  char *v170; // [sp+4910h] [-60h]
  char *format; // [sp+4914h] [-5Ch]
  const char *v172; // [sp+4918h] [-58h]
  char *v173; // [sp+491Ch] [-54h]
  int v174; // [sp+4920h] [-50h]
  int v175; // [sp+4924h] [-4Ch]
  int v176; // [sp+4928h] [-48h]
  int v177; // [sp+492Ch] [-44h]
  char *v178; // [sp+4930h] [-40h]
  const char *v179; // [sp+4934h] [-3Ch]
  int v180; // [sp+4938h] [-38h]
  char *v181; // [sp+493Ch] [-34h]
  char *v182; // [sp+4940h] [-30h]
  char *v183; // [sp+4944h] [-2Ch]
  char *v184; // [sp+4948h] [-28h]
  char *v185; // [sp+494Ch] [-24h]
  char *v186; // [sp+4950h] [-20h]
  char *v187; // [sp+4954h] [-1Ch]
  char *v188; // [sp+4958h] [-18h]
  int v189; // [sp+495Ch] [-14h]
  int v190; // [sp+4960h] [-10h]
  char *v191; // [sp+4964h] [-Ch]
  char *v192; // [sp+4968h] [-8h]

  v1 = off_66D294;
  v2 = &v143;
  do
  {
    v3 = *v1;
    v4 = v1[1];
    v5 = v1[2];
    v6 = v1[3];
    v1 += 4;
    *(_DWORD *)v2 = v3;
    *((_DWORD *)v2 + 1) = v4;
    *((_DWORD *)v2 + 2) = v5;
    *((_DWORD *)v2 + 3) = v6;
    v2 += 16;
  }
  while ( v1 != off_66D2E4 );
  v7 = *v1;
  v8 = v1[1];
  v9 = v1[2];
  v10 = v142;
  *(_DWORD *)v2 = v7;
  *((_DWORD *)v2 + 1) = v8;
  *((_DWORD *)v2 + 2) = v9;
  memset(v142, 0, sizeof(v142));
  v173 = "a";
  v11 = httpd_get_json_parm(a1, (int)"lans");
  v181 = "a";
  v176 = v11;
  v12 = httpd_get_json_parm(a1, (int)"dual_lan_list");
  v154 = "a";
  v190 = v12;
  v13 = v12;
  format = httpd_get_parm(a1, "dual_lan_mode");
  v146 = httpd_get_parm(a1, "dhcp_bind_ipmac_en");
  _lan_vlan_asp(a1);
  v14 = 0;
  if ( v13 )
  {
    if ( !cJSON_IsArray(v13) )
      goto LABEL_5;
    v172 = (const char *)cJSON_GetArraySize(v190);
    if ( (int)v172 > 0 )
    {
      v159 = "a";
      v158 = "a";
      v161 = "a";
      v157 = "a";
      v169 = "dhcp_end";
      v156 = "a";
      v160 = "a";
      v162 = "a";
      v163 = "a";
      v164 = "a";
      v28 = 0;
      v165 = "a";
      v29 = 0;
      v155 = "a";
      v167 = "dhcp_dns0";
      v166 = "a";
      v168 = "dhcp_dns1";
      format = "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<";
      v170 = v142;
      while ( 1 )
      {
        v30 = cJSON_GetArrayItem(v190, v29);
        v31 = cJSON_GetObjectItem(v30, v167);
        v153 = (char *)cJSON_GetObjectItem(v30, v168);
        v152 = (char *)cJSON_GetObjectItem(v30, v169);
        v151 = (char *)cJSON_GetObjectItem(v30, v159 + 14932);
        v32 = cJSON_GetObjectItem(v30, v158 + 14944);
        v150 = (char *)cJSON_GetObjectItem(v30, v161 + 14960);
        v33 = cJSON_GetObjectItem(v30, v157 + 14980);
        v34 = cJSON_GetObjectItem(v30, v156 + 14996);
        v149 = (char *)cJSON_GetObjectItem(v30, v160 + 15012);
        v35 = cJSON_GetObjectItem(v30, v162 + 15028);
        v36 = cJSON_GetObjectItem(v30, v163 + 15044);
        v148 = (char *)cJSON_GetObjectItem(v30, v164 + 15060);
        v147 = (char *)cJSON_GetObjectItem(v30, v165 + 15072);
        v37 = cJSON_GetObjectItem(v30, v155 + 15080);
        v38 = v30;
        v40 = v37;
        v39 = cJSON_GetObjectItem(v38, v166 + 15092);
        if ( !v31 )
          break;
        if ( !v153 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643A30;
          goto LABEL_265;
        }
        if ( !v152 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643A40;
          goto LABEL_265;
        }
        if ( !v151 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643A50;
          goto LABEL_265;
        }
        if ( !v32 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643A5C;
          goto LABEL_265;
        }
        if ( !v150 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643A6C;
          goto LABEL_265;
        }
        if ( !v33 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643A80;
          goto LABEL_265;
        }
        if ( !v34 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643A90;
          goto LABEL_265;
        }
        if ( !v149 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643AA0;
          goto LABEL_265;
        }
        if ( !v35 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643AB0;
          goto LABEL_265;
        }
        if ( !v36 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643AC0;
          goto LABEL_265;
        }
        if ( !v148 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643AD0;
          goto LABEL_265;
        }
        if ( !v147 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = "not mem";
          goto LABEL_265;
        }
        if ( !v40 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = (const char *)&unk_643AE4;
          goto LABEL_265;
        }
        if ( !v39 )
        {
          v138 = *(unsigned __int8 *)(a1 + 210102);
          v139 = "not vlanid";
          goto LABEL_265;
        }
        v41 = snprintf(
                &v170[v28],
                0x2000 - v28,
                format,
                *(_DWORD *)(v39 + 16),
                *(_DWORD *)(v35 + 16),
                *(_DWORD *)(v36 + 16),
                *(_DWORD *)(v34 + 16),
                *(_DWORD *)(v32 + 16),
                *(_DWORD *)(v33 + 16),
                *((_DWORD *)v152 + 4),
                *((_DWORD *)v151 + 4),
                *((_DWORD *)v149 + 4),
                *(_DWORD *)(v31 + 16),
                *((_DWORD *)v153 + 4),
                *((_DWORD *)v148 + 4),
                *(_DWORD *)(v40 + 16),
                *((_DWORD *)v147 + 4),
                *((_DWORD *)v150 + 4));
        if ( v41 >= 0x2000 - v28 )
          v41 = 0x1FFF - v28;
        v28 += v41;
        if ( v172 == (const char *)++v29 )
        {
          v10 = v170;
          format = "1";
          goto LABEL_51;
        }
      }
      v138 = *(unsigned __int8 *)(a1 + 210102);
      v139 = (const char *)&unk_643A20;
LABEL_265:
      v140 = (const char *)_GET_LANG_TEXT(12, v138, v139);
      v26 = snprintf(v141, 10240, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v140);
      if ( v26 >= 0x2800 )
        v26 = 10239;
      return httpd_cgi_ret(a1, v141, v26, 4);
    }
LABEL_51:
    v42 = (const char *)nvram_get(v173 + 13664);
    if ( v42 && !strcmp(v42, v10) )
    {
LABEL_5:
      v14 = 0;
    }
    else
    {
      nvram_set(v173 + 13664, v10);
      v14 = 1;
    }
  }
  v15 = v146;
  if ( !v146 || (v16 = (const char *)nvram_get(v154 + 7972)) != 0 && !strcmp(v16, v15) )
  {
    v175 = 0;
  }
  else
  {
    nvram_set(v154 + 7972, v146);
    v175 = 1;
    v14 = 1;
  }
  v191 = "a";
  if ( jhl_web_save_parm(a1, "duolanlist", 0) || jhl_web_save_parm(a1, "duolan_enble", 0) )
  {
    v189 = 1;
    v14 = 1;
  }
  else
  {
    v189 = 0;
  }
  if ( !v176 || !cJSON_IsArray(v176) || (v182 = (char *)cJSON_GetArraySize(v176), (int)v182 <= 0) )
  {
    v180 = 0;
    v174 = 0;
    goto LABEL_15;
  }
  v187 = "a";
  v149 = "a";
  v188 = "a";
  v172 = "dhcp_filter";
  v184 = "a";
  v183 = "a";
  v146 = "lan_ipaddr";
  v185 = "1\"";
  v147 = "lan_netmask";
  v192 = "a";
  v186 = &v144;
  v180 = 0;
  v174 = 0;
  v170 = 0;
  v173 = 0;
  v148 = "mac_lan";
  v45 = &v145;
  do
  {
    v46 = cJSON_GetArrayItem(v176, v173);
    v47 = cJSON_GetObjectItem(v46, v187 + 13148);
    v48 = cJSON_GetIntvalue(v47);
    v177 = cJSON_GetObjectItem(v46, v188 + 14348);
    if ( !cJSON_GetObjectItem(v46, v149 + 7992) )
    {
      v133 = jhl_langet(v172, v48);
      v134 = (const char *)nvram_get(v133);
      if ( !v134 || strcmp(v134, v192 + 14076) )
      {
        v135 = jhl_langet(v149 + 7992, v48);
        nvram_set(v135, "0");
        if ( !v48 )
          v175 = 1;
        v14 = 1;
      }
    }
    v49 = *(_DWORD **)(v46 + 8);
    if ( v49 )
    {
      v158 = "a";
      v161 = "a";
      v165 = "a";
      v150 = "a";
      v162 = "a";
      v160 = "a";
      v151 = "a";
      v163 = "a";
      v152 = "a";
      v156 = "a";
      v159 = "a";
      v153 = "a";
      v154 = "a";
      v157 = "a";
      v167 = "dhcp_lease";
      v178 = v45;
      v50 = v175;
      v179 = v10;
      v155 = "a";
      v164 = "a";
      v166 = "dhcp_type";
      v168 = "dhcp_start";
      v169 = "dhcp_end";
      while ( 1 )
      {
        v51 = (const char *)v49[8];
        v52 = (char *)v49[4];
        v49 = (_DWORD *)*v49;
        if ( strcmp(v51, v146)
          || (v75 = jhl_langet(v146, v48), (v76 = (const char *)nvram_get(v75)) != 0) && v52 && !strcmp(v76, v52) )
        {
          if ( strcmp(v51, v147) )
            goto LABEL_70;
        }
        else
        {
          v77 = jhl_langet(v146, v48);
          nvram_set(v77, v52);
          if ( !v48 )
          {
            v180 = 1;
            v174 = 1;
          }
          v14 = 1;
          if ( strcmp(v51, v147) )
          {
LABEL_70:
            if ( strcmp(v51, v148) )
              goto LABEL_71;
LABEL_149:
            v81 = jhl_langet(v148, v48);
            v82 = (const char *)nvram_get(v81);
            if ( !v82 || !v52 || strcmp(v82, v52) )
            {
              v83 = jhl_langet(v148, v48);
              nvram_set(v83, v52);
              v14 = 1;
            }
            goto LABEL_71;
          }
        }
        v78 = jhl_langet(v147, v48);
        v79 = (const char *)nvram_get(v78);
        if ( v79 && v52 && !strcmp(v79, v52) )
          goto LABEL_70;
        v80 = jhl_langet(v147, v48);
        nvram_set(v80, v52);
        if ( !v48 )
          v174 = 1;
        v14 = 1;
        if ( !strcmp(v51, v148) )
          goto LABEL_149;
LABEL_71:
        if ( !strcmp(v51, v157 + 14996) )
        {
          v130 = jhl_langet(v166, v48);
          v131 = (const char *)nvram_get(v130);
          if ( !v131 || !v52 || strcmp(v131, v52) )
          {
            v132 = jhl_langet(v157 + 14996, v48);
            nvram_set(v132, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v156 + 14944) )
        {
          v127 = jhl_langet(v167, v48);
          v128 = (const char *)nvram_get(v127);
          if ( !v128 || !v52 || strcmp(v128, v52) )
          {
            v129 = jhl_langet(v156 + 14944, v48);
            nvram_set(v129, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v155 + 14980) )
        {
          v124 = jhl_langet(v168, v48);
          v125 = (const char *)nvram_get(v124);
          if ( !v125 || !v52 || strcmp(v125, v52) )
          {
            v126 = jhl_langet(v155 + 14980, v48);
            nvram_set(v126, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v149 + 7992) )
        {
          v121 = jhl_langet(v172, v48);
          v122 = (const char *)nvram_get(v121);
          if ( !v122 || !v52 || strcmp(v122, v52) )
          {
            v123 = jhl_langet(v149 + 7992, v48);
            nvram_set(v123, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v154 + 14916) )
        {
          v118 = jhl_langet(v169, v48);
          v119 = (const char *)nvram_get(v118);
          if ( !v119 || !v52 || strcmp(v119, v52) )
          {
            v120 = jhl_langet(v154 + 14916, v48);
            nvram_set(v120, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v159 + 14932) )
        {
          v115 = jhl_langet("dhcp_gw", v48);
          v116 = (const char *)nvram_get(v115);
          if ( !v116 || !v52 || strcmp(v116, v52) )
          {
            v117 = jhl_langet(v159 + 14932, v48);
            nvram_set(v117, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v158 + 15012) )
        {
          v112 = jhl_langet("dhcp_mask", v48);
          v113 = (const char *)nvram_get(v112);
          if ( !v113 || !v52 || strcmp(v113, v52) )
          {
            v114 = jhl_langet(v158 + 15012, v48);
            nvram_set(v114, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v161 + 14884) )
        {
          v109 = jhl_langet("dhcp_dns0", v48);
          v110 = (const char *)nvram_get(v109);
          if ( !v110 || !v52 || strcmp(v110, v52) )
          {
            v111 = jhl_langet(v161 + 14884, v48);
            nvram_set(v111, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v160 + 14900) )
        {
          v106 = jhl_langet("dhcp_dns1", v48);
          v107 = (const char *)nvram_get(v106);
          if ( !v107 || !v52 || strcmp(v107, v52) )
          {
            v108 = jhl_langet(v160 + 14900, v48);
            nvram_set(v108, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v150 + 14248) )
        {
          v103 = jhl_langet("dhcp_static_en", v48);
          v104 = (const char *)nvram_get(v103);
          if ( !v104 || !v52 || strcmp(v104, v52) )
          {
            v105 = jhl_langet(v150 + 14248, v48);
            nvram_set(v105, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v162 + 14264) )
        {
          v98 = jhl_langet("dhcp_static_addr", v48);
          v99 = (const char *)nvram_get(v98);
          if ( !v99 )
            goto LABEL_186;
          if ( v52 )
          {
            if ( !strcmp(v99, v52) )
              goto LABEL_82;
LABEL_186:
            v100 = v52;
          }
          else
          {
            v100 = 0;
          }
          while ( 1 )
          {
            v100 = strchr(v100, 62);
            if ( !v100 )
              break;
            *v100 = 60;
          }
          for ( i = v52; ; *i = 124 )
          {
            i = strchr(i, 44);
            if ( !i )
              break;
          }
          v102 = jhl_langet(v162 + 14264, v48);
          nvram_set(v102, v52);
          if ( !v48 )
            v50 = 1;
          v14 = 1;
        }
LABEL_82:
        if ( !strcmp(v51, v151 + 14284) )
        {
          v95 = jhl_langet("dhcp_notan_en", v48);
          v96 = (const char *)nvram_get(v95);
          if ( !v96 || !v52 || strcmp(v96, v52) )
          {
            v97 = jhl_langet(v151 + 14284, v48);
            nvram_set(v97, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( strcmp(v51, v163 + 14300) )
          goto LABEL_84;
        v90 = jhl_langet("dhcp_notan_addr", v48);
        v91 = (const char *)nvram_get(v90);
        if ( !v91 )
        {
LABEL_168:
          v92 = v52;
LABEL_170:
          while ( 1 )
          {
            v92 = strchr(v92, 62);
            if ( !v92 )
              break;
            *v92 = 60;
          }
          for ( j = v52; ; *j = 124 )
          {
            j = strchr(j, 44);
            if ( !j )
              break;
          }
          v94 = jhl_langet(v163 + 14300, v48);
          nvram_set(v94, v52);
          if ( !v48 )
            v50 = 1;
          v14 = 1;
          goto LABEL_84;
        }
        if ( !v52 )
        {
          v92 = 0;
          goto LABEL_170;
        }
        if ( strcmp(v91, v52) )
          goto LABEL_168;
LABEL_84:
        if ( !strcmp(v51, v152 + 14316) )
        {
          v87 = jhl_langet("dhcp_pool_en", v48);
          v88 = (const char *)nvram_get(v87);
          if ( !v88 || !v52 || strcmp(v88, v52) )
          {
            v89 = jhl_langet(v152 + 14316, v48);
            nvram_set(v89, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v153 + 14332) )
        {
          unescape(v52);
          v84 = jhl_langet("dhcp_ip_pool", v48);
          v85 = (const char *)nvram_get(v84);
          if ( !v85 || !v52 || strcmp(v85, v52) )
          {
            v86 = jhl_langet(v153 + 14332, v48);
            nvram_set(v86, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, "dhcp_option43") )
        {
          v72 = jhl_langet("dhcp_option43", v48);
          v73 = (const char *)nvram_get(v72);
          if ( !v73 || !v52 || strcmp(v73, v52) )
          {
            v74 = jhl_langet("dhcp_option43", v48);
            nvram_set(v74, v52);
            if ( !v48 )
              v50 = 1;
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v165 + 15072) || !strcmp(v51, "lan_mem") )
        {
          v53 = jhl_langet("lan_mem", v48);
          v54 = (const char *)nvram_get(v53);
          if ( !v54 || !v52 || strcmp(v54, v52) )
          {
            v55 = jhl_langet("lan_mem", v48);
            nvram_set(v55, v52);
            v14 = 1;
          }
        }
        if ( !strcmp(v51, v164 + 15148) || !strcmp(v51, "lan_ifacebind") )
        {
          v56 = jhl_langet("lan_ifacebind", v48);
          v57 = (const char *)nvram_get(v56);
          if ( !v57 || !v52 || strcmp(v57, v52) )
          {
            if ( strlen(v52) < 3 )
              v52 = "LAN1";
            v58 = jhl_langet("lan_ifacebind", v48);
            nvram_set(v58, v52);
            v14 = 1;
          }
          if ( v48 > 0 && !strcmp(v52, (const char *)&off_63F984) )
            format = "1";
        }
        if ( !v49 )
        {
          v175 = v50;
          v10 = v179;
          v45 = v178;
          break;
        }
      }
    }
    v59 = 0x2000 - (_DWORD)v170;
    if ( v177 )
      v60 = *(char **)(v177 + 16);
    else
      v60 = "";
    v61 = snprintf(&v170[(_DWORD)v10], 0x2000 - (_DWORD)v170, v184 + 15160, v48, v60);
    if ( v61 >= v59 )
      v61 = 0x1FFF - (_DWORD)v170;
    v62 = v186;
    v63 = &v170[v61];
    v64 = v183 + 11516;
    do
    {
      v65 = jhl_langet(*(_DWORD *)v62, v48);
      v66 = nvram_get(v65);
      v67 = snprintf(&v63[(_DWORD)v10], 0x2000 - (_DWORD)v63, v64, v66);
      v62 += 4;
      if ( v67 >= 0x2000 - (int)v63 )
        v67 = 0x1FFF - (_DWORD)v63;
      v63 += v67;
    }
    while ( v45 != v62 );
    v68 = snprintf(&v63[(_DWORD)v10], 0x2000 - (_DWORD)v63, v185 - 17872);
    if ( v68 >= 0x2000 - (int)v63 )
      v68 = 0x1FFF - (_DWORD)v63;
    v170 = &v63[v68];
  }
  while ( v182 != ++v173 );
  if ( (int)v170 > 0 )
    nvram_set("dual_lan_ssid_list", v10);
LABEL_15:
  if ( !format )
    format = "0";
  v17 = (const char *)nvram_get(v181 + 13964);
  if ( (!v17 || strcmp(v17, format)) && v176 && v190 )
  {
    nvram_set(v181 + 13964, format);
    v14 = 1;
    nvram_set("duolan_enble", "0");
  }
  v18 = (const char *)nvram_get(v181 + 13964);
  if ( !v18
    || strcmp(v18, "0")
    || (v43 = (const char *)nvram_get("dual_lan_mode_old")) == 0
    || (v44 = strcmp(v43, "0")) != 0 )
  {
    if ( v189 )
    {
      jhl_web_save_parm(a1, v191 + 7052, 1);
      jhl_web_save_parm(a1, "duolan_enble", 1);
    }
    jhl_parm_commit(v19);
    jhl_gl_lan_restart_timer(1000);
    v20 = v141;
    v21 = "{\"code\":4,\"error\":\"\",\"data\":null}";
    do
    {
      v22 = *(_DWORD *)v21;
      v23 = *((_DWORD *)v21 + 1);
      v24 = *((_DWORD *)v21 + 2);
      v25 = *((_DWORD *)v21 + 3);
      v21 += 16;
      *(_DWORD *)v20 = v22;
      *((_DWORD *)v20 + 1) = v23;
      *((_DWORD *)v20 + 2) = v24;
      *((_DWORD *)v20 + 3) = v25;
      v20 += 16;
    }
    while ( v21 != "}" );
    v26 = 33;
    *(_WORD *)v20 = *(_WORD *)v21;
    return httpd_cgi_ret(a1, v141, v26, 4);
  }
  if ( v189 )
  {
    duolan_undo();
    jhl_web_save_parm(a1, v191 + 7052, 1);
    jhl_web_save_parm(a1, "duolan_enble", 1);
  }
  else if ( !v174 )
  {
    if ( v175 )
    {
      start_dhcp_server();
      goto LABEL_121;
    }
    goto LABEL_122;
  }
  lanip_change();
  start_dhcp_server();
  start_rzgl(0);
  start_arp_sys();
  exec_service("ac_server-restart");
  duolan_do(0);
LABEL_121:
  jhl_start_firewall();
LABEL_122:
  if ( v14 )
  {
    v44 = 4;
    jhl_parm_commit(v19);
    jhl_gl_lan_restart_timer(1000);
  }
  v70 = snprintf(v141, 10240, "{\"code\":%d,\"error\":\"\",\"data\":{", v44);
  if ( v70 >= 0x2800 )
    v70 = 10239;
  if ( v180 )
  {
    v136 = (const char *)nvram_get("lan_ipaddr");
    v137 = (const char *)nvram_get("http_lanport");
    v70 += sprintf(&v141[v70], "\"lan_ipaddr\":\"%s:%s\"", v136, v137);
  }
  v71 = snprintf(&v141[v70], 10240 - v70, "}}");
  if ( v71 >= 10240 - v70 )
    v71 = 10239 - v70;
  return httpd_cgi_ret(a1, v141, v71 + v70, 4);
}
// 445B68: variable 'v19' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 66D294: using guessed type char *off_66D294[23];
// 66D2E4: using guessed type char *off_66D2E4[3];
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81EC: using guessed type int start_arp_sys(void);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8398: using guessed type int duolan_undo(void);
// 6A83CC: using guessed type int __fastcall duolan_do(_DWORD);
// 6A84B8: using guessed type int start_dhcp_server(void);
// 6A8518: using guessed type int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A86D0: using guessed type int lanip_change(void);
// 6A86FC: using guessed type int __fastcall cJSON_GetArraySize(_DWORD);
// 6A8744: using guessed type int __fastcall cJSON_GetIntvalue(_DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);
// 6A8994: using guessed type int __fastcall jhl_langet(_DWORD, _DWORD);

//----- (00447AD4) --------------------------------------------------------
int __fastcall sub_447AD4(int a1)
{
  int v1; // $a0
  const char *v3; // $v0
  char *v4; // $v1
  int v5; // $t1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  int v10; // $t1
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  char v14[504]; // [sp+18h] [-1F8h] BYREF

  if ( _lan_vlan_asp(a1) )
  {
    jhl_parm_commit(v1);
    v4 = v14;
    v3 = "{\"code\":4,\"error\":\"\",\"data\":null}";
    do
    {
      v10 = *(_DWORD *)v3;
      v11 = *((_DWORD *)v3 + 1);
      v12 = *((_DWORD *)v3 + 2);
      v13 = *((_DWORD *)v3 + 3);
      v3 += 16;
      *(_DWORD *)v4 = v10;
      *((_DWORD *)v4 + 1) = v11;
      *((_DWORD *)v4 + 2) = v12;
      *((_DWORD *)v4 + 3) = v13;
      v4 += 16;
    }
    while ( v3 != "}" );
  }
  else
  {
    v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v4 = v14;
    do
    {
      v5 = *(_DWORD *)v3;
      v6 = *((_DWORD *)v3 + 1);
      v7 = *((_DWORD *)v3 + 2);
      v8 = *((_DWORD *)v3 + 3);
      v3 += 16;
      *(_DWORD *)v4 = v5;
      *((_DWORD *)v4 + 1) = v6;
      *((_DWORD *)v4 + 2) = v7;
      *((_DWORD *)v4 + 3) = v8;
      v4 += 16;
    }
    while ( v3 != "}" );
  }
  *(_WORD *)v4 = *(_WORD *)v3;
  return httpd_cgi_ret(a1, v14, 33, 4);
}
// 447B7C: variable 'v1' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);

//----- (00447BD0) --------------------------------------------------------
int __fastcall get_vlan_name_data(char *a1)
{
  bool v2; // dc
  char *v3; // $v0
  const char *v4; // $v0
  int v5; // $v0
  char *v6; // $v1
  char *v7; // $a0
  char *v8; // $v1
  char *v9; // $a0
  char *v10; // $v1
  char *v11; // $a0
  char *v12; // $v1
  char *v13; // $v1
  int v14; // $a1
  int v15; // $a0
  int result; // $v0
  char *v17; // $a0
  const char *v18; // $v1
  int v19; // $a0
  int v20; // $a1
  int v21; // $a0
  char v22; // $a1
  char v23; // $a0
  char v24; // $v1

  v2 = sq_file_get_jb() == 0;
  v3 = a1;
  if ( v2 )
  {
    v18 = "\"vlan_name\":\"L123456789\",\"vlan_wans\":[{\"lab\":\"1\",\"v\":\"L123456789\"}";
    do
    {
      v19 = *((_DWORD *)v18 + 1);
      *(_DWORD *)v3 = *(_DWORD *)v18;
      *((_DWORD *)v3 + 1) = v19;
      v20 = *((_DWORD *)v18 + 2);
      *((_DWORD *)v3 + 1) = v19;
      *((_DWORD *)v3 + 2) = v20;
      v21 = *((_DWORD *)v18 + 3);
      *((_DWORD *)v3 + 2) = v20;
      *((_DWORD *)v3 + 3) = v21;
      v18 += 16;
      *((_DWORD *)v3 + 3) = v21;
      v3 += 16;
    }
    while ( v18 != "\"}" );
    v22 = *v18;
    v23 = v18[1];
    v24 = v18[2];
    *v3 = v22;
    v3[1] = v23;
    v3[2] = v24;
    v15 = 67;
    result = 83;
    v14 = 66;
  }
  else
  {
    v4 = (const char *)nvram_get("vlan_name_old");
    if ( !v4 )
    {
      v4 = (const char *)nvram_get("vlan_name");
      if ( !v4 )
        v4 = "L1";
    }
    v5 = sprintf(a1, "\"vlan_name\":\"%s\",\"vlan_wans\":[", v4);
    strcpy(&a1[v5], "{\"lab\":\"1\",\"v\":\"L123456789\"},");
    qmemcpy(&a1[v5], "{\"lab\":\"1\",\"v\":\"L123", 20);
    v6 = &a1[v5 + 29];
    *(_DWORD *)&a1[v5 + 24] = 2099394872;
    strcpy(v6, "{\"lab\":\"2\",\"v\":\"L12345678\"},");
    *(_DWORD *)v6 = 1634476667;
    *((_DWORD *)v6 + 1) = 574235234;
    v7 = &a1[v5 + 57];
    *((_DWORD *)v6 + 6) = 746398264;
    strcpy(v7, "{\"lab\":\"3\",\"v\":\"L1234567\"},");
    *((_DWORD *)v7 + 5) = 926299444;
    v8 = &a1[v5 + 84];
    strcpy(v8, "{\"lab\":\"4\",\"v\":\"L123456\"},");
    qmemcpy(v8, "{\"lab\":\"4\",\"v\":\"", 16);
    v9 = &a1[v5 + 110];
    *((_DWORD *)v8 + 5) = 573977908;
    strcpy(v9, "{\"lab\":\"5\",\"v\":\"L12345\"},");
    qmemcpy(v9, "{\"lab\":\"5\",\"", 12);
    *((_DWORD *)v9 + 4) = 858927436;
    v10 = &a1[v5 + 135];
    *((_DWORD *)v9 + 5) = 2099393844;
    strcpy(v10, "{\"lab\":\"6\",\"v\":\"L1234\"},");
    *(_DWORD *)v10 = *(_DWORD *)"{\"lab\":\"6\",\"v\":\"L1234\"},";
    qmemcpy(v10 + 16, "L1234\"},", 8);
    v11 = &a1[v5 + 159];
    strcpy(v11, "{\"lab\":\"7\",\"v\":\"L123\"},");
    v12 = &a1[v5 + 182];
    strcpy(v11 + 20, "\"},");
    strcpy(v12, "{\"lab\":\"8\",\"v\":\"L12\"},");
    *((_DWORD *)v12 + 3) = 574235254;
    v13 = &a1[v5 + 204];
    strcpy(v13, "{\"lab\":\"9\",\"v\":\"L1\"}");
    qmemcpy(v13, "{\"lab\":\"9\",\"v\":\"", 16);
    v14 = v5 + 224;
    v15 = v5 + 225;
    result = v5 + 241;
  }
  *(_WORD *)&a1[v14] = 93;
  v17 = &a1[v15];
  strcpy(v17, ",\"port_max\":\"10\"");
  qmemcpy(v17, ",\"port_max\":", 12);
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A85E4: using guessed type int sq_file_get_jb(void);

//----- (004480DC) --------------------------------------------------------
int __fastcall sub_4480DC(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  int v5; // $s1
  char *v6; // $v0
  int v7; // $s1
  int v8; // $s1
  int v9; // $s1
  int v10; // $v0
  char *v11; // $v0
  int v12; // $s1
  char *v13; // $v1
  int v14; // $s1
  int v15; // $s1
  char *v16; // $a0
  int v17; // $a2
  int result; // $v0
  const char *v19; // $v0
  unsigned int v20; // $v0
  char v21[256]; // [sp+20h] [-140h] BYREF
  int v22[8]; // [sp+120h] [-40h] BYREF
  int v23[8]; // [sp+140h] [-20h] BYREF

  v23[0] = 0;
  v23[1] = 0;
  v23[2] = 0;
  v23[3] = 0;
  v23[4] = 0;
  v23[5] = 0;
  v23[6] = 0;
  v23[7] = 0;
  v22[0] = 0;
  v22[1] = 0;
  v22[2] = 0;
  v22[3] = 0;
  v22[4] = 0;
  v22[5] = 0;
  v22[6] = 0;
  v22[7] = 0;
  _mem_malloc(0x200000, "wans_data", 1199);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v4 = get_vlan_name_data((char *)(v2 + 29));
    v5 = v4 + 30;
    v6 = &v3[v4 + 29];
    *v6 = 44;
    v6[1] = 0;
    v7 = v5 + get_wan_nvarms((const char **)wan_parms, &v3[v5], 0x200000 - v5);
    v8 = v7 + sprintf(&v3[v7], "\"x86\":%d,", 0);
    v9 = v8 + sprintf(&v3[v8], "\"ipc\":%d,", 1);
    get_client_info((int)v23, (int)v22, a1 + 205460);
    if ( v10 )
    {
      v12 = v9 + sprintf(&v3[v9], "\"compmac\":\"%s\",", (const char *)v23);
    }
    else
    {
      v11 = &v3[v9];
      strcpy(&v3[v9], "\"compmac\":\"\",");
      *(_DWORD *)v11 = 1836016418;
      *((_DWORD *)v11 + 1) = 1667329392;
      v12 = v9 + 13;
    }
    strcpy(&v3[v12], "\"show_ifname_mem\":\"0\",");
    qmemcpy(&v3[v12], "\"show_ifname_mem\":\"0", 20);
    v13 = &v3[v12 + 22];
    strcpy(v13, "\"ap_flag\":\"0\",");
    *(_DWORD *)v13 = 1601200418;
    *((_DWORD *)v13 + 1) = 1734437990;
    v14 = v12 + 36 + sprintf(&v3[v12 + 36], "\"hide_ipoe\":%d,", 0);
    v15 = v14 + sprintf(&v3[v14], "\"hide_igmp\":%d,", 0);
    v16 = &v3[v15];
    if ( v15 > 0 && *(v16 - 1) == 44 )
      v16 = &v3[--v15];
    *v16 = 0;
    v17 = snprintf(v16, 0x200000 - v15, "}}");
    if ( v17 >= 0x200000 - v15 )
      v17 = 0x1FFFFF - v15;
    result = httpd_cgi_ret(a1, v3, v15 + v17, 8);
  }
  else
  {
    v19 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v20 = snprintf(v21, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
    if ( v20 >= 0x100 )
      v20 = 255;
    result = httpd_cgi_ret(a1, v21, v20, 4);
  }
  return result;
}
// 44816C: variable 'v2' is possibly undefined
// 448290: variable 'v10' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 643D4C: using guessed type char byte_643D4C;
// 66E224: using guessed type char *wan_parms[4];
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00448510) --------------------------------------------------------
int __fastcall sub_448510(int a1)
{
  int v2; // $s1
  unsigned int v3; // $v0
  char v5[1028]; // [sp+18h] [-404h] BYREF

  strcpy(v5, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = get_vlan_name_data(&v5[29]) + 29;
  v3 = snprintf(&v5[v2], 1024 - v2, "}}");
  if ( v3 >= 1024 - v2 )
    v3 = 1023 - v2;
  return httpd_cgi_ret(a1, v5, v3 + v2, 4);
}
// 642164: using guessed type __int16 word_642164;

//----- (0044860C) --------------------------------------------------------
int __fastcall set_vlan_name_data(int a1)
{
  int v2; // $a0

  if ( !a1 || nvram_match_def("vlan_name", a1) )
    return -1;
  nvram_set("vlan_name_old", a1);
  jhl_parm_commit(v2);
  return 0;
}
// 44867C: variable 'v2' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004486B8) --------------------------------------------------------
int __fastcall sub_4486B8(int a1)
{
  int v1; // $v0
  int v3; // $a0
  _BOOL4 v4; // $s1
  const char *v5; // $v0
  char *v6; // $v1
  int v7; // $t1
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  int v12; // $t1
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  char v16[260]; // [sp+18h] [-104h] BYREF

  v1 = httpd_get_json_parm(a1, (int)"vlan_name");
  if ( v1 )
  {
    v4 = set_vlan_name_data(*(_DWORD *)(v1 + 16)) == 0;
    if ( !(v4 | wan_webset_json(a1)) )
      goto LABEL_3;
  }
  else
  {
    v4 = 0;
    if ( !wan_webset_json(a1) )
      goto LABEL_3;
  }
  jhl_parm_commit(v3);
  if ( !v4 )
  {
LABEL_3:
    v5 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v6 = v16;
    do
    {
      v7 = *(_DWORD *)v5;
      v8 = *((_DWORD *)v5 + 1);
      v9 = *((_DWORD *)v5 + 2);
      v10 = *((_DWORD *)v5 + 3);
      v5 += 16;
      *(_DWORD *)v6 = v7;
      *((_DWORD *)v6 + 1) = v8;
      *((_DWORD *)v6 + 2) = v9;
      *((_DWORD *)v6 + 3) = v10;
      v6 += 16;
    }
    while ( v5 != "}" );
    goto LABEL_5;
  }
  jhl_gl_net_restart_timer(1000);
  v6 = v16;
  v5 = "{\"code\":4,\"error\":\"\",\"data\":null}";
  do
  {
    v12 = *(_DWORD *)v5;
    v13 = *((_DWORD *)v5 + 1);
    v14 = *((_DWORD *)v5 + 2);
    v15 = *((_DWORD *)v5 + 3);
    v5 += 16;
    *(_DWORD *)v6 = v12;
    *((_DWORD *)v6 + 1) = v13;
    *((_DWORD *)v6 + 2) = v14;
    *((_DWORD *)v6 + 3) = v15;
    v6 += 16;
  }
  while ( v5 != "}" );
LABEL_5:
  *(_WORD *)v6 = *(_WORD *)v5;
  return httpd_cgi_ret(a1, v16, 33, 4);
}
// 4487CC: variable 'v3' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);

//----- (0044883C) --------------------------------------------------------
int __fastcall sub_44883C(int a1)
{
  char *v1; // $v0
  int v3; // $a0
  const char *v4; // $v0
  char *v5; // $v1
  int v6; // $t1
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  char v11[1024]; // [sp+18h] [-400h] BYREF

  v1 = httpd_get_parm(a1, "vlan_name");
  if ( v1 && !set_vlan_name_data((int)v1) )
    jhl_parm_commit(v3);
  v4 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v5 = v11;
  do
  {
    v6 = *(_DWORD *)v4;
    v7 = *((_DWORD *)v4 + 1);
    v8 = *((_DWORD *)v4 + 2);
    v9 = *((_DWORD *)v4 + 3);
    v4 += 16;
    *(_DWORD *)v5 = v6;
    *((_DWORD *)v5 + 1) = v7;
    *((_DWORD *)v5 + 2) = v8;
    *((_DWORD *)v5 + 3) = v9;
    v5 += 16;
  }
  while ( v4 != "}" );
  *(_WORD *)v5 = *(_WORD *)v4;
  return httpd_cgi_ret(a1, v11, 33, 4);
}
// 448908: variable 'v3' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);

//----- (0044891C) --------------------------------------------------------
int __fastcall get_wans_increase_data(char *a1, int a2)
{
  int v3; // $s3
  int v4; // $s1
  int v5; // $s0
  int v6; // $v0
  const char *v7; // $fp
  int v8; // $v0
  const char *v9; // $v0
  int v10; // $v0
  _BYTE *v11; // $v0
  int v12; // $fp
  int v13; // $v0
  char *v14; // $v0
  char v16[64]; // [sp+20h] [-60h] BYREF
  int v17[4]; // [sp+60h] [-20h] BYREF
  const char *v18; // [sp+70h] [-10h]
  const char *v19; // [sp+74h] [-Ch]
  char *format; // [sp+78h] [-8h]

  v3 = sq_file_get_max_wan();
  v4 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v4 >= a2 )
    v4 = a2 - 1;
  if ( v3 > 0 && v4 < a2 - 99 )
  {
    v18 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
    v5 = 0;
    v19 = "wan_increase";
    format = "{\"iface\":%d,\"org_iface\":%s,\"vid\":%s},";
    do
    {
      v6 = jhl_nvget("wan_ifname", v5);
      v7 = (const char *)nvram_get(v6);
      if ( !v7 )
        v7 = v18 - 1556;
      if ( !*v7 )
        break;
      v8 = jhl_nvget("wan_down", v5);
      v9 = (const char *)nvram_get(v8);
      if ( v9 && !strcmp(v9, "1")
        || jhl_iface_link_up_check(v7, v5)
        || (v10 = jhl_nvget(v19, v5), (v11 = (_BYTE *)nvram_get(v10)) == 0)
        || !*v11
        || (strlcpy(v16, v11, 64), v12 = a2 - v4, split_string(v16, 124, v17, 2) < 2) )
      {
        if ( v3 == ++v5 )
          break;
      }
      else
      {
        v13 = snprintf(&a1[v4], a2 - v4, format, v5, v17[0], v17[1]);
        if ( v13 >= v12 )
          v13 = v12 - 1;
        ++v5;
        v4 += v13;
        if ( v3 == v5 )
          break;
      }
    }
    while ( v4 < a2 - 99 );
  }
  v14 = &a1[v4];
  if ( v4 > 0 && *(v14 - 1) == 44 )
    v14 = &a1[--v4];
  *(_WORD *)v14 = 93;
  return v4 + 1;
}
// 642A04: using guessed type __int16 word_642A04;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (00448C00) --------------------------------------------------------
int __fastcall sub_448C00(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $s1
  int v5; // $v0
  int v6; // $s1
  int v7; // $v0
  int v8; // $s1
  int v9; // $v0
  int v10; // $a2
  int result; // $v0
  const char *v12; // $v0
  unsigned int v13; // $v0
  char v14[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(0x200000, "wan_extend_list_data", 4126);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{\"reaal_wans\":");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v4 = get_realwans_data(0, v2 + 41, 2097111) + 41;
    v5 = snprintf(&v3[v4], 0x200000 - v4, ",\"ex_wans\":");
    if ( v5 >= 0x200000 - v4 )
      v5 = 0x1FFFFF - v4;
    v6 = v5 + v4 + get_wans_increase_data(&v3[v5 + v4], 0x200000 - (v5 + v4));
    v7 = snprintf(&v3[v6], 0x200000 - v6, ",\"br_wans\":");
    if ( v7 >= 0x200000 - v6 )
      v7 = 0x1FFFFF - v6;
    v8 = v7 + v6 + get_wans_pppoebr_data(&v3[v7 + v6], 0x200000 - (v7 + v6));
    v9 = snprintf(&v3[v8], 0x200000 - v8, "}}");
    if ( v9 >= 0x200000 - v8 )
      v10 = 0x1FFFFF - v8;
    else
      v10 = v9;
    result = httpd_cgi_ret(a1, v3, v10 + v8, 8);
  }
  else
  {
    v12 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v13 = snprintf(v14, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v12);
    if ( v13 >= 0x100 )
      v13 = 255;
    result = httpd_cgi_ret(a1, v14, v13, 4);
  }
  return result;
}
// 448C50: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A85B4: using guessed type int __fastcall get_realwans_data(_DWORD, _DWORD, _DWORD);

//----- (00448EC0) --------------------------------------------------------
void __fastcall format_wan_extend_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 4 )
    snprintf(a3, a4, "{\"wan_name\":\"%s\",\"wan_iface\":%s,\"wan_num\":%s,\"wan_vlan\":%s},", *a1, a1[1], a1[2], a1[3]);
}

//----- (00448F50) --------------------------------------------------------
int __fastcall sub_448F50(int a1)
{
  int v1; // $v0
  char *v2; // $fp
  const char *v3; // $s1
  const char *v4; // $v0
  int v5; // $v0
  int v6; // $s3
  int v7; // $s1
  char *v8; // $s4
  int v9; // $s5
  int v10; // $s0
  const char **v11; // $s2
  void *v12; // $v0
  _DWORD *v13; // $s6
  int v14; // $a1
  void *v15; // $s5
  int v16; // $s5
  int i; // $s7
  int v18; // $v0
  int v19; // $v0
  char *v20; // $a0
  int v21; // $s1
  int v22; // $v0
  int v23; // $s0
  int v24; // $v0
  int v25; // $s0
  int v26; // $v0
  int v27; // $s0
  int v28; // $v0
  int v29; // $s0
  int v30; // $v0
  int v31; // $a2
  int result; // $v0
  const char *v33; // $v0
  unsigned int v34; // $v0
  char v35[256]; // [sp+20h] [-108h] BYREF
  _DWORD *v36; // [sp+120h] [-8h]
  void *ptr; // [sp+124h] [-4h]

  _mem_malloc(0x200000, "wan_extend_data", 3948);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    v3 = (const char *)jhl_nv_get_def("increase_wan");
    v4 = (const char *)jhl_nv_get_def("increase_base");
    v5 = snprintf(v2 + 29, 2097123, "\"increase_wan\":\"%s\",\"increase_base\":\"%s\",\"all\":", v3, v4);
    if ( v5 >= 2097123 )
      v5 = 2097122;
    v6 = v5 + 29;
    v7 = 0x200000 - (v5 + 29);
    v8 = &v2[v5 + 29];
    v9 = nvram_get("increase_wan_all");
    v10 = snprintf(&v2[v6], 0x200000 - v6, (char *)&word_642A04);
    if ( v10 >= 0x200000 - v6 )
      v10 = 0x1FFFFF - v6;
    if ( v9 )
    {
      v11 = (const char **)malloc(0x18u);
      v36 = malloc(0x4008u);
      v13 = v36;
      v12 = malloc(0x200000u);
      ptr = v12;
      if ( v12 )
      {
        if ( v11 )
        {
          v14 = v9;
          if ( v36 )
          {
            v15 = v12;
            strlcpy(v12, v14, 0x200000);
            v16 = split_string(v15, 60, v36, 4096);
            if ( v16 > 0 )
            {
              for ( i = 0; i != v16; ++i )
              {
                v18 = split_string(*v13, 124, v11, 4);
                format_wan_extend_data(v11, v18, &v8[v10], v7 - v10);
                v10 += v19;
                ++v13;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v11 )
        free(v11);
      if ( v36 )
        free(v36);
    }
    v20 = &v8[v10];
    if ( v10 > 0 && *(v20 - 1) == 44 )
      v20 = &v8[--v10];
    v21 = v7 - v10;
    *v20 = 0;
    v22 = snprintf(v20, v21, &byte_6445A0);
    if ( v22 >= v21 )
      v22 = v21 - 1;
    v23 = v10 + v22 + v6;
    v24 = snprintf(&v2[v23], 0x200000 - v23, (char *)&dword_6448E0);
    if ( v24 >= 0x200000 - v23 )
      v24 = 0x1FFFFF - v23;
    v25 = v24 + v23 + get_wans_increase_data(&v2[v24 + v23], 0x200000 - (v24 + v23));
    v26 = snprintf(&v2[v25], 0x200000 - v25, ",\"real_wans\":");
    if ( v26 >= 0x200000 - v25 )
      v26 = 0x1FFFFF - v25;
    v27 = v26 + v25 + get_realwans_data(0, &v2[v26 + v25], 0x200000 - (v26 + v25));
    v28 = snprintf(&v2[v27], 0x200000 - v27, ",\"sfp_num\":%d", 0);
    if ( v28 >= 0x200000 - v27 )
      v28 = 0x1FFFFF - v27;
    v29 = v28 + v27;
    v30 = snprintf(&v2[v29], 0x200000 - v29, "}}");
    if ( v30 >= 0x200000 - v29 )
      v31 = 0x1FFFFF - v29;
    else
      v31 = v30;
    result = httpd_cgi_ret(a1, v2, v31 + v29, 8);
  }
  else
  {
    v33 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v34 = snprintf(v35, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v33);
    if ( v34 >= 0x100 )
      v34 = 255;
    result = httpd_cgi_ret(a1, v35, v34, 4);
  }
  return result;
}
// 448FB0: variable 'v1' is possibly undefined
// 4491C0: variable 'v19' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6448E0: using guessed type int dword_6448E0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85B4: using guessed type int __fastcall get_realwans_data(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00449480) --------------------------------------------------------
void __fastcall format_wys_bonding_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 6 )
    snprintf(
      a3,
      a4,
      "{\"name\":\"%s\",\"port\":\"%s\",\"mode\":\"%s\",\"policy\":\"%s\",\"lw\":\"%s\",\"ifname\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5]);
}

//----- (00449520) --------------------------------------------------------
int __fastcall sub_449520(int a1)
{
  const char *v1; // $v0
  const char *v2; // $s2
  const char *v3; // $v1
  char *v4; // $v0
  int v5; // $t0
  int v6; // $a3
  int v7; // $a2
  int v8; // $a1
  int v9; // $a1
  int v10; // $a0
  __int16 v11; // $v1
  const char *v12; // $v0
  char *v13; // $s0
  int v14; // $a3
  int v15; // $a2
  int v16; // $a1
  int v17; // $a0
  const char *v18; // $v0
  char *v19; // $s0
  int v20; // $a3
  int v21; // $a2
  int v22; // $a1
  int v23; // $a0
  int v24; // $a3
  __int16 v25; // $a2
  int v26; // $s0
  const char **v27; // $s2
  void *v28; // $v0
  _DWORD *v29; // $s7
  int v30; // $s4
  int v31; // $a1
  void *v32; // $s0
  int v33; // $s5
  _DWORD *v34; // $fp
  int v35; // $s0
  int i; // $s6
  int v37; // $v0
  int v38; // $v0
  int v39; // $v0
  int v40; // $s0
  unsigned int v41; // $v0
  unsigned int v42; // $s0
  unsigned int v43; // $v0
  const char *v45; // $v0
  char *v46; // $s0
  int v47; // $a3
  int v48; // $a2
  int v49; // $a1
  int v50; // $a0
  int v51; // $a0
  int v52; // $a1
  const char *v53; // $v1
  char *v54; // $v0
  int v55; // $t0
  int v56; // $a3
  int v57; // $a2
  int v58; // $a1
  int v59; // $a0
  int v60; // $v1
  const char *v61; // $v1
  char *v62; // $v0
  int v63; // $t0
  int v64; // $a3
  int v65; // $a2
  int v66; // $a1
  const char *v67; // $v1
  char *v68; // $v0
  int v69; // $t0
  int v70; // $a3
  int v71; // $a2
  int v72; // $a1
  const char *v73; // $v0
  char *v74; // $s0
  int v75; // $a3
  int v76; // $a2
  int v77; // $a1
  int v78; // $a0
  __int16 v79; // $t3
  const char *v80; // $v1
  char *v81; // $v0
  int v82; // $t0
  int v83; // $a3
  int v84; // $a2
  int v85; // $a1
  int v86; // $a1
  const char *v87; // $v1
  char *v88; // $v0
  int v89; // $t0
  int v90; // $a3
  int v91; // $a2
  int v92; // $a1
  int v93; // $a1
  int v94; // $a0
  int v95; // $v1
  const char *v96; // $v1
  char *v97; // $v0
  int v98; // $t0
  int v99; // $a3
  int v100; // $a2
  int v101; // $a1
  int v102; // $a0
  __int16 v103; // $v1
  const char *v104; // $v1
  char *v105; // $v0
  int v106; // $t0
  int v107; // $a3
  int v108; // $a2
  int v109; // $a1
  char v110[102400]; // [sp+20h] [-1E008h] BYREF
  char v111[10240]; // [sp+19020h] [-5008h] BYREF
  char v112[10240]; // [sp+1B820h] [-2808h] BYREF
  void *v113; // [sp+1E020h] [-8h]

  memset(v110, 0, sizeof(v110));
  memset(v112, 0, sizeof(v112));
  memset(v111, 0, sizeof(v111));
  v1 = (const char *)nvram_get("vlan_name");
  if ( v1 )
  {
    v2 = v1;
    if ( !strcmp(v1, "L123456789") )
    {
      v18 = "eth3.4081 eth3.4082 eth3.4083 eth3.4084 eth3.4085 eth2.4081 eth2.4082 eth2.4083 eth2.4084";
      v19 = v112;
      do
      {
        v20 = *(_DWORD *)v18;
        v21 = *((_DWORD *)v18 + 1);
        v22 = *((_DWORD *)v18 + 2);
        v23 = *((_DWORD *)v18 + 3);
        v18 += 16;
        *(_DWORD *)v19 = v20;
        *((_DWORD *)v19 + 1) = v21;
        *((_DWORD *)v19 + 2) = v22;
        *((_DWORD *)v19 + 3) = v23;
        v19 += 16;
      }
      while ( v18 != "eth2.4084" );
      v24 = *((_DWORD *)v18 + 1);
      v25 = *((_WORD *)v18 + 4);
      *(_DWORD *)v19 = *(_DWORD *)v18;
      *((_DWORD *)v19 + 1) = v24;
      *((_WORD *)v19 + 4) = v25;
      strcpy(v111, "eth2.4085");
      goto LABEL_20;
    }
    if ( !strcmp(v2, "L12345678") )
    {
      v12 = "eth3.4081 eth3.4082 eth3.4083 eth3.4084 eth3.4085 eth2.4081 eth2.4082 eth2.4083";
      v13 = v112;
      do
      {
        v14 = *(_DWORD *)v12;
        v15 = *((_DWORD *)v12 + 1);
        v16 = *((_DWORD *)v12 + 2);
        v17 = *((_DWORD *)v12 + 3);
        v12 += 16;
        *(_DWORD *)v13 = v14;
        *((_DWORD *)v13 + 1) = v15;
        *((_DWORD *)v13 + 2) = v16;
        *((_DWORD *)v13 + 3) = v17;
        v13 += 16;
      }
      while ( v12 != "eth2.4085 eth2.4084" );
      strcpy(v111, "eth2.4085 eth2.4084");
      goto LABEL_20;
    }
    if ( !strcmp(v2, "L1234567") )
    {
      v73 = "eth3.4081 eth3.4082 eth3.4083 eth3.4084 eth3.4085 eth2.4081 eth2.4082";
      v74 = v112;
      do
      {
        v75 = *(_DWORD *)v73;
        v76 = *((_DWORD *)v73 + 1);
        v77 = *((_DWORD *)v73 + 2);
        v78 = *((_DWORD *)v73 + 3);
        v73 += 16;
        *(_DWORD *)v74 = v75;
        *((_DWORD *)v74 + 1) = v76;
        *((_DWORD *)v74 + 2) = v77;
        *((_DWORD *)v74 + 3) = v78;
        v74 += 16;
      }
      while ( v73 != ".4082" );
      v79 = *((_WORD *)v73 + 2);
      *(_DWORD *)v74 = *(_DWORD *)v73;
      *((_WORD *)v74 + 2) = v79;
      strcpy(v111, "eth2.4085 eth2.4084 eth2.4083");
      goto LABEL_20;
    }
    if ( !strcmp(v2, "L123456") )
    {
      v45 = "eth3.4081 eth3.4082 eth3.4083 eth3.4084 eth3.4085 eth2.4081";
      v46 = v112;
      do
      {
        v47 = *(_DWORD *)v45;
        v48 = *((_DWORD *)v45 + 1);
        v49 = *((_DWORD *)v45 + 2);
        v50 = *((_DWORD *)v45 + 3);
        v45 += 16;
        *(_DWORD *)v46 = v47;
        *((_DWORD *)v46 + 1) = v48;
        *((_DWORD *)v46 + 2) = v49;
        *((_DWORD *)v46 + 3) = v50;
        v46 += 16;
      }
      while ( v45 != "5 eth2.4081" );
      v51 = *((_DWORD *)v45 + 1);
      v52 = *(_DWORD *)v45;
      *((_DWORD *)v46 + 2) = *((_DWORD *)v45 + 2);
      v53 = "eth2.4085 eth2.4084 eth2.4083 eth2.4082";
      *((_DWORD *)v46 + 1) = v51;
      *(_DWORD *)v46 = v52;
      v54 = v111;
      do
      {
        v55 = *(_DWORD *)v53;
        v56 = *((_DWORD *)v53 + 1);
        v57 = *((_DWORD *)v53 + 2);
        v58 = *((_DWORD *)v53 + 3);
        v53 += 16;
        *(_DWORD *)v54 = v55;
        *((_DWORD *)v54 + 1) = v56;
        *((_DWORD *)v54 + 2) = v57;
        *((_DWORD *)v54 + 3) = v58;
        v54 += 16;
      }
      while ( v53 != "h2.4082" );
      v59 = *(_DWORD *)v53;
      v60 = *((_DWORD *)v53 + 1);
      *(_DWORD *)v54 = v59;
      *((_DWORD *)v54 + 1) = v60;
      goto LABEL_20;
    }
  }
  else
  {
    v2 = "";
  }
  if ( !strcmp(v2, "L12345") )
  {
    v61 = "eth3.4081 eth3.4082 eth3.4083 eth3.4084 eth3.4085";
    v62 = v112;
    do
    {
      v63 = *(_DWORD *)v61;
      v64 = *((_DWORD *)v61 + 1);
      v65 = *((_DWORD *)v61 + 2);
      v66 = *((_DWORD *)v61 + 3);
      v61 += 16;
      *(_DWORD *)v62 = v63;
      *((_DWORD *)v62 + 1) = v64;
      *((_DWORD *)v62 + 2) = v65;
      *((_DWORD *)v62 + 3) = v66;
      v62 += 16;
    }
    while ( v61 != "5" );
    *(_WORD *)v62 = *(_WORD *)v61;
    v67 = "eth2.4085 eth2.4084 eth2.4083 eth2.4082 eth2.4081";
    v68 = v111;
    do
    {
      v69 = *(_DWORD *)v67;
      v70 = *((_DWORD *)v67 + 1);
      v71 = *((_DWORD *)v67 + 2);
      v72 = *((_DWORD *)v67 + 3);
      v67 += 16;
      *(_DWORD *)v68 = v69;
      *((_DWORD *)v68 + 1) = v70;
      *((_DWORD *)v68 + 2) = v71;
      *((_DWORD *)v68 + 3) = v72;
      v68 += 16;
    }
    while ( v67 != "1" );
    *(_WORD *)v68 = *(_WORD *)v67;
  }
  else if ( !strcmp(v2, "L1234") )
  {
    v80 = "eth3.4081 eth3.4082 eth3.4083 eth3.4084";
    v81 = v112;
    do
    {
      v82 = *(_DWORD *)v80;
      v83 = *((_DWORD *)v80 + 1);
      v84 = *((_DWORD *)v80 + 2);
      v85 = *((_DWORD *)v80 + 3);
      v80 += 16;
      *(_DWORD *)v81 = v82;
      *((_DWORD *)v81 + 1) = v83;
      *((_DWORD *)v81 + 2) = v84;
      *((_DWORD *)v81 + 3) = v85;
      v81 += 16;
    }
    while ( v80 != "h3.4084" );
    v86 = *(_DWORD *)v80;
    *((_DWORD *)v81 + 1) = *((_DWORD *)v80 + 1);
    *(_DWORD *)v81 = v86;
    v87 = "eth2.4085 eth2.4084 eth2.4083 eth2.4082 eth2.4081 eth3.4085";
    v88 = v111;
    do
    {
      v89 = *(_DWORD *)v87;
      v90 = *((_DWORD *)v87 + 1);
      v91 = *((_DWORD *)v87 + 2);
      v92 = *((_DWORD *)v87 + 3);
      v87 += 16;
      *(_DWORD *)v88 = v89;
      *((_DWORD *)v88 + 1) = v90;
      *((_DWORD *)v88 + 2) = v91;
      *((_DWORD *)v88 + 3) = v92;
      v88 += 16;
    }
    while ( v87 != "1 eth3.4085" );
    v93 = *(_DWORD *)v87;
    v94 = *((_DWORD *)v87 + 1);
    v95 = *((_DWORD *)v87 + 2);
    *(_DWORD *)v88 = v93;
    *((_DWORD *)v88 + 1) = v94;
    *((_DWORD *)v88 + 2) = v95;
  }
  else if ( !strcmp(v2, "L123") )
  {
    v96 = "eth2.4085 eth2.4084 eth2.4083 eth2.4082 eth2.4081 eth3.4085 eth3.4084";
    strcpy(v112, "eth3.4081 eth3.4082 eth3.4083");
    v97 = v111;
    do
    {
      v98 = *(_DWORD *)v96;
      v99 = *((_DWORD *)v96 + 1);
      v100 = *((_DWORD *)v96 + 2);
      v101 = *((_DWORD *)v96 + 3);
      v96 += 16;
      *(_DWORD *)v97 = v98;
      *((_DWORD *)v97 + 1) = v99;
      *((_DWORD *)v97 + 2) = v100;
      *((_DWORD *)v97 + 3) = v101;
      v97 += 16;
    }
    while ( v96 != ".4084" );
    v102 = *(_DWORD *)v96;
    v103 = *((_WORD *)v96 + 2);
    *(_DWORD *)v97 = v102;
    *((_WORD *)v97 + 2) = v103;
  }
  else if ( !strcmp(v2, "L12") )
  {
    v104 = "eth2.4085 eth2.4084 eth2.4083 eth2.4082 eth2.4081 eth3.4085 eth3.4084 eth3.4083";
    strcpy(v112, "eth3.4081 eth3.4082");
    v105 = v111;
    do
    {
      v106 = *(_DWORD *)v104;
      v107 = *((_DWORD *)v104 + 1);
      v108 = *((_DWORD *)v104 + 2);
      v109 = *((_DWORD *)v104 + 3);
      v104 += 16;
      *(_DWORD *)v105 = v106;
      *((_DWORD *)v105 + 1) = v107;
      *((_DWORD *)v105 + 2) = v108;
      *((_DWORD *)v105 + 3) = v109;
      v105 += 16;
    }
    while ( v104 != "eth3.4081" );
  }
  else if ( !strcmp(v2, "L1") )
  {
    v3 = "eth2.4085 eth2.4084 eth2.4083 eth2.4082 eth2.4081 eth3.4085 eth3.4084 eth3.4083 eth3.4082";
    strcpy(v112, "eth3.4081");
    v4 = v111;
    do
    {
      v5 = *(_DWORD *)v3;
      v6 = *((_DWORD *)v3 + 1);
      v7 = *((_DWORD *)v3 + 2);
      v8 = *((_DWORD *)v3 + 3);
      v3 += 16;
      *(_DWORD *)v4 = v5;
      *((_DWORD *)v4 + 1) = v6;
      *((_DWORD *)v4 + 2) = v7;
      *((_DWORD *)v4 + 3) = v8;
      v4 += 16;
    }
    while ( v3 != "eth3.4082" );
    v9 = *(_DWORD *)v3;
    v10 = *((_DWORD *)v3 + 1);
    v11 = *((_WORD *)v3 + 4);
    *(_DWORD *)v4 = v9;
    *((_DWORD *)v4 + 1) = v10;
    *((_WORD *)v4 + 4) = v11;
  }
LABEL_20:
  strcpy(v110, "{\"code\":0,\"error\":\"\",\"data\":{\"bondlist\":");
  v26 = nvram_get("bond_list");
  strcpy(&v110[40], "[");
  if ( !v26 )
  {
    v30 = 1;
    v35 = 1;
    if ( v110[40] != 44 )
      goto LABEL_35;
    goto LABEL_53;
  }
  v27 = (const char **)malloc(0x20u);
  v29 = malloc(0x4008u);
  v28 = malloc(0x200000u);
  v113 = v28;
  if ( v28 )
  {
    v30 = 1;
    if ( v27 )
    {
      v31 = v26;
      if ( v29 )
      {
        v32 = v28;
        strlcpy(v28, v31, 0x200000);
        v33 = split_string(v32, 60, v29, 4096);
        if ( v33 > 0 )
        {
          v34 = v29;
          v35 = 1;
          for ( i = 0; i != v33; ++i )
          {
            v37 = split_string(*v34, 124, v27, 6);
            format_wys_bonding_data(v27, v37, &v110[v35 + 40], 102360 - v35);
            v35 += v38;
            ++v34;
          }
          v30 = v35;
          goto LABEL_28;
        }
        v30 = 1;
      }
    }
    v35 = 1;
LABEL_28:
    free(v113);
    goto LABEL_29;
  }
  v30 = 1;
  v35 = 1;
LABEL_29:
  if ( v27 )
    free(v27);
  if ( v29 )
    free(v29);
  if ( v35 > 0 && v110[v30 + 39] == 44 )
LABEL_53:
    v30 = --v35;
LABEL_35:
  v110[v30 + 40] = 0;
  v39 = snprintf(&v110[v30 + 40], 102360 - v35, &byte_6445A0);
  if ( v39 >= 102360 - v35 )
    v39 = 102359 - v35;
  v40 = v35 + v39 + 40;
  v41 = snprintf(&v110[v40], 102400 - v40, ",\"wan\":\"%s\",\"lan\":\"%s\",\"x86\":\"%d\"", v111, v112, 0);
  if ( v41 >= 102400 - v40 )
    v41 = 102399 - v40;
  v42 = v41 + v40;
  v43 = snprintf(&v110[v42], 102400 - v42, "}}");
  if ( v43 >= 102400 - v42 )
    v43 = 102399 - v42;
  return httpd_cgi_ret(a1, v110, v43 + v42, 4);
}
// 449A40: variable 'v38' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044A020) --------------------------------------------------------
int __fastcall _wan_group_modify(const char *a1, int a2)
{
  int v4; // $s4
  int v5; // $s0
  int v6; // $s5
  int v7; // $v0
  const char *v8; // $v0
  int v9; // $v0
  int v10; // $v0
  _BYTE *v11; // $v0

  v4 = sq_file_get_max_wan();
  if ( v4 <= 0 )
    return 0;
  v5 = 0;
  v6 = 0;
  do
  {
    v10 = jhl_nvget("wan_ifname", v5);
    v11 = (_BYTE *)nvram_get(v10);
    if ( v11 )
    {
      if ( !*v11 )
        return v6;
    }
    else if ( !asc_4CF9E8[4] )
    {
      return v6;
    }
    v7 = jhl_nvget("wan_group", v5);
    v8 = (const char *)nvram_get(v7);
    if ( v8 && a1 && !strcmp(v8, a1) )
    {
      v9 = jhl_nvget("wan_group", v5);
      nvram_set(v9, a2);
      v6 = 1;
    }
    ++v5;
  }
  while ( v4 != v5 );
  return v6;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044A1B8) --------------------------------------------------------
int __fastcall sub_44A1B8(int a1)
{
  char *v2; // $s4
  char *v3; // $s6
  int v4; // $s5
  char *v5; // $v0
  char *v6; // $v0
  char *v7; // $s0
  char *v8; // $s1
  int v9; // $v0
  _DWORD *v10; // $fp
  const char *v11; // $a0
  int v12; // $s4
  int v13; // $s7
  char *v15; // $v1
  const char *v16; // $v0
  int v17; // $t0
  int v18; // $a3
  int v19; // $a2
  int v20; // $a1
  int v21; // $a1
  const char *v22; // $a2
  int v23; // $a0
  const char *v24; // $v0
  char *v25; // $s4
  int v26; // $v0
  char s[256]; // [sp+28h] [-110h] BYREF
  char *v28; // [sp+128h] [-10h]
  char *v29; // [sp+12Ch] [-Ch]
  const char *v30; // [sp+130h] [-8h]

  v2 = httpd_get_parm(a1, "opt");
  v3 = httpd_get_parm(a1, "name");
  v29 = httpd_get_parm(a1, "old_name");
  v4 = httpd_get_json_parm(a1, (int)"del_list");
  _mem_malloc(102400, "wan_group_asp", 4979);
  v7 = v6;
  _mem_malloc(102400, "wan_group_asp", 4980);
  v8 = v5;
  if ( v7 && v5 )
  {
    v9 = a1 + 196608;
    if ( v2 )
    {
      if ( !strcmp(v2, (const char *)&off_646D8C) || !strcmp(v2, (const char *)&off_648DDC) )
      {
        if ( strcmp(v2, "del") )
          goto LABEL_17;
        goto LABEL_7;
      }
      if ( !strcmp(v2, "del") )
      {
LABEL_7:
        if ( v4 && cJSON_IsArray(v4) )
        {
          v10 = *(_DWORD **)(v4 + 8);
          if ( !v10 )
            goto LABEL_23;
          v11 = (const char *)v10[4];
          if ( !v11 )
            goto LABEL_23;
          v28 = "a";
          v29 = 0;
          v12 = 0;
          v30 = "wan_groups";
          do
          {
            v12 += _wan_group_modify(v11, (int)"");
            jhl_parm_get("wan_groups", v7, 102400);
            if ( nvparm_del_str(v7, 60, 4, v10[4], 124, 0, v8) )
            {
              jhl_parm_set(v30, v8);
              v29 = (char *)1;
            }
            v10 = (_DWORD *)*v10;
            if ( !v10 )
              break;
            v11 = (const char *)v10[4];
          }
          while ( v11 );
          if ( !v29 )
          {
            if ( !v12 )
            {
LABEL_23:
              v15 = s;
              v16 = "{\"code\":0,\"error\":\"\",\"data\":null}";
              do
              {
                v17 = *(_DWORD *)v16;
                v18 = *((_DWORD *)v16 + 1);
                v19 = *((_DWORD *)v16 + 2);
                v20 = *((_DWORD *)v16 + 3);
                v16 += 16;
                *(_DWORD *)v15 = v17;
                *((_DWORD *)v15 + 1) = v18;
                *((_DWORD *)v15 + 2) = v19;
                *((_DWORD *)v15 + 3) = v20;
                v15 += 16;
              }
              while ( v16 != "}" );
              v13 = 33;
              *(_WORD *)v15 = *(_WORD *)v16;
              goto LABEL_21;
            }
LABEL_37:
            jhl_parm_commit(v11);
            goto LABEL_23;
          }
LABEL_36:
          jhl_parm_set(v28 + 17112, v8);
          goto LABEL_37;
        }
LABEL_17:
        if ( v3 )
        {
          if ( strcmp(v2, (const char *)&off_646D8C) )
          {
            if ( strcmp(v2, (const char *)&off_648DDC) )
              goto LABEL_23;
            v28 = "a";
            goto LABEL_20;
          }
          v28 = "a";
          jhl_parm_get("wan_groups", v8, 102400);
          if ( !nvparm_find_str(v8, 60, 4, v3, 124, 0) )
          {
LABEL_20:
            v13 = check_rule_num_limit(a1, 40, (int)(v28 + 17112), 60, s, 0x100u);
            if ( v13 > 0 )
              goto LABEL_21;
            if ( !strcmp(v2, (const char *)&off_648DDC)
              && ((jhl_parm_get(v28 + 17112, v7, 102400), (v25 = v29) == 0) ? (v26 = nvparm_del_str(
                                                                                       v7,
                                                                                       60,
                                                                                       4,
                                                                                       v3,
                                                                                       124,
                                                                                       0,
                                                                                       v8)) : (_wan_group_modify(
                                                                                                 v29,
                                                                                                 (int)v3),
                                                                                               v26 = nvparm_del_str(v7, 60, 4, v25, 124, 0, v8)),
                  v26) )
            {
              sprintf(v7, "%s<", v3);
            }
            else
            {
              sprintf(v7, "%s<", v3);
              jhl_parm_get(v28 + 17112, v8, 102400);
              if ( !strcmp(v8, " ") )
                *v8 = 0;
            }
            strcat(v8, v7);
            goto LABEL_36;
          }
          v21 = *(unsigned __int8 *)(a1 + 210102);
          v22 = "same name";
        }
        else
        {
          v21 = *(unsigned __int8 *)(a1 + 210102);
          v22 = (const char *)&unk_6442E4;
        }
        goto LABEL_29;
      }
      v9 = a1 + 196608;
    }
    v21 = *(unsigned __int8 *)(v9 + 13494);
    v22 = "not opt";
LABEL_29:
    v23 = 12;
    goto LABEL_30;
  }
  v21 = *(unsigned __int8 *)(a1 + 210102);
  v22 = (const char *)102400;
  v23 = 4;
LABEL_30:
  v24 = (const char *)_GET_LANG_TEXT(v23, v21, v22);
  v13 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
  if ( (unsigned int)v13 >= 0x100 )
    v13 = 255;
LABEL_21:
  _mem_free(v7);
  _mem_free(v8);
  return httpd_cgi_ret(a1, s, v13, 4);
}
// 44A298: variable 'v6' is possibly undefined
// 44A2A4: variable 'v5' is possibly undefined
// 44A704: variable 'v11' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (0044A834) --------------------------------------------------------
void __fastcall format_wan_groups_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 > 0 )
    snprintf(a3, a4, "{\"name\":\"%s\"},", *a1);
}

//----- (0044A8A4) --------------------------------------------------------
int __fastcall sub_44A8A4(int a1)
{
  int v1; // $v0
  char *v2; // $s0
  _BYTE *v3; // $s4
  int v4; // $s1
  const char **v5; // $s3
  void *v6; // $v0
  _DWORD *v7; // $s7
  int v8; // $a1
  void *v9; // $s1
  int v10; // $s6
  _DWORD *v11; // $fp
  int v12; // $s1
  int i; // $s2
  int v14; // $v0
  int v15; // $v0
  int v16; // $s5
  char *v17; // $a0
  int v18; // $v0
  int v19; // $s1
  int v20; // $v0
  int v21; // $s1
  int v22; // $a2
  const char *v24; // $v0
  unsigned int v25; // $v0
  char v26[1024]; // [sp+20h] [-408h] BYREF
  void *ptr; // [sp+420h] [-8h]

  _mem_malloc(0x200000, "wan_group_data", 5116);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{\"groups\":");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    *(_BYTE *)(v1 + 32) = 111;
    v3 = (_BYTE *)(v1 + 38);
    v4 = nvram_get("wan_groups");
    v2[38] = 91;
    v2[39] = 0;
    if ( v4 )
    {
      v5 = (const char **)malloc(0x10u);
      v7 = malloc(0x4008u);
      v6 = malloc(0x200000u);
      ptr = v6;
      if ( v6 )
      {
        if ( v5 && (v8 = v4, v7) && (v9 = v6, strlcpy(v6, v8, 0x200000), v10 = split_string(v9, 60, v7, 4096), v10 > 0) )
        {
          v11 = v7;
          v12 = 1;
          for ( i = 0; i != v10; ++i )
          {
            v14 = split_string(*v11, 124, v5, 2);
            format_wan_groups_data(v5, v14, &v3[v12], 2097114 - v12);
            v12 += v15;
            ++v11;
          }
          v16 = v12;
        }
        else
        {
          v16 = 1;
          v12 = 1;
        }
        free(ptr);
      }
      else
      {
        v16 = 1;
        v12 = 1;
      }
      if ( v5 )
        free(v5);
      if ( v7 )
        free(v7);
      if ( v12 <= 0 )
      {
        v17 = &v3[v16];
        goto LABEL_17;
      }
      v17 = &v3[v16];
      if ( v3[v16 - 1] != 44 )
      {
LABEL_17:
        *v17 = 0;
        v18 = snprintf(v17, 2097114 - v12, &byte_6445A0);
        if ( v18 >= 2097114 - v12 )
          v18 = 2097113 - v12;
        v19 = v12 + v18 + 38;
        v20 = snprintf(&v2[v19], 0x200000 - v19, (char *)&dword_6448E0);
        if ( v20 >= 0x200000 - v19 )
          v20 = 0x1FFFFF - v19;
        v21 = v20 + v19 + get_wans_data(&v2[v20 + v19], 0x200000 - (v20 + v19));
        v22 = snprintf(&v2[v21], 0x200000 - v21, "}}");
        if ( v22 >= 0x200000 - v21 )
          v22 = 0x1FFFFF - v21;
        return httpd_cgi_ret(a1, v2, v22 + v21, 8);
      }
    }
    else
    {
      v17 = v2 + 39;
      v12 = 1;
      if ( *v3 != 44 )
        goto LABEL_17;
    }
    v17 = &v3[--v12];
    goto LABEL_17;
  }
  v24 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v25 = snprintf(v26, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
  if ( v25 >= 0x400 )
    v25 = 1023;
  return httpd_cgi_ret(a1, v26, v25, 4);
}
// 44A904: variable 'v1' is possibly undefined
// 44AAB8: variable 'v15' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6448E0: using guessed type int dword_6448E0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044AD10) --------------------------------------------------------
int __fastcall jhl_web_save_json_parm(int a1, int a2, int a3)
{
  int v3; // $v0
  _DWORD *v5; // $s0
  int v6; // $v0
  int v7; // $a1
  bool v8; // dc
  int result; // $v0
  const char *v10; // $s2
  const char *v11; // $v0

  v3 = httpd_get_json_parm(a1, a2);
  if ( !v3 )
    return 0;
  v5 = (_DWORD *)v3;
  if ( cJSON_IsNumber(v3) )
  {
    v6 = nvram_get_int(v5[8]);
    v7 = v5[5];
    v8 = v6 == v7;
    result = 1;
    if ( !v8 )
    {
      if ( a3 == 1 )
      {
        nvram_set_int(v5[8], v7);
        result = 1;
      }
      return result;
    }
    return 0;
  }
  v8 = cJSON_IsString(v5) == 0;
  result = 0;
  if ( v8 )
    return result;
  v10 = (const char *)v5[4];
  if ( !strcmp(v10, "undefined") )
    return 0;
  v11 = (const char *)nvram_get(v5[8]);
  if ( !v11 || (v8 = strcmp(v11, v10) == 0, result = 0, !v8) )
  {
    result = 1;
    if ( a3 == 1 )
    {
      nvram_set(v5[8], v5[4]);
      result = 1;
    }
  }
  return result;
}
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8248: using guessed type int __fastcall cJSON_IsString(_DWORD);
// 6A878C: using guessed type int __fastcall nvram_set_int(_DWORD, _DWORD);
// 6A88F0: using guessed type int __fastcall cJSON_IsNumber(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044AE7C) --------------------------------------------------------
int __fastcall jhl_web_save_parm(int a1, char *a2, int a3)
{
  char *v5; // $v0
  const char *v7; // $s0
  bool v8; // dc
  int result; // $v0
  const char *v10; // $v0

  v5 = httpd_get_parm(a1, a2);
  if ( !v5 )
    return jhl_web_save_json_parm(a1, (int)a2, a3);
  v7 = v5;
  v8 = strcmp(v5, "undefined") != 0;
  result = 0;
  if ( v8 )
  {
    v10 = (const char *)nvram_get(a2);
    if ( !v10 || (v8 = strcmp(v10, v7) == 0, result = 0, !v8) )
    {
      result = 1;
      if ( a3 == 1 )
      {
        nvram_set(a2, v7);
        result = 1;
      }
    }
  }
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044AF88) --------------------------------------------------------
int __fastcall jhl_web_save_json_parm2(int a1, int a2, int a3, int a4)
{
  int v5; // $v0
  int v7; // $s0
  int v8; // $v0
  int v9; // $a1
  bool v10; // dc
  int result; // $v0
  const char *v12; // $s3
  const char *v13; // $v0

  v5 = httpd_get_json_parm(a1, a2);
  if ( !v5 )
    return 0;
  v7 = v5;
  if ( cJSON_IsNumber(v5) )
  {
    v8 = nvram_get_int(a3);
    v9 = *(_DWORD *)(v7 + 20);
    v10 = v8 == v9;
    result = 1;
    if ( !v10 )
    {
      if ( a4 == 1 )
      {
        nvram_set_int(a3, v9);
        result = 1;
      }
      return result;
    }
    return 0;
  }
  v10 = cJSON_IsString(v7) == 0;
  result = 0;
  if ( v10 )
    return result;
  v12 = *(const char **)(v7 + 16);
  if ( !strcmp(v12, "undefined") )
    return 0;
  v13 = (const char *)nvram_get(a3);
  if ( !v13 || (v10 = strcmp(v13, v12) == 0, result = 0, !v10) )
  {
    result = 1;
    if ( a4 == 1 )
    {
      nvram_set(a3, *(_DWORD *)(v7 + 16));
      result = 1;
    }
  }
  return result;
}
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8248: using guessed type int __fastcall cJSON_IsString(_DWORD);
// 6A878C: using guessed type int __fastcall nvram_set_int(_DWORD, _DWORD);
// 6A88F0: using guessed type int __fastcall cJSON_IsNumber(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044B100) --------------------------------------------------------
int __fastcall sub_44B100(int a1, char *a2, int a3, int a4)
{
  char *v7; // $v0
  const char *v9; // $s0
  bool v10; // dc
  int result; // $v0
  const char *v12; // $v0

  v7 = httpd_get_parm(a1, a2);
  if ( !v7 )
    return jhl_web_save_json_parm2(a1, (int)a2, a3, a4);
  v9 = v7;
  v10 = strcmp(v7, "undefined") != 0;
  result = 0;
  if ( v10 )
  {
    v12 = (const char *)nvram_get(a3);
    if ( !v12 || (v10 = strcmp(v12, v9) == 0, result = 0, !v10) )
    {
      result = 1;
      if ( a4 == 1 )
      {
        nvram_set(a3, v9);
        result = 1;
      }
    }
  }
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044B224) --------------------------------------------------------
int __fastcall jhl_web_save_parms(int a1, char **a2, int a3)
{
  char *v4; // $a1
  char **v7; // $s0
  int v8; // $s3
  bool v9; // dc

  v4 = *a2;
  if ( !v4 || !*v4 )
    return 0;
  v7 = a2 + 1;
  v8 = 0;
  do
  {
    if ( jhl_web_save_parm(a1, v4, a3) )
      v8 = 1;
    v4 = *v7;
    v9 = *v7++ != 0;
  }
  while ( v9 && *v4 );
  return v8;
}

//----- (0044B2E4) --------------------------------------------------------
int __fastcall get_nvarms(const char **a1, int a2, int a3)
{
  const char **v3; // $s0
  const char *v4; // $a0
  int v7; // $s1
  const char *v8; // $s7
  const char *v9; // $v0
  int v10; // $a0

  v3 = a1;
  v4 = *a1;
  if ( !v4 || !*v4 )
    return 0;
  v7 = 0;
  do
  {
    v10 = jhl_nv_get_def(v4);
    if ( v10 )
    {
      v8 = *v3++;
      v9 = (const char *)get_json_data(v10);
      v7 += sprintf((char *)(a2 + v7), " \"%s\":\"%s\",", v8, v9);
      if ( v7 + 199 >= a3 )
        return v7;
    }
    else
    {
      v7 += sprintf((char *)(a2 + v7), " \"%s\":\"\",", *v3++);
      if ( v7 + 199 >= a3 )
        return v7;
    }
    v4 = *v3;
  }
  while ( *v3 && *v4 );
  return v7;
}
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);

//----- (0044B440) --------------------------------------------------------
int __fastcall set_nvrams(int a1, _BYTE **a2, int a3)
{
  _DWORD *v3; // $s0
  _BYTE *v4; // $a1
  int v7; // $s3
  int v8; // $v0
  int v9; // $s1
  int v10; // $v0
  int v11; // $a1
  const char *v13; // $s7
  const char *v14; // $v0

  v3 = a2;
  v4 = *a2;
  v7 = 0;
  if ( v4 )
  {
    while ( 1 )
    {
      if ( !*v4 )
        return v7;
      v8 = httpd_get_json_parm(a1, (int)v4);
      v9 = v8;
      if ( !v8 )
        goto LABEL_8;
      if ( !cJSON_IsNumber(v8) )
        break;
      v10 = nvram_get_int(*v3);
      v11 = *(_DWORD *)(v9 + 20);
      if ( v10 != v11 )
      {
        if ( a3 == 1 )
        {
          v7 = 1;
          nvram_set_int(*v3++, v11);
          goto LABEL_9;
        }
LABEL_7:
        v7 = 1;
      }
LABEL_8:
      ++v3;
LABEL_9:
      v4 = (_BYTE *)*v3;
      if ( !*v3 )
        return v7;
    }
    if ( !cJSON_IsString(v9) )
      goto LABEL_8;
    v13 = *(const char **)(v9 + 16);
    if ( !strcmp(v13, "undefined") )
      goto LABEL_8;
    v14 = (const char *)nvram_get(*v3);
    if ( v14 )
    {
      if ( !strcmp(v14, v13) )
        goto LABEL_8;
    }
    if ( a3 == 1 )
    {
      v7 = 1;
      nvram_set(*v3++, *(_DWORD *)(v9 + 16));
      goto LABEL_9;
    }
    goto LABEL_7;
  }
  return v7;
}
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8248: using guessed type int __fastcall cJSON_IsString(_DWORD);
// 6A878C: using guessed type int __fastcall nvram_set_int(_DWORD, _DWORD);
// 6A88F0: using guessed type int __fastcall cJSON_IsNumber(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044B60C) --------------------------------------------------------
int __fastcall sub_44B60C(_BYTE **a1, int a2, int a3)
{
  _BYTE **v3; // $s0
  _BYTE *v4; // $a0
  int v7; // $s1
  int v8; // $s6
  char *v9; // $v0
  const char *v10; // $v0
  char v12[256]; // [sp+18h] [-108h] BYREF
  char *format; // [sp+118h] [-8h]

  v3 = a1;
  v4 = *a1;
  if ( !v4 || !*v4 )
    return 0;
  v7 = 0;
  format = " \"%s\":\"\",";
  do
  {
    v8 = jhl_nv_get_def(v4);
    strlcpy(v12, *v3, 256);
    v9 = strstr(v12, "_5g");
    if ( v9 )
      *v9 = 0;
    if ( v8 )
    {
      v10 = (const char *)get_json_data(v8);
      v7 += sprintf((char *)(a2 + v7), " \"%s\":\"%s\",", v12, v10);
    }
    else
    {
      v7 += sprintf((char *)(a2 + v7), format, v12);
    }
    ++v3;
    if ( v7 + 199 >= a3 )
      break;
    v4 = *v3;
    if ( !*v3 )
      break;
  }
  while ( *v4 );
  return v7;
}
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);

//----- (0044B7AC) --------------------------------------------------------
char *__fastcall reltime(char *a1, int a2)
{
  int v3; // $a2
  int v4; // $t0
  int v5; // $v1
  const char *v6; // $a3
  int v7; // $v0
  int v8; // $a1

  if ( a2 < 0 )
  {
    v4 = 0;
    v7 = 0;
    v8 = 0;
    v3 = 0;
    v6 = "s";
  }
  else
  {
    v3 = a2 / 86400;
    v4 = a2 % 60;
    v5 = a2 / 60;
    if ( a2 / 86400 == 1 )
    {
      v8 = a2 / 3600 % 24;
      v7 = v5 % 60;
      v6 = "";
    }
    else
    {
      v6 = "s";
      v7 = v5 % 60;
      v8 = a2 / 3600 % 24;
    }
  }
  sprintf(a1, "%d day%s, %02d:%02d:%02d", v3, v6, v8, v7, v4);
  return a1;
}

//----- (0044B908) --------------------------------------------------------
int __fastcall jhl_link_uptime(char *a1, int a2, int a3)
{
  int v4; // $v0
  const char *v6; // $s1
  int result; // $v0
  int v8; // $v0
  struct sysinfo v9[4]; // [sp+18h] [-138h] BYREF

  v4 = jhl_nvget("wan_uptime", a2);
  v6 = (const char *)nvram_get(v4);
  result = 45;
  *a1 = 45;
  a1[1] = 0;
  if ( a3 )
  {
    if ( v6 )
    {
      sysinfo(v9);
      v8 = atol(v6);
      result = (int)reltime(a1, v9[0].uptime - v8);
    }
  }
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (0044B9D4) --------------------------------------------------------
_BYTE *__fastcall asp_jhl_dns(_BYTE *a1, int a2)
{
  int *v3; // $fp
  char *v4; // $s6
  int v5; // $s1
  int v6; // $s0
  const char *v7; // $s7
  struct in_addr v8; // $a0
  char *v9; // $v0
  _BYTE *v10; // $s1

  v3 = (int *)jhl_get_dns(a2);
  *a1 = 91;
  a1[1] = 32;
  a1[2] = 0;
  v4 = a1 + 2;
  if ( *v3 <= 0 )
  {
    v5 = 2;
  }
  else
  {
    v5 = 2;
    v6 = 0;
    v7 = "";
    while ( 1 )
    {
      v8.s_addr = v3[++v6];
      v9 = inet_ntoa(v8);
      v5 += sprintf(v4, "%s\"%s\"", v7, v9);
      if ( v6 >= *v3 )
        break;
      v4 = &a1[v5];
      if ( v6 )
        v7 = &byte_643D4C;
      else
        v7 = "";
    }
  }
  v10 = &a1[v5];
  *v10 = 93;
  v10[1] = 0;
  return a1;
}
// 643D4C: using guessed type char byte_643D4C;
// 6A857C: using guessed type int __fastcall jhl_get_dns(_DWORD);

//----- (0044BB14) --------------------------------------------------------
int __fastcall sub_44BB14(int a1, int a2)
{
  int *v3; // $s3
  int v4; // $s0
  int v5; // $s1
  char *v6; // $v0

  v3 = (int *)jhl_get_dns(a2);
  v4 = 0;
  if ( *v3 > 0 )
  {
    v5 = 0;
    do
    {
      v6 = inet_ntoa((struct in_addr)v3[++v5]);
      v4 += sprintf((char *)(a1 + v4), "%s ", v6);
    }
    while ( v5 < *v3 );
    if ( v4 > 0 && *(_BYTE *)(a1 + v4 - 1) == 32 )
      --v4;
  }
  *(_BYTE *)(a1 + v4) = 0;
  return a1;
}
// 6A857C: using guessed type int __fastcall jhl_get_dns(_DWORD);

//----- (0044BC08) --------------------------------------------------------
void __fastcall get_client_info(int a1, int a2, int a3)
{
  FILE *v6; // $s3
  char v7[256]; // [sp+10h] [-138h] BYREF
  char v8[20]; // [sp+110h] [-38h] BYREF

  if ( !*(_BYTE *)a3 )
  {
    v6 = fopen("/proc/net/arp", "r");
    if ( v6 )
    {
      while ( fgets(v7, 256, v6)
           && (sscanf(v7, "%15s %*s %*s %17s %*s %16s", v8, a1, a2) != 3 || inet_addr(v8) != *(_DWORD *)(a3 + 4)) )
        ;
      fclose(v6);
    }
  }
}

//----- (0044BD64) --------------------------------------------------------
int __fastcall asp_time(char *a1)
{
  struct tm *v2; // $v0
  char v4[64]; // [sp+18h] [-4Ch] BYREF
  time_t v5; // [sp+58h] [-Ch] BYREF

  v5 = time(0);
  v2 = localtime(&v5);
  strftime(v4, 0x40u, "%F %H:%M:%S", v2);
  return sprintf(a1, "%s", v4);
}

//----- (0044BE00) --------------------------------------------------------
int __fastcall sub_44BE00(int a1)
{
  int v1; // $a2
  char v3[260]; // [sp+18h] [-104h] BYREF

  if ( *(_BYTE *)(a1 + 210100) == 2 )
  {
    strcpy(v3, "{\"list\":[]}");
    v1 = 11;
  }
  else
  {
    strcpy(v3, "{\"code\":0,\"error\":\"\",\"data\":{\"list\":[]}}");
    v1 = 40;
  }
  return httpd_cgi_ret(a1, v3, v1, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;

//----- (0044BF20) --------------------------------------------------------
int __fastcall sub_44BF20(int a1)
{
  return lans_data(a1);
}

//----- (0044BF3C) --------------------------------------------------------
int __fastcall ai_cgi_common_timeout(_DWORD *a1)
{
  _DWORD *v1; // $s0
  int v2; // $v0
  int v4; // $v0
  int result; // $v0
  const char *v6; // $v0
  char *v7; // $v1
  int v8; // $t1
  int v9; // $t0
  int v10; // $a3
  int v11; // $a2
  char v12[1024]; // [sp+18h] [-400h] BYREF

  v1 = a1 + 49152;
  v2 = a1[51393];
  if ( v2 < 5 && (v4 = v2 + 1, a1[52524]) )
  {
    a1[51393] = v4;
    a1[51387] = jiffies_get() + 1000;
    v1[2237] = a1;
    v1[2236] = ai_cgi_common_timeout;
    result = add_timer(a1 + 51385);
  }
  else
  {
    a1[51388] = httpd_keep_alive_timeout;
    a1[51387] = jiffies_get() + 5000;
    add_timer(a1 + 51385);
    result = a1[52524];
    if ( result )
    {
      v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      a1[52524] = 0;
      v7 = v12;
      do
      {
        v8 = *(_DWORD *)v6;
        v9 = *((_DWORD *)v6 + 1);
        v10 = *((_DWORD *)v6 + 2);
        v11 = *((_DWORD *)v6 + 3);
        v6 += 16;
        *(_DWORD *)v7 = v8;
        *((_DWORD *)v7 + 1) = v9;
        *((_DWORD *)v7 + 2) = v10;
        *((_DWORD *)v7 + 3) = v11;
        v7 += 16;
      }
      while ( v6 != "}" );
      *(_WORD *)v7 = *(_WORD *)v6;
      result = httpd_cgi_ret((int)a1, v12, 33, 4);
    }
  }
  return result;
}
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (0044C09C) --------------------------------------------------------
int __fastcall sub_44C09C(int a1)
{
  char v3[512]; // [sp+18h] [-200h] BYREF

  jhl_gl_reboot_timer(2000);
  strcpy(v3, "{\"code\":\"0\",\"msg\":\"ok\"}");
  return httpd_cgi_ret(a1, v3, 23, 4);
}

//----- (0044C130) --------------------------------------------------------
int __fastcall sub_44C130(int a1)
{
  char *v2; // $s0
  char *v3; // $s1
  char *v4; // $s5
  int v5; // $s0
  unsigned int v6; // $s1
  char *v7; // $s6
  unsigned int v8; // $s2
  const char *v9; // $v0
  unsigned int v10; // $v0
  int v11; // $s0
  unsigned int v12; // $v0
  const char *v14; // $v0
  unsigned int v15; // $v0
  char v16[10240]; // [sp+18h] [-2808h] BYREF
  int v17; // [sp+2818h] [-8h]
  int v18; // [sp+281Ch] [-4h] BYREF

  v17 = 0;
  v2 = httpd_get_parm(a1, "user");
  v3 = httpd_get_parm(a1, "password");
  v4 = httpd_get_parm(a1, "callback");
  if ( v2 )
  {
    if ( v3 )
      goto LABEL_3;
  }
  else
  {
    v2 = "";
    if ( v3 )
      goto LABEL_3;
  }
  v3 = "";
LABEL_3:
  v5 = httpd_cgi_user_check(v2, v3, &v18);
  if ( v4 )
  {
    v6 = snprintf(v16, 10240, "%s(", v4);
    if ( v6 >= 0x2800 )
      v6 = 10239;
    v7 = &v16[v6];
    v8 = 10240 - v6;
  }
  else
  {
    v8 = 10240;
    v7 = v16;
    v6 = 0;
  }
  if ( v5 <= 0 )
  {
    v14 = (const char *)get_sn();
    v15 = snprintf(v7, v8, "{\"login_flag\":\"0\",\"sn\":\"%s\"}", v14);
    if ( v15 >= v8 )
      v15 = 10239 - v6;
    v11 = v15 + v6;
  }
  else
  {
    v9 = (const char *)get_sn();
    v10 = snprintf(v7, v8, "{\"login_flag\":\"1\",\"sn\":\"%s\"}", v9);
    if ( v10 >= v8 )
      v10 = 10239 - v6;
    v11 = v10 + v6;
    *(_DWORD *)(a1 + 36) |= 0x1000u;
  }
  if ( v4 )
  {
    v12 = snprintf(&v16[v11], 10240 - v11, ")");
    if ( v12 >= 10240 - v11 )
      v12 = 10239 - v11;
    v11 += v12;
  }
  return httpd_cgi_ret(a1, v16, v11, 4);
}
// 6A81D8: using guessed type int get_sn(void);

//----- (0044C388) --------------------------------------------------------
int __fastcall sub_44C388(int a1)
{
  char *v1; // $v0
  char *v2; // $s0
  char *v3; // $fp
  char *v4; // $s1
  char *v5; // $s2
  char *v6; // $s3
  char *v7; // $s4
  char *v8; // $s5
  char *v9; // $s6
  char *v10; // $s7
  char *v11; // $v1
  char *v12; // $v0
  int v13; // $v0
  int v14; // $v0
  int v15; // $s1
  const char *v16; // $s3
  int v17; // $s2
  const char *v18; // $v0
  int v19; // $v0
  int v20; // $s1
  int v21; // $v0
  int v22; // $a2
  const char *v24; // $v0
  unsigned int v25; // $v0
  char *v26; // [sp+58h] [-140h]
  char v27[256]; // [sp+68h] [-130h] BYREF
  int v28; // [sp+168h] [-30h]
  char *v29; // [sp+16Ch] [-2Ch]
  char *v30; // [sp+170h] [-28h]
  char *v31; // [sp+174h] [-24h]
  char *v32; // [sp+178h] [-20h]
  char *v33; // [sp+17Ch] [-1Ch]
  const char *v34; // [sp+180h] [-18h]
  char *v35; // [sp+184h] [-14h]
  int v36; // [sp+188h] [-10h]
  int v37; // [sp+18Ch] [-Ch]
  char *v38; // [sp+190h] [-8h]

  memset(v27, 0, sizeof(v27));
  v36 = nvram_get_int("mqtt_ai_server_mode");
  _mem_malloc(204800, "wys_ai_state_data", 640);
  v2 = v1;
  if ( v1 )
  {
    strcpy(v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v1, "{\"code\":0,\"error", 16);
    v3 = (char *)jhl_nv_get_def("mqtt_ai_enable");
    v28 = (int)(v2 + 29);
    if ( !v3 )
      v3 = "";
    v28 = jhl_nv_get_def("wys_mqtt_ai_v3_addr");
    if ( !v28 )
      v28 = (int)"";
    v29 = (char *)jhl_nv_get_def("wys_mqtt_ai_v3_port");
    if ( !v29 )
      v29 = "";
    v30 = (char *)jhl_nv_get_def("mqtt_ai_ping_addr1");
    if ( !v30 )
      v30 = "";
    v31 = (char *)jhl_nv_get_def("mqtt_ai_ping_addr2");
    if ( !v31 )
      v31 = "";
    v32 = (char *)jhl_nv_get_def("wys_mqtt_ai_state");
    if ( !v32 )
      v32 = "";
    v33 = (char *)jhl_nv_get_def("wys_mqtt_ai_online");
    if ( !v33 )
      v33 = "";
    v34 = (const char *)nvram_get("mqtt_ai_sdwan_iface");
    if ( !v34 )
      v34 = "65535";
    v35 = (char *)jhl_nv_get_def("mqtt_ai_pversion");
    if ( !v35 )
      v35 = "";
    v4 = (char *)jhl_nv_get_def("mqtt_ai_login_count");
    if ( !v4 )
      v4 = "";
    v5 = (char *)jhl_nv_get_def("mqtt_ai_user_id");
    if ( !v5 )
      v5 = "";
    v6 = (char *)jhl_nv_get_def("mqtt_ai_user_name");
    if ( !v6 )
      v6 = "";
    v7 = (char *)jhl_nv_get_def("mqtt_ai_user_mobile");
    if ( !v7 )
      v7 = "";
    v8 = (char *)jhl_nv_get_def("mqtt_ai_scene_name");
    if ( !v8 )
      v8 = "";
    v9 = (char *)jhl_nv_get_def("mqtt_ai_client_mode");
    if ( !v9 )
      v9 = "";
    v10 = (char *)jhl_nv_get_def("mqtt_ai_main_mode");
    if ( !v10 )
      v10 = "";
    v37 = get_sn();
    v11 = (char *)jhl_nv_get_def("mqtt_ai_server_url");
    if ( !v11 )
      v11 = "";
    v38 = v11;
    v12 = (char *)jhl_nv_get_def("mqtt_sdwan_mode");
    if ( !v12 )
      v12 = "";
    v26 = v12;
    v13 = v28;
    v28 = 196608;
    v14 = snprintf(
            v2 + 29,
            204771,
            aEnSSrvAddrSSrv,
            v3,
            v13,
            v29,
            v30,
            v31,
            v32,
            v33,
            v34,
            v35,
            v4,
            v5,
            v6,
            v7,
            v8,
            v36,
            v9,
            v10,
            v37,
            v38,
            v26,
            0);
    if ( v14 >= (v28 | 0x1FE3) )
      v14 = v28 + 8162;
    v15 = v14 + 29 + get_wans_data(&v2[v14 + 29], 204800 - (v14 + 29));
    v16 = (const char *)jhl_nv_get_def("mqtt_ai_sdwan_link");
    v17 = 204800 - v15;
    if ( v16 )
    {
      v18 = (const char *)jhl_nv_get_def("mqtt_ai_sdwan_state");
      if ( v18 )
      {
LABEL_42:
        v19 = snprintf(&v2[v15], v17, ",\"sdwan_link\":[%s],\"sdwan_state\":\"%s\"", v16, v18);
        if ( v19 >= v17 )
          v19 = 204799 - v15;
        v20 = v19 + v15;
        v21 = snprintf(&v2[v20], 204800 - v20, "}}");
        if ( v21 >= 204800 - v20 )
          v22 = 204799 - v20;
        else
          v22 = v21;
        return httpd_cgi_ret(a1, v2, v22 + v20, 8);
      }
    }
    else
    {
      v18 = (const char *)jhl_nv_get_def("mqtt_ai_sdwan_state");
      v16 = "";
      if ( v18 )
        goto LABEL_42;
    }
    v18 = "";
    goto LABEL_42;
  }
  v24 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 204800);
  v25 = snprintf(v27, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
  if ( v25 >= 0x100 )
    v25 = 255;
  return httpd_cgi_ret(a1, v27, v25, 4);
}
// 44C424: variable 'v1' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81D8: using guessed type int get_sn(void);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0044CABC) --------------------------------------------------------
int __fastcall sub_44CABC(int a1)
{
  int v2; // $v0
  const char *v3; // $s0
  const char *v4; // $s5
  const char *v5; // $s1
  const char *v6; // $s2
  const char *v7; // $s3
  const char *v8; // $s4
  const char *v9; // $v0
  int v10; // $v0
  char *v11; // $v1
  char v13[1024]; // [sp+30h] [-400h] BYREF

  v2 = nvram_get("speed_test_iface");
  if ( v2 )
    v3 = (const char *)v2;
  else
    v3 = "";
  v4 = (const char *)nvram_get("speed_test_ai_proxy_up");
  if ( !v4 )
    v4 = "";
  v5 = (const char *)nvram_get("speed_test_ai_proxy_down");
  if ( !v5 )
    v5 = "";
  v6 = (const char *)nvram_get("speed_test_ai_proxy_state");
  if ( !v6 )
    v6 = "";
  v7 = (const char *)nvram_get("speed_test_result");
  if ( !v7 )
    v7 = "";
  v8 = (const char *)nvram_get("speed_test_upload");
  if ( !v8 )
  {
    v9 = (const char *)nvram_get("speed_test_download");
    v8 = "";
    if ( v9 )
      goto LABEL_13;
LABEL_16:
    v9 = "";
    goto LABEL_13;
  }
  v9 = (const char *)nvram_get("speed_test_download");
  if ( !v9 )
    goto LABEL_16;
LABEL_13:
  v10 = sprintf(
          v13,
          "{\"iface\":\"%s\",\"speed_up\":\"%s\",\"speed_down\":\"%s\",\"speed_state\":\"%s\",\"msg\":\"%s\"\"speed_test_"
          "average_up\":\"%s\",\"speed_test_average_up\":\"%s\"",
          v3,
          v4,
          v5,
          v6,
          v7,
          v8,
          v9);
  v11 = &v13[v10];
  *v11 = 125;
  v11[1] = 0;
  return httpd_cgi_ret(a1, v13, v10 + 1, 4);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (0044CCC4) --------------------------------------------------------
int __fastcall sub_44CCC4(int a1)
{
  char *v1; // $v0
  const char *v3; // $s0
  int v4; // $s2
  char *v5; // $v0
  char *v6; // $s0
  char *v8; // $s3
  char *v9; // $v0
  int v10; // $a2
  char *v11; // $v1
  int v12; // $v0
  _WORD *v13; // $s3
  char *v14; // $s2
  _WORD *v15; // $v0
  int v16; // $a2
  int v17; // $a1
  int v18; // $s2
  _WORD *v19; // $v0
  int v20; // $a2
  int v21; // $a1
  int v22; // $s2
  int v23; // $s2
  int v24; // $v0
  int v25; // $v0
  char v26[104]; // [sp+18h] [-68h] BYREF

  v1 = httpd_get_parm(a1, "type");
  if ( !v1 )
  {
    strcpy(v26, "{\"err\":\"type err\"}");
    return httpd_cgi_ret(a1, v26, 18, 4);
  }
  v3 = v1;
  v4 = 1;
  if ( strcmp(v1, "arp") )
  {
    v4 = 3;
    if ( strcmp(v3, "wan") )
    {
      v4 = 4;
      if ( strcmp(v3, "prog") )
      {
        v4 = 5;
        if ( strcmp(v3, "ddos") )
        {
          v4 = 6;
          if ( strcmp(v3, "pppoe") )
          {
            v4 = 7;
            if ( strcmp(v3, "web") )
            {
              v4 = 8;
              if ( strcmp(v3, "dhcp") )
              {
                v4 = 9;
                if ( strcmp(v3, (const char *)&off_644A94) )
                {
                  v4 = 10;
                  if ( strcmp(v3, "tg") )
                  {
                    v4 = 11;
                    if ( strcmp(v3, "mrzc") )
                    {
                      v4 = 12;
                      if ( strcmp(v3, "url") )
                      {
                        v4 = 14;
                        if ( strcmp(v3, "urlrd") )
                        {
                          v4 = 15;
                          if ( strcmp(v3, "pg2") )
                          {
                            v4 = 18;
                            if ( strcmp(v3, "homepage") )
                            {
                              if ( !strcmp(v3, "vpn") )
                              {
                                _mem_malloc(0x200000, "ai_device_log", 1236);
                                v6 = (char *)v12;
                                if ( !v12 )
                                  goto LABEL_4;
                                v13 = (_WORD *)(v12 + 1);
                                *(_WORD *)v12 = 91;
                                v14 = read_vpnmessage_file((char *)(v12 + 1), 0x1FFFFF);
                                v9 = &read_ipsec_file(&v14[(_DWORD)v13], 0x1FFFFF)[(_DWORD)v14];
                                v4 = 2;
                              }
                              else
                              {
                                v4 = 19;
                                if ( !strcmp(v3, "dns") )
                                  goto LABEL_3;
                                v4 = 20;
                                if ( !strcmp(v3, "wifidog") )
                                  goto LABEL_3;
                                v4 = 21;
                                if ( !strcmp(v3, "ac_server") )
                                  goto LABEL_3;
                                v4 = 23;
                                if ( !strcmp(v3, "wan_err") )
                                  goto LABEL_3;
                                v4 = 24;
                                if ( !strcmp(v3, "lan_pppoe_err") )
                                  goto LABEL_3;
                                if ( !strcmp(v3, "vpn_error") )
                                {
                                  _mem_malloc(0x200000, "ai_device_log", 1236);
                                  v6 = (char *)v25;
                                  if ( !v25 )
                                    goto LABEL_4;
                                  v13 = (_WORD *)(v25 + 1);
                                  *(_WORD *)v25 = 91;
                                  v9 = read_error_by_ipsec_file((char *)(v25 + 1), 0x1FFFFF);
                                  v4 = 26;
                                }
                                else if ( !strcmp(v3, "ipsec_debug") )
                                {
                                  _mem_malloc(0x200000, "ai_device_log", 1236);
                                  v6 = (char *)v24;
                                  if ( !v24 )
                                    goto LABEL_4;
                                  v13 = (_WORD *)(v24 + 1);
                                  *(_WORD *)v24 = 91;
                                  v9 = read_ipsec_file((char *)(v24 + 1), 0x1FFFFF);
                                  v4 = 28;
                                }
                                else if ( !strcmp(v3, "sys") )
                                {
                                  _mem_malloc(0x200000, "ai_device_log", 1236);
                                  v6 = (char *)v19;
                                  if ( !v19 )
                                    goto LABEL_4;
                                  *v19 = 91;
                                  v13 = (_WORD *)((char *)v19 + 1);
                                  if ( nvram_match_def("usblogd_en", "1") )
                                  {
                                    v22 = read_sysmessage_file("/var/log/messages2", v6 + 1, 0x1FFFFF);
                                    v21 = v22;
                                    v20 = 0x1FFFFF - v22;
                                  }
                                  else
                                  {
                                    v20 = 0x1FFFFF;
                                    v21 = 0;
                                    v22 = 0;
                                  }
                                  v23 = v22 + read_sysmessage_file("/var/log/messages.0", (char *)v13 + v21, v20);
                                  v9 = (char *)(v23
                                              + read_sysmessage_file(
                                                  "/var/log/messages",
                                                  (char *)v13 + v23,
                                                  0x1FFFFF - v23));
                                  v4 = -1;
                                }
                                else
                                {
                                  if ( strcmp(v3, "ovpn") )
                                  {
                                    v4 = 25;
                                    if ( strcmp(v3, "offline") )
                                    {
                                      v4 = 33;
                                      if ( strcmp(v3, "gongx") )
                                      {
                                        v4 = 34;
                                        if ( strcmp(v3, "voip") )
                                        {
                                          v4 = 35;
                                          if ( strcmp(v3, "av") )
                                          {
                                            if ( strcmp(v3, "ips") )
                                            {
                                              strcpy(v26, "{\"err\":\"id err\"}");
                                              return httpd_cgi_ret(a1, v26, 16, 4);
                                            }
                                            v4 = 36;
                                          }
                                        }
                                      }
                                    }
                                    goto LABEL_3;
                                  }
                                  _mem_malloc(0x200000, "ai_device_log", 1236);
                                  v6 = (char *)v15;
                                  if ( !v15 )
                                    goto LABEL_4;
                                  *v15 = 91;
                                  v13 = (_WORD *)((char *)v15 + 1);
                                  if ( nvram_match_def("usblogd_en", "1") )
                                  {
                                    v18 = read_ovpn_file("/var/log/openvpn2.log", v6 + 1, 0x1FFFFF);
                                    v17 = v18;
                                    v16 = 0x1FFFFF - v18;
                                  }
                                  else
                                  {
                                    v16 = 0x1FFFFF;
                                    v17 = 0;
                                    v18 = 0;
                                  }
                                  v9 = (char *)(v18 + read_ovpn_file("/var/log/openvpn.log", (char *)v13 + v17, v16));
                                  v4 = -2;
                                }
                              }
                              v11 = &v9[(_DWORD)v13];
                              if ( !v9 )
                              {
                                *v13 = 93;
                                v10 = 2;
                                return httpd_cgi_ret(a1, v6, v10, 8);
                              }
                              goto LABEL_37;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_3:
  _mem_malloc(0x200000, "ai_device_log", 1236);
  v6 = v5;
  if ( v5 )
  {
    v8 = v5 + 1;
    *(_WORD *)v5 = 91;
    v9 = (char *)read_log_data(v4, v5 + 1, 0x1FFFFF, 0);
    v10 = 2;
    if ( !v9 )
      goto LABEL_38;
    v11 = &v9[(_DWORD)v8];
LABEL_37:
    v8 = v11 - 1;
    *(v11 - 1) = 0;
    v10 = (int)(v9 + 1);
LABEL_38:
    *v8 = 93;
    v8[1] = 0;
    if ( v4 == 34 )
      *(_DWORD *)(a1 + 36) |= 0x8000u;
    return httpd_cgi_ret(a1, v6, v10, 8);
  }
LABEL_4:
  strcpy(v26, "{\"err\":\"mem_malloc err\"}");
  return httpd_cgi_ret(a1, v26, 24, 4);
}
// 44CD54: variable 'v5' is possibly undefined
// 44D300: variable 'v12' is possibly undefined
// 44D38C: variable 'v15' is possibly undefined
// 44D444: variable 'v19' is possibly undefined
// 44D524: variable 'v24' is possibly undefined
// 44D574: variable 'v25' is possibly undefined
// 644A94: using guessed type void *off_644A94;
// 6A8294: using guessed type int __fastcall read_ovpn_file(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A868C: using guessed type int __fastcall read_sysmessage_file(_DWORD, _DWORD, _DWORD);
// 6A88BC: using guessed type int __fastcall read_log_data(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044D5A8) --------------------------------------------------------
int __fastcall sub_44D5A8(int a1)
{
  int v2; // $v0
  char v4[4100]; // [sp+18h] [-1004h] BYREF

  v2 = miitool_data_buf(v4, 4096);
  return httpd_cgi_ret(a1, v4, v2, 4);
}
// 6A82D0: using guessed type int __fastcall miitool_data_buf(_DWORD, _DWORD);

//----- (0044D610) --------------------------------------------------------
int __fastcall sub_44D610(int a1)
{
  const char **v2; // $v1
  char **v3; // $v0
  char *v4; // $t0
  const char *v5; // $a3
  const char *v6; // $a2
  const char *v7; // $a1
  char *v8; // $v0
  char *v9; // $s3
  unsigned int v10; // $s0
  char *v11; // $a0
  unsigned int v12; // $s4
  unsigned int v13; // $v0
  int v14; // $s0
  unsigned int v15; // $v0
  int v16; // $s0
  unsigned int v17; // $v0
  int v18; // $s0
  unsigned int v19; // $v0
  int v20; // $a2
  char v22[10240]; // [sp+18h] [-282Ch] BYREF
  const char *v23[11]; // [sp+2818h] [-2Ch] BYREF

  memset(v22, 0, sizeof(v22));
  v2 = v23;
  v3 = off_66E300;
  do
  {
    v4 = *v3;
    v5 = v3[1];
    v6 = v3[2];
    v7 = v3[3];
    v3 += 4;
    *v2 = v4;
    v2[1] = v5;
    v2[2] = v6;
    v2[3] = v7;
    v2 += 4;
  }
  while ( v3 != (char **)&off_66E320 );
  *v2 = *v3;
  v8 = httpd_get_parm(a1, "callback");
  v9 = v8;
  if ( v8 )
  {
    v10 = snprintf(v22, 10240, "%s(", v8);
    if ( v10 >= 0x2800 )
      v10 = 10239;
    v11 = &v22[v10];
    v12 = 10240 - v10;
  }
  else
  {
    v12 = 10240;
    v11 = v22;
    v10 = 0;
  }
  v13 = snprintf(v11, v12, (char *)&word_642164);
  if ( v13 >= v12 )
    v13 = 10239 - v10;
  v14 = v13 + v10 + get_wan_nvarms(v23, &v22[v13 + v10], 10240 - (v13 + v10));
  v15 = snprintf(&v22[v14], 10240 - v14, "\"mitool_arr\":");
  if ( v15 >= 10240 - v14 )
    v15 = 10239 - v14;
  v16 = v15 + v14 + miitool_data_buf(&v22[v15 + v14], 10240 - (v15 + v14));
  v17 = snprintf(&v22[v16], 10240 - v16, "}");
  if ( v17 >= 10240 - v16 )
    v17 = 10239 - v16;
  v18 = v17 + v16;
  if ( v9 )
  {
    v19 = snprintf(&v22[v18], 10240 - v18, ")");
    v20 = v19 + v18;
    if ( v19 >= 10240 - v18 )
      v20 = 10239;
  }
  else
  {
    v20 = v18;
  }
  return httpd_cgi_ret(a1, v22, v20, 4);
}
// 642164: using guessed type __int16 word_642164;
// 66E300: using guessed type char *off_66E300[7];
// 66E320: using guessed type void *off_66E320;
// 6A82D0: using guessed type int __fastcall miitool_data_buf(_DWORD, _DWORD);

//----- (0044D870) --------------------------------------------------------
int __fastcall sub_44D870(int a1)
{
  char *v2; // $v0
  int v3; // $s1
  char *v4; // $s4
  int v5; // $fp
  int v6; // $s3
  int v7; // $v0
  char *v8; // $s6
  unsigned int v9; // $v0
  int v10; // $s0
  int v11; // $a0
  int v12; // $a1
  int v13; // $v0
  int v14; // $a2
  int v16; // $v0
  const char *v17; // $v0
  int v18; // $a2
  int v19; // $v0
  int v20; // $s3
  int v21; // $v0
  int v22; // $a2
  int v23; // $v0
  int v24; // $s0
  int v25[256]; // [sp+58h] [-410h] BYREF
  char *format; // [sp+458h] [-10h]
  char *v27; // [sp+45Ch] [-Ch]
  char *v28; // [sp+460h] [-8h]
  int v29; // [sp+464h] [-4h]

  v3 = sq_file_get_max_wan();
  _mem_malloc(102400, "ai_rate_flow", 1328);
  v4 = v2;
  if ( !v2 )
    return httpd_cgi_ret(a1, (char *)v25, 24, 4);
  *v2 = 91;
  v2[1] = 0;
  if ( v3 > 0 )
  {
    v27 = "a";
    v28 = "{\"wan_num\":\"all\",";
    v5 = 0;
    v6 = 1;
    format = "\"totup\":%llu,\"totqup\":%llu,\"totupk\":%lu,\"totqupk\":%lu,\"totdw\":%llu,\"totqdw\":%llu,\"totdwk\":%lu"
             ",\"totqdwk\":%lu,\"zup\":%lu,\"zdw\":%lu,\"qzup\":%lu,\"qzdw\":%lu},";
    while ( 1 )
    {
      if ( v5 <= 0 )
      {
        memset(v25, 0, sizeof(v25));
        v25[0] = 14;
        v25[3] = 4;
        LOWORD(v25[8]) = v5;
        v25[1] = 1024;
        if ( jianhl_order_opt_fun(v25, 1024, v22) )
        {
LABEL_30:
          v14 = 23;
          strcpy(v4, "{\"err\":\"get_opt false\"}");
          qmemcpy(v4, "{\"err\":\"get_opt ", 16);
          *((_DWORD *)v4 + 5) = 8200805;
          return httpd_cgi_ret(a1, v4, v14, 8);
        }
        v23 = snprintf(&v4[v6], 102400 - v6, v28);
        if ( v23 < 102400 - v6 )
          v24 = v23;
        else
          v24 = 102399 - v6;
        v20 = v24 + v6;
      }
      else
      {
        v7 = jhl_nvget("wan_ifname", v5 - 1);
        v8 = (char *)nvram_get(v7);
        if ( !v8 )
          v8 = "";
        v9 = jhl_get_wan_proto(v5 - 1) - 10;
        if ( !*v8 )
          goto LABEL_9;
        if ( v9 < 3 )
          goto LABEL_9;
        v16 = jhl_nvget("wan_down", v5 - 1);
        v17 = (const char *)nvram_get(v16);
        if ( v17 )
        {
          if ( !strcmp(v17, "1") )
            goto LABEL_9;
        }
        if ( jhl_iface_link_up_check(v8, v5 - 1) )
          goto LABEL_9;
        memset(v25, 0, sizeof(v25));
        v25[0] = 14;
        v25[3] = 4;
        LOWORD(v25[8]) = v5;
        v25[1] = 1024;
        if ( jianhl_order_opt_fun(v25, 1024, v18) )
          goto LABEL_30;
        v29 = 102400 - v6;
        v19 = snprintf(&v4[v6], 102400 - v6, v27 + 19392, v5 - 1);
        if ( v19 >= v29 )
          v19 = 102399 - v6;
        v20 = v19 + v6;
      }
      v21 = snprintf(&v4[v20], 102400 - v20, format);
      if ( v21 >= 102400 - v20 )
        v21 = 102399 - v20;
      v6 = v20 + v21;
LABEL_9:
      if ( v3 == ++v5 )
      {
        if ( v6 >= 4 )
          --v6;
        v10 = 102400 - v6;
        v11 = v6;
        v12 = 102400 - v6;
        goto LABEL_13;
      }
    }
  }
  v12 = 102399;
  v10 = 102399;
  v11 = 1;
  v6 = 1;
LABEL_13:
  v13 = snprintf(&v4[v11], v12, &byte_6445A0);
  if ( v13 >= v10 )
    v13 = 102399 - v6;
  v14 = v6 + v13;
  return httpd_cgi_ret(a1, v4, v14, 8);
}
// 44D8E4: variable 'v2' is possibly undefined
// 44DAE0: variable 'v18' is possibly undefined
// 44DCD8: variable 'v22' is possibly undefined
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (0044DD30) --------------------------------------------------------
int __fastcall sub_44DD30(int a1)
{
  char *v2; // $s2
  char *v3; // $s1
  char *v4; // $v0
  char *v5; // $s3
  const char *v6; // $v0
  unsigned int v7; // $s1
  int v8; // $s2
  unsigned int v9; // $v0
  const char *v11; // $v0
  char v12[1028]; // [sp+18h] [-404h] BYREF

  v2 = httpd_get_parm(a1, "nonce");
  v3 = httpd_get_parm(a1, "sn");
  v5 = httpd_get_parm(a1, "name");
  v4 = httpd_get_parm(a1, (char *)&off_649194);
  strcpy(v12, "{\"code\":0,\"error\":\"\",\"data\":{");
  if ( v3 && v2 && v5 && v4 )
  {
    v6 = (const char *)get_sn();
    if ( !strcmp(v3, v6) )
    {
      v11 = (const char *)nvram_get("ai_qrcode_nonce");
      if ( v11 && !strcmp(v11, v2) )
      {
        v7 = 995;
        v8 = 29;
      }
      else
      {
        nvram_set("ai_qrcode_nonce_state", "2");
        v7 = 968;
        strcpy(&v12[29], "\"msg\":\"session id mismatch\"");
        v8 = 56;
      }
    }
    else
    {
      nvram_set("ai_qrcode_nonce_state", "2");
      v7 = 965;
      strcpy(&v12[29], "\"msg\":\"Serial number mismatch\"");
      v8 = 59;
    }
  }
  else
  {
    nvram_set("ai_qrcode_nonce_state", "2");
    v7 = 970;
    strcpy(&v12[29], "\"msg\":\"Missing parameter\"");
    v8 = 54;
  }
  v9 = snprintf(&v12[v8], v7, "}}");
  if ( v9 >= v7 )
    v9 = 1023 - v8;
  return httpd_cgi_ret(a1, v12, v9 + v8, 4);
}
// 642164: using guessed type __int16 word_642164;
// 649194: using guessed type char *off_649194;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81D8: using guessed type int get_sn(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044E0C4) --------------------------------------------------------
int __fastcall sub_44E0C4(int a1)
{
  char *v2; // $v0
  char *v3; // $v0
  char *v4; // $s6
  char *v5; // $v0
  const char *v6; // $s4
  char *v7; // $v0
  char *v8; // $v0
  char *v9; // $v0
  const char *v10; // $s5
  int v11; // $v0
  unsigned int v12; // $s3
  unsigned int v13; // $s1
  unsigned int v14; // $v0
  int v15; // $s3
  unsigned int v16; // $v0
  int v18; // $s6
  int v19; // $v0
  int v20; // $v0
  const char *v21; // $v0
  int v22; // $v0
  const char *v23; // $v0
  int v24; // $v0
  int v25; // $a0
  int v26; // $v0
  int v27; // $v0
  const char *v28; // $v0
  int v29; // $v0
  int v30; // $v0
  int v31; // $v0
  int v32; // $v0
  int v33; // $v0
  int v34; // $v0
  char v35[1024]; // [sp+18h] [-470h] BYREF
  int v36[8]; // [sp+418h] [-70h] BYREF
  int v37[6]; // [sp+438h] [-50h] BYREF
  char *s; // [sp+450h] [-38h]
  char *v39; // [sp+454h] [-34h]
  char *v40; // [sp+458h] [-30h]
  char *v41; // [sp+45Ch] [-2Ch]
  int *v42; // [sp+460h] [-28h]
  char *v43; // [sp+464h] [-24h]
  char *v44; // [sp+468h] [-20h]
  char *v45; // [sp+46Ch] [-1Ch]
  char *v46; // [sp+470h] [-18h]
  char *v47; // [sp+474h] [-14h]
  char *v48; // [sp+478h] [-10h]
  char *v49; // [sp+47Ch] [-Ch]
  char *v50; // [sp+480h] [-8h]
  char *v51; // [sp+484h] [-4h]

  memset(v35, 0, sizeof(v35));
  v2 = httpd_get_parm(a1, "iface");
  v49 = "a";
  v4 = v2;
  v3 = httpd_get_parm(a1, "wan_proto");
  v50 = "a";
  v6 = v3;
  v5 = httpd_get_parm(a1, "wan_dns");
  v51 = "a";
  v48 = v5;
  v40 = httpd_get_parm(a1, "wan_ipaddr");
  v7 = httpd_get_parm(a1, "wan_netmask");
  v44 = "a";
  v43 = v7;
  v8 = httpd_get_parm(a1, "wan_getway");
  v45 = "a";
  v47 = v8;
  v39 = httpd_get_parm(a1, "ppp_username");
  v41 = httpd_get_parm(a1, "ppp_passwd");
  v9 = httpd_get_parm(a1, "callback");
  v42 = v36;
  v36[0] = 0;
  v36[1] = 0;
  v36[2] = 0;
  v36[3] = 0;
  v36[4] = 0;
  v36[5] = 0;
  v36[6] = 0;
  v36[7] = 0;
  v10 = v9;
  sprintf((char *)v36, "%d", 0);
  v11 = jhl_nvget("wan_new_proto", 0);
  nvram_unset(v11);
  if ( v10 )
  {
    v12 = snprintf(v35, 1024, "%s(", v10);
    if ( v12 >= 0x400 )
    {
      v12 = 1023;
      s = &v35[1023];
      v13 = 1;
    }
    else
    {
      s = &v35[v12];
      v13 = 1024 - v12;
    }
  }
  else
  {
    v13 = 1024;
    s = v35;
    v12 = 0;
  }
  if ( !v6 || (v46 = "a", strcmp(v6, "static")) && strcmp(v6, "dhcp") && strcmp(v6, "pppoe") )
  {
    v14 = snprintf(s, v13, "{\"ret\":\"0\",\"msg\":\"wan_proto error!\"}");
    goto LABEL_9;
  }
  if ( !v4 || !*v4 )
  {
    v14 = snprintf(s, v13, "{\"ret\":\"0\",\"msg\":\"iface error!\"}");
    goto LABEL_9;
  }
  v18 = J_atoi(v4);
  if ( !strcmp(v6, v46 + 17216) )
  {
    if ( !v40 && !v43 && !v47 && !v48 )
    {
      v14 = snprintf(s, v13, "{\"ret\":\"0\",\"msg\":\"static param error!\"}");
      goto LABEL_9;
    }
    if ( !strcmp(v50 + 6780, v40) )
    {
      v40 = 0;
    }
    else
    {
      v33 = jhl_nvget("wan_ipaddr", v18);
      nvram_set(v33, v40);
      v40 = (char *)1;
    }
    if ( strcmp(v51 + 6792, v43) )
    {
      v32 = jhl_nvget("wan_netmask", v18);
      nvram_set(v32, v43);
      v40 = (char *)1;
    }
    v43 = "a";
    if ( strcmp("wan_gateway", v47) )
    {
      v34 = jhl_nvget(v43 + 6804, v18);
      nvram_set(v34, v47);
      v40 = (char *)1;
    }
    if ( strcmp(v49 + 7028, v48) )
    {
      v26 = jhl_nvget("wan_dns", v18);
      nvram_set(v26, v48);
      v40 = (char *)1;
    }
  }
  else
  {
    v40 = 0;
  }
  v43 = "a";
  if ( !strcmp(v6, "pppoe") )
  {
    if ( !v39 && !v41 )
    {
      v14 = snprintf(s, v13, "{\"ret\":\"0\",\"msg\":\"pppoe param error!\"}");
      goto LABEL_9;
    }
    if ( strcmp(v44 + 6864, v39) )
    {
      v31 = jhl_nvget("ppp_username", v18);
      nvram_set(v31, v39);
      v40 = (char *)1;
    }
    if ( strcmp(v45 + 6880, v41) )
    {
      v30 = jhl_nvget("ppp_passwd", v18);
      nvram_set(v30, v41);
      v40 = (char *)1;
    }
  }
  v19 = jhl_nvget("wan_new_proto", v18);
  nvram_unset(v19);
  if ( (!strcmp(v6, v43 + 13636)
     || (v20 = jhl_nvget("wan_proto", v18), (v21 = (const char *)nvram_get(v20)) != 0) && !strcmp(v21, "pppoe"))
    && (v27 = jhl_nvget("ppp_demand", v18), (v28 = (const char *)nvram_get(v27)) != 0)
    && !strcmp(v28, "2") )
  {
    jhl_stop_wan(0);
    v29 = jhl_nvget("wan_proto", v18);
    nvram_set(v29, v6);
  }
  else
  {
    v22 = jhl_nvget("wan_proto", v18);
    v23 = (const char *)nvram_get(v22);
    if ( !v23 || strcmp(v23, v6) )
    {
      v24 = jhl_nvget("wan_new_proto", v18);
      nvram_set(v24, v6);
    }
    v37[0] = (int)"wan_conn";
    v37[1] = (int)"restart";
    v37[2] = (int)v42;
    v37[3] = (int)"wys_ai_wx_network_set_asp";
    v37[4] = 0;
    eval_nowait(v37, 0, 0, 0);
  }
  if ( v40 )
    jhl_parm_commit(v25);
  v14 = snprintf(s, v13, "{\"ret\":\"1\",\"msg\":\"ok!\"}");
LABEL_9:
  if ( v14 >= v13 )
    v14 = 1023 - v12;
  v15 = v14 + v12;
  if ( v10 )
  {
    v16 = snprintf(&v35[v15], 1024 - v15, ")");
    if ( v16 >= 1024 - v15 )
      v16 = 1023 - v15;
    v15 += v16;
  }
  return httpd_cgi_ret(a1, v35, v15, 4);
}
// 44E834: variable 'v25' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A87E8: using guessed type int __fastcall jhl_stop_wan(_DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0044E9D0) --------------------------------------------------------
int __fastcall ai_read_upgrade_state(int a1, int a2)
{
  int v3; // $v0
  int v5; // $v0
  int v6; // $s0
  int v7; // $v0
  int v8; // $s1
  void *v9; // $a0
  int v10; // $s1

  v3 = f_read_json("/tmp/mqtt_ai_check_upgrade_state");
  if ( !v3 )
    return -1;
  v6 = v3;
  v5 = custom_device_name();
  v7 = cJSON_GetObjectItem(v6, v5);
  if ( v7 )
  {
    v8 = cJSON_PrintUnformatted(v7);
    strlcpy(a1, v8, a2);
    v9 = (void *)v8;
    v10 = 0;
    free(v9);
  }
  else
  {
    v10 = -1;
  }
  cJSON_Delete(v6);
  return v10;
}
// 6A8454: using guessed type int __fastcall f_read_json(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A85D0: using guessed type int __fastcall cJSON_PrintUnformatted(_DWORD);
// 6A86E4: using guessed type int custom_device_name(void);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (0044EADC) --------------------------------------------------------
int __fastcall ai_check_upgrade_data(int a1)
{
  unsigned int v2; // $v0
  int v3; // $s2
  unsigned int v4; // $s1
  unsigned int v5; // $v0
  char v7[1024]; // [sp+18h] [-804h] BYREF
  int v8[257]; // [sp+418h] [-404h] BYREF

  memset(v7, 0, sizeof(v7));
  strcpy((char *)v8, "{\"code\":0,\"error\":\"\",\"data\":");
  if ( ai_read_upgrade_state((int)v7, 1024) )
  {
    v4 = 985;
    strcpy((char *)&v8[7], "{\"state\":0}");
    v3 = 39;
  }
  else
  {
    v2 = snprintf((char *)&v8[7], 996, "%s", v7);
    if ( v2 >= 0x3E4 )
      v2 = 995;
    v3 = v2 + 28;
    v4 = 1024 - (v2 + 28);
  }
  v5 = snprintf((char *)v8 + v3, v4, "}");
  if ( v5 >= v4 )
    v5 = 1023 - v3;
  return httpd_cgi_ret(a1, (char *)v8, v5 + v3, 4);
}

//----- (0044EC58) --------------------------------------------------------
int __fastcall get_duolanlist_data(char *a1, int a2)
{
  int v4; // $s0
  char *v5; // $s1
  int v6; // $s7
  int i; // $s2
  int v8; // $s3
  int v9; // $v0
  char *v10; // $a0
  int v11; // $s4
  int v12; // $v0
  char v14[8192]; // [sp+20h] [-2098h] BYREF
  char v15[136]; // [sp+2020h] [-98h] BYREF
  const char *v16[4]; // [sp+20A8h] [-10h] BYREF

  memset(v14, 0, sizeof(v14));
  jhl_parm_get("duolanlist", v14, 0x2000);
  v4 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v4 >= a2 )
    v4 = a2 - 1;
  v5 = v15;
  v6 = split_string(v14, 60, v15, 32);
  if ( v6 > 0 )
  {
    for ( i = 0; i != v6; ++i )
    {
      v8 = a2 - v4;
      if ( split_string(*(_DWORD *)v5, 124, v16, 2) >= 2 )
      {
        v9 = snprintf(&a1[v4], a2 - v4, "{\"ip\":\"%s\",\"mask\":\"%s\"},", v16[0], v16[1]);
        if ( v9 >= v8 )
          v9 = v8 - 1;
        v4 += v9;
      }
      v5 += 4;
    }
  }
  v10 = &a1[v4];
  if ( v4 > 0 && *(v10 - 1) == 44 )
    v10 = &a1[--v4];
  v11 = a2 - v4;
  *v10 = 0;
  v12 = snprintf(v10, v11, &byte_6445A0);
  if ( v12 >= v11 )
    v12 = v11 - 1;
  return v4 + v12;
}
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0044EE2C) --------------------------------------------------------
bool __fastcall ai_is_running(int a1)
{
  _BOOL4 result; // $v0
  const char *v3; // $v0
  bool v4; // dc

  if ( !f_exists(&dword_641714) )
    return 0;
  v3 = (const char *)nvram_get("mqtt_ai_enable");
  if ( !v3 )
    return 0;
  v4 = strcmp(v3, "1") != 0;
  result = 0;
  if ( !v4 )
  {
    if ( a1 )
      result = nvram_get_int("wys_mqtt_ai_online") != 0;
    else
      result = 1;
  }
  return result;
}
// 641714: using guessed type int dword_641714;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);

//----- (0044EEF4) --------------------------------------------------------
void __fastcall ai_unix_cgi_send(uint32_t a1, uint32_t a2, void *a3, int a4)
{
  uint32_t v4; // $s1
  uint32_t *v8; // $v0
  uint32_t *v10; // $s0

  v4 = a4 + 12;
  _mem_malloc(a4 + 12, "ai_unix_cgi_send", 162);
  if ( v8 )
  {
    v10 = v8;
    *v8 = htonl(a1);
    v10[2] = a2;
    v10[1] = htonl(v4);
    if ( a3 )
    {
      if ( a4 )
        memcpy(v10 + 3, a3, a4);
    }
    httpd_unix_send_to_ai(v10, v4);
    _mem_free(v10);
  }
}
// 44EF58: variable 'v8' is possibly undefined

//----- (0044F02C) --------------------------------------------------------
int __fastcall sub_44F02C(_DWORD *a1)
{
  char *v2; // $s0
  uint32_t v3; // $a0
  int v4; // $s2
  int result; // $v0
  char v6[256]; // [sp+18h] [-100h] BYREF

  v2 = httpd_get_parm((int)a1, "type");
  if ( ai_is_running(0) )
  {
    if ( v2 && (v3 = 10022, *v2 == 49) )
    {
      v4 = 10022;
    }
    else
    {
      v3 = 10021;
      v4 = 10021;
    }
    ai_unix_cgi_send(v3, a1[51354], 0, 0);
    a1[52524] = v4;
    a1[51393] = 0;
    ai_cgi_common_timeout(a1);
    result = 0;
  }
  else
  {
    strcpy(v6, "{\"code\":0,\"error\":\"\",\"data\":[]}");
    result = httpd_cgi_ret((int)a1, v6, 31, 4);
  }
  return result;
}

//----- (0044F178) --------------------------------------------------------
int __fastcall sub_44F178(int a1)
{
  char *v2; // $fp
  char *v3; // $s2
  char *v4; // $s4
  char *v5; // $s3
  char *v6; // $s5
  char *v7; // $v0
  char *v8; // $s7
  const char *v9; // $a3
  unsigned int v10; // $v0
  char *v11; // $v1
  const char *v12; // $v0
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  int v16; // $a1
  unsigned int v17; // $a2
  const char *v19; // $s6
  const char *v20; // $v0
  const char *v21; // $v0
  int v22; // $fp
  const char *v23; // $v0
  int v24; // $a0
  int v25; // $s2
  const char *v26; // $v0
  const char *v27; // $v0
  const char *v28; // $v0
  const char *v29; // $v0
  int v30; // $t0
  int v31; // $a3
  int v32; // $a2
  int v33; // $a1
  const char *v34; // $v0
  char v35[1024]; // [sp+20h] [-408h] BYREF
  char *v36; // [sp+420h] [-8h]

  memset(v35, 0, sizeof(v35));
  v2 = httpd_get_parm(a1, "en");
  v3 = httpd_get_parm(a1, "srv_addr");
  v4 = httpd_get_parm(a1, "srv_port");
  v5 = httpd_get_parm(a1, "iface");
  v6 = httpd_get_parm(a1, "alone");
  v36 = httpd_get_parm(a1, "mode");
  v8 = httpd_get_parm(a1, "ping_addr1");
  v7 = httpd_get_parm(a1, "ping_addr2");
  if ( v6 )
  {
    if ( J_atoi(v6) )
      v9 = "true";
    else
      v9 = "false";
    v10 = snprintf(v35, 1024, "{\"alone\":%s}", v9);
    if ( v10 >= 0x400 )
      v10 = 1023;
    ai_unix_cgi_send(0x272Au, 0xFFFFFFFF, v35, v10);
    v11 = v35;
    v12 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v13 = *(_DWORD *)v12;
      v14 = *((_DWORD *)v12 + 1);
      v15 = *((_DWORD *)v12 + 2);
      v16 = *((_DWORD *)v12 + 3);
      v12 += 16;
      *(_DWORD *)v11 = v13;
      *((_DWORD *)v11 + 1) = v14;
      *((_DWORD *)v11 + 2) = v15;
      *((_DWORD *)v11 + 3) = v16;
      v11 += 16;
    }
    while ( v12 != "}" );
    goto LABEL_8;
  }
  if ( v2 )
  {
    v19 = v7;
    if ( v3 )
    {
      v20 = (const char *)nvram_get("mqtt_ai_enable");
      if ( v20 && !strcmp(v20, v2) )
      {
        v21 = (const char *)nvram_get("wys_mqtt_ai_v3_addr");
        v22 = 0;
        if ( !v21 )
          goto LABEL_17;
      }
      else
      {
        nvram_set("mqtt_ai_enable", v2);
        v21 = (const char *)nvram_get("wys_mqtt_ai_v3_addr");
        v22 = 1;
        if ( !v21 )
          goto LABEL_17;
      }
      if ( !strcmp(v21, v3) )
      {
LABEL_18:
        v23 = (const char *)nvram_get("wys_mqtt_ai_v3_port");
        if ( !v23 || !v4 || strcmp(v23, v4) )
        {
          nvram_set("wys_mqtt_ai_v3_port", v4);
          v22 = 1;
        }
        v25 = v22;
        if ( v8 )
        {
          v26 = (const char *)nvram_get("mqtt_ai_ping_addr1");
          if ( v26 && !strcmp(v26, v8) )
          {
            v25 = v22;
          }
          else
          {
            nvram_set("mqtt_ai_ping_addr1", v8);
            v25 = 1;
          }
        }
        if ( v19 )
        {
          v27 = (const char *)nvram_get("mqtt_ai_ping_addr2");
          if ( !v27 || strcmp(v27, v19) )
          {
            nvram_set("mqtt_ai_ping_addr2", v19);
            v25 = 1;
          }
        }
        if ( !v36 || (v28 = (const char *)nvram_get("mqtt_sdwan_mode")) != 0 && !strcmp(v28, v36) )
        {
          if ( !v5 )
            goto LABEL_41;
        }
        else
        {
          nvram_set("mqtt_sdwan_mode", v36);
          v22 = 1;
          if ( !v5 )
          {
LABEL_46:
            v25 = 1;
LABEL_47:
            stop_mqtt_ai();
            start_mqtt_ai();
LABEL_42:
            if ( !v25 )
            {
LABEL_43:
              v11 = v35;
              v12 = "{\"code\":0,\"error\":\"\",\"data\":null}";
              do
              {
                v30 = *(_DWORD *)v12;
                v31 = *((_DWORD *)v12 + 1);
                v32 = *((_DWORD *)v12 + 2);
                v33 = *((_DWORD *)v12 + 3);
                v12 += 16;
                *(_DWORD *)v11 = v30;
                *((_DWORD *)v11 + 1) = v31;
                *((_DWORD *)v11 + 2) = v32;
                *((_DWORD *)v11 + 3) = v33;
                v11 += 16;
              }
              while ( v12 != "}" );
LABEL_8:
              v17 = 33;
              *(_WORD *)v11 = *(_WORD *)v12;
              return httpd_cgi_ret(a1, v35, v17, 4);
            }
LABEL_39:
            jhl_parm_commit(v24);
            goto LABEL_43;
          }
          v25 = 1;
        }
        v29 = (const char *)nvram_get("mqtt_ai_sdwan_iface");
        if ( !v29 || strcmp(v29, v5) )
        {
          if ( J_atoi(v5) != 0xFFFF )
          {
            nvram_set("mqtt_ai_sdwan_iface", v5);
            if ( !v22 )
              goto LABEL_39;
            goto LABEL_46;
          }
          if ( nvram_get("mqtt_ai_sdwan_iface") )
          {
            nvram_unset("mqtt_ai_sdwan_iface");
            if ( !v22 )
              goto LABEL_39;
            v25 = 1;
            goto LABEL_47;
          }
        }
LABEL_41:
        if ( !v22 )
          goto LABEL_42;
        goto LABEL_47;
      }
LABEL_17:
      nvram_set("wys_mqtt_ai_v3_addr", v3);
      v22 = 1;
      goto LABEL_18;
    }
  }
  v34 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not en or addr");
  v17 = snprintf(v35, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v34);
  if ( v17 >= 0x400 )
    v17 = 1023;
  return httpd_cgi_ret(a1, v35, v17, 4);
}
// 44F684: variable 'v24' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A8868: using guessed type int start_mqtt_ai(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8964: using guessed type int stop_mqtt_ai(void);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0044F800) --------------------------------------------------------
int __fastcall ai_wait_upgrade(unsigned int a1)
{
  int v1; // $s0
  _BOOL4 v2; // $s4
  int v3; // $v0
  int result; // $v0

  v1 = 600;
  v2 = a1 < time(0);
  while ( 1 )
  {
    sleep(1u);
    --v1;
    v3 = nvram_get_int("fw_upgrade_state");
    if ( v3 == 2 )
    {
      nvram_set("fw_upgrade_state", "0");
      return 0;
    }
    if ( v3 == 1 )
      break;
    if ( v3 == 3 && v2 )
    {
      system("echo \" upgrade timeout\" >/dev/console");
      system("killall fw_upgrade");
      nvram_set("fw_upgrade_state", "0");
      return 148;
    }
    result = 150;
    if ( !v1 )
      return result;
  }
  system("echo \" upgrade err\" >/dev/console");
  nvram_set("fw_upgrade_state", "0");
  return 149;
}
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0044F9AC) --------------------------------------------------------
int __fastcall sub_44F9AC(int a1)
{
  char *v1; // $v0
  const char *v3; // $s1
  int v4; // $s0
  int v5; // $v0
  int v6; // $s3
  int v7; // $v0
  int v8; // $a2
  int v9; // $a1
  int v10; // $a0
  const char *v11; // $v0
  unsigned int v12; // $s0
  int v14; // $a1
  int v15; // $a2
  int v16; // $a0
  const char *v17; // $v0
  const char *v18; // $v0
  unsigned int v19; // $v0
  int v20; // $a2
  const char *v21; // $v0
  int v22; // $v0
  int v23; // $s0
  int v24; // $v0
  int v25; // $s4
  int v26; // $v0
  time_t v27; // $v0
  int v28; // $v0
  int v29; // $a0
  int v30; // $a2
  const char *v31; // $s6
  const char *v32; // $v0
  char v33[1024]; // [sp+20h] [-508h] BYREF
  int v34[64]; // [sp+420h] [-108h] BYREF
  int v35; // [sp+520h] [-8h]

  v1 = httpd_get_parm(a1, "opt");
  if ( !v1 )
    goto LABEL_14;
  v3 = v1;
  v4 = strcmp(v1, "check");
  if ( v4 )
  {
    if ( !strcmp(v3, "upgrade") )
    {
      memset(v33, 0, sizeof(v33));
      if ( ai_read_upgrade_state((int)v33, 1024) < 0 )
      {
        v14 = *(unsigned __int8 *)(a1 + 210102);
        v15 = 1;
        v16 = 145;
      }
      else
      {
        v5 = cJSON_Parse(v33);
        v6 = v5;
        if ( v5 )
        {
          v7 = cJSON_GetObjectItem(v5, "state");
          if ( !v7 || !*(_DWORD *)(v7 + 20) )
          {
            v9 = *(unsigned __int8 *)(a1 + 210102);
            v10 = 146;
LABEL_9:
            v11 = (const char *)_GET_LANG_TEXT(v10, v9, v8);
            goto LABEL_10;
          }
          v22 = cJSON_GetObjectItem(v6, "url");
          v23 = v22;
          if ( v22 && *(_DWORD *)(v22 + 16) )
          {
            v24 = cJSON_GetObjectItem(v6, "md5");
            v25 = v24;
            if ( v24 && *(_DWORD *)(v24 + 16) )
            {
              v26 = nvram_get_int("fw_upgrade_state");
              if ( (unsigned int)(v26 - 3) < 2 )
              {
                v9 = *(unsigned __int8 *)(a1 + 210102);
                v10 = 21;
                goto LABEL_9;
              }
              if ( v26 == 2 )
              {
                v31 = *(const char **)(v23 + 16);
                v32 = (const char *)nvram_get("fw_upgrade_last");
                if ( v32 )
                {
                  if ( v31 && !strcmp(v32, v31) )
                  {
                    v9 = *(unsigned __int8 *)(a1 + 210102);
                    v10 = 147;
                    goto LABEL_9;
                  }
                }
              }
              system("killall fw_upgrade");
              nvram_set("fw_upgrade_state", "0");
              nvram_set("fw_upgrade_last", "");
              v34[0] = (int)"fw_upgrade";
              v34[1] = *(_DWORD *)(v23 + 16);
              v34[2] = *(_DWORD *)(v25 + 16);
              v34[3] = 0;
              eval_nowait(v34, 0, 0, 0);
              unregister_signal();
              exec_service("jhttpd_check-stop");
              prepare_upgrade();
              v27 = time(0);
              v28 = ai_wait_upgrade(v27 + 300);
              if ( !v28 )
              {
                jhl_gl_reboot_timer(3000);
                nvram_set("fw_upgrade_last", *(_DWORD *)(v23 + 16));
                v21 = (const char *)_GET_LANG_TEXT(22, *(unsigned __int8 *)(a1 + 210102), v20);
                v12 = snprintf((char *)v34, 256, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v21);
                if ( v12 < 0x100 )
                  goto LABEL_11;
                goto LABEL_23;
              }
              v35 = v28;
              register_signal();
              exec_service("jhttpd_check-start");
              upgrade_after(v29);
              v11 = (const char *)_GET_LANG_TEXT(v35, *(unsigned __int8 *)(a1 + 210102), v30);
            }
            else
            {
              v11 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not md5");
            }
          }
          else
          {
            v11 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not url");
          }
LABEL_10:
          v12 = snprintf((char *)v34, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
          if ( v12 < 0x100 )
          {
LABEL_11:
            cJSON_Delete(v6);
            return httpd_cgi_ret(a1, (char *)v34, v12, 4);
          }
LABEL_23:
          v12 = 255;
          goto LABEL_11;
        }
        v14 = *(unsigned __int8 *)(a1 + 210102);
        v15 = 2;
        v16 = 145;
      }
LABEL_15:
      v17 = (const char *)_GET_LANG_TEXT(v16, v14, v15);
      v12 = snprintf((char *)v34, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
      if ( v12 >= 0x100 )
        v12 = 255;
      return httpd_cgi_ret(a1, (char *)v34, v12, 4);
    }
LABEL_14:
    v14 = *(unsigned __int8 *)(a1 + 210102);
    v15 = (int)"not opt";
    v16 = 12;
    goto LABEL_15;
  }
  if ( !ai_is_running(1) )
    return ai_check_upgrade_data(a1);
  v18 = (const char *)custom_device_name();
  v19 = snprintf((char *)v34, 256, "[{\"model\":\"%s\",\"model_x\":\"%s\",\"sversion\":\"%s\"}]", v18, "FBM-1008V", "");
  if ( v19 >= 0x100 )
    v19 = 255;
  ai_unix_cgi_send(0x2727u, *(_DWORD *)(a1 + 205416), v34, v19);
  *(_DWORD *)(a1 + 205572) = 0;
  *(_DWORD *)(a1 + 210096) = 10023;
  ai_cgi_common_timeout((_DWORD *)a1);
  return v4;
}
// 44FAE0: variable 'v8' is possibly undefined
// 44FCFC: variable 'v20' is possibly undefined
// 44FF58: variable 'v29' is possibly undefined
// 44FF7C: variable 'v30' is possibly undefined
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81C0: using guessed type int prepare_upgrade(void);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A837C: using guessed type int __fastcall upgrade_after(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A86E4: using guessed type int custom_device_name(void);
// 6A8780: using guessed type int __fastcall cJSON_Parse(_DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00450054) --------------------------------------------------------
int check_net()
{
  int v0; // $v0
  unsigned int v1; // $s0
  int v2; // $s1
  int *v4; // $v0
  char *v5; // $v0
  struct sockaddr *v6; // $v0
  char *v7; // $a2
  int *v8; // $s1
  int v9; // $a0
  int v10; // $v0
  int v11; // $v0
  fd_set v12; // [sp+20h] [-11Ch] BYREF
  char v13[128]; // [sp+A0h] [-9Ch] BYREF
  struct sockaddr v14; // [sp+120h] [-1Ch] BYREF
  struct timeval timeout; // [sp+130h] [-Ch] BYREF

  v0 = socket(2, 2, 0);
  v1 = v0;
  if ( v0 >= 0 )
  {
    if ( setnonblocking(v0) >= 0 )
    {
      v14.sa_family = 2;
      *(_WORD *)v14.sa_data = htons(0x35u);
      *(_DWORD *)&v14.sa_data[6] = 0;
      *(_DWORD *)&v14.sa_data[10] = 0;
      *(_DWORD *)&v14.sa_data[2] = inet_addr("114.114.114.114");
      if ( connect(v1, &v14, 0x10u) )
      {
        if ( *_errno_location() != 150 )
        {
          v2 = 0;
          v4 = _errno_location();
          v5 = strerror(*v4);
          printf("connect error :%s\n", v5);
          goto LABEL_5;
        }
        timeout.tv_sec = 2;
        timeout.tv_usec = 0;
        v6 = (struct sockaddr *)v13;
        do
        {
          v6 = (struct sockaddr *)((char *)v6 + 4);
          *(_DWORD *)&v6[-1].sa_data[10] = 0;
        }
        while ( v6 != &v14 );
        v7 = (char *)&v12;
        do
        {
          v7 += 4;
          *((_DWORD *)v7 - 1) = 0;
        }
        while ( v7 != v13 );
        v8 = &v12.__fds_bits[v1 >> 5];
        v9 = 1 << (v1 & 0x1F);
        v10 = *v8 | v9;
        v8[32] |= v9;
        *v8 = v10;
        if ( select(v1 + 1, &v12, (fd_set *)v7, 0, &timeout) == 1 && (((unsigned int)v8[32] >> (v1 & 0x1F)) & 1) != 0 )
        {
          v11 = fcntl(v1, 3, 0);
          fcntl(v1, 4, v11 & 0xFFFFFF7F);
          v2 = 1;
          goto LABEL_5;
        }
      }
    }
    v2 = 0;
LABEL_5:
    close(v1);
    return v2;
  }
  perror("socket");
  v2 = 0;
  if ( v1 != -1 )
    goto LABEL_5;
  return 0;
}

//----- (004502D8) --------------------------------------------------------
int get_nonce()
{
  const char *v0; // $v0
  const char *v1; // $s0
  bool v2; // dc
  int result; // $v0
  int v4; // $s0

  v0 = (const char *)nvram_get("ai_qrcode_nonce");
  if ( !v0 || (v1 = v0, v2 = strlen(v0) < 5, result = (int)v1, v2) )
  {
    v4 = GenerateStr();
    nvram_set("ai_qrcode_nonce", v4);
    result = v4;
  }
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84F4: using guessed type int GenerateStr(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00450388) --------------------------------------------------------
int __fastcall sub_450388(int a1)
{
  time_t v1; // $v0
  const char *v2; // $v0
  const char *v3; // $v0
  size_t v4; // $v0
  const char **v5; // $fp
  int v6; // $s7
  unsigned int v7; // $v0
  size_t v8; // $v0
  const char *v9; // $s1
  int v10; // $v0
  unsigned int v11; // $v0
  int v12; // $s0
  unsigned int v13; // $s2
  char v15[1024]; // [sp+30h] [-650h] BYREF
  char v16[256]; // [sp+430h] [-250h] BYREF
  char v17[128]; // [sp+530h] [-150h] BYREF
  char v18[64]; // [sp+5B0h] [-D0h] BYREF
  char v19[64]; // [sp+5F0h] [-90h] BYREF
  int v20[8]; // [sp+630h] [-50h] BYREF
  int v21[5]; // [sp+650h] [-30h] BYREF
  char *v22; // [sp+664h] [-1Ch] BYREF
  const char *v23; // [sp+668h] [-18h]
  char *v24; // [sp+66Ch] [-14h]
  _BOOL4 v25; // [sp+670h] [-10h]
  char *v26; // [sp+674h] [-Ch]
  const char *v27; // [sp+678h] [-8h]
  char *v28; // [sp+67Ch] [-4h]

  v28 = v19;
  memset(v19, 0, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  v26 = v17;
  memset(v17, 0, sizeof(v17));
  v20[0] = 0;
  v20[1] = 0;
  v20[2] = 0;
  v20[3] = 0;
  v20[4] = 0;
  v20[5] = 0;
  v20[6] = 0;
  v20[7] = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  memset(v16, 0, sizeof(v16));
  v21[0] = 0;
  v21[1] = 0;
  v21[2] = 0;
  v21[3] = 0;
  v21[4] = 0;
  v25 = ai_is_running(1);
  v1 = time(0);
  snprintf(v19, 64, "%u", v1);
  v2 = (const char *)get_sn();
  snprintf(v18, 64, "%s", v2);
  v27 = (const char *)v20;
  v3 = (const char *)get_nonce();
  snprintf((char *)v20, 32, "%s", v3);
  v22 = v19;
  v23 = (const char *)v20;
  v24 = v18;
  params_sort(&v22, 3);
  snprintf(v16, 256, "%s%s%s", v22, v23, v24);
  v4 = strlen(v16);
  SHA1(v16, v4, v21);
  v5 = (const char **)v21;
  v6 = 0;
  do
  {
    v7 = snprintf(&v16[v6], 256 - v6, "%02x", *(unsigned __int8 *)v5);
    v5 = (const char **)((char *)v5 + 1);
    if ( v7 >= 256 - v6 )
      v7 = 255 - v6;
    v6 += v7;
  }
  while ( &v22 != (char **)v5 );
  v8 = strlen(v18);
  v9 = v26;
  base64_encode(v18, v26, v8);
  strcpy(v15, "{\"code\":0,\"error\":\"\",\"data\":{");
  v10 = check_net();
  v11 = snprintf(
          &v15[29],
          995,
          "\"sn\":\"%s\",\"timestamp\":\"%s\",\"nonce\":\"%s\",\"signature\":\"%s\",\"network\":%d,\"ai_en\":%d",
          v9,
          v28,
          v27,
          v16,
          v10,
          v25);
  v12 = v11 + 29;
  if ( v11 >= 0x3E3 )
    v12 = 1023;
  v13 = snprintf(&v15[v12], 1024 - v12, "}}");
  if ( v13 >= 1024 - v12 )
    v13 = 1023 - v12;
  nvram_set("ai_qrcode_nonce_state", "0");
  return httpd_cgi_ret(a1, v15, v13 + v12, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81D8: using guessed type int get_sn(void);
// 6A8364: using guessed type int __fastcall SHA1(_DWORD, _DWORD, _DWORD);
// 6A8474: using guessed type int __fastcall base64_encode(_DWORD, _DWORD, _DWORD);
// 6A87B8: using guessed type int __fastcall params_sort(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00450784) --------------------------------------------------------
int __fastcall jhl_link_uptime_s(int a1, int a2)
{
  int v3; // $v0
  int v4; // $v0
  const char *v5; // $s0
  int v6; // $v0
  struct sysinfo v8[4]; // [sp+18h] [-13Ch] BYREF

  v3 = jhl_nvget("wan_uptime", a1);
  v4 = nvram_get(v3);
  if ( !a2 )
    return 0;
  v5 = (const char *)v4;
  if ( !v4 )
    return 0;
  sysinfo(v8);
  v6 = atol(v5);
  return v8[0].uptime - v6;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (00450844) --------------------------------------------------------
int __fastcall sub_450844(int a1)
{
  char *v1; // $v0
  int v2; // $s2
  char *v3; // $s4
  int v4; // $s1
  unsigned int v5; // $s0
  int v6; // $s5
  int v7; // $v0
  const char *v8; // $fp
  int v9; // $v0
  int v10; // $s7
  int v11; // $fp
  int v12; // $s0
  int v13; // $a0
  int v14; // $a1
  int v15; // $v0
  int v16; // $a2
  int result; // $v0
  int v18; // $v0
  const char *v19; // $v0
  int v20; // $v0
  int v21; // $v0
  int v22; // $v0
  int v23; // $v0
  int v24; // $v0
  int v25; // $s7
  int v26; // $v0
  int v27; // $s5
  const char *v28; // $a3
  int v29; // $v0
  int v30; // $s5
  int v31; // $v0
  int v32; // $s5
  int v33; // $v0
  int v34; // $s5
  const char *v35; // $a3
  int v36; // $v0
  int v37; // $v0
  int v38; // $s7
  const char *v39; // $v0
  int v40; // $s5
  int v41; // $v0
  int v42; // $v0
  int v43; // $s7
  const char *v44; // $v0
  int v45; // $s5
  int v46; // $v0
  int v47; // $v0
  int v48; // $s7
  const char *v49; // $v0
  int v50; // $s5
  int v51; // $v0
  int v52; // $v0
  int v53; // $s7
  const char *v54; // $v0
  int v55; // $s5
  int v56; // $v0
  int v57; // $v0
  int v58; // $s7
  char *v59; // $v0
  int v60; // $v0
  const char *v61; // $v0
  const char *v62; // $s7
  const char *v63; // $v0
  const char *v64; // $s7
  int v65; // $v0
  const char *v66; // $v0
  int v67; // $v0
  int v68; // $a3
  int v69; // $v0
  int v70; // $v0
  const char *v71; // $s7
  const char *v72; // $v0
  int v73; // $v0
  int v74; // $v0
  const char *v75; // $s7
  const char *v76; // $v0
  int v77; // $v0
  int v78; // $v0
  const char *v79; // $v0
  int v80; // $v0
  int v81; // $v0
  const char *v82; // [sp+10h] [-718h]
  char v83[1024]; // [sp+20h] [-708h] BYREF
  char v84[512]; // [sp+420h] [-308h] BYREF
  __int16 v85[64]; // [sp+620h] [-108h] BYREF
  const char *v86[2]; // [sp+6A0h] [-88h] BYREF
  const char *v87; // [sp+6A8h] [-80h]
  int v88; // [sp+6ACh] [-7Ch]
  char v89[36]; // [sp+6DCh] [-4Ch] BYREF
  const char *v90; // [sp+700h] [-28h]
  const char *v91; // [sp+704h] [-24h]
  char *v92; // [sp+708h] [-20h]
  const char *v93; // [sp+70Ch] [-1Ch]
  const char **v94; // [sp+710h] [-18h]
  char *v95; // [sp+714h] [-14h]
  int v96; // [sp+718h] [-10h]
  const char *v97; // [sp+71Ch] [-Ch]
  char *v98; // [sp+720h] [-8h]

  memset(v83, 0, sizeof(v83));
  v2 = sq_file_get_max_wan();
  _mem_malloc(0x200000, "ai_wan_info", 852);
  v3 = v1;
  if ( v1 )
  {
    *v1 = 91;
    v1[1] = 0;
    if ( v2 <= 0 )
    {
      v14 = 0x1FFFFF;
      v12 = 0x1FFFFF;
      v13 = 1;
      v6 = 1;
    }
    else
    {
      v90 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
      v92 = "a";
      v4 = 1;
      v91 = "wan_ipaddr";
      v5 = 0;
      v6 = 1;
      v93 = "0.0.0.0";
      do
      {
        v7 = jhl_nvget("wan_ifname", v5);
        v8 = (const char *)nvram_get(v7);
        if ( !v8 )
          v8 = v90 - 1556;
        v9 = jhl_get_wan_proto(v5);
        v10 = v9;
        if ( !*v8 )
          break;
        if ( (unsigned int)(v9 - 10) < 3
          || (v18 = jhl_nvget("wan_down", v5), (v19 = (const char *)nvram_get(v18)) != 0) && !strcmp(v19, "1")
          || jhl_iface_link_up_check(v8, v5) )
        {
          v11 = v4;
        }
        else
        {
          v20 = jhl_nvget(v91, v5);
          v95 = (char *)nvram_get(v20);
          if ( !v95 )
            v95 = (char *)v93;
          v21 = jhl_nvget(v92 + 6792, v5);
          v97 = (const char *)nvram_get(v21);
          if ( !v97 )
            v97 = v93;
          v22 = jhl_nvget("wan_gateway", v5);
          v96 = nvram_get(v22);
          if ( !v96 )
            v96 = (int)v93;
          if ( v10 == 4 )
          {
            if ( (v78 = jhl_nvget("ppp_demand_run", v5), (v79 = (const char *)nvram_get(v78)) != 0) && !strcmp(v79, "1")
              || (v94 = (const char **)jhl_check_wanup(v5)) == 0 )
            {
              v94 = 0;
              v96 = (int)v93;
              v97 = v93;
              v95 = (char *)v93;
            }
            else
            {
              v80 = jhl_nvget("ppp_get_ip", v5);
              v95 = (char *)nvram_get(v80);
              v81 = jhl_nvget("ppp_gw", v5);
              v96 = nvram_get(v81);
              if ( !v96 )
                v96 = (int)v95;
              v97 = "255.255.255.255";
            }
          }
          else
          {
            v94 = (const char **)jhl_check_wanup(v5);
            if ( !v94 )
            {
              v96 = (int)v93;
              v97 = v93;
              v95 = (char *)v93;
            }
          }
          v98 = v89;
          sprintf(v89, "WAN%d", v4);
          v82 = v98;
          v98 = (char *)(0x200000 - v6);
          v23 = snprintf(&v3[v6], 0x200000 - v6, "{\"iface\":%d,\"wan_name\":\"%s\",", v5, v82);
          v11 = v4;
          if ( v23 >= (int)v98 )
            v23 = 0x1FFFFF - v6;
          v25 = v23 + v6;
          v24 = jhl_link_uptime_s(v5, (int)v94);
          v98 = (char *)(0x200000 - v25);
          v26 = snprintf(&v3[v25], 0x200000 - v25, "\"connect_time\":\"%ld\",", v24);
          if ( v26 >= (int)v98 )
            v26 = 0x1FFFFF - v25;
          v27 = v26 + v25;
          v28 = v95;
          v95 = (char *)(0x200000 - (v26 + v25));
          v29 = snprintf(&v3[v26 + v25], (int)v95, "\"wan_ip\":\"%s\",", v28);
          if ( v29 >= (int)v95 )
            v29 = 0x1FFFFF - v27;
          v30 = v29 + v27;
          v95 = (char *)(0x200000 - v30);
          v31 = snprintf(&v3[v30], 0x200000 - v30, "\"wan_mask\":\"%s\",", v97);
          if ( v31 >= (int)v95 )
            v31 = 0x1FFFFF - v30;
          v32 = v31 + v30;
          v95 = (char *)(0x200000 - v32);
          v33 = snprintf(&v3[v32], 0x200000 - v32, "\"wan_gateway\":\"%s\",", (const char *)v96);
          if ( v33 >= (int)v95 )
            v33 = 0x1FFFFF - v32;
          v95 = (char *)v85;
          v34 = v33 + v32;
          memset(v85, 0, sizeof(v85));
          v35 = (const char *)v85;
          if ( v94 )
          {
            v94 = (const char **)v95;
            asp_jhl_dns(v95, v5);
            v35 = (const char *)v94;
          }
          else
          {
            v85[0] = 23899;
            v95[2] = 0;
          }
          v94 = (const char **)(0x200000 - v34);
          v36 = snprintf(&v3[v34], 0x200000 - v34, "\"dns\":%s,", v35);
          if ( v36 >= (int)v94 )
            v36 = 0x1FFFFF - v34;
          v38 = v36 + v34;
          v37 = jhl_nvget("mac_wan", v5);
          v39 = (const char *)nvram_get(v37);
          v40 = 0x200000 - v38;
          if ( !v39 )
            v39 = v90 - 1556;
          v41 = snprintf(&v3[v38], v40, "\"wan_mac\":\"%s\",", v39);
          if ( v41 >= v40 )
            v41 = 0x1FFFFF - v38;
          v43 = v41 + v38;
          v42 = jhl_nvget("wan_proto", v5);
          v44 = (const char *)nvram_get(v42);
          v45 = 0x200000 - v43;
          if ( !v44 )
            v44 = v90 - 1556;
          v46 = snprintf(&v3[v43], v45, "\"connect_ype\":\"%s\",", v44);
          if ( v46 >= v45 )
            v46 = 0x1FFFFF - v43;
          v48 = v46 + v43;
          v47 = jhl_nvget("ppp_username", v5);
          v49 = (const char *)nvram_get(v47);
          v50 = 0x200000 - v48;
          if ( !v49 )
            v49 = v90 - 1556;
          v51 = snprintf(&v3[v48], v50, "\"pppoe_username\":\"%s\",", v49);
          if ( v51 >= v50 )
            v51 = 0x1FFFFF - v48;
          v53 = v51 + v48;
          v52 = jhl_nvget("ppp_passwd", v5);
          v54 = (const char *)nvram_get(v52);
          v55 = 0x200000 - v53;
          if ( !v54 )
            v54 = v90 - 1556;
          v56 = snprintf(&v3[v53], v55, "\"pppoe_password\":\"%s\",", v54);
          if ( v56 >= v55 )
            v56 = 0x1FFFFF - v53;
          v58 = v56 + v53;
          v57 = jhl_nvget("mr_parm", v5);
          v59 = (char *)nvram_get(v57);
          if ( !v59 || !*v59 )
            v59 = " ";
          strlcpy(v84, v59, 512);
          v94 = v86;
          v60 = split_string(v84, 60, v86, 14);
          mr_parm_default(v60, v94, v5);
          v95 = (char *)(0x200000 - v58);
          v96 = 0x200000;
          v61 = (const char *)snprintf(&v3[v58], 0x200000 - v58, "\"zc_en\":\"%s\",", v86[0]);
          if ( (int)v61 >= (int)v95 )
            v61 = (const char *)(v96 - 1 - v58);
          v62 = &v61[v58];
          v95 = (char *)(0x200000 - (_DWORD)v62);
          v96 = 0x200000;
          v63 = (const char *)snprintf((char *)&v62[(_DWORD)v3], 0x200000 - (_DWORD)v62, "\"jh_en\":\"%s\",", v87);
          if ( (int)v63 >= (int)v95 )
            v63 = (const char *)(v96 - 1 - (_DWORD)v62);
          v64 = &v62[(_DWORD)v63];
          if ( v5 < 0x65 )
            v65 = jhl_nvget("qos_dk", v5);
          else
            v65 = jhl_vpnget("vpnqos_dk", v5 - 101);
          v66 = (const char *)nvram_get(v65);
          if ( !v66 || !*v66 )
            v66 = "on|hi|0|0|75|85|1000|2000|5|10|4|1500|8|16";
          strlcpy(v84, v66, 512);
          split_string(v84, 124, v94, 14);
          v94 = (const char **)J_atoi(v87);
          v67 = J_atoi(v88);
          v68 = (int)v94;
          v94 = (const char **)(0x200000 - (_DWORD)v64);
          v69 = snprintf((char *)&v64[(_DWORD)v3], 0x200000 - (_DWORD)v64, "\"qos_dk\":\"%lu|%lu\",", v68, v67);
          if ( v69 >= (int)v94 )
            v69 = 0x1FFFFF - (_DWORD)v64;
          v71 = &v64[v69];
          v70 = jhl_nvget("mtu_enable", v5);
          v72 = (const char *)nvram_get(v70);
          if ( !v72 )
            v72 = v90 - 1556;
          v73 = snprintf((char *)&v71[(_DWORD)v3], 0x200000 - (_DWORD)v71, "\"mtu_enable\":\"%s\",", v72);
          if ( v73 >= 0x200000 - (int)v71 )
            v73 = 0x1FFFFF - (_DWORD)v71;
          v75 = &v71[v73];
          v74 = jhl_nvget("wan_mtu", v5);
          v76 = (const char *)nvram_get(v74);
          if ( !v76 )
            v76 = v90 - 1556;
          v77 = snprintf((char *)&v75[(_DWORD)v3], 0x200000 - (_DWORD)v75, "\"mtu\":\"%s\"},", v76);
          if ( v77 >= 0x200000 - (int)v75 )
            v77 = 0x1FFFFF - (_DWORD)v75;
          v6 = (int)&v75[v77];
        }
        ++v5;
        ++v4;
      }
      while ( v11 < v2 );
      if ( v6 >= 4 )
        --v6;
      v12 = 0x200000 - v6;
      v13 = v6;
      v14 = 0x200000 - v6;
    }
    v15 = snprintf(&v3[v13], v14, &byte_6445A0);
    if ( v15 >= v12 )
      v16 = 0x1FFFFF - v6;
    else
      v16 = v15;
    result = httpd_cgi_ret(a1, v3, v6 + v16, 8);
  }
  else
  {
    strcpy(v83, "[]");
    result = httpd_cgi_ret(a1, v83, 2, 4);
  }
  return result;
}
// 4508DC: variable 'v1' is possibly undefined
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8270: using guessed type int __fastcall mr_parm_default(_DWORD, _DWORD, _DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004514F4) --------------------------------------------------------
int get_speed_test_iface()
{
  int v0; // $s2
  int v1; // $s0
  int result; // $v0
  int v3; // $v0
  char *v4; // $s7
  int v5; // $v0
  int v6; // $fp
  int v7; // $v0
  const char *v8; // $v0
  int v9; // $a1
  int v10; // $v0
  int v11; // $v0
  const char *v12; // $v0
  int v13; // $v0

  v0 = sq_file_get_max_wan();
  if ( v0 > 0 )
  {
    v1 = 0;
    while ( 1 )
    {
      v3 = jhl_nvget("wan_ifname", v1);
      v4 = (char *)nvram_get(v3);
      if ( !v4 )
        v4 = "";
      v5 = jhl_get_wan_proto(v1);
      v6 = v5;
      if ( !*v4 )
        break;
      if ( (unsigned int)(v5 - 10) < 3
        || (v7 = jhl_nvget("wan_down", v1), (v8 = (const char *)nvram_get(v7)) != 0) && !strcmp(v8, "1")
        || jhl_iface_link_up_check(v4, v1) )
      {
        ++v1;
      }
      else
      {
        if ( v6 != 4
          || (v11 = jhl_nvget("ppp_demand_run", v1), (v12 = (const char *)nvram_get(v11)) == 0)
          || (v13 = strcmp(v12, "1"), v9 = 0, v13) )
        {
          v9 = jhl_check_wanup(v1);
        }
        v10 = jhl_link_uptime_s(v1++, v9);
        if ( v10 >= 2 )
          return v1 - 1;
      }
      result = -1;
      if ( v0 == v1 )
        return result;
    }
  }
  return -1;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (00451730) --------------------------------------------------------
int __fastcall speed_test_info_get(char *a1, int a2)
{
  unsigned int v4; // $v0
  int v5; // $s6
  char *v6; // $s1
  int v7; // $v0
  int v8; // $v1
  char *v9; // $s2
  int result; // $v0

  nvram_get_int("speed_test_upload");
  nvram_get_int("speed_test_download");
  v4 = nvram_get_int("speed_test_state") - 1;
  v5 = -1;
  if ( v4 < 5 )
    v5 = dword_6454D0[v4];
  v6 = (char *)nvram_get("speed_test_isp");
  if ( !v6 )
    v6 = "";
  v7 = nvram_get("speed_test_server");
  v9 = (char *)v7;
  if ( !v7 )
    v9 = "";
  result = snprintf(a1, a2, aCode0MsgOkData, "router", v6, v9, v7, v8, v7, v8, v5);
  if ( result >= a2 )
    result = a2 - 1;
  return result;
}
// 451904: variable 'v8' is possibly undefined
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (0045195C) --------------------------------------------------------
int __fastcall sub_45195C(int a1)
{
  char *v2; // $s1
  char *v3; // $s0
  int v4; // $v0
  int v5; // $v0
  char *v6; // $s1
  int v7; // $a0
  int v8; // $a2
  const char *v10; // $v0
  int *v11; // $v1
  int v12; // $t0
  int v13; // $a3
  int v14; // $a2
  int v15; // $a1
  const char *v16; // $v0
  int *v17; // $v1
  int v18; // $t0
  int v19; // $a3
  int v20; // $a2
  int v21; // $a1
  __int16 v22; // $a0
  char v23; // $v0
  int v24[256]; // [sp+18h] [-40Ch] BYREF
  int v25; // [sp+418h] [-Ch]

  v2 = httpd_get_parm(a1, "iface");
  v3 = httpd_get_parm(a1, "type");
  if ( v2 )
  {
    v4 = J_atoi(v2);
  }
  else
  {
    v4 = get_speed_test_iface();
    if ( v4 < 0 )
    {
      v16 = "{\"code\":\"-1\",\"msg\":\"There is no interface for speed measurement!\"}";
      v17 = v24;
      do
      {
        v18 = *(_DWORD *)v16;
        v19 = *((_DWORD *)v16 + 1);
        v20 = *((_DWORD *)v16 + 2);
        v21 = *((_DWORD *)v16 + 3);
        v16 += 16;
        *v17 = v18;
        v17[1] = v19;
        v17[2] = v20;
        v17[3] = v21;
        v17 += 4;
      }
      while ( v16 != "\"}" );
      v22 = *(_WORD *)v16;
      v23 = v16[2];
      *(_WORD *)v17 = v22;
      *((_BYTE *)v17 + 2) = v23;
      v8 = 66;
      return httpd_cgi_ret(a1, (char *)v24, v8, 4);
    }
  }
  v5 = jhl_nvget("wan_name", v4);
  v6 = (char *)nvram_get(v5);
  if ( v6 )
  {
    if ( v3 )
      goto LABEL_5;
  }
  else
  {
    v6 = "";
    if ( v3 )
    {
LABEL_5:
      if ( !strcmp(v3, "stop") )
      {
        killall_tk("speedTest");
        v25 = speed_test_info_get((char *)v24, 1024);
        nvram_set("speed_test_result", "");
        v8 = v25;
        return httpd_cgi_ret(a1, (char *)v24, v8, 4);
      }
      nvram_set("speed_test_iface", v6);
      nvram_set("speed_test_result", "");
      if ( !strcmp(v3, "start") )
      {
        nvram_set("speed_test_isp", "");
        nvram_set("speed_test_server", "");
        nvram_set("speed_test_download", "");
        nvram_set("speed_test_upload", "");
        killall_tk("speedTest");
        v24[0] = (int)"speedTest";
        v24[1] = (int)v6;
        v24[2] = 0;
        eval_nowait(v24, 0, 0, 0);
      }
      else if ( !strcmp(v3, "result") || !strcmp(v3, "info") )
      {
        goto LABEL_10;
      }
      jhl_parm_commit(v7);
LABEL_10:
      v8 = speed_test_info_get((char *)v24, 1024);
      return httpd_cgi_ret(a1, (char *)v24, v8, 4);
    }
  }
  v10 = "{\"code\":\"-1\",\"msg\":\"type null!\"}";
  v11 = v24;
  do
  {
    v12 = *(_DWORD *)v10;
    v13 = *((_DWORD *)v10 + 1);
    v14 = *((_DWORD *)v10 + 2);
    v15 = *((_DWORD *)v10 + 3);
    v10 += 16;
    *v11 = v12;
    v11[1] = v13;
    v11[2] = v14;
    v11[3] = v15;
    v11 += 4;
  }
  while ( v10 != "" );
  v8 = 32;
  *(_BYTE *)v11 = *v10;
  return httpd_cgi_ret(a1, (char *)v24, v8, 4);
}
// 451AE0: variable 'v7' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00451D28) --------------------------------------------------------
int __fastcall ai_sn_pub_check_token(int a1)
{
  char *v1; // $v0
  int v3; // $a0
  char *v4; // $s0
  int v5; // $v0
  char *v6; // $s2
  unsigned int v7; // $v0
  int v8; // $s0
  int result; // $v0
  char v10[128]; // [sp+18h] [-C0h] BYREF
  char v11[64]; // [sp+98h] [-40h] BYREF

  v1 = httpd_get_parm(a1, "tm");
  v3 = a1;
  v4 = v1;
  v6 = httpd_get_parm(v3, "token");
  v5 = J_atoi(v4);
  if ( dword_67D4F0 >= v5 )
    return -1;
  v8 = v5;
  v7 = snprintf(v10, 128, "%luGFX2654724QRRMLO!@$#&^HH", v5);
  if ( v7 >= 0x80 )
    v7 = 127;
  get_md5_str(v10, v7, v11);
  if ( !v6 )
    return -1;
  result = strcmp(v6, v11);
  if ( result )
    return -1;
  dword_67D4F0 = v8;
  return result;
}
// 67D4F0: using guessed type int dword_67D4F0;
// 6A8520: using guessed type int __fastcall get_md5_str(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00451E6C) --------------------------------------------------------
int __fastcall ai_sn_data(int a1)
{
  char *v2; // $v0
  const char *v3; // $s2
  const char *v4; // $v0
  const char *v5; // $s3
  unsigned int v6; // $a2
  const char *v8; // $v0
  const char *v9; // $s2
  char v10[1028]; // [sp+28h] [-404h] BYREF

  memset(v10, 0, 0x400u);
  v2 = httpd_get_parm(a1, "callback");
  if ( !v2 )
  {
    v9 = (const char *)get_sn();
    v8 = (const char *)custom_device_name();
    v6 = snprintf(v10, 1024, "{\"sn\":\"%s\",\"model\":\"%s\",\"version\":\"%s\"}", v9, v8, wayos_version);
    if ( v6 < 0x400 )
      return httpd_cgi_ret(a1, v10, v6, 4);
LABEL_5:
    v6 = 1023;
    return httpd_cgi_ret(a1, v10, v6, 4);
  }
  v3 = v2;
  v5 = (const char *)get_sn();
  v4 = (const char *)custom_device_name();
  v6 = snprintf(v10, 1024, "%s({\"sn\":\"%s\",\"model\":\"%s\",\"version\":\"%s\"})", v3, v5, v4, wayos_version);
  if ( v6 >= 0x400 )
    goto LABEL_5;
  return httpd_cgi_ret(a1, v10, v6, 4);
}
// 6A81D8: using guessed type int get_sn(void);
// 6A86E4: using guessed type int custom_device_name(void);

//----- (00451FEC) --------------------------------------------------------
int __fastcall sub_451FEC(int a1)
{
  int result; // $v0

  if ( ai_sn_pub_check_token(a1) )
    result = httpd_cgi_ret(a1, "?", 1, 4);
  else
    result = ai_sn_data(a1);
  return result;
}

//----- (00452058) --------------------------------------------------------
void __fastcall ai_ping_check_file_status(const char *a1, int a2, _DWORD *a3)
{
  char *v3; // $v0

  if ( a1 )
  {
    v3 = strstr(a1, "packets received, ");
    if ( v3 )
    {
      if ( J_atoi(v3 + 18) != 100 )
        *a3 = 1;
    }
  }
}
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004520D8) --------------------------------------------------------
int __fastcall ai_ping_test(int a1, int a2)
{
  char *v2; // $v0
  int v4[10]; // [sp+18h] [-2Ch] BYREF
  char v5; // [sp+40h] [-4h] BYREF

  v2 = (char *)v4;
  do
  {
    *(_DWORD *)v2 = 0;
    v2 += 4;
  }
  while ( v2 != &v5 );
  v4[0] = (int)"ping";
  v4[1] = (int)"-c";
  v4[2] = (int)"4";
  v4[5] = a1;
  v4[3] = (int)"-s";
  v4[4] = (int)"32";
  eval_nowait_file(v4, ">>/tmp/ai_wx_wan_ping/ping", 0, a2);
  return 0;
}
// 6A8640: using guessed type int __fastcall eval_nowait_file(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045217C) --------------------------------------------------------
int __fastcall sub_45217C(int a1)
{
  int v2; // $v0
  __pid_t v3; // $s7
  const char *v4; // $s5
  char *v5; // $v0
  char *v6; // $s4
  unsigned int v7; // $s2
  unsigned int v8; // $s0
  __pid_t v9; // $a2
  char *v10; // $s7
  const char *v11; // $s5
  int v12; // $v0
  unsigned int v13; // $v0
  int v14; // $s2
  unsigned int v15; // $v0
  char v17[4100]; // [sp+18h] [-14A8h] BYREF
  char v18[1024]; // [sp+101Ch] [-4A4h] BYREF
  char v19[128]; // [sp+141Ch] [-A4h] BYREF
  int v20; // [sp+149Ch] [-24h] BYREF
  int v21; // [sp+14A0h] [-20h] BYREF
  char *s; // [sp+14A8h] [-18h]
  char *v23; // [sp+14ACh] [-14h]
  char *v24; // [sp+14B0h] [-10h]
  char *v25; // [sp+14B4h] [-Ch]
  char *v26; // [sp+14B8h] [-8h]

  v26 = v19;
  v21 = 0;
  v20 = 0;
  memset(v19, 0, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  v25 = v17;
  memset(v17, 0, sizeof(v17));
  v24 = httpd_get_parm(a1, "chack_new");
  v3 = nvram_get_int("ai_wx_wan_ping_pid1");
  v2 = nvram_get("ai_wx_ping_start_flag");
  if ( v2 )
    v4 = (const char *)v2;
  else
    v4 = "";
  v5 = httpd_get_parm(a1, "callback");
  v6 = v5;
  if ( v5 )
  {
    v7 = snprintf(v18, 1024, "%s(", v5);
    if ( v7 >= 0x400 )
      v7 = 1023;
    s = &v18[v7];
    v8 = 1024 - v7;
  }
  else
  {
    v8 = 1024;
    s = v18;
    v7 = 0;
  }
  if ( !kill(v3, 0) && v3 )
  {
LABEL_20:
    v13 = snprintf(s, v8, "{\"states\":\"0\"}");
    if ( v13 < v8 )
      goto LABEL_14;
    goto LABEL_21;
  }
  v23 = "a";
  if ( strcmp(v4, "1") )
    goto LABEL_19;
  v9 = v3;
  if ( !v24 )
    goto LABEL_13;
  if ( strcmp(v24, v23 + 9340) )
  {
LABEL_19:
    mkdir("/tmp/ai_wx_wan_ping", 0x1EDu);
    system("rm /tmp/ai_wx_wan_ping/* -rf");
    ai_ping_test((int)"114.114.114.114", (int)&v21);
    nvram_set_int("ai_wx_wan_ping_pid1", v21);
    nvram_set("ai_wx_ping_start_flag", v23 + 9340);
    goto LABEL_20;
  }
  v9 = v3;
LABEL_13:
  v10 = v26;
  sprintf(v26, "/tmp/ai_wx_wan_ping/ping_%d", v9);
  v11 = v25;
  v12 = f_read(v10, v25, 4096);
  v11[v12] = 0;
  ai_ping_check_file_status(v11, v12, &v20);
  nvram_set("ai_wx_ping_start_flag", "0");
  v13 = snprintf(s, v8, "{\"states\":\"%d\"}", v20);
  if ( v13 < v8 )
    goto LABEL_14;
LABEL_21:
  v13 = 1023 - v7;
LABEL_14:
  v14 = v7 + v13;
  if ( v6 )
  {
    v15 = snprintf(&v18[v14], 1024 - v14, ")");
    if ( v15 >= 1024 - v14 )
      v15 = 1023 - v14;
    v14 += v15;
  }
  return httpd_cgi_ret(a1, v18, v14, 4);
}
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);
// 6A878C: using guessed type int __fastcall nvram_set_int(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00452560) --------------------------------------------------------
void __fastcall ai_send_router_login(int a1, const char *a2, const char *a3, int a4, const char *a5)
{
  int v9; // $v0
  const char *v10; // $s0
  const char *v11; // $s2
  time_t v12; // $v0
  unsigned int v13; // $v0
  char v14[1024]; // [sp+38h] [-434h] BYREF
  char v15[52]; // [sp+438h] [-34h] BYREF

  memset(v14, 0, sizeof(v14));
  v9 = IpaddrToStr(v15, a1 + 205460);
  v10 = *(const char **)(a1 + 205504);
  v11 = (const char *)v9;
  if ( !v10 )
    v10 = "\"\"";
  v12 = time(0);
  v13 = snprintf(
          v14,
          1024,
          "{\"ip\":\"%s\",\"host\":\"%s\",\"time\":\"%u\",\"ui\":\"%d\",\"type\":\"%s\",\"username\":\"%s\",\"passwd\":\""
          "%s\",\"status\":\"%d\"}",
          v11,
          v10,
          v12,
          3,
          a5,
          a2,
          a3,
          a4);
  if ( v13 >= 0x400 )
    v13 = 1023;
  ai_unix_cgi_send(0x272Bu, 0xFFFFFFFF, v14, v13);
}
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);

//----- (00452698) --------------------------------------------------------
int __fastcall sub_452698(int a1)
{
  char *v2; // $s0
  char *v3; // $s1
  const char *v4; // $v0
  int v5; // $s0
  unsigned int v6; // $v0
  int v7; // $s0
  unsigned int v8; // $v0
  char *v10; // $v0
  const char *v11; // $s1
  const char *v12; // $s3
  int v13; // $s4
  const char *v14; // $v0
  char v15[1024]; // [sp+20h] [-408h] BYREF
  int v16; // [sp+424h] [-4h] BYREF

  v2 = httpd_get_parm(a1, "nonce");
  v3 = httpd_get_parm(a1, "signature");
  strcpy(v15, "{\"code\":0,\"error\":\"\",\"data\":{");
  if ( !v2 || !v3 )
    goto LABEL_25;
  v4 = (const char *)nvram_get("ai_qrcode_nonce");
  if ( !v4 || strcmp(v4, v2) )
  {
    nvram_set("ai_qrcode_nonce_state", "100");
    v5 = 100;
    goto LABEL_6;
  }
  v10 = (char *)nvram_get("ai_qrcode_nonce_state");
  if ( !v10 )
    v10 = "0";
  v5 = J_atoi(v10);
  if ( (unsigned int)(v5 - 1) >= 3 )
    goto LABEL_14;
  v14 = (const char *)nvram_get("ai_qrcode_signature");
  if ( !v14 || strcmp(v14, v3) )
  {
LABEL_25:
    v5 = 0;
    goto LABEL_6;
  }
  nvram_set("ai_qrcode_signature", "");
  nvram_set("ai_qrcode_nonce", "");
LABEL_14:
  if ( v5 == 1 )
  {
    if ( gl_httpd_high_admin_en )
    {
      v11 = gl_httpd_high_adminpwd;
      v12 = gl_httpd_high_admin;
    }
    else if ( gl_httpd_admin_en )
    {
      v11 = gl_httpd_adminpwd;
      v12 = gl_httpd_admin;
    }
    else if ( gl_httpd_user_en )
    {
      v11 = gl_httpd_password;
      v12 = gl_httpd_user;
    }
    else if ( gl_httpd_guest_user_en )
    {
      v11 = gl_httpd_guest_pwd;
      v12 = gl_httpd_guest_user;
    }
    else
    {
      v11 = "";
      v12 = "";
    }
    v13 = httpd_cgi_user_check(v12, v11, &v16);
    if ( v13 <= 0 )
      jhl_user_login_add((_DWORD *)(a1 + 205460), (void *)0x64, v12, 1);
    else
      *(_DWORD *)(a1 + 36) |= 0x1000u;
    ai_send_router_login(a1, v12, v11, v13 > 0, "scan");
  }
LABEL_6:
  v6 = snprintf(&v15[29], 995, "\"state\":%d", v5);
  v7 = v6 + 29;
  if ( v6 >= 0x3E3 )
    v7 = 1023;
  v8 = snprintf(&v15[v7], 1024 - v7, "}}");
  if ( v8 >= 1024 - v7 )
    v8 = 1023 - v7;
  return httpd_cgi_ret(a1, v15, v8 + v7, 4);
}
// 642164: using guessed type __int16 word_642164;
// 666170: using guessed type int gl_httpd_admin_en;
// 67D090: using guessed type int gl_httpd_guest_user_en;
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 67D098: using guessed type int gl_httpd_user_en;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00452A70) --------------------------------------------------------
int init_diagnosis_timer()
{
  init_timer(&gl_auto_diagnosis_timer);
  dword_6A3C44 = jiffies_get() + 1000;
  dword_6A3C4C = 0;
  dword_6A3C48 = (int)auto_diagnosis_timer_fun;
  return add_timer(&gl_auto_diagnosis_timer);
}
// 6A3C44: using guessed type int dword_6A3C44;
// 6A3C48: using guessed type int dword_6A3C48;
// 6A3C4C: using guessed type int dword_6A3C4C;
// 6A8368: using guessed type int __fastcall init_timer(_DWORD);
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00452AE0) --------------------------------------------------------
int start_diagnosis()
{
  nvram_set("vue_health_score", "0");
  stop_dhcp_server_just_check();
  start_dhcp_server_just_check();
  stop_wan_gw_ping_check();
  start_wan_gw_ping_check();
  stop_wan_http_check();
  start_wan_http_check();
  stop_wan_dns_check();
  return start_wan_dns_check();
}
// 6A824C: using guessed type int stop_dhcp_server_just_check(void);
// 6A82E0: using guessed type int start_dhcp_server_just_check(void);
// 6A83EC: using guessed type int stop_wan_dns_check(void);
// 6A847C: using guessed type int stop_wan_http_check(void);
// 6A8610: using guessed type int stop_wan_gw_ping_check(void);
// 6A8698: using guessed type int start_wan_http_check(void);
// 6A87E4: using guessed type int start_wan_dns_check(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A897C: using guessed type int start_wan_gw_ping_check(void);

//----- (00452BD0) --------------------------------------------------------
int __fastcall sub_452BD0(int a1)
{
  char v2[1024]; // [sp+18h] [-40Ch] BYREF
  int v3; // [sp+418h] [-Ch]

  v3 = a1;
  start_diagnosis();
  strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":0}");
  return httpd_cgi_ret(v3, v2, 30, 4);
}

//----- (00452C78) --------------------------------------------------------
int __fastcall wan_port_max_speed_get(int a1)
{
  void *v2; // $v0
  void *v3; // $s3
  int v4; // $v0
  int v5; // $s5
  _DWORD *v6; // $fp
  unsigned int v7; // $s4
  int v8; // $v0
  const char *v9; // $s7
  bool v10; // dc
  int v11; // $v0
  int result; // $v0
  int v13; // $s4
  int v14; // $v0
  int v15; // $v0
  int v16; // $v0
  int v17; // $a0
  int v18; // [sp+28h] [-8h]

  _mem_malloc(0x200000, "wan_port_max_speed_get", 108);
  if ( !v2 )
    return 0;
  v3 = v2;
  miitool_data_buf(v2, 0x200000);
  v4 = cJSON_Parse(v3);
  v5 = v4;
  if ( !v4 )
  {
    _mem_free(v3);
    return 0;
  }
  v6 = *(_DWORD **)(v4 + 8);
  v7 = 0;
  if ( v6 )
  {
    while ( 1 )
    {
      v8 = cJSON_GetObjectItem(v6, "n");
      if ( !v8 )
        goto LABEL_8;
      v9 = *(const char **)(v8 + 16);
      if ( !v9 )
        goto LABEL_8;
      v10 = strstr(*(const char **)(v8 + 16), (const char *)&off_645568) == 0;
      v11 = 1;
      if ( !v10 )
        goto LABEL_7;
      if ( !strstr(v9, (const char *)&off_64556C) && !strstr(v9, "2.5GE") )
        break;
      v14 = cJSON_GetObjectItem(v6, "wan");
      if ( !v14 )
        break;
      if ( (*(_DWORD *)(v14 + 20) != 0) == a1 )
      {
LABEL_19:
        v15 = cJSON_GetObjectItem(v6, "link");
        if ( v15 )
        {
          if ( *(_DWORD *)(v15 + 20) )
          {
            v16 = cJSON_GetObjectItem(v6, "state");
            if ( v16 )
            {
              v17 = *(_DWORD *)(v16 + 16);
              v18 = v16;
              if ( v17 )
              {
                if ( v7 < J_atoi(v17) )
                  v7 = J_atoi(*(_DWORD *)(v18 + 16));
              }
            }
          }
        }
      }
LABEL_8:
      v6 = (_DWORD *)*v6;
      if ( !v6 )
        goto LABEL_9;
    }
    v11 = 0;
LABEL_7:
    if ( v11 == a1 )
      goto LABEL_19;
    goto LABEL_8;
  }
LABEL_9:
  _mem_free(v3);
  cJSON_Delete(v5);
  if ( !v7 )
    return 0;
  result = 2;
  if ( v7 != 10 )
  {
    v10 = v7 == 100;
    v13 = v7 ^ 0x3E8;
    if ( v10 )
      result = 4;
    else
      result = 6 - (v13 == 0);
  }
  return result;
}
// 452CD4: variable 'v2' is possibly undefined
// 645568: using guessed type void *off_645568;
// 64556C: using guessed type void *off_64556C;
// 6A82D0: using guessed type int __fastcall miitool_data_buf(_DWORD, _DWORD);
// 6A8780: using guessed type int __fastcall cJSON_Parse(_DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00452F70) --------------------------------------------------------
int get_diagnosis_result()
{
  int v0; // $s1
  int v1; // $s2
  int v2; // $s0
  int v3; // $v0
  _BOOL4 v4; // $s2
  _BOOL4 v5; // $v0
  int v6; // $s2
  int v7; // $a3
  int v8; // $s2
  int v9; // $v1
  char *v10; // $v0
  int v11; // $v1
  char *v12; // $s2
  const char *v13; // $v0
  const char *v14; // $v0
  const char *v15; // $v0
  const char *v16; // $v0
  int v17; // $v0
  int v18; // $s2
  int v19; // $s2
  int v20; // $v1
  int v21; // $v0
  _BOOL4 v22; // $s2
  int v23; // $v1
  int v24; // $v0
  int v25; // $s2
  int v26; // $s2
  int v27; // $v1
  _BOOL4 v28; // $s2
  int v29; // $v1
  int v30; // $v0
  int v32; // $a3
  int v33; // $a3
  int v34; // $s2
  int v35; // $v1
  int v36; // $s2
  int v37; // $v1
  int v38; // $s2
  int v39; // $v1
  int v40; // $s2
  int v41; // $v1
  char v42[2048]; // [sp+18h] [-80Ch] BYREF
  int v43[3]; // [sp+818h] [-Ch] BYREF

  v43[0] = 0;
  v0 = cJSON_CreateObject();
  v1 = wan_port_max_speed_get(1);
  if ( v1 <= 0 )
  {
    cJSON_AddNumberToObject(v0, "line", 0, 1072693248);
    v2 = 0;
  }
  else
  {
    cJSON_AddNumberToObject(v0, "line", 0, 0);
    v2 = 1;
  }
  v3 = wan_port_max_speed_get(0);
  v4 = v1 < 4;
  if ( v3 > 0 )
  {
    v5 = v3 < 4;
    if ( !v4 && !v5 )
      goto LABEL_41;
LABEL_5:
    cJSON_AddNumberToObject(v0, "speed", 0, 1072693248);
    goto LABEL_6;
  }
  if ( v4 )
    goto LABEL_5;
LABEL_41:
  cJSON_AddNumberToObject(v0, "speed", 0, 0);
  ++v2;
LABEL_6:
  v6 = wan_proto_check(v43);
  if ( !v6 )
  {
    cJSON_AddNumberToObject(v0, "wan_conf", 0, 1072693248);
    goto LABEL_8;
  }
  cJSON_AddNumberToObject(v0, "wan_conf", 0, 0);
  if ( v6 == 2 )
  {
    if ( v43[0] )
      v32 = 0;
    else
      v32 = 1072693248;
    cJSON_AddNumberToObject(v0, "dhcp_addr", 0, v32);
    if ( v43[0] )
    {
LABEL_39:
      v2 += 2;
      goto LABEL_12;
    }
LABEL_47:
    ++v2;
    goto LABEL_12;
  }
  if ( v6 == 4 )
  {
    if ( v43[0] )
      v33 = 0;
    else
      v33 = 1072693248;
    cJSON_AddNumberToObject(v0, "pppoe_addr", 0, v33);
    if ( v43[0] )
      goto LABEL_39;
    goto LABEL_47;
  }
  ++v2;
LABEL_8:
  if ( v43[0] )
    v7 = 0;
  else
    v7 = 1072693248;
  cJSON_AddNumberToObject(v0, "static_addr", 0, v7);
  if ( v43[0] )
    ++v2;
LABEL_12:
  v8 = wan_lan_confilict();
  cJSON_AddNumberToObject(v0, "wan_lan_confilict", v8, v9);
  if ( !v8 )
    ++v2;
  if ( !get_log_data_in_time(27, v42, 2048, 10) )
  {
    cJSON_AddNumberToObject(v0, "broadcast_loop", 0, 0);
LABEL_49:
    cJSON_AddNumberToObject(v0, "ip_confilict", 0, 0);
    v2 += 2;
    goto LABEL_18;
  }
  v12 = strstr(v42, byte_6455B0);
  v10 = strstr(v42, byte_6455BC);
  if ( !v10 )
  {
    cJSON_AddNumberToObject(v0, "broadcast_loop", 0, v11);
    if ( v12 )
    {
      cJSON_AddNumberToObject(v0, "ip_confilict", 0, 0);
      ++v2;
      goto LABEL_18;
    }
    goto LABEL_49;
  }
  cJSON_AddNumberToObject(v0, "broadcast_loop", v10, v11);
  cJSON_AddNumberToObject(v0, "ip_confilict", 0, 1072693248);
  if ( !v12 )
    ++v2;
LABEL_18:
  v13 = (const char *)nvram_get("dhcp_ck_state");
  if ( v13 )
  {
    if ( !strcmp(v13, "1") )
    {
      v34 = nvram_get_int("dhcp_ck_num");
      cJSON_AddNumberToObject(v0, "dhcp_confilict", v34, v35);
      if ( !v34 )
        ++v2;
    }
  }
  v14 = (const char *)nvram_get("wan_http_ck_state");
  if ( v14 )
  {
    if ( !strcmp(v14, "1") )
    {
      v36 = nvram_get_int("wan_http_ck_err");
      cJSON_AddNumberToObject(v0, "route_conf", v36, v37);
      if ( !v36 )
        ++v2;
    }
  }
  v15 = (const char *)nvram_get("wan_gw_ck_state");
  if ( v15 )
  {
    if ( !strcmp(v15, "1") )
    {
      v38 = nvram_get_int("wan_gw_ck_err");
      cJSON_AddNumberToObject(v0, "next_route", v38, v39);
      if ( !v38 )
        ++v2;
    }
  }
  v16 = (const char *)nvram_get("wan_dns_ck_state");
  if ( v16 )
  {
    if ( !strcmp(v16, "1") )
    {
      v40 = nvram_get_int("wan_dns_ck_err");
      cJSON_AddNumberToObject(v0, "dns_conf", v40, v41);
      if ( !v40 )
        ++v2;
    }
  }
  v18 = ct_low_limit_check(100);
  v17 = ct_default_low_limit_check(100, 1000, 10000);
  v19 = v18 + v17;
  cJSON_AddNumberToObject(v0, "ct_check", v17, v20);
  if ( !v19 )
    ++v2;
  v21 = get_dhcp_left_num();
  v22 = v21 < 10;
  cJSON_AddNumberToObject(v0, "dhcp_pool", v21, v23);
  if ( !v22 )
    ++v2;
  v25 = qos_low_limit_check(100);
  v24 = qos_default_low_limit_check(100);
  v26 = v25 + v24;
  cJSON_AddNumberToObject(v0, "qos_check", v24, v27);
  if ( !v26 )
    ++v2;
  v28 = ai_is_running(1);
  cJSON_AddNumberToObject(v0, "ai_conf", v28, v29);
  v30 = 4 * v2;
  if ( v28 )
  {
    ++v2;
    v30 = 4 * v2;
  }
  nvram_set_int("vue_health_score", 5 * (v30 + 16 * v2) / 15);
  return v0;
}
// 4530FC: variable 'v9' is possibly undefined
// 4531A0: variable 'v11' is possibly undefined
// 453338: variable 'v20' is possibly undefined
// 453390: variable 'v23' is possibly undefined
// 453400: variable 'v27' is possibly undefined
// 453458: variable 'v29' is possibly undefined
// 453668: variable 'v35' is possibly undefined
// 4536C8: variable 'v37' is possibly undefined
// 453728: variable 'v39' is possibly undefined
// 453788: variable 'v41' is possibly undefined
// 6A81B0: using guessed type int get_dhcp_left_num(void);
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8258: using guessed type int cJSON_CreateObject(void);
// 6A8328: using guessed type int __fastcall get_log_data_in_time(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84A4: using guessed type int __fastcall ct_low_limit_check(_DWORD);
// 6A8650: using guessed type int __fastcall qos_low_limit_check(_DWORD);
// 6A878C: using guessed type int __fastcall nvram_set_int(_DWORD, _DWORD);
// 6A87A4: using guessed type int __fastcall wan_proto_check(_DWORD);
// 6A87C8: using guessed type int __fastcall cJSON_AddNumberToObject(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8810: using guessed type int wan_lan_confilict(void);
// 6A8960: using guessed type int __fastcall ct_default_low_limit_check(_DWORD, _DWORD, _DWORD);
// 6A899C: using guessed type int __fastcall qos_default_low_limit_check(_DWORD);

//----- (0045388C) --------------------------------------------------------
int auto_diagnosis_timer_fun()
{
  int v0; // $v0
  int v1; // $s1
  int v2; // $v0
  int v4; // $v0
  int v5; // $v0

  v0 = nvram_get_int("vue_health_checking");
  v1 = v0;
  if ( v0 )
  {
    if ( v0 >= 15 || nvram_get_int("vue_health_score") >= 100 )
    {
      nvram_set("vue_health_checking", "0");
      v2 = jiffies_get();
      return mod_timer(&gl_auto_diagnosis_timer, v2 + 3600000);
    }
    v4 = get_diagnosis_result();
    cJSON_Delete(v4);
    nvram_set_int("vue_health_checking", v1 + 1);
  }
  else
  {
    nvram_set("vue_health_checking", "1");
    start_diagnosis();
  }
  v5 = jiffies_get();
  return mod_timer(&gl_auto_diagnosis_timer, v5 + 1000);
}
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A878C: using guessed type int __fastcall nvram_set_int(_DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00453A04) --------------------------------------------------------
int __fastcall sub_453A04(int a1)
{
  int v2; // $s3
  const char *v3; // $v0
  char *v4; // $s1
  unsigned int v5; // $s0
  int v6; // $v0
  int v7; // $s0
  unsigned int v8; // $s1
  unsigned int v9; // $v0
  char v11[2052]; // [sp+18h] [-804h] BYREF

  v2 = get_diagnosis_result();
  strcpy(v11, "{\"code\":0,\"error\":\"\",\"data\":");
  if ( v2 )
  {
    v3 = (const char *)cJSON_PrintUnformatted(v2);
    v4 = (char *)v3;
    if ( v3 )
    {
      v5 = snprintf(&v11[28], 2020, "%s", v3);
      free(v4);
      v6 = v5;
      if ( v5 >= 0x7E4 )
        v6 = 2019;
      v7 = v6 + 28;
      v8 = 2048 - (v6 + 28);
    }
    else
    {
      v8 = 2020;
      v7 = 28;
    }
    cJSON_Delete(v2);
  }
  else
  {
    v8 = 2020;
    v7 = 28;
  }
  v9 = snprintf(&v11[v7], v8, "}");
  if ( v9 >= v8 )
    v9 = 2047 - v7;
  return httpd_cgi_ret(a1, v11, v9 + v7, 4);
}
// 6A85D0: using guessed type int __fastcall cJSON_PrintUnformatted(_DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);

//----- (00453BA0) --------------------------------------------------------
int del_vpnmessage_file()
{
  FILE *v0; // $v0
  FILE *v1; // $fp
  FILE *v2; // $s2
  char v4[1024]; // [sp+18h] [-400h] BYREF

  memset(v4, 0, sizeof(v4));
  v0 = fopen("/var/log/messages_tmp", "w");
  if ( !v0 )
    return -1;
  v1 = v0;
  v2 = fopen("/var/log/messages", "r");
  if ( v2 )
  {
    while ( fgets(v4, 1023, v2) )
    {
      if ( !strstr(v4, "pptpd[") && !strstr(v4, "pptp[") && !strstr(v4, "xl2tpd[") && !strstr(v4, "pppd[") )
        fputs(v4, v1);
    }
    fclose(v1);
    fclose(v2);
  }
  else
  {
    fclose(v1);
  }
  unlink("/var/log/messages");
  rename("/var/log/messages_tmp", "/var/log/messages");
  return 0;
}

//----- (00453DC4) --------------------------------------------------------
char *__fastcall read_vpnmessage_file(char *a1, int a2)
{
  FILE *v4; // $s2
  char *v5; // $s4
  bool v6; // dc
  _BOOL4 v7; // $v0
  int v8; // $a1
  char *v9; // $v1
  int v10; // $v0
  _BYTE *v11; // $a0
  int v12; // $v0
  unsigned __int8 v13; // $v0
  int v14; // $v0
  int v15; // $v0
  int v16; // $v0
  char v18[1024]; // [sp+20h] [-408h] BYREF
  char *v19; // [sp+420h] [-8h]

  memset(v18, 0, sizeof(v18));
  v4 = fopen("/var/log/messages", "r");
  if ( v4 )
  {
    v5 = a1;
    v19 = "a";
LABEL_3:
    while ( 2 )
    {
      v6 = fgets(v18, 1023, v4) == 0;
      v7 = a2 < 3000;
      if ( v6 )
        goto LABEL_32;
LABEL_4:
      if ( v7 )
        goto LABEL_32;
      if ( !strstr(v18, "pptpd[") && !strstr(v18, "pptp[") && !strstr(v18, "xl2tpd[") && !strstr(v18, v19 + 22336)
        || !v18[0] )
      {
        continue;
      }
      break;
    }
    v8 = 0;
    v9 = v18;
    if ( v18[0] != 32 )
    {
LABEL_8:
      v10 = v9[1];
      goto LABEL_9;
    }
    while ( 1 )
    {
      if ( v8 )
      {
        if ( ++v8 == 3 )
        {
          *v9 = 0;
          v10 = v9[1];
        }
        else
        {
          v10 = v9[1];
          if ( v8 == 5 )
          {
            *v9 = 0;
            v11 = v9 + 1;
            if ( !v10 )
              goto LABEL_3;
            while ( 2 )
            {
              v13 = v10 - 34;
              while ( v13 < 0x1Bu && ((0x4000021u >> v13) & 1) != 0 )
              {
                *v11++ = 32;
                v14 = (char)*v11;
                v6 = v14 != 0;
                v13 = v14 - 34;
                if ( !v6 )
                  goto LABEL_27;
              }
              v12 = (char)*v11;
              if ( v12 != 10 && v12 != 13 )
              {
                LOBYTE(v10) = *++v11;
                if ( *v11 )
                  continue;
LABEL_27:
                v15 = v9[1];
                goto LABEL_28;
              }
              break;
            }
            *v11 = 0;
            v15 = v9[1];
LABEL_28:
            if ( !v15 )
              goto LABEL_3;
            v16 = snprintf(v5, a2, "\"%s <%s\",", v9 + 1, v18);
            if ( v16 >= a2 )
              v16 = a2 - 1;
            a2 -= v16;
            v5 += v16;
            v6 = fgets(v18, 1023, v4) != 0;
            v7 = a2 < 3000;
            if ( !v6 )
            {
LABEL_32:
              fclose(v4);
              return (char *)(v5 - a1);
            }
            goto LABEL_4;
          }
        }
      }
      else
      {
        v10 = v9[1];
        if ( v10 == 32 )
        {
          v10 = v9[2];
          v8 = 1;
          ++v9;
        }
        else
        {
          v8 = 1;
        }
      }
LABEL_9:
      ++v9;
      if ( !v10 )
        goto LABEL_3;
      if ( v10 != 32 )
        goto LABEL_8;
    }
  }
  return 0;
}

//----- (004540F4) --------------------------------------------------------
char *__fastcall read_ipsec_file(char *a1, int a2)
{
  FILE *v3; // $s2
  char *v4; // $s4
  int v5; // $a0
  char *v6; // $v1
  char *v7; // $v1
  int v8; // $v0
  _BYTE *v9; // $a0
  int v10; // $v0
  unsigned __int8 v11; // $v0
  int v12; // $v0
  bool v13; // dc
  int v14; // $v0
  char v16[1024]; // [sp+20h] [-400h] BYREF

  memset(v16, 0, sizeof(v16));
  v3 = fopen("/etc/racoon/ipsec.log", "r");
  v4 = a1;
  if ( v3 )
  {
LABEL_2:
    while ( fgets(v16, 1023, v3) && a2 >= 3000 )
    {
      v5 = 0;
      if ( !v16[0] )
        goto LABEL_2;
      v6 = v16;
      if ( v16[0] != 58 )
        goto LABEL_6;
      while ( 1 )
      {
        if ( ++v5 == 3 )
        {
          *v6 = 0;
LABEL_6:
          ++v6;
          goto LABEL_7;
        }
        ++v6;
        if ( v5 == 4 )
          break;
LABEL_7:
        if ( !*v6 )
          goto LABEL_2;
        if ( *v6 != 58 )
          goto LABEL_6;
      }
      v7 = v6 - 1;
      v8 = v7[1];
      *v7 = 0;
      v9 = v7 + 1;
      if ( v8 )
      {
        while ( 2 )
        {
          v11 = v8 - 34;
          while ( v11 < 0x1Bu && ((0x4000021u >> v11) & 1) != 0 )
          {
            *v9++ = 32;
            v12 = (char)*v9;
            v13 = v12 != 0;
            v11 = v12 - 34;
            if ( !v13 )
              goto LABEL_20;
          }
          v10 = (char)*v9;
          if ( v10 != 10 && v10 != 13 )
          {
            LOBYTE(v8) = *++v9;
            if ( *v9 )
              continue;
LABEL_20:
            if ( !v7[1] )
              goto LABEL_2;
            goto LABEL_21;
          }
          break;
        }
        *v9 = 0;
        if ( !v7[1] )
          goto LABEL_2;
LABEL_21:
        v14 = snprintf(v4, a2, "\"%s <%s\",", v7 + 1, v16);
        if ( v14 >= a2 )
          v14 = a2 - 1;
        a2 -= v14;
        v4 += v14;
      }
    }
    fclose(v3);
  }
  return (char *)(v4 - a1);
}
// 4542D8: conditional instruction was optimized away because of '$s2.4!=0'

//----- (00454354) --------------------------------------------------------
char *__fastcall read_error_by_ipsec_file(char *a1, int a2)
{
  FILE *v3; // $s3
  char *v4; // $s5
  const char *v5; // $fp
  bool v6; // dc
  _BOOL4 v7; // $v0
  int v8; // $v1
  int v9; // $v0
  char *v10; // $s0
  char v11; // $v0
  char *v12; // $v1
  int v13; // $v0
  unsigned __int8 v14; // $v0
  int v15; // $v0
  int v16; // $v0
  char *v18; // $fp
  char v19[1024]; // [sp+20h] [-400h] BYREF

  memset(v19, 0, sizeof(v19));
  v3 = fopen("/etc/racoon/ipsec.log", "r");
  if ( !v3 )
    return 0;
  v4 = a1;
  v5 = 0;
LABEL_3:
  v6 = fgets(v19, 1023, v3) == 0;
  v7 = a2 < 3000;
  if ( v6 )
    goto LABEL_26;
  do
  {
    v8 = 0;
    if ( v7 )
      break;
    v9 = v19[0];
    v10 = v19;
    while ( v9 )
    {
      if ( v9 != 58 )
        goto LABEL_8;
      if ( ++v8 == 3 )
      {
        v9 = v10[1];
        v5 = v10 + 1;
        *v10 = 0;
        if ( v9 == 32 )
        {
          v18 = v10 + 2;
          do
            v9 = *v18++;
          while ( v9 == 32 );
          v5 = v18 - 1;
        }
        v10 = (char *)v5;
      }
      else
      {
        if ( v8 == 4 )
        {
          *v10++ = 0;
          break;
        }
LABEL_8:
        v9 = *++v10;
      }
    }
    if ( strcmp(v5, "ERROR") )
      goto LABEL_3;
    v11 = *v10;
    if ( !*v10 )
      goto LABEL_3;
    v12 = v10;
    while ( 2 )
    {
      v14 = v11 - 34;
      while ( v14 < 0x1Bu && ((0x4000021u >> v14) & 1) != 0 )
      {
        *v12++ = 32;
        v15 = *v12;
        v6 = v15 != 0;
        v14 = v15 - 34;
        if ( !v6 )
          goto LABEL_22;
      }
      v13 = *v12;
      if ( v13 != 10 && v13 != 13 )
      {
        v11 = *++v12;
        if ( *v12 )
          continue;
LABEL_22:
        if ( !*v10 )
          goto LABEL_3;
        goto LABEL_23;
      }
      break;
    }
    *v12 = 0;
    if ( !*v10 )
      goto LABEL_3;
LABEL_23:
    v16 = snprintf(v4, a2, "\"%s <%s\",", v10, v19);
    if ( v16 >= a2 )
      v16 = a2 - 1;
    a2 -= v16;
    v4 += v16;
    v6 = fgets(v19, 1023, v3) != 0;
    v7 = a2 < 3000;
  }
  while ( v6 );
LABEL_26:
  fclose(v3);
  return (char *)(v4 - a1);
}

//----- (0045461C) --------------------------------------------------------
int __fastcall sub_45461C(int a1)
{
  char *v2; // $v0
  char *v3; // $s2
  _BOOL4 v4; // $s4
  const char *v5; // $a0
  void **v6; // $s0
  int v7; // $s1
  char *v8; // $s1
  int v9; // $v0
  char *v10; // $s0
  int v11; // $s2
  char *v12; // $v0
  int v13; // $s5
  int v14; // $s4
  char *v15; // $a0
  int v16; // $a1
  int v17; // $v0
  int v18; // $a2
  int v20; // $a1
  const char *v21; // $a2
  int v22; // $a0
  const char *v23; // $v0
  unsigned int v24; // $v0
  int v25; // $a2
  int v26; // $a1
  int v27; // $s4
  int v28; // $s4
  int v29; // $a2
  int v30; // $a1
  int v31; // $s4
  char *v32; // $s4
  char v33[260]; // [sp+20h] [-104h] BYREF

  v3 = httpd_get_parm(a1, "id");
  v2 = httpd_get_parm(a1, "mode");
  v4 = 0;
  if ( v2 )
    v4 = J_atoi(v2) != 0;
  if ( v3 )
  {
    v5 = ll_log_str;
    v6 = &off_66F118;
    if ( !ll_log_str )
      goto LABEL_25;
    v7 = 0;
    while ( 1 )
    {
      v6 += 2;
      if ( !strcmp(v5, v3) )
        break;
      v5 = (const char *)*(v6 - 2);
      ++v7;
      if ( !v5 )
        goto LABEL_25;
    }
    v8 = (&ll_log_str)[2 * v7 + 1];
    if ( v8 )
    {
      _mem_malloc(0x200000, "sys_log_data", 387);
      v10 = (char *)v9;
      if ( v9 )
      {
        qmemcpy((void *)v9, "{\"code\":0,\"error\":\"\",\"data\":", 28);
        qmemcpy((void *)v9, "{\"code\":0,\"error", 16);
        v11 = v9 + 29;
        *(_BYTE *)(v9 + 28) = 91;
        *(_BYTE *)(v9 + 29) = 0;
        if ( v8 == (char *)-1 )
        {
          if ( nvram_match_def("usblogd_en", "1") )
          {
            v27 = read_sysmessage_file("/var/log/messages2", v10 + 29, 2097123);
            v26 = v27;
            v25 = 2097123 - v27;
          }
          else
          {
            v25 = 2097123;
            v26 = 0;
            v27 = 0;
          }
          v28 = v27 + read_sysmessage_file("/var/log/messages.0", v11 + v26, v25);
          v12 = (char *)(v28 + read_sysmessage_file("/var/log/messages", v11 + v28, 2097123 - v28));
        }
        else if ( v8 == (char *)-2 )
        {
          if ( nvram_match_def("usblogd_en", "1") )
          {
            v31 = read_ovpn_file("/var/log/openvpn2.log", v10 + 29, 2097123);
            v30 = v31;
            v29 = 2097123 - v31;
          }
          else
          {
            v29 = 2097123;
            v30 = 0;
            v31 = 0;
          }
          v12 = (char *)(v31 + read_ovpn_file("/var/log/openvpn.log", v11 + v30, v29));
        }
        else
        {
          if ( v8 == (char *)-3 )
          {
            *(_BYTE *)(v9 + 29) = 93;
            v18 = 31;
            *(_WORD *)(v9 + 30) = 125;
            return httpd_cgi_ret(a1, v10, v18, 8);
          }
          if ( v8 == (char *)2 )
          {
            v32 = read_vpnmessage_file((char *)(v9 + 29), 2097123);
            v12 = &read_ipsec_file(&v32[v11], 2097123)[(_DWORD)v32];
          }
          else if ( v8 == (char *)39 )
          {
            v12 = (char *)((int (__fastcall *)(int, int, int))read_vpnmessage_file)(v9 + 29, 2097123, -1);
          }
          else if ( v8 == (char *)26 )
          {
            v12 = (char *)((int (__fastcall *)(int, int, int))read_error_by_ipsec_file)(v9 + 29, 2097123, -1);
          }
          else if ( v8 == (char *)28 )
          {
            v12 = (char *)((int (__fastcall *)(int, int, int))read_ipsec_file)(v9 + 29, 2097123, 2031616);
          }
          else
          {
            v12 = (char *)read_log_data(v8, v9 + 29, 2097123, v4);
          }
        }
        if ( v12 )
        {
          v13 = (int)(v12 + 28);
          v14 = 0x200000 - (_DWORD)(v12 + 28);
          v12[v11 - 1] = 0;
          v15 = &v12[(_DWORD)v10 + 28];
          v16 = v14;
        }
        else
        {
          v16 = 2097123;
          v15 = v10 + 29;
          v14 = 2097123;
          v13 = 29;
        }
        v17 = snprintf(v15, v16, "]}");
        if ( v17 >= v14 )
          v17 = 0x1FFFFF - v13;
        v18 = v17 + v13;
        if ( v8 == (char *)34 )
          *(_DWORD *)(a1 + 36) |= 0x8000u;
        return httpd_cgi_ret(a1, v10, v18, 8);
      }
      v20 = *(unsigned __int8 *)(a1 + 210102);
      v21 = (const char *)0x200000;
      v22 = 4;
    }
    else
    {
LABEL_25:
      v20 = *(unsigned __int8 *)(a1 + 210102);
      v21 = "not logid";
      v22 = 12;
    }
  }
  else
  {
    v20 = *(unsigned __int8 *)(a1 + 210102);
    v21 = "not id";
    v22 = 12;
  }
  v23 = (const char *)_GET_LANG_TEXT(v22, v20, v21);
  v24 = snprintf(v33, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v23);
  if ( v24 >= 0x100 )
    v24 = 255;
  return httpd_cgi_ret(a1, v33, v24, 4);
}
// 454728: variable 'v9' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 66F110: using guessed type char *ll_log_str;
// 66F118: using guessed type void *off_66F118;
// 6A8294: using guessed type int __fastcall read_ovpn_file(_DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A868C: using guessed type int __fastcall read_sysmessage_file(_DWORD, _DWORD, _DWORD);
// 6A88BC: using guessed type int __fastcall read_log_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00454B30) --------------------------------------------------------
int __fastcall sub_454B30(int a1)
{
  char *v1; // $v0
  const char *v3; // $a0
  const char *v4; // $s2
  void **v5; // $s0
  int v6; // $s1
  char *v7; // $a0
  const char *v8; // $v0
  char *v9; // $v1
  int v10; // $t0
  int v11; // $a3
  int v12; // $a2
  int v13; // $a1
  int v15; // $a1
  const char *v16; // $a2
  const char *v17; // $v0
  unsigned int v18; // $v0
  char v19[256]; // [sp+20h] [-100h] BYREF

  v1 = httpd_get_parm(a1, "id");
  if ( v1 )
  {
    v3 = ll_log_str;
    v4 = v1;
    if ( ll_log_str )
    {
      v5 = &off_66F118;
      v6 = 0;
      while ( 1 )
      {
        v5 += 2;
        if ( !strcmp(v3, v4) )
          break;
        v3 = (const char *)*(v5 - 2);
        ++v6;
        if ( !v3 )
          goto LABEL_16;
      }
      v7 = (&ll_log_str)[2 * v6 + 1];
      if ( v7 )
      {
        if ( v7 == (char *)-1 )
        {
          log_del_file_all("/var/log/messages");
          log_del_file_all("/var/log/messages.0");
          log_del_file_all("/var/log/messages2");
        }
        else if ( v7 == (char *)-2 )
        {
          log_del_file_all("/var/log/openvpn.log");
          log_del_file_all("/var/log/openvpn2.log");
        }
        else if ( v7 == (char *)1 )
        {
          del_log_data(1);
          del_log_data(27);
        }
        else if ( v7 == (char *)28 )
        {
          log_del_file_all("/etc/racoon/ipsec.log");
        }
        else if ( v7 == (char *)39 )
        {
          del_vpnmessage_file();
        }
        else
        {
          del_log_data(v7);
        }
        v8 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        v9 = v19;
        do
        {
          v10 = *(_DWORD *)v8;
          v11 = *((_DWORD *)v8 + 1);
          v12 = *((_DWORD *)v8 + 2);
          v13 = *((_DWORD *)v8 + 3);
          v8 += 16;
          *(_DWORD *)v9 = v10;
          *((_DWORD *)v9 + 1) = v11;
          *((_DWORD *)v9 + 2) = v12;
          *((_DWORD *)v9 + 3) = v13;
          v9 += 16;
        }
        while ( v8 != "}" );
        *(_WORD *)v9 = *(_WORD *)v8;
        return httpd_cgi_ret(a1, v19, 33, 4);
      }
    }
LABEL_16:
    v15 = *(unsigned __int8 *)(a1 + 210102);
    v16 = "not logid";
  }
  else
  {
    v15 = *(unsigned __int8 *)(a1 + 210102);
    v16 = "not id";
  }
  v17 = (const char *)_GET_LANG_TEXT(12, v15, v16);
  v18 = snprintf(v19, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
  if ( v18 >= 0x100 )
    v18 = 255;
  return httpd_cgi_ret(a1, v19, v18, 4);
}
// 66F110: using guessed type char *ll_log_str;
// 66F118: using guessed type void *off_66F118;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8498: using guessed type int __fastcall del_log_data(_DWORD);
// 6A85C4: using guessed type int __fastcall log_del_file_all(_DWORD);

//----- (00454E58) --------------------------------------------------------
int __fastcall sub_454E58(int a1)
{
  char *v2; // $v0
  char *v3; // $s2
  _BOOL4 v4; // $s5
  const char *v5; // $a0
  void **v6; // $s0
  int v7; // $s1
  char *v8; // $s0
  _BYTE *v9; // $v0
  int v10; // $a2
  _BYTE *v11; // $s1
  char *v12; // $s3
  char *v13; // $v0
  int v14; // $a3
  char *v15; // $v1
  int v16; // $a1
  const char *v17; // $a2
  int v18; // $a0
  const char *v19; // $v0
  unsigned int v20; // $v0
  int v22; // $a2
  int v23; // $a1
  int v24; // $s2
  int v25; // $s2
  int v26; // $a2
  int v27; // $a1
  int v28; // $s2
  char *v29; // $s2
  char v30[260]; // [sp+20h] [-104h] BYREF

  v3 = httpd_get_parm(a1, "id");
  v2 = httpd_get_parm(a1, "mode");
  v4 = 0;
  if ( v2 )
    v4 = J_atoi(v2) != 0;
  if ( v3 )
  {
    v5 = ll_log_str;
    v6 = &off_66F118;
    if ( !ll_log_str )
      goto LABEL_22;
    v7 = 0;
    while ( 1 )
    {
      v6 += 2;
      if ( !strcmp(v5, v3) )
        break;
      v5 = (const char *)*(v6 - 2);
      ++v7;
      if ( !v5 )
        goto LABEL_22;
    }
    v8 = (&ll_log_str)[2 * v7 + 1];
    if ( v8 )
    {
      _mem_malloc(0x200000, "sys_log_cfg", 581);
      v11 = v9;
      if ( v9 )
      {
        *(_WORD *)v9 = 91;
        v12 = v9 + 1;
        if ( v8 == (char *)-1 )
        {
          if ( nvram_match_def("usblogd_en", "1") )
          {
            v24 = read_sysmessage_file("/var/log/messages2", v11 + 1, 0x1FFFFF);
            v23 = v24;
            v22 = 0x1FFFFF - v24;
          }
          else
          {
            v22 = 0x1FFFFF;
            v23 = 0;
            v24 = 0;
          }
          v25 = v24 + read_sysmessage_file("/var/log/messages.0", &v12[v23], v22);
          v13 = (char *)(v25 + read_sysmessage_file("/var/log/messages", &v12[v25], 0x1FFFFF - v25));
          v15 = &v13[(_DWORD)v12];
          if ( v13 )
            goto LABEL_19;
        }
        else if ( v8 == (char *)-2 )
        {
          if ( nvram_match_def("usblogd_en", "1") )
          {
            v28 = read_ovpn_file("/var/log/openvpn2.log", v11 + 1, 0x1FFFFF);
            v27 = v28;
            v26 = 0x1FFFFF - v28;
          }
          else
          {
            v26 = 0x1FFFFF;
            v27 = 0;
            v28 = 0;
          }
          v13 = (char *)(v28 + read_ovpn_file("/var/log/openvpn.log", &v12[v27], v26));
          v15 = &v13[(_DWORD)v12];
          if ( v13 )
            goto LABEL_19;
        }
        else if ( v8 != (char *)-3 )
        {
          if ( v8 == (char *)2 )
          {
            v29 = read_vpnmessage_file(v9 + 1, 0x1FFFFF);
            v13 = &read_ipsec_file(&v29[(_DWORD)v12], 0x1FFFFF)[(_DWORD)v29];
            v15 = &v13[(_DWORD)v12];
            if ( v13 )
              goto LABEL_19;
          }
          else
          {
            if ( v8 == (char *)39 )
            {
              v13 = (char *)((int (__fastcall *)(_BYTE *, int, int))read_vpnmessage_file)(v9 + 1, 0x1FFFFF, v10);
            }
            else if ( v8 == (char *)26 )
            {
              v13 = (char *)((int (__fastcall *)(_BYTE *, int, int))read_error_by_ipsec_file)(v9 + 1, 0x1FFFFF, v10);
            }
            else
            {
              if ( v8 != (char *)28 )
              {
                v13 = (char *)read_log_data(v8, v9 + 1, 0x1FFFFF, v4);
                v14 = 2;
                if ( !v13 )
                  goto LABEL_20;
                v15 = &v13[(_DWORD)v12];
LABEL_19:
                v12 = v15 - 1;
                *(v15 - 1) = 0;
                v14 = (int)(v13 + 1);
LABEL_20:
                *v12 = 93;
                v12[1] = 0;
                if ( v8 == (char *)34 )
                  *(_DWORD *)(a1 + 36) |= 0x8000u;
                return httpd_send_mime_file(a1, "application/binary-file", v11, v14);
              }
              v13 = (char *)((int (__fastcall *)(_BYTE *, int, int))read_ipsec_file)(v9 + 1, 0x1FFFFF, 2031616);
            }
            v15 = &v13[(_DWORD)v12];
            if ( v13 )
              goto LABEL_19;
          }
        }
        v11[1] = 93;
        v14 = 2;
        v11[2] = 0;
        return httpd_send_mime_file(a1, "application/binary-file", v11, v14);
      }
      v16 = *(unsigned __int8 *)(a1 + 210102);
      v17 = (const char *)0x200000;
      v18 = 4;
    }
    else
    {
LABEL_22:
      v16 = *(unsigned __int8 *)(a1 + 210102);
      v17 = "not logid";
      v18 = 12;
    }
  }
  else
  {
    v16 = *(unsigned __int8 *)(a1 + 210102);
    v17 = "not id";
    v18 = 12;
  }
  v19 = (const char *)_GET_LANG_TEXT(v18, v16, v17);
  v20 = snprintf(v30, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
  if ( v20 >= 0x100 )
    v20 = 255;
  return httpd_cgi_ret(a1, v30, v20, 4);
}
// 454F64: variable 'v9' is possibly undefined
// 455208: variable 'v10' is possibly undefined
// 66F110: using guessed type char *ll_log_str;
// 66F118: using guessed type void *off_66F118;
// 6A8294: using guessed type int __fastcall read_ovpn_file(_DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A868C: using guessed type int __fastcall read_sysmessage_file(_DWORD, _DWORD, _DWORD);
// 6A88BC: using guessed type int __fastcall read_log_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004552E0) --------------------------------------------------------
int __fastcall sub_4552E0(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  char *v4; // $s0
  int v5; // $s0
  uint32_t v6; // $s3
  char *v7; // $v0
  char *v8; // $v0
  char *v9; // $s1
  char *v10; // $s2
  uint32_t v11; // $v0
  int v12; // $a1
  int v13; // $a2
  unsigned int v14; // $v0
  int v15; // $a1
  bool v16; // dc
  unsigned int v17; // $v0
  char *v18; // $a2
  const char *v19; // $v0
  unsigned int v20; // $v0
  const char *v22; // $v0
  int v23; // $s0
  char *v24; // $s7
  const char *v25; // $s0
  int v26; // $fp
  int v27; // $s3
  uint32_t v28; // $v0
  int v29; // $a0
  int v30; // $v0
  char *v31; // $a0
  int v32; // $v0
  int v33; // $s3
  char v34[128]; // [sp+38h] [-80h] BYREF

  v3 = httpd_get_parm(a1, "id");
  v2 = httpd_get_parm(a1, "iface");
  if ( v2 && (v4 = v2, strcmp(v2, "all")) )
  {
    v5 = J_atoi(v4);
    if ( v5 < 101 )
      ++v5;
  }
  else
  {
    v5 = 0;
  }
  v6 = J_atohx16(v3);
  _mem_malloc(0x200000, "shibie_id_data", 76);
  v9 = v8;
  _mem_malloc(0x100000, "shibie_id_data", 77);
  v10 = v7;
  if ( v9 && v7 )
  {
    *(_DWORD *)v7 = 34;
    *((_DWORD *)v7 + 3) = 13;
    *((_DWORD *)v7 + 1) = 0x100000;
    v11 = htonl(v6);
    v12 = *((_DWORD *)v10 + 1);
    *((_DWORD *)v10 + 4) = v11;
    *((_DWORD *)v10 + 5) = v5;
    if ( jianhl_order_opt_fun(v10, v12, v13) )
    {
      v15 = *(unsigned __int8 *)(a1 + 210102);
      v18 = "";
LABEL_18:
      v22 = (const char *)_GET_LANG_TEXT(3, v15, v18);
      v23 = snprintf(v9, 0x200000, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v22);
      if ( v23 >= 0x200000 )
        v23 = 0x1FFFFF;
      _mem_free(v10);
      return httpd_cgi_ret(a1, v9, v23, 8);
    }
    v14 = *((_DWORD *)v10 + 2);
    if ( v14 )
    {
      v15 = *(unsigned __int8 *)(a1 + 210102);
      v16 = v14 >= 0x33;
      v17 = v14;
      if ( v16 || (v18 = (char *)jhlret_err_str[v17]) == 0 )
        v18 = "not find err!";
      goto LABEL_18;
    }
    strcpy(v9, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy(v9, "{\"code\":0,\"error", 16);
    v24 = v9 + 29;
    if ( *((int *)v10 + 6) <= 0 )
    {
      v30 = 28;
      v29 = 29;
      v27 = 29;
    }
    else
    {
      v25 = v10 + 40;
      v26 = 0;
      v27 = 29;
      do
      {
        ++v26;
        v28 = ntohl(*((_DWORD *)v25 - 2));
        v27 += sprintf(
                 v24,
                 "{\"id\":\"%08X\",\"n\":\"%s\",\"cn\":%d,\"su\":%u,\"sd\":%u,\"cu\":%llu,\"cd\":%llu},",
                 v28,
                 v25,
                 *((_DWORD *)v25 - 1),
                 *((_DWORD *)v25 + 8),
                 *((_DWORD *)v25 + 9),
                 *((_QWORD *)v25 + 5),
                 *((_QWORD *)v25 + 6));
        v29 = v27;
        v24 = &v9[v27];
        if ( v26 >= *((_DWORD *)v10 + 6) )
          break;
        v25 += 64;
      }
      while ( 0x200000 - v27 >= 500 );
      v30 = v27 - 1;
      if ( v27 <= 0 )
      {
        v31 = &v9[v27];
LABEL_29:
        *v31 = 0;
        v32 = snprintf(v31, 0x200000 - v27, "]}");
        if ( v32 >= 0x200000 - v27 )
          v32 = 0x1FFFFF - v27;
        v33 = v27 + v32;
        _mem_free(v10);
        return jhl_data_giz(a1, v9, v33, 0x200000);
      }
    }
    if ( v9[v30] == 44 )
      v31 = &v9[--v27];
    else
      v31 = &v9[v29];
    goto LABEL_29;
  }
  _mem_free(v9);
  _mem_free(v10);
  v19 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v20 = snprintf(v34, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
  if ( v20 >= 0x80 )
    v20 = 127;
  return httpd_cgi_ret(a1, v34, v20, 4);
}
// 4553C0: variable 'v8' is possibly undefined
// 4553CC: variable 'v7' is possibly undefined
// 45540C: variable 'v13' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8244: using guessed type int __fastcall J_atohx16(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004557F4) --------------------------------------------------------
int __fastcall sub_4557F4(int a1)
{
  char *v1; // $v0
  int v2; // $a2
  char *v3; // $v0
  char *v4; // $s0
  char *v5; // $s6
  char *v6; // $s7
  const char *v7; // $s2
  int v8; // $fp
  int v9; // $s1
  uint32_t v10; // $v0
  int v11; // $t1
  int v12; // $v0
  char *v13; // $a0
  unsigned int v14; // $s2
  unsigned int v15; // $v0
  int result; // $v0
  const char *v17; // $v0
  unsigned int v18; // $s1
  int v19; // $a2
  const char *v20; // $v0
  unsigned int v21; // $v0
  char v22[128]; // [sp+20h] [-88h] BYREF
  int v23; // [sp+A0h] [-8h]

  _mem_malloc(1024000, "shibie_app_data", 162);
  v4 = v3;
  _mem_malloc(1024000, "shibie_app_data", 163);
  v5 = v1;
  if ( !v4 || !v1 )
  {
    _mem_free(v4);
    _mem_free(v5);
    v20 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v21 = snprintf(v22, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v20);
    if ( v21 >= 0x80 )
      result = httpd_cgi_ret(a1, v22, 127, 4);
    else
      result = httpd_cgi_ret(a1, v22, v21, 4);
    return result;
  }
  *(_DWORD *)v1 = 34;
  *((_DWORD *)v1 + 3) = 8;
  *((_DWORD *)v1 + 1) = 1024000;
  if ( !jianhl_order_opt_fun(v1, 1024000, v2) )
  {
    strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy(v4, "{\"code\":0,\"error", 16);
    v6 = v4 + 29;
    if ( *((int *)v5 + 5) <= 0 )
    {
      _mem_free(v5);
      v9 = 29;
      v12 = 28;
      v11 = 29;
    }
    else
    {
      v7 = v5 + 28;
      v8 = 0;
      v9 = 29;
      do
      {
        ++v8;
        v10 = ntohl(*((_DWORD *)v7 - 1));
        v9 += sprintf(v6, "{\"n\":\"%s\",\"id\":\"%08x\"},", v7, v10);
        v6 = &v4[v9];
        if ( v8 >= *((_DWORD *)v5 + 5) )
          break;
        v7 += 68;
      }
      while ( (unsigned int)(1024000 - v9) >= 0xC8 );
      v23 = v9;
      _mem_free(v5);
      v11 = v9;
      v12 = v9 - 1;
      if ( v9 <= 0 )
      {
        v13 = &v4[v9];
LABEL_12:
        v14 = 1024000 - v11;
        v23 = v11;
        *v13 = 0;
        v15 = snprintf(v13, 1024000 - v11, "]}");
        if ( v15 >= v14 )
          v15 = 1023999 - v23;
        return httpd_cgi_ret(a1, v4, v23 + v15, 8);
      }
    }
    if ( v4[v12] == 44 )
      v11 = v9 - 1;
    v13 = &v4[v11];
    goto LABEL_12;
  }
  v17 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
  v18 = snprintf(v22, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
  _mem_free(v5);
  v19 = v18;
  if ( v18 >= 0x80 )
    v19 = 127;
  return httpd_cgi_ret(a1, v4, v19, 8);
}
// 455868: variable 'v3' is possibly undefined
// 455874: variable 'v1' is possibly undefined
// 45589C: variable 'v2' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00455C00) --------------------------------------------------------
void __fastcall qos_parm_apply(int a1, int a2, int a3)
{
  _BOOL4 v3; // $s3
  int v7; // $v0
  const char *v8; // $v0
  int v9; // $v0
  int v10; // $v0
  int v11; // $s5
  int v12; // $s4
  char *v13; // $fp
  int v14; // $v0
  char *v15; // $s2
  int v16; // $v0
  int v17; // $v0
  int v18; // $s5
  int v19; // $s7
  int v20[128]; // [sp+38h] [-6F0h] BYREF
  char v21[512]; // [sp+238h] [-4F0h] BYREF
  char v22[512]; // [sp+438h] [-2F0h] BYREF
  int v23; // [sp+638h] [-F0h] BYREF
  int v24; // [sp+63Ch] [-ECh]
  char *v25; // [sp+640h] [-E8h]
  char *v26; // [sp+678h] [-B0h] BYREF
  const char *v27; // [sp+67Ch] [-ACh]
  char *v28; // [sp+680h] [-A8h]
  char *v29; // [sp+684h] [-A4h]
  const char *v30; // [sp+688h] [-A0h]
  const char *v31; // [sp+68Ch] [-9Ch]
  const char *v32; // [sp+690h] [-98h]
  const char *v33; // [sp+694h] [-94h]
  const char *v34; // [sp+698h] [-90h]
  char *v35; // [sp+69Ch] [-8Ch]
  char *v36; // [sp+6A0h] [-88h]
  const char *v37; // [sp+6A4h] [-84h]
  char *v38; // [sp+6A8h] [-80h]
  char *v39; // [sp+6ACh] [-7Ch]
  char v40[32]; // [sp+6B8h] [-70h] BYREF
  char v41[32]; // [sp+6D8h] [-50h] BYREF
  int v42; // [sp+6F8h] [-30h]

  if ( !a2 )
    return;
  v3 = a1 < 101;
  if ( a1 < 101 )
    v7 = jhl_nvget("qos_dk", a1);
  else
    v7 = jhl_vpnget("vpnqos_dk", a1 - 101);
  v8 = (const char *)nvram_get(v7);
  if ( v8 && *v8 )
  {
    v42 = 0;
  }
  else
  {
    v42 = 1;
    v8 = "on|hi|0|0|75|85|1000|2000|5|10|4|1500|8|16";
  }
  strlcpy(v22, v8, 512);
  v9 = split_string(v22, 124, &v26, 14);
  v26 = "on";
  if ( v9 < 14 )
  {
    v28 = "0";
    v29 = "0";
    v30 = "75";
    v27 = "hi";
    v31 = "85";
    v32 = "1000";
    v33 = "2000";
    v34 = (const char *)&unk_4D15F8;
    v35 = "10";
    v36 = "4";
    v37 = "1500";
    v38 = "8";
    v39 = "16";
  }
  strlcpy(v21, a2, 512);
  v10 = split_string(v21, 124, &v23, 14);
  if ( v10 == 2 )
  {
    v18 = J_atoi(v23);
    v19 = J_atoi(v24);
    sprintf(v41, "%u", v18);
    sprintf(v40, "%u", v19);
    if ( strcmp(v28, v41) || strcmp(v29, v40) )
    {
      v28 = v41;
      v29 = v40;
      goto LABEL_18;
    }
  }
  else
  {
    if ( v10 != 3 )
      return;
    v11 = J_atoi(v23);
    v12 = J_atoi(v24);
    sprintf(v41, "%u", v11);
    sprintf(v40, "%u", v12);
    v13 = v25;
    if ( strcmp(v25, "on") && strcmp(v13, (const char *)&off_63F984) )
    {
      v25 = "on";
      v13 = "on";
    }
    if ( strcmp(v28, v41) || strcmp(v29, v40) || strcmp(v26, v13) )
    {
      v28 = v41;
      v29 = v40;
      v26 = v13;
      goto LABEL_18;
    }
  }
  if ( !v42 )
    return;
LABEL_18:
  if ( !a3 )
    goto LABEL_22;
  if ( !v3 )
  {
    v17 = jhl_vpnget(&unk_645880, a1 - 101);
    v15 = (char *)nvram_get(v17);
    if ( !v15 )
      v15 = "";
    v14 = jhl_get_wan_proto(a1);
    if ( !*v15 )
      goto LABEL_22;
    goto LABEL_33;
  }
  v15 = (char *)jhl_get_wan_name(a1);
  v14 = jhl_get_wan_proto(a1);
  if ( v15 && *v15 )
  {
LABEL_33:
    if ( v14 )
    {
      v20[0] = (int)"wys";
      v20[1] = (int)"qos";
      v20[2] = (int)"set";
      v20[4] = (int)v26;
      v20[5] = (int)v27;
      v20[6] = (int)v28;
      v20[3] = (int)v15;
      v20[7] = (int)v29;
      v20[8] = (int)v30;
      v20[9] = (int)v31;
      v20[10] = (int)v32;
      v20[11] = (int)v33;
      v20[12] = (int)v34;
      v20[13] = (int)v35;
      v20[14] = (int)v36;
      v20[15] = (int)v37;
      v20[16] = (int)v38;
      v20[17] = (int)v39;
      v20[18] = 0;
      eval(v20, 0, 0, 0);
      mr_set(a1);
    }
  }
LABEL_22:
  sprintf(
    (char *)v20,
    "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s",
    v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39);
  if ( v3 )
    v16 = jhl_nvget("qos_dk", a1);
  else
    v16 = jhl_vpnget("vpnqos_dk", a1 - 101);
  nvram_set(v16, v20);
}
// 63F984: using guessed type void *off_63F984;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8688: using guessed type int __fastcall jhl_get_wan_name(_DWORD);
// 6A8708: using guessed type int __fastcall mr_set(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004562DC) --------------------------------------------------------
void __fastcall format_spqos_data(const char **a1, int a2, char *a3, int a4)
{
  const char *v4; // $s3

  if ( a2 >= 17 )
  {
    v4 = *a1;
    if ( strcmp(*a1, "aaabbbzzzf") )
      snprintf(
        a3,
        a4,
        "{\"name\":\"%s\",\"en\":%s,\"rpri\":%s,\"dev_prio\":%s,\"hi_prio\":%s,\"bh\":%s,\"type\":%s,\"thd_type\":%s,\"sx"
        "\":%s,\"xx\":%s,\"ips\":\"%s\",\"wans\":\"%s\",\"thd\":\"%s\",\"shibie_id\":\"%s\",\"ipport\":\"%s\",\"time\":\""
        "%s\",\"flowed_val\":%s},",
        v4,
        a1[1],
        a1[2],
        a1[3],
        a1[4],
        a1[5],
        a1[6],
        a1[7],
        a1[8],
        a1[9],
        a1[10],
        a1[11],
        a1[12],
        a1[13],
        a1[14],
        a1[15],
        a1[16]);
  }
}

//----- (0045642C) --------------------------------------------------------
int __fastcall spqos_data(const char *a1, int a2)
{
  int v2; // $v0
  int v3; // $fp
  _BYTE *v4; // $s2
  int v5; // $s0
  const char **v6; // $s1
  void *v7; // $v0
  _DWORD *v8; // $s5
  int v9; // $a1
  void *v10; // $s0
  int v11; // $s4
  _DWORD *v12; // $s6
  int v13; // $s0
  int i; // $s7
  int v15; // $v0
  int v16; // $v0
  int v17; // $s3
  char *v18; // $a0
  int v19; // $v0
  int v20; // $s0
  int v21; // $v0
  int v22; // $s0
  _DWORD *v23; // $v0
  int v24; // $v0
  int v25; // $a0
  const char *v26; // $a1
  int v27; // $a2
  int v28; // $a3
  int v29; // $a2
  char v30; // $t0
  char v31; // $a3
  int v32; // $s0
  int v33; // $a2
  const char *v35; // $s1
  const char *v36; // $v0
  const char *v37; // $v0
  unsigned int v38; // $v0
  char v39[64]; // [sp+20h] [-88h] BYREF
  char v40[64]; // [sp+60h] [-48h] BYREF
  void *ptr; // [sp+A0h] [-8h]

  memset(v39, 0, sizeof(v39));
  _mem_malloc(0x200000, "spqos_data", 260);
  if ( v2 )
  {
    v3 = v2;
    snprintf(v39, 64, "sqos_%s", a1);
    v4 = (_BYTE *)(v3 + 47);
    strcpy((char *)v3, "{\"code\":0,\"error\":\"\",\"data\":{\"sqos3\":\"1\",\"all\":");
    qmemcpy((void *)v3, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v3 + 24) = 975331700;
    *(_DWORD *)(v3 + 29) = 1869706018;
    *(_DWORD *)(v3 + 33) = 975319923;
    v5 = nvram_get(v39);
    *(_BYTE *)(v3 + 47) = 91;
    *(_BYTE *)(v3 + 48) = 0;
    if ( v5 )
    {
      v6 = (const char **)malloc(0x4Cu);
      v8 = malloc(0x4008u);
      v7 = malloc(0x200000u);
      ptr = v7;
      if ( v7 )
      {
        if ( v6
          && (v9 = v5, v8)
          && (v10 = v7, strlcpy(v7, v9, 0x200000), v11 = split_string(v10, 60, v8, 4096), v11 > 0) )
        {
          v12 = v8;
          v13 = 1;
          for ( i = 0; i != v11; ++i )
          {
            v15 = split_string(*v12, 124, v6, 17);
            format_spqos_data(v6, v15, &v4[v13], 2097105 - v13);
            v13 += v16;
            ++v12;
          }
          v17 = v13;
        }
        else
        {
          v17 = 1;
          v13 = 1;
        }
        free(ptr);
      }
      else
      {
        v17 = 1;
        v13 = 1;
      }
      if ( v6 )
        free(v6);
      if ( v8 )
        free(v8);
      if ( v13 <= 0 )
      {
        v18 = &v4[v17];
        goto LABEL_17;
      }
      v18 = &v4[v17];
      if ( v4[v17 - 1] != 44 )
      {
LABEL_17:
        *v18 = 0;
        v19 = snprintf(v18, 2097105 - v13, &byte_6445A0);
        if ( v19 >= 2097105 - v13 )
          v19 = 2097104 - v13;
        v20 = v13 + v19;
        v21 = v3 + v20 + 47;
        strcpy((char *)v21, ",\"wans\":");
        *(_DWORD *)v21 = 1635197484;
        *(_DWORD *)(v21 + 4) = 975336302;
        v22 = v20 + 55 + get_wans_data((char *)(v3 + v20 + 55), 0x200000 - (v20 + 55));
        v23 = (_DWORD *)(v3 + v22);
        strcpy((char *)(v3 + v22), ",\"vpns\":");
        *v23 = 1886790188;
        v23[1] = 975336302;
        v24 = v22 + 8 + get_vpns_iface((_BYTE *)(v3 + v22 + 8));
        v25 = v3 + v24;
        v26 = ",\"qos_flowed\":\"1\",\"flowed_enable\":\"1\"";
        do
        {
          v27 = *((_DWORD *)v26 + 1);
          *(_DWORD *)v25 = *(_DWORD *)v26;
          *(_DWORD *)(v25 + 4) = v27;
          v28 = *((_DWORD *)v26 + 2);
          *(_DWORD *)(v25 + 4) = v27;
          *(_DWORD *)(v25 + 8) = v28;
          v29 = *((_DWORD *)v26 + 3);
          *(_DWORD *)(v25 + 8) = v28;
          *(_DWORD *)(v25 + 12) = v29;
          v26 += 16;
          *(_DWORD *)(v25 + 12) = v29;
          v25 += 16;
        }
        while ( v26 != "\":\"1\"" );
        v30 = v26[4];
        v31 = v26[5];
        *(_DWORD *)v25 = *(_DWORD *)v26;
        *(_BYTE *)(v25 + 4) = v30;
        *(_BYTE *)(v25 + 5) = v31;
        v32 = v24 + 37;
        if ( !strcmp(a1, "xz") )
        {
          v35 = (const char *)jhl_nv_get_def("qos_sp_ct_up");
          v36 = (const char *)jhl_nv_get_def("qos_sp_ct_dw");
          v32 += sprintf((char *)(v3 + v32), ",\"ct_up\":\"%s\",\"ct_dw\":\"%s\"", v35, v36);
        }
        v33 = snprintf((char *)(v3 + v32), 0x200000 - v32, "}}");
        if ( v33 >= 0x200000 - v32 )
          v33 = 0x1FFFFF - v32;
        return httpd_cgi_ret(a2, (char *)v3, v32 + v33, 8);
      }
    }
    else
    {
      v18 = (char *)(v3 + 48);
      v13 = 1;
      if ( *v4 != 44 )
        goto LABEL_17;
    }
    v18 = &v4[--v13];
    goto LABEL_17;
  }
  v37 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a2 + 210102), 0x200000);
  v38 = snprintf(v40, 64, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v37);
  if ( v38 >= 0x40 )
    v38 = 63;
  return httpd_cgi_ret(a2, v40, v38, 4);
}
// 4564A8: variable 'v2' is possibly undefined
// 45669C: variable 'v16' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 64331C: using guessed type int dword_64331C;
// 6445A0: using guessed type char byte_6445A0;
// 6448E0: using guessed type int dword_6448E0;
// 6459A8: using guessed type int dword_6459A8;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00456A14) --------------------------------------------------------
int __fastcall spqos_asp(const char *a1, int a2)
{
  char *v4; // $s1
  _WORD *v5; // $v0
  void *v6; // $v0
  void *v7; // $s3
  _WORD *v8; // $s2
  const char *v9; // $a2
  int v10; // $v0
  int v11; // $a1
  int v12; // $a0
  const char *v13; // $v0
  int v14; // $s7
  int v16; // $s6
  _DWORD *v17; // $s6
  const char *v18; // $v0
  int *v19; // $v1
  const char *v20; // $v0
  int v21; // $t0
  int v22; // $a3
  int v23; // $a2
  int v24; // $a1
  int v25; // $a0
  int v26; // $v0
  _BOOL4 v27; // $s1
  const char *v28; // $v0
  int s[64]; // [sp+58h] [-1E0h] BYREF
  const char *v30; // [sp+158h] [-E0h] BYREF
  char *v31; // [sp+15Ch] [-DCh]
  char *v32; // [sp+160h] [-D8h]
  char *v33; // [sp+164h] [-D4h]
  char *v34; // [sp+168h] [-D0h]
  char *v35; // [sp+16Ch] [-CCh]
  char *v36; // [sp+170h] [-C8h]
  char *v37; // [sp+174h] [-C4h]
  char *v38; // [sp+178h] [-C0h]
  char *v39; // [sp+17Ch] [-BCh]
  char *v40; // [sp+180h] [-B8h]
  char *v41; // [sp+184h] [-B4h]
  char *v42; // [sp+188h] [-B0h]
  char *v43; // [sp+18Ch] [-ACh]
  char *v44; // [sp+190h] [-A8h]
  char *v45; // [sp+194h] [-A4h]
  char *v46; // [sp+198h] [-A0h]
  char v47[68]; // [sp+1A4h] [-94h] BYREF
  char *v48; // [sp+1E8h] [-50h]
  int v49; // [sp+1ECh] [-4Ch]
  char *v50; // [sp+1F0h] [-48h]
  char *v51; // [sp+1F4h] [-44h]
  char *v52; // [sp+1F8h] [-40h]
  char *v53; // [sp+1FCh] [-3Ch]
  char *v54; // [sp+200h] [-38h]
  char *v55; // [sp+204h] [-34h]
  char *v56; // [sp+208h] [-30h]
  char *v57; // [sp+20Ch] [-2Ch]
  char *v58; // [sp+210h] [-28h]
  char *v59; // [sp+214h] [-24h]
  char *v60; // [sp+218h] [-20h]
  char *v61; // [sp+21Ch] [-1Ch]
  char *v62; // [sp+220h] [-18h]
  char *v63; // [sp+224h] [-14h]
  char *v64; // [sp+228h] [-10h]
  char *v65; // [sp+22Ch] [-Ch]
  int v66; // [sp+230h] [-8h]

  memset(v47, 0, 0x40u);
  v48 = httpd_get_parm(a2, "name");
  v49 = (int)httpd_get_parm(a2, "old_name");
  v50 = httpd_get_parm(a2, "en");
  v51 = httpd_get_parm(a2, "rpri");
  v52 = httpd_get_parm(a2, "dev_prio");
  v53 = httpd_get_parm(a2, "hi_prio");
  v54 = httpd_get_parm(a2, "bh");
  v55 = httpd_get_parm(a2, "type");
  v56 = httpd_get_parm(a2, "thd_type");
  v57 = httpd_get_parm(a2, "sx");
  v58 = httpd_get_parm(a2, "xx");
  v59 = httpd_get_parm(a2, "ips");
  v60 = httpd_get_parm(a2, "wans");
  v61 = httpd_get_parm(a2, (char *)&off_645A5C);
  v62 = httpd_get_parm(a2, "shibie_id");
  v63 = httpd_get_parm(a2, "ipport");
  v64 = httpd_get_parm(a2, "time");
  v65 = httpd_get_parm(a2, "flowed_val");
  v66 = httpd_get_json_parm(a2, (int)"del_list");
  v4 = httpd_get_parm(a2, "opt");
  _mem_malloc(102400, "spqos_asp", 359);
  v7 = v6;
  _mem_malloc(102400, "spqos_asp", 360);
  v8 = v5;
  if ( v7 )
  {
    v9 = (const char *)102400;
    if ( !v5 )
    {
      v11 = *(unsigned __int8 *)(a2 + 210102);
      v12 = 4;
      goto LABEL_11;
    }
    if ( !a1 )
    {
      v11 = *(unsigned __int8 *)(a2 + 210102);
      v9 = "not type param";
      v12 = 12;
      goto LABEL_11;
    }
    v10 = a2 + 196608;
    if ( !v4 )
    {
LABEL_10:
      v11 = *(unsigned __int8 *)(v10 + 13494);
      v9 = "not opt";
      v12 = 12;
LABEL_11:
      v13 = (const char *)_GET_LANG_TEXT(v12, v11, v9);
      goto LABEL_12;
    }
    if ( strcmp(v4, (const char *)&off_646D8C)
      && strcmp(v4, (const char *)&off_648DDC)
      && strcmp(v4, "del")
      && strcmp(v4, "delall") )
    {
      v10 = a2 + 196608;
      goto LABEL_10;
    }
    snprintf(v47, 64, "sqos_%s", a1);
    if ( !strcmp(v4, "delall") )
    {
      if ( set_qos_to_kernel(a1, v4, &v30) )
        goto LABEL_36;
      *v8 = 32;
      goto LABEL_42;
    }
    if ( !strcmp(v4, "del") )
    {
      v16 = v66;
      if ( v66 )
      {
        if ( cJSON_IsArray(v66) )
        {
          v17 = *(_DWORD **)(v16 + 8);
          if ( !v17 )
            goto LABEL_36;
          v18 = (const char *)v17[4];
          if ( !v18 )
            goto LABEL_36;
          v49 = 0;
          v48 = (char *)102400;
          do
          {
            v30 = v18;
            if ( set_qos_to_kernel(a1, v4, &v30) >= 0 )
            {
              jhl_parm_get(v47, v7, v48);
              if ( nvparm_del_str(v7, 60, 19, v30, 124, 0, v8) )
              {
                jhl_parm_set(v47, v8);
                v49 = 1;
              }
            }
            v17 = (_DWORD *)*v17;
            if ( !v17 )
              break;
            v18 = (const char *)v17[4];
          }
          while ( v18 );
          if ( !v49 )
            goto LABEL_36;
          goto LABEL_42;
        }
      }
    }
    if ( !v48 )
    {
      v11 = *(unsigned __int8 *)(a2 + 210102);
      v9 = (const char *)&unk_6442E4;
      v12 = 12;
      goto LABEL_11;
    }
    v30 = v48;
    if ( v49 )
    {
      if ( strcmp(v4, (const char *)&off_648DDC) )
      {
        if ( strcmp(v4, (const char *)&off_646D8C) )
          goto LABEL_36;
        goto LABEL_33;
      }
      s[0] = (int)"qos_del.sh";
      s[1] = (int)a1;
      s[2] = v49;
      s[3] = 0;
      eval(s, 0, 0, 0);
    }
    if ( strcmp(v4, (const char *)&off_646D8C) )
    {
      if ( strcmp(v4, (const char *)&off_648DDC) )
      {
LABEL_36:
        v19 = s;
        v20 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v21 = *(_DWORD *)v20;
          v22 = *((_DWORD *)v20 + 1);
          v23 = *((_DWORD *)v20 + 2);
          v24 = *((_DWORD *)v20 + 3);
          v20 += 16;
          *v19 = v21;
          v19[1] = v22;
          v19[2] = v23;
          v19[3] = v24;
          v19 += 4;
        }
        while ( v20 != "}" );
        v14 = 33;
        *(_WORD *)v19 = *(_WORD *)v20;
        goto LABEL_39;
      }
      goto LABEL_47;
    }
LABEL_33:
    v14 = check_rule_num_limit(a2, 7, (int)v47, 60, (char *)s, 0x100u);
    if ( v14 > 0 )
    {
LABEL_39:
      _mem_free(v7);
      goto LABEL_14;
    }
    jhl_parm_get(v47, v8, 102400);
    if ( nvparm_find_str(v8, 60, 19, v48, 124, 0) )
    {
      v13 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a2 + 210102), "same name");
LABEL_12:
      v14 = snprintf((char *)s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
      if ( (unsigned int)v14 >= 0x100 )
      {
        _mem_free(v7);
        v14 = 255;
        goto LABEL_14;
      }
      goto LABEL_39;
    }
LABEL_47:
    if ( !v50 || !*v50 )
      v50 = "0";
    v31 = v50;
    if ( !v51 || !*v51 )
      v51 = "0";
    v32 = v51;
    if ( !v52 || !*v52 )
      v52 = "0";
    v33 = v52;
    if ( !v53 || !*v53 )
      v53 = "0";
    v34 = v53;
    if ( !v54 || !*v54 )
      v54 = "0";
    v35 = v54;
    if ( !v55 || !*v55 )
      v55 = "0";
    v36 = v55;
    if ( !v56 || !*v56 )
      v56 = "0";
    v37 = v56;
    if ( !v57 || !*v57 )
      v57 = "0";
    v38 = v57;
    if ( !v58 || !*v58 )
      v58 = "0";
    v39 = v58;
    if ( !v59 || !*v59 )
      v59 = "";
    v40 = v59;
    if ( !v60 || !*v60 )
      v60 = "";
    v41 = v60;
    if ( !v61 || !*v61 )
      v61 = "";
    v42 = v61;
    if ( !v62 || !*v62 )
      v62 = "00000000";
    v43 = v62;
    if ( !v63 || !*v63 )
      v63 = "";
    v44 = v63;
    if ( !v64 || !*v64 )
      v64 = "OFF";
    v45 = v64;
    if ( !v65 || !*v65 )
      v65 = "0";
    v46 = v65;
    if ( set_qos_to_kernel(a1, v4, &v30) < 0 )
      goto LABEL_36;
    jhl_parm_get(v47, v7, 102400);
    memset(v8, 0, 0x19000u);
    if ( v49 )
      v26 = nvparm_del_str(v7, 60, 19, v49, 124, 0, v8);
    else
      v26 = nvparm_del_str(v7, 60, 19, v48, 124, 0, v8);
    v27 = v26 != 0;
    sprintf(
      (char *)v7,
      "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<",
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      v42,
      v43,
      v44,
      v45,
      v46);
    if ( !v27 )
    {
      jhl_parm_get(v47, v8, 102400);
      if ( !strcmp((const char *)v8, " ") )
        *(_BYTE *)v8 = 0;
    }
    strcat((char *)v8, (char *)v7);
LABEL_42:
    jhl_parm_set(v47, v8);
    jhl_parm_commit(v25);
    goto LABEL_36;
  }
  v28 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a2 + 210102), 102400);
  v14 = snprintf((char *)s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v28);
  if ( (unsigned int)v14 >= 0x100 )
    v14 = 255;
LABEL_14:
  if ( v8 )
    _mem_free(v8);
  return httpd_cgi_ret(a2, (char *)s, v14, 4);
}
// 456CDC: variable 'v6' is possibly undefined
// 456CE8: variable 'v5' is possibly undefined
// 457190: variable 'v25' is possibly undefined
// 645A5C: using guessed type char *off_645A5C;
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A85DC: using guessed type int __fastcall set_qos_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (00457864) --------------------------------------------------------
int __fastcall spqos_cgi(const char *a1, int a2)
{
  int v2; // $s1
  int v3; // $s3
  char *v4; // $v0
  char *v5; // $s0
  char *v6; // $v0
  char *v7; // $s1
  char *v8; // $v0
  int v9; // $a1
  int v10; // $v1
  _BOOL4 v11; // $a2
  size_t v12; // $s1
  const char *v13; // $v0
  unsigned int v14; // $v0
  unsigned int v15; // $a2
  _DWORD *v17; // $s3
  int v18; // $s5
  int v19; // $s0
  const char **v20; // $s6
  int v21; // $fp
  int i; // $s7
  int v23; // $s0
  int v24; // $a0
  int v25; // $a2
  const char *v26; // $v0
  char v27[102400]; // [sp+20h] [-36630h] BYREF
  char v28[94208]; // [sp+19020h] [-1D630h] BYREF
  int v29; // [sp+30020h] [-6630h] BYREF
  char v30[10240]; // [sp+32020h] [-4630h] BYREF
  char v31[5120]; // [sp+34820h] [-1E30h] BYREF
  _BYTE v32[2048]; // [sp+35C20h] [-A30h] BYREF
  int v33; // [sp+36420h] [-230h] BYREF
  _DWORD v34[4]; // [sp+36620h] [-30h] BYREF
  const char **v35; // [sp+36630h] [-20h]
  int v36; // [sp+36634h] [-1Ch]
  char *v37; // [sp+36638h] [-18h]
  int v38; // [sp+3663Ch] [-14h]
  int v39; // [sp+36640h] [-10h]
  int *v40; // [sp+36644h] [-Ch]
  int v41; // [sp+36648h] [-8h]
  char **v42; // [sp+3664Ch] [-4h]

  v34[0] = 0;
  v34[1] = 0;
  v34[2] = 0;
  v34[3] = 0;
  v2 = a2 + 196608;
  v39 = get_rule_num_limit(7);
  snprintf((char *)v34, 16, "sqos_%s", a1);
  v3 = *(_DWORD *)(a2 + 205364);
  find_file_head(a2, *(const char **)(a2 + 205564));
  if ( !v4 )
    goto LABEL_12;
  v5 = v4;
  v6 = find_file_end(a2, v4, *(_DWORD *)(v2 + 8956) + v3 - (_DWORD)v4);
  v7 = v6;
  if ( !v6 )
    goto LABEL_12;
  *v6 = 0;
  jhl_parm_get(v34, v27, 102400);
  if ( !strcmp(v27, " ") )
    v27[0] = 0;
  if ( v7 - v5 <= 0 )
  {
    v9 = 0;
  }
  else
  {
    v8 = v5;
    v9 = 0;
    do
    {
      v10 = *v8++;
      v11 = v9 + 1 < 102399;
      if ( v10 != 13 && v10 != 10 )
      {
        v28[v9++] = v10;
        if ( !v11 )
          break;
      }
    }
    while ( v7 != v8 );
  }
  v28[v9] = 0;
  v12 = strlen(a1);
  if ( strncmp(v28, a1, v12) )
  {
LABEL_12:
    v13 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a2 + 210102), "Error reading file");
    v14 = snprintf(v31, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
    if ( v14 < 0x1400 )
    {
LABEL_13:
      v15 = v14;
      return httpd_cgi_ret(a2, v31, v15, 4);
    }
LABEL_24:
    v14 = 5119;
    goto LABEL_13;
  }
  v17 = v32;
  v36 = split_string(&v28[v12], 60, v32, 512);
  if ( v36 > 0 )
  {
    v41 = 0;
    v37 = v31;
    v35 = (const char **)&v33;
    v40 = &v29;
    v18 = 0;
    v42 = &off_646D8C;
    do
    {
      strlcpy(v37, *v17, 5120);
      v19 = split_string(*v17, 124, v35, 128);
      if ( v19 >= 10 )
      {
        v38 = v40[6400];
        if ( !nvparm_find_str(v27, 60, 19, v38, 124, 0) )
        {
          v20 = v35;
          set_qos_to_kernel(a1, v42, v35);
          v21 = 0;
          for ( i = 0; i != v19; ++i )
            v21 += sprintf(&v30[v21], "%s|", *v20++);
          *(_WORD *)&v30[v21 - 1] = 60;
          v23 = ++v41;
          strcat(v27, v30);
          if ( v23 >= v39 )
            break;
        }
      }
      ++v18;
      ++v17;
    }
    while ( v36 != v18 );
  }
  jhl_parm_set(v34, v27);
  jhl_parm_commit(v24);
  v26 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a2 + 210102), v25);
  v15 = snprintf(v31, 5120, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v26);
  if ( v15 >= 0x1400 )
    goto LABEL_24;
  return httpd_cgi_ret(a2, v31, v15, 4);
}
// 457984: variable 'v4' is possibly undefined
// 457E3C: variable 'v24' is possibly undefined
// 457E6C: variable 'v25' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A85DC: using guessed type int __fastcall set_qos_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00457EB8) --------------------------------------------------------
int __fastcall spqos_txt(const char *a1, int a2)
{
  char *v4; // $v0
  const char *v5; // $v0
  char *v6; // $s1
  int v7; // $v0
  int result; // $v0
  const char *v9; // $v0
  unsigned int v10; // $v0
  char v11[256]; // [sp+20h] [-114h] BYREF
  int v12[5]; // [sp+120h] [-14h] BYREF

  v12[0] = 0;
  v12[1] = 0;
  v12[2] = 0;
  v12[3] = 0;
  snprintf((char *)v12, 16, "sqos_%s", a1);
  _mem_malloc(0x200000, "spqos_txt", 674);
  if ( v4 )
  {
    v6 = v4;
    v5 = (const char *)nvram_get(v12);
    if ( !v5 )
      v5 = " ";
    v7 = sprintf(v6, "%s%s", a1, v5);
    *(_DWORD *)(a2 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a2, "application/binary-file", v6, v7);
  }
  else
  {
    v9 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a2 + 210102), 0x200000);
    v10 = snprintf(v11, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 >= 0x100 )
      v10 = 255;
    result = httpd_cgi_ret(a2, v11, v10, 4);
  }
  return result;
}
// 457F38: variable 'v4' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0045805C) --------------------------------------------------------
int __fastcall sub_45805C(int a1)
{
  int v2; // $v0
  int v3; // $s1
  int v4; // $s4
  int v5; // $s0
  int v6; // $s2
  int v7; // $v0
  char *v8; // $s6
  int v9; // $v0
  const char *v10; // $v0
  int v11; // $v0
  _BYTE *v12; // $v0
  int v13; // $v0
  int i; // $s0
  int v15; // $v0
  const char *v16; // $v0
  int v17; // $v0
  const char *v18; // $v0
  const char *v19; // $s4
  const char *v20; // $s5
  const char *v21; // $s0
  const char *v22; // $s3
  const char *v23; // $v0
  int v24; // $s2
  int v25; // $v0
  int v26; // $a2
  int result; // $v0
  const char *v28; // $v0
  unsigned int v29; // $a2
  char v30[256]; // [sp+28h] [-110h] BYREF
  const char *v31; // [sp+128h] [-10h]
  char *format; // [sp+12Ch] [-Ch]
  char *v33; // [sp+130h] [-8h]

  _mem_malloc(0x200000, "qos_data", 702);
  if ( v2 )
  {
    v3 = v2;
    v4 = sq_file_get_max_wan();
    strcpy((char *)v3, "{\"code\":0,\"error\":\"\",\"data\":{\"wans\":\"");
    qmemcpy((void *)v3, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v3 + 24) = 975331700;
    *(_BYTE *)(v3 + 32) = 110;
    if ( v4 <= 0 )
    {
      v6 = 37;
    }
    else
    {
      v33 = "a";
      v31 = "qos_dk";
      v5 = 0;
      v6 = 37;
      format = "%d|%s<";
      while ( 1 )
      {
        v7 = jhl_nvget("wan_ifname", v5);
        v8 = (char *)nvram_get(v7);
        if ( !v8 )
          v8 = "";
        if ( !*v8 )
          break;
        v9 = jhl_nvget("wan_down", v5);
        v10 = (const char *)nvram_get(v9);
        if ( v10 && !strcmp(v10, "1") || jhl_iface_link_up_check(v8, v5) )
        {
          if ( v4 == ++v5 )
            break;
        }
        else
        {
          v11 = jhl_nvget(v31, v5);
          v12 = (_BYTE *)nvram_get(v11);
          if ( !v12 || !*v12 )
            v12 = v33 + 20488;
          v13 = sprintf((char *)(v3 + v6), format, v5++, v12);
          v6 += v13;
          if ( v4 == v5 )
            break;
        }
      }
    }
    for ( i = 0; i != 5; ++i )
    {
      v15 = jhl_vpnget("vpn_proto", i);
      v16 = (const char *)nvram_get(v15);
      if ( !v16 || strcmp(v16, (const char *)&off_63F984) )
      {
        v17 = jhl_vpnget("vpnqos_dk", i);
        v18 = (const char *)nvram_get(v17);
        if ( !v18 || !*v18 )
          v18 = "on|hi|0|0|75|85|1000|2000|5|10|4|1500|8|16";
        v6 += sprintf((char *)(v3 + v6), "%d|%s<", i + 101, v18);
      }
    }
    v19 = (const char *)nvram_get("qosFip");
    if ( !v19 )
      v19 = "not";
    v20 = (const char *)jhl_nv_get_def("qosDns");
    v21 = (const char *)nvram_get("qosProt");
    if ( !v21 )
      v21 = "not";
    v22 = (const char *)nvram_get("qosInip");
    if ( !v22 )
      v22 = "not";
    v23 = (const char *)jhl_nv_get_def("qos_tmctl_en");
    v24 = v6
        + sprintf(
            (char *)(v3 + v6),
            "\",\"fip\":\"%s\",\"dns\":\"%s\",\"prot\":\"%s\",\"inip\":\"%s\",\"qos_tm_ctl\":\"%s\"",
            v19,
            v20,
            v21,
            v22,
            v23);
    v25 = snprintf((char *)(v3 + v24), 0x200000 - v24, "}}");
    if ( v25 >= 0x200000 - v24 )
      v26 = 0x1FFFFF - v24;
    else
      v26 = v25;
    result = httpd_cgi_ret(a1, (char *)v3, v26 + v24, 8);
  }
  else
  {
    v28 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v29 = snprintf(v30, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v28);
    if ( v29 >= 0x100 )
      v29 = 255;
    result = httpd_cgi_ret(a1, v30, v29, 4);
  }
  return result;
}
// 4580B8: variable 'v2' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (004585CC) --------------------------------------------------------
int __fastcall sub_4585CC(int a1)
{
  char *v1; // $s2
  char *v2; // $s3
  char *v3; // $s1
  char *v4; // $s0
  const char *v5; // $a0
  int v6; // $s5
  int v7; // $s0
  int v8; // $v0
  int v9; // $v0
  _DWORD *v10; // $fp
  int v11; // $s7
  int v12; // $s3
  int v13; // $s4
  const char *v14; // $s6
  int v15; // $s0
  int v16; // $v0
  char *v17; // $s0
  char *v18; // $v1
  const char *v19; // $v0
  int v20; // $t0
  int v21; // $a3
  int v22; // $a2
  int v23; // $a1
  int v25[64]; // [sp+20h] [-118h] BYREF
  int v26; // [sp+120h] [-18h]
  int v27; // [sp+124h] [-14h]
  char *v28; // [sp+128h] [-10h]
  char *v29; // [sp+12Ch] [-Ch]
  char *v30; // [sp+130h] [-8h]

  v1 = httpd_get_parm(a1, "fip");
  v2 = httpd_get_parm(a1, "dns");
  v3 = httpd_get_parm(a1, "prot");
  v4 = httpd_get_parm(a1, "inip");
  v26 = httpd_get_json_parm(a1, (int)"wans");
  if ( v1 )
    jhl_parm_set("qosFip", v1);
  if ( v2 )
    jhl_parm_set("qosDns", v2);
  if ( v3 )
    jhl_parm_set("qosProt", v3);
  if ( v4 )
    jhl_parm_set("qosInip", v4);
  if ( v1 || v2 )
  {
    if ( (*v1 & 0xDF) == 0 )
    {
      v1 = (char *)nvram_get("qosFip");
      if ( !v1 )
        v1 = "";
    }
    if ( (*v2 & 0xDF) == 0 )
    {
      v2 = (char *)nvram_get("qosDns");
      if ( !v2 )
        v2 = "";
    }
    if ( !v3 || (*v3 & 0xDF) == 0 )
    {
      v3 = (char *)nvram_get("qosProt");
      if ( !v3 )
        v3 = "";
    }
    if ( !v4 || (*v4 & 0xDF) == 0 )
    {
      v4 = (char *)nvram_get("qosInip");
      if ( !v4 )
        v4 = "";
    }
    v29 = (char *)v25;
    v25[0] = (int)"wys";
    v25[1] = (int)"qos";
    v25[2] = (int)"dns_ip";
    v25[3] = (int)v2;
    v25[4] = (int)v1;
    v25[5] = (int)v3;
    v25[6] = (int)v4;
    v25[7] = 0;
    eval(v25, 0, 0, 0);
  }
  else
  {
    v29 = (char *)v25;
  }
  if ( v26 )
  {
    v27 = cJSON_GetArraySize(v26);
    if ( v27 > 0 )
    {
      v28 = "a";
      v6 = 0;
      v30 = "a";
      do
      {
        v7 = cJSON_GetArrayItem(v26, v6);
        v8 = cJSON_GetObjectItem(v7, v28 + 13148);
        v9 = cJSON_GetIntvalue(v8);
        v10 = *(_DWORD **)(v7 + 8);
        v11 = v9;
        if ( v10 )
        {
          v12 = 0;
          v13 = 0;
          do
          {
            while ( 1 )
            {
              v14 = (const char *)v10[8];
              v15 = v10[4];
              v10 = (_DWORD *)*v10;
              v16 = strcmp(v14, "up");
              v5 = v14;
              if ( v16 )
                break;
              v12 = v15;
              if ( !v10 )
                goto LABEL_28;
            }
            if ( !strcmp(v14, "down") )
              v13 = v15;
          }
          while ( v10 );
LABEL_28:
          if ( v12 && v13 )
          {
            v17 = v29;
            snprintf(v29, 128, v30 + 22708, v12, v13);
            qos_parm_apply(v11, (int)v17, 1);
          }
        }
        ++v6;
      }
      while ( v27 != v6 );
    }
  }
  jhl_parm_commit(v5);
  v18 = v29;
  v19 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v20 = *(_DWORD *)v19;
    v21 = *((_DWORD *)v19 + 1);
    v22 = *((_DWORD *)v19 + 2);
    v23 = *((_DWORD *)v19 + 3);
    v19 += 16;
    *(_DWORD *)v18 = v20;
    *((_DWORD *)v18 + 1) = v21;
    *((_DWORD *)v18 + 2) = v22;
    *((_DWORD *)v18 + 3) = v23;
    v18 += 16;
  }
  while ( v19 != "}" );
  *(_WORD *)v18 = *(_WORD *)v19;
  return httpd_cgi_ret(a1, v29, 33, 4);
}
// 458960: variable 'v5' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8518: using guessed type int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD);
// 6A86FC: using guessed type int __fastcall cJSON_GetArraySize(_DWORD);
// 6A8744: using guessed type int __fastcall cJSON_GetIntvalue(_DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (00458AAC) --------------------------------------------------------
int __fastcall sub_458AAC(int a1)
{
  return spqos_data((const char *)&off_645B94, a1);
}
// 645B94: using guessed type void *off_645B94;

//----- (00458AD0) --------------------------------------------------------
int __fastcall sub_458AD0(int a1)
{
  return spqos_asp((const char *)&off_645B94, a1);
}
// 645B94: using guessed type void *off_645B94;

//----- (00458AF4) --------------------------------------------------------
int __fastcall sub_458AF4(int a1)
{
  return spqos_cgi((const char *)&off_645B94, a1);
}
// 645B94: using guessed type void *off_645B94;

//----- (00458B18) --------------------------------------------------------
int __fastcall sub_458B18(int a1)
{
  return spqos_txt((const char *)&off_645B94, a1);
}
// 645B94: using guessed type void *off_645B94;

//----- (00458B3C) --------------------------------------------------------
int __fastcall sub_458B3C(int a1)
{
  return spqos_data("xz", a1);
}

//----- (00458B60) --------------------------------------------------------
int __fastcall sub_458B60(int a1)
{
  return spqos_asp("xz", a1);
}

//----- (00458B84) --------------------------------------------------------
int __fastcall sub_458B84(int a1)
{
  return spqos_cgi("xz", a1);
}

//----- (00458BA8) --------------------------------------------------------
int __fastcall sub_458BA8(int a1)
{
  return spqos_txt("xz", a1);
}

//----- (00458BCC) --------------------------------------------------------
int __fastcall sub_458BCC(int a1)
{
  return spqos_data("bz", a1);
}

//----- (00458BF0) --------------------------------------------------------
int __fastcall sub_458BF0(int a1)
{
  return spqos_asp("bz", a1);
}

//----- (00458C14) --------------------------------------------------------
int __fastcall sub_458C14(int a1)
{
  return spqos_cgi("bz", a1);
}

//----- (00458C38) --------------------------------------------------------
int __fastcall sub_458C38(int a1)
{
  return spqos_txt("bz", a1);
}

//----- (00458C60) --------------------------------------------------------
int __fastcall sub_458C60(int a1)
{
  char **v1; // $v0
  const char **v3; // $v1
  char *v4; // $t0
  const char *v5; // $a3
  const char *v6; // $a2
  const char *v7; // $a1
  char *v8; // $a0
  const char *v9; // $v0
  int v10; // $v0
  int v11; // $s0
  int v12; // $v0
  int v13; // $s1
  int v14; // $s1
  int v15; // $s2
  int v16; // $v0
  int v17; // $a2
  int v18; // $s1
  int v19; // $a2
  const char *v21; // $v0
  unsigned int v22; // $v0
  char v23[256]; // [sp+20h] [-16Ch] BYREF
  const char *v24[27]; // [sp+120h] [-6Ch] BYREF

  v1 = off_66FCA0;
  v3 = v24;
  do
  {
    v4 = *v1;
    v5 = v1[1];
    v6 = v1[2];
    v7 = v1[3];
    v1 += 4;
    *v3 = v4;
    v3[1] = v5;
    v3[2] = v6;
    v3[3] = v7;
    v3 += 4;
  }
  while ( v1 != (char **)&off_66FD00 );
  v8 = *v1;
  v9 = v1[1];
  *v3 = v8;
  v3[1] = v9;
  _mem_malloc(10240, "webgl_data", 65);
  v11 = v10;
  if ( v10 )
  {
    v12 = nvram_match_def("pppoe_br_enable", "1");
    strcpy((char *)v11, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v11, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v11 + 24) = 975331700;
    v13 = sprintf((char *)(v11 + 29), "\"pppoe_br\":\"%d\",", v12 != 0) + 29;
    v14 = v13 + get_nvarms(v24, v11 + v13, 10240 - v13);
    v15 = pidof("dropbear");
    v16 = pidof("telnetd");
    if ( v16 < 0 )
    {
      v16 = 0;
      v17 = v15;
      if ( v15 >= 0 )
        goto LABEL_6;
    }
    else
    {
      v17 = v15;
      if ( v15 >= 0 )
      {
LABEL_6:
        v18 = v14 + sprintf((char *)(v11 + v14), "\"sdup\":\"%d\",\"tdup\":\"%d\"", v17, v16);
        v19 = snprintf((char *)(v11 + v18), 10240 - v18, "}}");
        if ( v19 >= 10240 - v18 )
          v19 = 10239 - v18;
        return httpd_cgi_ret(a1, (char *)v11, v19 + v18, 8);
      }
    }
    v17 = 0;
    goto LABEL_6;
  }
  v21 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
  v22 = snprintf(v23, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v21);
  if ( v22 >= 0x100 )
    v22 = 255;
  return httpd_cgi_ret(a1, v23, v22, 4);
}
// 458CFC: variable 'v10' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 66FCA0: using guessed type char *off_66FCA0[24];
// 66FD00: using guessed type void *off_66FD00;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8614: using guessed type int __fastcall pidof(_DWORD);

//----- (00458F3C) --------------------------------------------------------
int __fastcall sub_458F3C(int a1)
{
  char *v2; // $s6
  char *v3; // $fp
  char *v4; // $s7
  char *v5; // $s5
  const char *v6; // $v0
  _BOOL4 v7; // $s2
  const char *v8; // $v0
  const char *v9; // $v0
  const char *v10; // $v0
  char *v11; // $s1
  const char *v12; // $v0
  char *v13; // $s5
  const char *v14; // $v0
  char *v15; // $s3
  const char *v16; // $v0
  char *v17; // $s4
  const char *v18; // $v0
  int v19; // $a0
  const char *v20; // $v0
  int v21; // $s3
  unsigned int v22; // $v0
  unsigned int v23; // $a2
  int v25; // $s1
  char *v26; // $v0
  const char *v27; // $v0
  char *v28; // $s3
  char v29[512]; // [sp+20h] [-200h] BYREF

  v2 = httpd_get_parm(a1, "http_passwd");
  v3 = httpd_get_parm(a1, "http_username");
  v4 = httpd_get_parm(a1, "http_gpwd");
  v5 = httpd_get_parm(a1, "http_gname");
  if ( v3 )
  {
    v6 = (const char *)nvram_get("http_username");
    if ( v6 )
      v7 = strcmp(v6, v3) != 0;
    else
      v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  if ( v2 )
  {
    v8 = (const char *)nvram_get("http_passwd");
    if ( !v8 || strcmp(v8, v2) )
      v7 = 1;
  }
  if ( v5 )
  {
    v9 = (const char *)nvram_get("http_gname");
    if ( !v9 || strcmp(v9, v5) )
    {
      if ( !v4 )
        goto LABEL_15;
      v7 = 1;
LABEL_13:
      v10 = (const char *)nvram_get("http_gpwd");
      if ( !v10 || strcmp(v10, v4) )
        goto LABEL_15;
      goto LABEL_35;
    }
  }
  if ( v4 )
    goto LABEL_13;
LABEL_35:
  if ( !v7 )
  {
    if ( save_variables(a1, 0) )
      goto LABEL_16;
    goto LABEL_37;
  }
LABEL_15:
  nvram_set("user_pwd_mod", "0");
  v7 = 1;
  if ( save_variables(a1, 0) )
  {
LABEL_16:
    v11 = httpd_get_parm(a1, "http_lanport");
    if ( !v11 || (v12 = (const char *)nvram_get("http_lanport")) != 0 && !strcmp(v12, v11) )
      v11 = 0;
    v13 = httpd_get_parm(a1, "https_lanport");
    if ( !v13 || (v14 = (const char *)nvram_get("https_lanport")) != 0 && !strcmp(v14, v13) )
      v13 = 0;
    v15 = httpd_get_parm(a1, "tggl_port");
    if ( !v15 || (v16 = (const char *)nvram_get("tggl_port")) != 0 && !strcmp(v16, v15) )
      v15 = 0;
    v17 = httpd_get_parm(a1, "allow_ips");
    if ( !v17 || (v18 = (const char *)nvram_get("allow_ips")) != 0 && !strcmp(v18, v17) )
    {
      v17 = 0;
      if ( !save_variables(a1, 1) )
        goto LABEL_29;
    }
    else if ( !save_variables(a1, 1) )
    {
LABEL_29:
      strcpy(v29, "{\"code\":0,\"error\":\"\",\"data\":{");
      if ( v11 )
      {
        v20 = (const char *)nvram_get("lan_ipaddr");
        v21 = sprintf(&v29[29], "\"lan_ipaddr\":\"%s:%s\",\"mod_passwd\":\"%d\"", v20, v11, v7) + 29;
      }
      else
      {
        v21 = sprintf(&v29[29], "\"mod_passwd\":\"%d\"", v7) + 29;
      }
      v22 = snprintf(&v29[v21], 512 - v21, "}}");
      v23 = v22 + v21;
      if ( v22 >= 512 - v21 )
        v23 = 511;
      return httpd_cgi_ret(a1, v29, v23, 4);
    }
    jhl_parm_commit(v19);
    if ( httpd_get_parm(a1, "shortset_flag") )
    {
      nvram_unset("shortset_flag");
      goto LABEL_29;
    }
    jhl_setwanxx();
    if ( v11 )
    {
      start_rzgl(0);
      v28 = "jadmin-restart";
    }
    else
    {
      if ( v15 || v13 )
      {
        start_rzgl(0);
      }
      else if ( !v17 )
      {
        v28 = "admin-restart";
        goto LABEL_50;
      }
      v28 = "jadmin-restart";
    }
LABEL_50:
    jhl_httpd_reset_user();
    jhl_gl_restart_jhttpd(v28, 200);
    goto LABEL_29;
  }
LABEL_37:
  v25 = *(unsigned __int8 *)(a1 + 210102);
  v26 = resmsg_get();
  v27 = (const char *)_GET_LANG_TEXT(12, v25, v26);
  v23 = snprintf(v29, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
  if ( v23 >= 0x200 )
    v23 = 511;
  return httpd_cgi_ret(a1, v29, v23, 4);
}
// 459480: variable 'v19' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82B8: using guessed type int jhl_setwanxx(void);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (004595C8) --------------------------------------------------------
int __fastcall sub_4595C8(int a1)
{
  const char *v2; // $s1
  const char *v3; // $v0
  const char *v4; // $v0
  int v5; // $s2
  unsigned int v6; // $s1
  char v8[512]; // [sp+18h] [-200h] BYREF

  v2 = (const char *)nvram_get("lan_ipaddr");
  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v3 = (const char *)nvram_get("http_lanport");
  if ( v3 && !strcmp(v3, "80") )
  {
    v5 = sprintf(&v8[29], "\"ip\":\"%s\"", v2) + 29;
  }
  else
  {
    v4 = (const char *)nvram_get("http_lanport");
    v5 = sprintf(&v8[29], "\"ip\":\"%s:%s\"", v2, v4) + 29;
  }
  v6 = snprintf(&v8[v5], 512 - v5, "}}");
  if ( v6 >= 512 - v5 )
    v6 = 511 - v5;
  jhl_gl_reboot_timer(3000);
  return httpd_cgi_ret(a1, v8, v6 + v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (00459774) --------------------------------------------------------
int __fastcall sub_459774(int a1)
{
  void *v2; // $v0
  void *v3; // $s3
  int v4; // $s0
  int result; // $v0
  int v6; // $s0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[256]; // [sp+20h] [-140h] BYREF
  char v10; // [sp+120h] [-40h] BYREF
  char v11[63]; // [sp+121h] [-3Fh] BYREF

  _mem_malloc(0x100000, "wayosparm_cfg", 277);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v9, "/tmp/backupXXXXXX");
    wys_mkstemp(v9);
    dword_66FD28 = (int)v9;
    sprintf(&v10, ">%s.msg", v9);
    eval(off_66FD20, &v10, 0, 0);
    if ( f_exists(v9) )
    {
      v6 = do_file(v9, (int)v3, 0x100000);
      unlink(v9);
      unlink(v11);
      result = httpd_send_mime_file(a1, "application/binary-file", v3, v6);
    }
    else
    {
      v4 = do_file(v11, (int)v3, 0x100000);
      unlink(v11);
      result = httpd_cgi_ret(a1, (char *)v3, v4, 8);
    }
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x100000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 4597C4: variable 'v2' is possibly undefined
// 66FD20: using guessed type char *off_66FD20[2];
// 66FD28: using guessed type int dword_66FD28;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);
// 6A863C: using guessed type int __fastcall wys_mkstemp(_DWORD);

//----- (004599F0) --------------------------------------------------------
int __fastcall sub_4599F0(int a1)
{
  int v1; // $s0
  int v2; // $s3
  char *v3; // $v0
  char *v5; // $v0
  char *v6; // $s2
  char *v7; // $s0
  const char *v8; // $a2
  const char *v9; // $v0
  unsigned int v10; // $a2
  int v12; // $a2
  const char *v13; // $v0
  char v14[1024]; // [sp+20h] [-54Ch] BYREF
  char v15[256]; // [sp+420h] [-14Ch] BYREF
  char v16; // [sp+520h] [-4Ch] BYREF
  char v17[63]; // [sp+521h] [-4Bh] BYREF
  const char *v18; // [sp+560h] [-Ch]

  v1 = a1 + 196608;
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( !v3
    || (v6 = v3, v5 = find_file_end(a1, v3, *(_DWORD *)(v1 + 8956) + v2 - (_DWORD)v3), v7 = (char *)(v5 - v6), !v5) )
  {
    v8 = "Error reading file";
    goto LABEL_5;
  }
  if ( (unsigned int)(v7 - 64) >= 0x1FFFC1 )
  {
    v8 = "Invalid file";
    goto LABEL_5;
  }
  strcpy(v15, "/tmp/restoreXXXXXX");
  wys_mkstemp(v15);
  if ( v7 != (char *)f_write(v15, v6, v7, 0, 384) )
  {
    v8 = "Error writing temporary file";
LABEL_5:
    if ( v15[0] )
    {
      v18 = v8;
      unlink(v15);
      v8 = v18;
    }
    v9 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v8);
    v10 = snprintf(v14, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 < 0x400 )
      return httpd_cgi_ret(a1, v14, v10, 4);
LABEL_14:
    v10 = 1023;
    return httpd_cgi_ret(a1, v14, v10, 4);
  }
  prepare_upgrade();
  dword_66FD18 = (int)v15;
  sprintf(&v16, ">%s.msg", v15);
  if ( eval(off_66FD10, &v16, 0, 0) )
  {
    do_file(v17, (int)v14, 1024);
    unlink(v17);
  }
  if ( v15[0] )
    unlink(v15);
  nvram_commit();
  jhl_gl_reboot_timer(2000);
  v13 = (const char *)_GET_LANG_TEXT(48, *(unsigned __int8 *)(a1 + 210102), v12);
  v10 = snprintf(v14, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v13);
  if ( v10 >= 0x400 )
    goto LABEL_14;
  return httpd_cgi_ret(a1, v14, v10, 4);
}
// 459A3C: variable 'v3' is possibly undefined
// 459BD8: variable 'v12' is possibly undefined
// 66FD10: using guessed type char *off_66FD10[2];
// 66FD18: using guessed type int dword_66FD18;
// 6A81C0: using guessed type int prepare_upgrade(void);
// 6A8204: using guessed type int __fastcall f_write(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A863C: using guessed type int __fastcall wys_mkstemp(_DWORD);
// 6A87C4: using guessed type int nvram_commit(void);

//----- (00459D24) --------------------------------------------------------
int defaults_asp_timer_fun()
{
  int v1[5]; // [sp+18h] [-14h] BYREF

  killall_tk("wan_flow_mr");
  prepare_upgrade();
  killall("pppoecd", 15);
  sleep(1u);
  v1[0] = (int)"nvram";
  v1[1] = (int)"defaults";
  v1[2] = (int)"--yes";
  v1[3] = 0;
  return eval(v1, 0, 0, 0);
}
// 6A8178: using guessed type int __fastcall killall(_DWORD, _DWORD);
// 6A81C0: using guessed type int prepare_upgrade(void);
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00459DEC) --------------------------------------------------------
int __fastcall sub_459DEC(int a1)
{
  const char *v1; // $v0
  char *v3; // $v1
  int v4; // $t0
  int v5; // $a3
  int v6; // $a2
  int v7; // $a1
  char v9[516]; // [sp+18h] [-204h] BYREF

  v1 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v3 = v9;
  do
  {
    v4 = *(_DWORD *)v1;
    v5 = *((_DWORD *)v1 + 1);
    v6 = *((_DWORD *)v1 + 2);
    v7 = *((_DWORD *)v1 + 3);
    v1 += 16;
    *(_DWORD *)v3 = v4;
    *((_DWORD *)v3 + 1) = v5;
    *((_DWORD *)v3 + 2) = v6;
    *((_DWORD *)v3 + 3) = v7;
    v3 += 16;
  }
  while ( v1 != "}" );
  *(_WORD *)v3 = *(_WORD *)v1;
  jhl_gl_poweroff_timer(3000);
  return httpd_cgi_ret(a1, v9, 33, 4);
}

//----- (00459E94) --------------------------------------------------------
int __fastcall sub_459E94(int a1)
{
  int v2; // $a2
  int v3; // $s0
  const char *v4; // $v0
  const char *v5; // $v0
  const char *v6; // $s0
  int v7; // $s3
  unsigned int v8; // $v0
  int result; // $v0
  const char *v10; // $v0
  const char *v11; // $v0
  unsigned int v12; // $v0
  char v13[512]; // [sp+20h] [-20Ch] BYREF
  int v14; // [sp+220h] [-Ch] BYREF
  __int16 v15; // [sp+224h] [-8h]

  v14 = 0;
  v15 = 0;
  v3 = a1 + 196608;
  if ( wys_get_mac_by_ipaddr(a1 + 205460, &v14) )
  {
    v11 = (const char *)_GET_LANG_TEXT(209, *(unsigned __int8 *)(v3 + 13494), v2);
    v12 = snprintf(v13, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
    if ( v12 >= 0x200 )
      result = httpd_cgi_ret(a1, v13, 511, 4);
    else
      result = httpd_cgi_ret(a1, v13, v12, 4);
  }
  else
  {
    defaults_asp_timer_fun();
    jhl_gl_reboot_timer(3000);
    strcpy(v13, "{\"code\":0,\"error\":\"\",\"data\":{");
    v4 = (const char *)nvram_get("http_lanport");
    if ( v4 && !strcmp(v4, "80") )
    {
      v10 = (const char *)nvram_get("lan_ipaddr");
      v7 = sprintf(&v13[29], "\"ip\":\"%s\"", v10) + 29;
    }
    else
    {
      v6 = (const char *)nvram_get("lan_ipaddr");
      v5 = (const char *)nvram_get("http_lanport");
      v7 = sprintf(&v13[29], "\"ip\":\"%s:%s\"", v6, v5) + 29;
    }
    v8 = snprintf(&v13[v7], 512 - v7, "}}");
    if ( v8 >= 512 - v7 )
      v8 = 511 - v7;
    result = httpd_cgi_ret(a1, v13, v8 + v7, 4);
  }
  return result;
}
// 45A0A8: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8438: using guessed type int __fastcall wys_get_mac_by_ipaddr(_DWORD, _DWORD);

//----- (0045A138) --------------------------------------------------------
int __fastcall sub_45A138(int a1)
{
  const char *v2; // $s0
  const char *v3; // $v0
  int v4; // $v0
  char *v5; // $v1
  int v6; // $s0
  const char *v7; // $s4
  const char *v8; // $s1
  const char *v9; // $v0
  int v10; // $s0
  unsigned int v11; // $v0
  char v13[512]; // [sp+20h] [-200h] BYREF

  memset(v13, 0, sizeof(v13));
  v2 = (const char *)jhl_nv_get_def("auto_reboot_enable");
  v3 = (const char *)jhl_nv_get_def("auto_reboot_time");
  strcpy(v13, "{\"code\":0,\"error\":\"\",\"data\":{");
  v4 = sprintf(&v13[29], "\"enable\":\"%s\",\"time\":\"%s\",\"display\":\"1\"", v2, v3);
  v5 = &v13[v4 + 29];
  strcpy(v5, ",\"wifi_en\":\"0\"");
  qmemcpy(v5, ",\"wifi_en\":\"", 12);
  v6 = v4 + 43;
  v7 = (const char *)jhl_nv_get_def("auto_reboot_mode");
  v8 = (const char *)jhl_nv_get_def("auto_reboot_runday");
  v9 = (const char *)jhl_nv_get_def("auto_reboot_runtm");
  v10 = v6 + sprintf(&v13[v6], ",\"mode\":\"%s\",\"run_day\":\"%s\",\"run_tm\":\"%s\"", v7, v8, v9);
  v11 = snprintf(&v13[v10], 512 - v10, "}}");
  if ( v11 >= 512 - v10 )
    v11 = 511 - v10;
  return httpd_cgi_ret(a1, v13, v11 + v10, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0045A358) --------------------------------------------------------
int __fastcall sub_45A358(int a1)
{
  char *v2; // $s5
  char *v3; // $s4
  char *v4; // $s3
  char *v5; // $s1
  int v6; // $a0
  char *v7; // $s6
  int v8; // $s5
  char *v9; // $v1
  const char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  char v16[516]; // [sp+18h] [-204h] BYREF

  memset(v16, 0, 0x200u);
  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "time");
  v4 = httpd_get_parm(a1, "mode");
  v5 = httpd_get_parm(a1, "run_day");
  v7 = httpd_get_parm(a1, "run_tm");
  if ( v2 && !nvram_match_def("auto_reboot_enable", v2) )
  {
    nvram_set("auto_reboot_enable", v2);
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  if ( v3 && !nvram_match_def("auto_reboot_time", v3) )
  {
    nvram_set("auto_reboot_time", v3);
    v8 = 1;
  }
  if ( v4 && !nvram_match_def("auto_reboot_mode", v4) )
  {
    nvram_set("auto_reboot_mode", v4);
    v8 = 1;
  }
  if ( v5 )
  {
    if ( !J_atoi(v5) )
      v5 = "1";
    if ( !nvram_match_def("auto_reboot_runday", v5) )
    {
      nvram_set("auto_reboot_runday", v5);
      if ( !v7 || nvram_match_def("auto_reboot_runtm", v7) )
        goto LABEL_24;
      goto LABEL_23;
    }
  }
  if ( v7 && !nvram_match_def("auto_reboot_runtm", v7) )
  {
LABEL_23:
    nvram_set("auto_reboot_runtm", v7);
    goto LABEL_24;
  }
  if ( v8 )
  {
LABEL_24:
    jhl_parm_commit(v6);
    start_auto_reboot(0);
  }
  v9 = v16;
  v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v11 = *(_DWORD *)v10;
    v12 = *((_DWORD *)v10 + 1);
    v13 = *((_DWORD *)v10 + 2);
    v14 = *((_DWORD *)v10 + 3);
    v10 += 16;
    *(_DWORD *)v9 = v11;
    *((_DWORD *)v9 + 1) = v12;
    *((_DWORD *)v9 + 2) = v13;
    *((_DWORD *)v9 + 3) = v14;
    v9 += 16;
  }
  while ( v10 != "}" );
  *(_WORD *)v9 = *(_WORD *)v10;
  return httpd_cgi_ret(a1, v16, 33, 4);
}
// 45A670: variable 'v6' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A83C0: using guessed type int __fastcall start_auto_reboot(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0045A69C) --------------------------------------------------------
int __fastcall sub_45A69C(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s6
  const char *v5; // $s1
  const char *v6; // $s3
  const char *v7; // $s4
  const char *v8; // $s5
  const char *v9; // $v0
  int v10; // $s3
  int v11; // $v0
  int v12; // $a2
  int result; // $v0
  const char *v14; // $v0
  unsigned int v15; // $v0
  char v16[256]; // [sp+28h] [-100h] BYREF

  _mem_malloc(10240, "parm_sendemail_data", 569);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\",\"da", 24);
    v4 = (const char *)jhl_nv_get_def("parm_email_en");
    v5 = (const char *)jhl_nv_get_def("parm_email_name");
    v6 = (const char *)jhl_nv_get_def("parm_email_url");
    v7 = (const char *)jhl_nv_get_def("parm_email_mode");
    v8 = (const char *)jhl_nv_get_def("parm_email_time");
    v9 = (const char *)jhl_nv_get_def("parm_email_hour");
    v10 = sprintf(
            v3 + 29,
            "\"enable\":\"%s\",\"name\":\"%s\",\"email\":\"%s\",\"mode\":\"%s\",\"time\":\"%s\",\"hour\":\"%s\"",
            v4,
            v5,
            v6,
            v7,
            v8,
            v9)
        + 29;
    v11 = snprintf(&v3[v10], 10240 - v10, "}}");
    if ( v11 >= 10240 - v10 )
      v12 = 10239 - v10;
    else
      v12 = v11;
    result = httpd_cgi_ret(a1, v3, v12 + v10, 8);
  }
  else
  {
    v14 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v15 = snprintf(v16, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v15 >= 0x100 )
      v15 = 255;
    result = httpd_cgi_ret(a1, v16, v15, 4);
  }
  return result;
}
// 45A6F4: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0045A930) --------------------------------------------------------
int __fastcall sub_45A930(int a1)
{
  char *v2; // $s2
  char *v3; // $s7
  char *v4; // $s6
  char *v5; // $s4
  char *v6; // $s5
  int v7; // $a0
  char *v8; // $s1
  char *v9; // $v1
  const char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  char v16[256]; // [sp+18h] [-100h] BYREF

  memset(v16, 0, sizeof(v16));
  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "name");
  v4 = httpd_get_parm(a1, "email");
  v5 = httpd_get_parm(a1, "time");
  v6 = httpd_get_parm(a1, "mode");
  v8 = httpd_get_parm(a1, "hour");
  if ( v2 && !nvram_match_def("parm_email_en", v2) )
    nvram_set("parm_email_en", v2);
  if ( v3 && !nvram_match_def("parm_email_name", v3) )
    nvram_set("parm_email_name", v3);
  if ( v4 && !nvram_match_def("parm_email_url", v4) )
    nvram_set("parm_email_url", v4);
  if ( v6 && !nvram_match_def("parm_email_mode", v6) )
    nvram_set("parm_email_mode", v6);
  if ( v5 && !nvram_match_def("parm_email_time", v5) )
    nvram_set("parm_email_time", v5);
  if ( v8 )
  {
    if ( !J_atoi(v8) )
      v8 = "4";
    if ( !nvram_match_def("parm_email_hour", v8) )
      nvram_set("parm_email_hour", v8);
  }
  if ( v2 )
  {
    stop_parm_auto_send_email();
    if ( nvram_match_def("parm_email_en", "1") )
    {
      start_parm_auto_send_email();
      jhl_system("parm_send_email &");
    }
  }
  jhl_parm_commit(v7);
  v9 = v16;
  v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v11 = *(_DWORD *)v10;
    v12 = *((_DWORD *)v10 + 1);
    v13 = *((_DWORD *)v10 + 2);
    v14 = *((_DWORD *)v10 + 3);
    v10 += 16;
    *(_DWORD *)v9 = v11;
    *((_DWORD *)v9 + 1) = v12;
    *((_DWORD *)v9 + 2) = v13;
    *((_DWORD *)v9 + 3) = v14;
    v9 += 16;
  }
  while ( v10 != "}" );
  *(_WORD *)v9 = *(_WORD *)v10;
  return httpd_cgi_ret(a1, v16, 33, 4);
}
// 45AB98: variable 'v7' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8594: using guessed type int __fastcall jhl_system(_DWORD);
// 6A859C: using guessed type int start_parm_auto_send_email(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A895C: using guessed type int stop_parm_auto_send_email(void);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0045AD14) --------------------------------------------------------
int __fastcall sub_45AD14(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s3
  const char *v5; // $s1
  const char *v6; // $s4
  const char *v7; // $s5
  const char *v8; // $s6
  const char *v9; // $fp
  const char *v10; // $v0
  int v11; // $s3
  int v12; // $v0
  int v13; // $a2
  int result; // $v0
  const char *v15; // $v0
  unsigned int v16; // $v0
  char v17[256]; // [sp+40h] [-110h] BYREF
  const char *v18; // [sp+140h] [-10h]
  const char *v19; // [sp+144h] [-Ch]
  const char *v20; // [sp+148h] [-8h]
  const char *v21; // [sp+14Ch] [-4h]

  _mem_malloc(10240, "http_proxy_client_data", 657);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error", 16);
    v4 = (const char *)nvram_get("proxy_http_status");
    if ( !v4 )
      v4 = "0";
    v5 = (const char *)nvram_get("proxy_http_port");
    if ( !v5 )
      v5 = "0";
    v6 = (const char *)nvram_get("proxy_http_msg");
    if ( !v6 )
    {
      if ( get_web_language_type(a1) )
        v6 = "This function is not enabled";
      else
        v6 = (const char *)&unk_645EF8;
    }
    v7 = (const char *)jhl_nv_get_only_def("proxy_http_srv");
    v8 = (const char *)jhl_nv_get_def("proxy_email_en");
    v9 = (const char *)jhl_nv_get_def("proxy_email_name");
    v21 = (const char *)jhl_nv_get_def("proxy_email_url");
    v20 = (const char *)jhl_nv_get_def("proxy_email_mode");
    v19 = (const char *)jhl_nv_get_def("proxy_email_time");
    v18 = (const char *)jhl_nv_get_def(&unk_645FA8);
    v10 = (const char *)jhl_nv_get_def(&unk_645FBC);
    v11 = sprintf(
            v3 + 29,
            "\"proxy_http_status\":\"%s\", \"proxy_http_port\":\"%s\",\"proxy_http_msg\":\"%s\",\"proxy_http_server\":\"%"
            "s\",\"enable\":\"%s\",\"name\":\"%s\",\"email\":\"%s\",\"mode\":\"%s\",\"time\":\"%s\",\"hour\":\"%s\",\"pho"
            "ne\":\"%s\",\"only_https\":%d",
            v4,
            v5,
            v6,
            v7,
            v8,
            v9,
            v21,
            v20,
            v19,
            v18,
            v10,
            0)
        + 29;
    v12 = snprintf(&v3[v11], 10240 - v11, "}}");
    if ( v12 >= 10240 - v11 )
      v13 = 10239 - v11;
    else
      v13 = v12;
    result = httpd_cgi_ret(a1, v3, v13 + v11, 8);
  }
  else
  {
    v15 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v16 = snprintf(v17, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v15);
    if ( v16 >= 0x100 )
      v16 = 255;
    result = httpd_cgi_ret(a1, v17, v16, 4);
  }
  return result;
}
// 45AD74: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A86F4: using guessed type int __fastcall jhl_nv_get_only_def(_DWORD);

//----- (0045B0C8) --------------------------------------------------------
int __fastcall sub_45B0C8(int a1)
{
  char *v2; // $s1
  char *v3; // $s3
  char *v4; // $s4
  char *v5; // $s5
  char *v6; // $s6
  char *v7; // $s2
  char *v8; // $s7
  int v9; // $s3
  char *v10; // $v0
  const char *v11; // $v0
  int v12; // $s2
  char *v13; // $s4
  const char *v14; // $v0
  int v15; // $a0
  int v16; // $a2
  int v18; // $a2
  int v19; // $a1
  const char *v20; // $v0
  const char *v21; // $v1
  unsigned int v22; // $v0
  char *v23; // $v1
  const char *v24; // $v0
  int v25; // $t0
  int v26; // $a3
  int v27; // $a2
  int v28; // $a1
  const char *v29; // $v0
  char v30[1024]; // [sp+20h] [-540h] BYREF
  char v31[256]; // [sp+420h] [-140h] BYREF
  int v32[10]; // [sp+520h] [-40h] BYREF
  char *s; // [sp+548h] [-18h]
  char *v34; // [sp+54Ch] [-14h]
  char *v35; // [sp+550h] [-10h]
  char *v36; // [sp+554h] [-Ch]
  char *v37; // [sp+558h] [-8h]

  v36 = v30;
  memset(v30, 0, sizeof(v30));
  s = v31;
  memset(v31, 0, sizeof(v31));
  v34 = httpd_get_parm(a1, "proxy_http_status");
  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "name");
  v4 = httpd_get_parm(a1, "email");
  v5 = httpd_get_parm(a1, "time");
  v6 = httpd_get_parm(a1, "mode");
  v7 = httpd_get_parm(a1, "hour");
  v8 = httpd_get_parm(a1, "phone");
  if ( v2 )
  {
    if ( strcmp(v2, "1") )
    {
LABEL_6:
      v35 = "a";
      if ( !nvram_match_def("proxy_email_en", v2) )
      {
        nvram_set(v35 + 24396, v2);
        v35 = (char *)1;
        goto LABEL_8;
      }
LABEL_7:
      v35 = 0;
LABEL_8:
      if ( v3 && (v37 = "a", !nvram_match_def("proxy_email_name", v3)) )
      {
        nvram_set(v37 + 24412, v3);
        v9 = 1;
      }
      else
      {
        v9 = 0;
      }
      if ( v4 )
      {
        v37 = "a";
        if ( !nvram_match_def("proxy_email_url", v4) )
        {
          nvram_set(v37 + 24432, v4);
          ++v9;
        }
      }
      if ( v6 && !nvram_match_def("proxy_email_mode", v6) )
      {
        nvram_set("proxy_email_mode", v6);
        ++v9;
      }
      if ( v5 && !nvram_match_def("proxy_email_time", v5) )
      {
        nvram_set("proxy_email_time", v5);
        ++v9;
      }
      if ( v7 )
      {
        if ( !J_atoi(v7) )
          v7 = "4";
        if ( !nvram_match_def(&unk_645FA8, v7) )
        {
          nvram_set(&unk_645FA8, v7);
          ++v9;
        }
      }
      if ( v8 && !nvram_match_def(&unk_645FBC, v8) )
      {
        nvram_set(&unk_645FBC, v8);
        ++v9;
      }
      if ( v2 )
      {
        if ( nvram_match_def("proxy_email_en", "1") )
        {
          v10 = (char *)nvram_get("proxy_http_port");
          if ( !v10 )
            v10 = "0";
          if ( J_atoi(v10) )
          {
            v29 = (const char *)nvram_get("proxy_http_pid");
            if ( !v29 )
              v29 = "-1";
            if ( J_atoi(v29) )
            {
              stop_proxy_auto_send_email();
              start_proxy_auto_send_email();
              system("proxy_send_email &");
              system("proxy_usb_send_email &");
LABEL_46:
              if ( v9 || v35 )
                jhl_parm_commit(v15);
              v16 = 0;
              if ( !v31[0] )
              {
                v23 = s;
                v24 = "{\"code\":0,\"error\":\"\",\"data\":null}";
                do
                {
                  v25 = *(_DWORD *)v24;
                  v26 = *((_DWORD *)v24 + 1);
                  v27 = *((_DWORD *)v24 + 2);
                  v28 = *((_DWORD *)v24 + 3);
                  v24 += 16;
                  *(_DWORD *)v23 = v25;
                  *((_DWORD *)v23 + 1) = v26;
                  *((_DWORD *)v23 + 2) = v27;
                  *((_DWORD *)v23 + 3) = v28;
                  v23 += 16;
                }
                while ( v24 != "}" );
                v16 = 33;
                *(_WORD *)v23 = *(_WORD *)v24;
              }
              return httpd_cgi_ret(a1, s, v16, 4);
            }
          }
        }
        if ( !nvram_match_def("proxy_email_en", "1") )
        {
          stop_proxy_auto_send_email();
          goto LABEL_46;
        }
      }
      if ( v34 )
        nvram_set("proxy_http_status", v34);
      v11 = (const char *)nvram_get("proxy_http_pid");
      if ( !v11 )
        v11 = "-1";
      v12 = J_atoi(v11);
      if ( v12 > 0 )
      {
        v13 = v36;
        memset(v36, 0, 0x400u);
        snprintf(v13, 1024, "kill -9 %d", v12);
        system(v13);
        if ( !nvram_get("proxy_http_msg") )
          get_web_language_type(a1);
        nvram_set("proxy_http_pid", "-1");
        nvram_set("proxy_http_port", "0");
      }
      exec_service("proxy_client_email-stop");
      v14 = (const char *)nvram_get("proxy_http_status");
      if ( v14 && !strcmp(v14, "1") )
      {
        if ( nvram_match_def("proxy_email_en", "1") )
        {
          exec_service("proxy_client_email-start");
        }
        else
        {
          v32[0] = (int)"proxy_client";
          v32[1] = jhl_nv_get_only_def("proxy_http_srv");
          v32[2] = jhl_nv_get_only_def("proxy_http_srvport");
          v32[3] = jhl_nv_get_def("lan_ipaddr");
          v32[4] = jhl_nv_get_def("http_lanport");
          v32[5] = (int)"proxy_http_port";
          v32[6] = (int)"proxy_http_msg";
          v32[7] = (int)"proxy_http_pid";
          v32[8] = 0;
          eval_nowait(v32, 0, 0, 0);
        }
      }
      else if ( !nvram_get("proxy_http_msg") )
      {
        get_web_language_type(a1);
      }
      goto LABEL_46;
    }
  }
  else
  {
    if ( !v34 )
      goto LABEL_7;
    if ( strcmp(v34, "1") )
    {
      v35 = 0;
      goto LABEL_8;
    }
  }
  if ( gl_httpd_high_admin_en )
  {
    v35 = "http_hadminpwd";
    if ( !jhl_nv_is_def("http_hadmin") )
      goto LABEL_5;
  }
  else
  {
    v35 = "http_passwd";
    if ( !jhl_nv_is_def("http_username") )
      goto LABEL_5;
  }
  if ( !jhl_nv_is_def(v35) )
  {
LABEL_5:
    if ( !v2 )
      goto LABEL_7;
    goto LABEL_6;
  }
  v19 = *(unsigned __int8 *)(a1 + 210102);
  if ( *(_DWORD *)(a1 + 205588) == 5 )
  {
    v20 = (const char *)_GET_LANG_TEXT(144, v19, v18);
    v21 = "huserSet";
  }
  else
  {
    v20 = (const char *)_GET_LANG_TEXT(144, v19, v18);
    v21 = "loginManage";
  }
  v22 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"url\":\"%s\",\"data\":null}", 6, v20, v21);
  if ( v22 >= 0x100 )
    v22 = 255;
  return httpd_cgi_ret(a1, s, v22, 4);
}
// 45B624: variable 'v15' is possibly undefined
// 45B6E4: variable 'v18' is possibly undefined
// 67D094: using guessed type int gl_httpd_high_admin_en;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A85A0: using guessed type int __fastcall jhl_nv_is_def(_DWORD);
// 6A86B4: using guessed type int stop_proxy_auto_send_email(void);
// 6A86F4: using guessed type int __fastcall jhl_nv_get_only_def(_DWORD);
// 6A87EC: using guessed type int start_proxy_auto_send_email(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0045BAE4) --------------------------------------------------------
int __fastcall proxy_client_data(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s6
  const char *v5; // $s1
  const char *v6; // $s3
  const char *v7; // $s4
  const char *v8; // $s7
  const char *v9; // $s5
  const char *v10; // $v0
  int v11; // $s3
  int v12; // $v0
  int v13; // $a2
  int result; // $v0
  const char *v15; // $v0
  unsigned int v16; // $v0
  char v17[256]; // [sp+30h] [-100h] BYREF

  _mem_malloc(10240, "proxy_client_data", 870);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error", 16);
    v4 = (const char *)nvram_get("proxy_en");
    if ( !v4 )
      v4 = "0";
    v5 = (const char *)nvram_get("proxy_srv");
    if ( !v5 )
      v5 = "";
    v6 = (const char *)nvram_get("proxy_srvport");
    if ( !v6 )
      v6 = "";
    v7 = (const char *)nvram_get("proxy_port");
    if ( !v7 )
      v7 = "";
    v8 = (const char *)nvram_get("proxy_msg");
    if ( !v8 )
    {
      if ( get_web_language_type(a1) )
        v8 = "This function is not enabled";
      else
        v8 = (const char *)&unk_645EF8;
    }
    v9 = (const char *)nvram_get("proxy_lanip");
    if ( !v9 )
      v9 = "";
    v10 = (const char *)nvram_get("proxy_lanport");
    if ( !v10 )
      v10 = "";
    v11 = sprintf(
            v3 + 29,
            "\"proxy_en\":%s,\"proxy_srv\":\"%s\",\"proxy_srvport\":%s,\"proxy_port\":\"%s\",\"proxy_msg\":\"%s\",\"proxy"
            "_lanip\":\"%s\",\"proxy_lanport\":%s",
            v4,
            v5,
            v6,
            v7,
            v8,
            v9,
            v10)
        + 29;
    v12 = snprintf(&v3[v11], 10240 - v11, "}}");
    if ( v12 >= 10240 - v11 )
      v13 = 10239 - v11;
    else
      v13 = v12;
    result = httpd_cgi_ret(a1, v3, v13 + v11, 8);
  }
  else
  {
    v15 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v16 = snprintf(v17, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v15);
    if ( v16 >= 0x100 )
      v16 = 255;
    result = httpd_cgi_ret(a1, v17, v16, 4);
  }
  return result;
}
// 45BB44: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0045BE48) --------------------------------------------------------
int __fastcall sub_45BE48(int a1)
{
  char *v2; // $s6
  char *v3; // $s5
  char *v4; // $s4
  char *v5; // $s3
  char *v6; // $s7
  int v7; // $s6
  const char *v9; // $v0
  int v10; // $s4
  char *v11; // $s5
  const char *v12; // $v0
  char *v13; // $v0
  char *v14; // $v0
  char v15[1024]; // [sp+18h] [-440h] BYREF
  int v16[10]; // [sp+418h] [-40h] BYREF
  char *v17; // [sp+440h] [-18h]
  char *v18; // [sp+444h] [-14h]
  char *v19; // [sp+448h] [-10h]
  char *v20; // [sp+44Ch] [-Ch]
  char *v21; // [sp+450h] [-8h]

  v19 = "a";
  v20 = "a";
  v2 = httpd_get_parm(a1, "proxy_en");
  v17 = httpd_get_parm(a1, "proxy_srv");
  v18 = "a";
  v3 = httpd_get_parm(a1, "proxy_srvport");
  v4 = httpd_get_parm(a1, "proxy_lanip");
  v5 = httpd_get_parm(a1, "proxy_lanport");
  v21 = v15;
  v6 = httpd_get_parm(a1, "proxy_port");
  memset(v15, 0, sizeof(v15));
  if ( v2 && !nvram_match_def("proxy_en", v2) )
  {
    nvram_set("proxy_en", v2);
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  if ( v17 && !nvram_match_def(v19 + 24976, v17) )
    v7 = 1;
  if ( v3 && !nvram_match_def(v20 + 24988, v3) )
  {
    nvram_set("proxy_srvport", v3);
    v7 = 1;
  }
  if ( v4 && !nvram_match_def("proxy_lanip", v4) )
  {
    nvram_set("proxy_lanip", v4);
    v7 = 1;
  }
  if ( v5 && !nvram_match_def(v18 + 25040, v5) )
  {
    nvram_set("proxy_lanport", v5);
    if ( !v6 || nvram_match_def("proxy_port", v6) )
      goto LABEL_23;
  }
  else if ( !v6 || nvram_match_def("proxy_port", v6) )
  {
    if ( !v7 )
      return proxy_client_data(a1);
    goto LABEL_23;
  }
  nvram_set("proxy_port", v6);
LABEL_23:
  v9 = (const char *)nvram_get("proxy_pid");
  if ( !v9 )
    v9 = "-1";
  v10 = J_atoi(v9);
  if ( v10 > 0 )
  {
    v11 = v21;
    memset(v21, 0, 0x400u);
    snprintf(v11, 1024, "kill -9 %d", v10);
    system(v11);
    if ( !nvram_get("proxy_msg") )
      get_web_language_type(a1);
    nvram_set("proxy_pid", "-1");
    nvram_set("proxy_port", "");
  }
  v12 = (const char *)nvram_get("proxy_en");
  if ( v12 && !strcmp(v12, "1") )
  {
    v16[0] = (int)"proxy_client";
    v16[1] = jhl_nv_get_def(v19 + 24976);
    v16[2] = jhl_nv_get_def(v20 + 24988);
    v13 = (char *)nvram_get("proxy_lanip");
    if ( !v13 )
      v13 = "";
    v16[3] = (int)v13;
    v14 = (char *)nvram_get(v18 + 25040);
    if ( !v14 )
      v14 = "";
    v16[4] = (int)v14;
    v16[5] = (int)"proxy_port";
    v16[6] = (int)"proxy_msg";
    v16[7] = (int)"proxy_pid";
    v16[8] = 0;
    eval_nowait(v16, 0, 0, 0);
  }
  return proxy_client_data(a1);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0045C384) --------------------------------------------------------
bool __fastcall sub_45C384(int a1)
{
  return jhl_web_save_parms(a1, base_time_nvarms, 1) != 0;
}
// 66FD30: using guessed type char *base_time_nvarms[8];

//----- (0045C3BC) --------------------------------------------------------
int __fastcall sub_45C3BC(int a1)
{
  int v2; // $v0
  char *v3; // $v1
  int v4; // $s0
  const char *v5; // $v0
  int v6; // $s0
  unsigned int v7; // $v0
  char v9[1028]; // [sp+18h] [-404h] BYREF

  strcpy(v9, "{\"code\":0,\"error\":\"\",\"data\":{\"rtime\":\"");
  v2 = asp_time(&v9[38]);
  v3 = &v9[v2 + 38];
  *v3 = 34;
  v3[1] = 44;
  v3[2] = 0;
  v4 = v2 + 40 + get_nvarms((const char **)base_time_nvarms, (int)&v9[v2 + 40], 1024 - (v2 + 40));
  v5 = (const char *)nvram_get("time_type");
  v6 = v4 + sprintf(&v9[v4], "\"time_type\":\"%s\"", v5);
  v7 = snprintf(&v9[v6], 1024 - v6, "}}");
  if ( v7 >= 1024 - v6 )
    v7 = 1023 - v6;
  return httpd_cgi_ret(a1, v9, v7 + v6, 4);
}
// 642164: using guessed type __int16 word_642164;
// 66FD30: using guessed type char *base_time_nvarms[8];
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (0045C558) --------------------------------------------------------
int __fastcall sub_45C558(int a1)
{
  char *v2; // $s1
  int v3; // $a0
  const char *v4; // $v0
  const char *v5; // $v0
  char *v6; // $v1
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  int v10; // $a1
  unsigned int v11; // $a2
  int v13; // $s1
  char *v14; // $v0
  const char *v15; // $v0
  char *v16; // $v0
  int v17; // $v0
  int v18; // $a0
  char v19[512]; // [sp+20h] [-200h] BYREF

  v2 = httpd_get_parm(a1, "time_type");
  if ( save_variables(a1, 0) )
  {
    if ( save_variables(a1, 1) )
      jhl_parm_commit(v3);
    if ( v2 )
    {
      if ( *v2 )
      {
        nvram_set("time_type", v2);
        jhl_parm_commit(v18);
      }
      if ( !strcmp(v2, "hand") )
      {
        v16 = httpd_get_parm(a1, "time_string");
        if ( v16 )
        {
          v17 = J_atoi(v16);
          set_systime(v17);
        }
      }
    }
    v4 = (const char *)nvram_get("time_type");
    if ( v4 && !strcmp(v4, "hand") )
      exec_service("ntpc-stop");
    else
      exec_service("ntpc-restart");
    v5 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v6 = v19;
    do
    {
      v7 = *(_DWORD *)v5;
      v8 = *((_DWORD *)v5 + 1);
      v9 = *((_DWORD *)v5 + 2);
      v10 = *((_DWORD *)v5 + 3);
      v5 += 16;
      *(_DWORD *)v6 = v7;
      *((_DWORD *)v6 + 1) = v8;
      *((_DWORD *)v6 + 2) = v9;
      *((_DWORD *)v6 + 3) = v10;
      v6 += 16;
    }
    while ( v5 != "}" );
    v11 = 33;
    *(_WORD *)v6 = *(_WORD *)v5;
  }
  else
  {
    v13 = *(unsigned __int8 *)(a1 + 210102);
    v14 = resmsg_get();
    v15 = (const char *)_GET_LANG_TEXT(12, v13, v14);
    v11 = snprintf(v19, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v15);
    if ( v11 >= 0x200 )
      v11 = 511;
  }
  return httpd_cgi_ret(a1, v19, v11, 4);
}
// 45C774: variable 'v3' is possibly undefined
// 45C7FC: variable 'v18' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84F0: using guessed type int __fastcall set_systime(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0045C810) --------------------------------------------------------
int __fastcall sub_45C810(int a1)
{
  const char *v2; // $v0
  unsigned int v3; // $v0
  int v4; // $s0
  unsigned int v5; // $v0
  char v7[1028]; // [sp+18h] [-404h] BYREF

  memset(v7, 0, 0x400u);
  strcpy(v7, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)nvram_get("http_hadmin");
  if ( !v2 )
    v2 = "";
  v3 = snprintf(&v7[29], 995, "\"http_username\":\"%s\"", v2);
  v4 = v3 + 29;
  if ( v3 >= 0x3E3 )
    v4 = 1023;
  v5 = snprintf(&v7[v4], 1024 - v4, "}}");
  if ( v5 >= 1024 - v4 )
    v5 = 1023 - v4;
  return httpd_cgi_ret(a1, v7, v5 + v4, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (0045C96C) --------------------------------------------------------
int __fastcall sub_45C96C(int a1)
{
  unsigned int v2; // $s4
  char *v3; // $v0
  char *v4; // $s2
  char *v5; // $s3
  int v6; // $a0
  char *v7; // $v1
  const char *v8; // $v0
  int v9; // $t0
  int v10; // $a3
  int v11; // $a2
  int v12; // $a1
  char v14[512]; // [sp+18h] [-200h] BYREF

  memset(v14, 0, sizeof(v14));
  v2 = time(0);
  v4 = httpd_get_parm(a1, "http_username");
  v3 = httpd_get_parm(a1, "http_passwd");
  v5 = v3;
  if ( !v4 )
  {
    if ( !v3 )
      goto LABEL_7;
    goto LABEL_3;
  }
  nvram_set("http_hadmin", v4);
  if ( v5 )
LABEL_3:
    nvram_set("http_hadminpwd", v5);
  if ( v2 >= 0x5FEDF581 )
    nvram_set_int("http_hadmin_time", v2);
  jhl_parm_commit(v6);
  jhl_httpd_reset_user();
LABEL_7:
  v7 = v14;
  v8 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v9 = *(_DWORD *)v8;
    v10 = *((_DWORD *)v8 + 1);
    v11 = *((_DWORD *)v8 + 2);
    v12 = *((_DWORD *)v8 + 3);
    v8 += 16;
    *(_DWORD *)v7 = v9;
    *((_DWORD *)v7 + 1) = v10;
    *((_DWORD *)v7 + 2) = v11;
    *((_DWORD *)v7 + 3) = v12;
    v7 += 16;
  }
  while ( v8 != "}" );
  *(_WORD *)v7 = *(_WORD *)v8;
  return httpd_cgi_ret(a1, v14, 33, 4);
}
// 45CA64: variable 'v6' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A878C: using guessed type int __fastcall nvram_set_int(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0045CB40) --------------------------------------------------------
int __fastcall sub_45CB40(int a1)
{
  _DWORD *v1; // $v0
  int v2; // $a2
  char *v3; // $v0
  char *v4; // $s0
  _DWORD *v5; // $s2
  int v6; // $a1
  int v7; // $a2
  int v8; // $a0
  const char *v9; // $v0
  unsigned int v10; // $s1
  const char *v12; // $v0
  int v13; // $fp
  unsigned __int8 *v14; // $s6
  int v15; // $s1
  int v16; // $v0
  int v17; // $v0
  unsigned __int8 *v18; // $s4
  int v19; // $v0
  int v20; // $v0
  int v21; // $s4
  int v22; // $v0
  char *v23; // $v0
  int v24; // $s1
  int v25; // $s1
  int v26; // $v0
  int v27; // $s1
  const char *v28; // $v0
  int v29; // [sp+10h] [-260h]
  int v30; // [sp+14h] [-25Ch]
  __int16 v31[256]; // [sp+38h] [-238h] BYREF
  char v32[32]; // [sp+238h] [-38h] BYREF
  uint32_t v33; // [sp+258h] [-18h]
  int v34; // [sp+25Ch] [-14h]
  char *v35; // [sp+260h] [-10h]
  int v36; // [sp+264h] [-Ch]
  char *format; // [sp+268h] [-8h]
  char *v38; // [sp+26Ch] [-4h]

  v38 = "a";
  _mem_malloc(0x200000, "arp_list_data", 63);
  v4 = v3;
  _mem_malloc(0x100000, "arp_list_data", 64);
  v5 = v1;
  if ( !v4 )
  {
    v28 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v10 = snprintf((char *)v31, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v28);
    if ( v10 >= 0x100 )
      v10 = 255;
    goto LABEL_8;
  }
  if ( !v1 )
  {
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v7 = 0x200000;
    v8 = 4;
    goto LABEL_5;
  }
  *v1 = 3;
  v1[3] = 9;
  v1[1] = 0x100000;
  if ( jianhl_order_opt_fun(v1, 0x100000, v2) )
  {
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v7 = (int)"";
    v8 = 3;
LABEL_5:
    v9 = (const char *)_GET_LANG_TEXT(v8, v6, v7);
    v10 = snprintf((char *)v31, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 >= 0x100 )
      v10 = 255;
    _mem_free(v4);
LABEL_8:
    if ( v5 )
      _mem_free(v5);
    return httpd_cgi_ret(a1, (char *)v31, v10, 4);
  }
  v12 = (const char *)nvram_get("lan_ifname");
  if ( !v12 || !*v12 )
    v12 = "br0";
  strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":{");
  qmemcpy(v4, "{\"code\":0,\"error", 16);
  v13 = sprintf(v4 + 29, "\"lan_ifname\":\"%s\",\"data\":[", v12) + 29;
  if ( (int)v5[5] > 0 )
  {
    v14 = (unsigned __int8 *)v5 + 42;
    if ( 0x200000 - v13 >= 100 )
    {
      v35 = "a";
      v36 = a1 + 196608;
      v15 = 0;
      format = "%s";
      while ( 1 )
      {
        v20 = *(_DWORD *)(v14 + 30);
        if ( (v20 & 1) != 0 )
          break;
        if ( (v20 & 2) != 0 )
        {
          v30 = v14[3];
          v29 = v14[2];
          v16 = _GET_LANG_TEXT(15, *(unsigned __int8 *)(v36 + 13494), *v14);
          goto LABEL_18;
        }
        v31[0] = 32;
        v17 = *(_DWORD *)(v14 + 6);
        v18 = v14 + 10;
        if ( v17 != 2 )
        {
LABEL_19:
          if ( v17 == 4 )
          {
            v34 = 2;
          }
          else if ( v17 == 3 )
          {
            v34 = 3;
          }
          else
          {
            v34 = 0;
          }
          goto LABEL_22;
        }
LABEL_27:
        v34 = 1;
LABEL_22:
        v33 = ntohl(*(_DWORD *)(v14 - 18));
        v19 = MacToStr(v32, v14 - 6);
        v13 += sprintf(&v4[v13], v35 + 25472, ++v15, v33, v19, v34, v18, v31, *(_DWORD *)(v14 + 26), v14 + 34, 0);
        if ( v15 < v5[5] )
        {
          v14 += 96;
          if ( 0x200000 - v13 >= 100 )
            continue;
        }
        --v13;
        goto LABEL_32;
      }
      v21 = *(unsigned __int8 *)(v36 + 13494);
      v22 = MacToStr(v32, v14);
      v16 = _GET_LANG_TEXT(14, v21, v22);
LABEL_18:
      snprintf((char *)v31, 512, format, v16, v29, v30);
      v17 = *(_DWORD *)(v14 + 6);
      v18 = v14 + 10;
      if ( v17 != 2 )
        goto LABEL_19;
      goto LABEL_27;
    }
  }
LABEL_32:
  v23 = &v4[v13];
  strcpy(&v4[v13], "],\"wans\":");
  *(_DWORD *)v23 = 1998728285;
  *((_DWORD *)v23 + 1) = 577990241;
  v24 = v13 + 9 + get_wans_data(&v4[v13 + 9], 0x200000 - (v13 + 9));
  strcpy(&v4[v24], ",\"noauth\":\"0\"");
  qmemcpy(&v4[v24], ",\"noauth\":\"0", 12);
  v25 = v24 + 13;
  v26 = snprintf(&v4[v25], 0x200000 - v25, "}}");
  if ( v26 >= 0x200000 - v25 )
    v26 = 0x1FFFFF - v25;
  v27 = v26 + v25;
  _mem_free(v5);
  return httpd_cgi_ret(a1, v4, v27, 8);
}
// 45CBB8: variable 'v3' is possibly undefined
// 45CBC4: variable 'v1' is possibly undefined
// 45CBEC: variable 'v2' is possibly undefined
// 45CE3C: variable 'v29' is possibly undefined
// 45CE3C: variable 'v30' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6463E0: using guessed type int dword_6463E0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0045D140) --------------------------------------------------------
int __fastcall sub_45D140(int a1)
{
  char *v1; // $s2
  void *v2; // $v0
  void *v3; // $s0
  int v4; // $a0
  int v5; // $v0
  int v6; // $s4
  int v7; // $s6
  int v8; // $s0
  int v9; // $s3
  int v10; // $v0
  int v11; // $s1
  int v12; // $a0
  int v13; // $s3
  int v14; // $s5
  int v15; // $v0
  char *v16; // $a0
  char *v17; // $v1
  const char *v18; // $v0
  int v19; // $t0
  int v20; // $a3
  int v21; // $a2
  int v22; // $a1
  __int16 v23; // $a0
  int v25; // $a1
  const char *v26; // $a2
  const char *v27; // $v0
  const char *v28; // $v0
  char v29[256]; // [sp+20h] [-138h] BYREF
  char v30[8]; // [sp+120h] [-38h] BYREF
  char *v31; // [sp+128h] [-30h]
  char *v32; // [sp+12Ch] [-2Ch]
  char *s; // [sp+130h] [-28h]
  char *v34; // [sp+134h] [-24h]
  char *v35; // [sp+138h] [-20h]
  char *v36; // [sp+13Ch] [-1Ch]
  char *v37; // [sp+140h] [-18h]
  int v38; // [sp+144h] [-14h]
  int v39; // [sp+148h] [-10h]
  char *v40; // [sp+14Ch] [-Ch]
  char *v41; // [sp+150h] [-8h]

  v1 = httpd_get_parm(a1, "opt");
  v40 = httpd_get_parm(a1, "t");
  v34 = httpd_get_parm(a1, "d");
  if ( !v40 )
    v40 = "0";
  if ( !v1 )
  {
LABEL_44:
    v25 = *(unsigned __int8 *)(a1 + 210102);
    v26 = "not opt";
    goto LABEL_45;
  }
  v35 = "a";
  if ( !strcmp(v1, (const char *)&off_646D8C) || !strcmp(v1, "del") || !strcmp(v1, (const char *)&off_648DDC) )
  {
    if ( !strcmp(v1, "delall") )
      goto LABEL_9;
    if ( !strcmp(v1, "addall") )
      goto LABEL_43;
    if ( v34 )
    {
      v5 = httpd_get_json_parm(a1, (int)"data");
      v6 = v5;
      if ( v5 )
      {
        v7 = cJSON_GetArraySize(v5);
        if ( v7 <= 0 )
        {
          s = v29;
          goto LABEL_36;
        }
        v31 = "1\"";
        v38 = 0;
        v32 = "a";
        v8 = 0;
        v41 = "a";
        s = v29;
        v37 = "del";
        v39 = (int)"arp_st";
        v36 = (char *)&off_648DDC;
        while ( 1 )
        {
          while ( 1 )
          {
            v9 = cJSON_GetArrayItem(v6, v8);
            v11 = cJSON_GetObjectItem(v9, "i");
            v10 = cJSON_GetObjectItem(v9, v31 - 8516);
            v12 = v9;
            v13 = v10;
            v14 = cJSON_GetObjectItem(v12, v32 + 28320);
            if ( !v11 || !get_ip_from_str(*(_DWORD *)(v11 + 16)) )
              goto LABEL_21;
            if ( !strcmp(v1, v37) || !strcmp(v1, v36) )
              break;
            if ( !strcmp(v1, v35 + 28044) )
              goto LABEL_29;
LABEL_21:
            if ( v7 == ++v8 )
              goto LABEL_35;
          }
          arp_st_del(v34, *(_DWORD *)(v11 + 16));
          if ( strcmp(v1, v35 + 28044) && strcmp(v1, v36) )
          {
            v38 = 1;
            goto LABEL_21;
          }
          v38 = 1;
LABEL_29:
          v15 = check_rule_num_limit(a1, 9, v39, 60, s, 0x100u);
          if ( v15 > 0 )
            return httpd_cgi_ret(a1, s, v15, 4);
          if ( !v13 || StrToMac(*(_DWORD *)(v13 + 16), v30) )
            goto LABEL_21;
          if ( v14 )
            v16 = *(char **)(v14 + 16);
          else
            v16 = v41 + 25596;
          arp_st_add(v16, v34, *(_DWORD *)(v11 + 16), *(_DWORD *)(v13 + 16), v40);
          ++v8;
          v38 = 1;
          if ( v7 == v8 )
          {
LABEL_35:
            if ( !v38 )
              goto LABEL_36;
            goto LABEL_10;
          }
        }
      }
      v25 = *(unsigned __int8 *)(a1 + 210102);
      v26 = (const char *)&unk_646418;
    }
    else
    {
      v25 = *(unsigned __int8 *)(a1 + 210102);
      v26 = "not net";
    }
LABEL_45:
    v27 = (const char *)_GET_LANG_TEXT(12, v25, v26);
    s = v29;
    v15 = snprintf(v29, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
    if ( (unsigned int)v15 >= 0x100 )
      v15 = 255;
    return httpd_cgi_ret(a1, s, v15, 4);
  }
  if ( strcmp(v1, "addall") )
  {
    if ( !strcmp(v1, "delall") )
    {
LABEL_9:
      s = v29;
      arp_st_delall();
      goto LABEL_10;
    }
    goto LABEL_44;
  }
  if ( !strcmp(v1, "delall") )
    goto LABEL_9;
LABEL_43:
  arp_st_addall("lan", v40);
  s = v29;
LABEL_10:
  _mem_malloc(0x200000, "arp_list_st_asp", 278);
  v3 = v2;
  if ( v2 )
  {
    if ( arp_st_get(v2, 0x200000) )
      nvram_set("arp_st", v3);
    else
      nvram_set("arp_st", " ");
    _mem_free(v3);
    jhl_parm_commit(v4);
LABEL_36:
    v17 = s;
    v18 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v19 = *(_DWORD *)v18;
      v20 = *((_DWORD *)v18 + 1);
      v21 = *((_DWORD *)v18 + 2);
      v22 = *((_DWORD *)v18 + 3);
      v18 += 16;
      *(_DWORD *)v17 = v19;
      *((_DWORD *)v17 + 1) = v20;
      *((_DWORD *)v17 + 2) = v21;
      *((_DWORD *)v17 + 3) = v22;
      v17 += 16;
    }
    while ( v18 != "}" );
    v23 = *(_WORD *)v18;
    v15 = 33;
    *(_WORD *)v17 = v23;
  }
  else
  {
    v28 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v15 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v28);
    if ( (unsigned int)v15 >= 0x100 )
      v15 = 255;
  }
  return httpd_cgi_ret(a1, s, v15, 4);
}
// 45D2C0: variable 'v2' is possibly undefined
// 45D328: variable 'v4' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8288: using guessed type int __fastcall arp_st_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82FC: using guessed type int arp_st_delall(void);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8518: using guessed type int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD);
// 6A855C: using guessed type int __fastcall arp_st_addall(_DWORD, _DWORD);
// 6A85EC: using guessed type int __fastcall StrToMac(_DWORD, _DWORD);
// 6A86E0: using guessed type int __fastcall arp_st_get(_DWORD, _DWORD);
// 6A86FC: using guessed type int __fastcall cJSON_GetArraySize(_DWORD);
// 6A8748: using guessed type int __fastcall get_ip_from_str(_DWORD);
// 6A8820: using guessed type int __fastcall arp_st_del(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0045D824) --------------------------------------------------------
int __fastcall wan_ping_data(int a1)
{
  const char *v2; // $v0
  int v3; // $s1
  unsigned int v4; // $v0
  char v6[516]; // [sp+18h] [-204h] BYREF

  strcpy(v6, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("wan_ping");
  v3 = sprintf(&v6[29], "\"wan_ping\":%s", v2) + 29;
  v4 = snprintf(&v6[v3], 512 - v3, "}}");
  if ( v4 >= 512 - v3 )
    v4 = 511 - v3;
  return httpd_cgi_ret(a1, v6, v4 + v3, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0045D93C) --------------------------------------------------------
int __fastcall sub_45D93C(int a1)
{
  int v2; // $v0
  void **v3; // $s5
  void **v4; // $s0
  const char *v5; // $s2
  const char *v6; // $s3
  const char *v7; // $s4
  const char *v8; // $v0
  int v9; // $s2
  unsigned int v10; // $v0
  char v12[1024]; // [sp+28h] [-524h] BYREF
  char v13[256]; // [sp+428h] [-124h] BYREF
  void **v14; // [sp+528h] [-24h] BYREF
  void **v15; // [sp+52Ch] [-20h]
  void **v16; // [sp+530h] [-1Ch]
  char *v17; // [sp+534h] [-18h]
  char *v18; // [sp+538h] [-14h]
  char *v19; // [sp+53Ch] [-10h]
  int v20; // [sp+540h] [-Ch]
  int v21; // [sp+544h] [-8h]

  v2 = jhl_nv_get_def("arp_sys");
  strlcpy(v13, v2, 256);
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  split_string(v13, 60, &v14, 6);
  if ( v14 )
  {
    v3 = v15;
    if ( v15 )
      goto LABEL_3;
  }
  else
  {
    v3 = v15;
    v14 = &off_63F984;
    if ( v15 )
    {
LABEL_3:
      v4 = v16;
      if ( v16 )
        goto LABEL_4;
      goto LABEL_14;
    }
  }
  v4 = v16;
  v3 = &off_63F984;
  v15 = &off_63F984;
  if ( v16 )
  {
LABEL_4:
    v5 = v17;
    if ( v17 )
      goto LABEL_5;
    goto LABEL_15;
  }
LABEL_14:
  v5 = v17;
  v4 = &off_63F984;
  v16 = &off_63F984;
  if ( v17 )
  {
LABEL_5:
    v6 = v18;
    if ( v18 )
      goto LABEL_6;
LABEL_16:
    v7 = v19;
    v6 = "0";
    v18 = "0";
    if ( v19 )
      goto LABEL_7;
    goto LABEL_17;
  }
LABEL_15:
  v6 = v18;
  v5 = "0";
  v17 = "0";
  if ( !v18 )
    goto LABEL_16;
LABEL_6:
  v7 = v19;
  if ( v19 )
    goto LABEL_7;
LABEL_17:
  v7 = "200";
  v19 = "200";
LABEL_7:
  strcpy(v12, "{\"code\":0,\"error\":\"\",\"data\":{");
  v8 = (const char *)nvram_get(&unk_646444);
  if ( !v8 )
    v8 = "";
  v9 = sprintf(
         &v12[29],
         "\"notify\":\"%s\",\"check\":\"%s\",\"notify_tm\":%s,\"check_tm\":%s,\"zn_jb\":%s,\"disonline\":%s",
         (const char *)v3,
         (const char *)v4,
         v5,
         v6,
         v7,
         v8)
     + 29;
  v10 = snprintf(&v12[v9], 1024 - v9, "}}");
  if ( v10 >= 1024 - v9 )
    v10 = 1023 - v9;
  return httpd_cgi_ret(a1, v12, v10 + v9, 4);
}
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0045DBCC) --------------------------------------------------------
int __fastcall sub_45DBCC(int a1)
{
  char *v2; // $s3
  char *v3; // $s5
  char *v4; // $fp
  char *v5; // $s7
  int v6; // $v0
  char *v7; // $s6
  int v8; // $a0
  char *v9; // $v1
  const char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  char v16[256]; // [sp+28h] [-1F0h] BYREF
  char v17[200]; // [sp+128h] [-F0h] BYREF
  void **v18; // [sp+1F0h] [-28h] BYREF
  void **v19; // [sp+1F4h] [-24h]
  void **v20; // [sp+1F8h] [-20h]
  char *v21; // [sp+1FCh] [-1Ch]
  char *v22; // [sp+200h] [-18h]
  char *v23; // [sp+204h] [-14h]
  int v24; // [sp+208h] [-10h]
  int v25; // [sp+20Ch] [-Ch]
  char *v26; // [sp+210h] [-8h]
  char *v27; // [sp+214h] [-4h]

  v2 = httpd_get_parm(a1, "arp_defense");
  v3 = httpd_get_parm(a1, "disonline");
  v27 = httpd_get_parm(a1, "notify");
  v4 = httpd_get_parm(a1, "notify_tm");
  v26 = httpd_get_parm(a1, "check");
  v5 = httpd_get_parm(a1, "check_tm");
  v7 = httpd_get_parm(a1, "zn_jb");
  v6 = jhl_nv_get_def("arp_sys");
  strlcpy(v16, v6, 256);
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  split_string(v16, 60, &v18, 6);
  if ( v18 )
  {
    if ( v19 )
      goto LABEL_3;
  }
  else
  {
    v18 = &off_63F984;
    if ( v19 )
    {
LABEL_3:
      if ( v20 )
        goto LABEL_4;
LABEL_29:
      v20 = &off_63F984;
      if ( v21 )
        goto LABEL_5;
      goto LABEL_30;
    }
  }
  v19 = &off_63F984;
  if ( !v20 )
    goto LABEL_29;
LABEL_4:
  if ( v21 )
    goto LABEL_5;
LABEL_30:
  v21 = "200";
LABEL_5:
  if ( !v22 )
    v22 = "10";
  if ( !v23 )
    v23 = "200";
  if ( v27 )
    v19 = (void **)v27;
  if ( v26 )
    v20 = (void **)v26;
  if ( v4 )
    v21 = v4;
  if ( v5 )
    v22 = v5;
  if ( v7 )
    v23 = v7;
  if ( v2 && !strcmp(v2, "disonline") )
  {
    if ( !v3 )
      v3 = "0";
    nvram_set(&unk_646444, v3);
    arp_st_disonline(v3);
  }
  sprintf(v17, "%s<%s<%s<%s<%s<%s", (const char *)v18, (const char *)v19, (const char *)v20, v21, v22, v23);
  nvram_set("arp_sys", v17);
  jhl_parm_commit(v8);
  start_arp_sys();
  v9 = v17;
  v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v11 = *(_DWORD *)v10;
    v12 = *((_DWORD *)v10 + 1);
    v13 = *((_DWORD *)v10 + 2);
    v14 = *((_DWORD *)v10 + 3);
    v10 += 16;
    *(_DWORD *)v9 = v11;
    *((_DWORD *)v9 + 1) = v12;
    *((_DWORD *)v9 + 2) = v13;
    *((_DWORD *)v9 + 3) = v14;
    v9 += 16;
  }
  while ( v10 != "}" );
  *(_WORD *)v9 = *(_WORD *)v10;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 45DEA0: variable 'v8' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81EC: using guessed type int start_arp_sys(void);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A88CC: using guessed type int __fastcall arp_st_disonline(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0045DFFC) --------------------------------------------------------
int __fastcall sub_45DFFC(int a1)
{
  int v2; // $v0
  int v3; // $s2
  char *v4; // $v0
  int v5; // $s4
  char *v6; // $v0
  char *v7; // $fp
  int v8; // $s3
  char *v9; // $a3
  char *v10; // $v1
  int v11; // $v0
  int v12; // $v0
  bool v13; // dc
  int v14; // $v0
  char *v15; // $t4
  char *v16; // $t5
  const char *v17; // $a0
  int v18; // $t2
  int v19; // $t1
  int v20; // $a3
  int v21; // $a2
  char *i; // $v0
  int v23; // $v1
  char *v24; // $v0
  int v25; // $v0
  void *v26; // $v0
  void *v27; // $s2
  int v28; // $a0
  int v29; // $a2
  const char *v30; // $v0
  unsigned int v31; // $v0
  int v33; // $a1
  int v34; // $a2
  int v35; // $a0
  const char *v36; // $v0
  char v37[1024]; // [sp+20h] [-890h] BYREF
  char v38[1024]; // [sp+420h] [-490h] BYREF
  char v39[120]; // [sp+820h] [-90h] BYREF
  char *v40; // [sp+898h] [-18h]
  char *v41; // [sp+89Ch] [-14h]
  int v42; // [sp+8A0h] [-10h]
  int v43; // [sp+8A4h] [-Ch]
  int v44; // [sp+8A8h] [-8h]
  int v45; // [sp+8ACh] [-4h]

  v2 = get_rule_num_limit(9);
  v3 = *(_DWORD *)(a1 + 205364);
  v5 = v2;
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( !v4 )
  {
    if ( debug_level > 0 )
      printf("%s:%d find_file_head err  \n", "arpstsfile_cgi", 483);
    goto LABEL_41;
  }
  v7 = v4;
  v6 = find_file_end(a1, v4, *(_DWORD *)(a1 + 205564) + v3 - (_DWORD)v4);
  v8 = 0;
  if ( !v6 )
  {
    if ( debug_level > 0 )
      printf("%s:%d find_file_end err \n", "arpstsfile_cgi", 490);
LABEL_41:
    v33 = *(unsigned __int8 *)(a1 + 210102);
    v34 = (int)"Error reading file";
    v35 = 33;
    goto LABEL_42;
  }
  *v6 = 0;
  v40 = "only";
  v41 = "a";
  while ( *v7 )
  {
    memset(v37, 0, sizeof(v37));
    v9 = v7 + 1002;
    v10 = v37;
    while ( 1 )
    {
      v11 = *v7;
      if ( !*v7 )
        break;
      if ( v11 == 10 || v11 == 13 )
        goto LABEL_20;
      *v10++ = v11;
      if ( v7 + 1 == v9 )
      {
        v11 = v7[1];
        v7 = v9;
LABEL_20:
        while ( v11 == 10 || v11 == 13 )
          v11 = *++v7;
        break;
      }
      ++v7;
    }
    if ( v37[0] == 123 && *(v10 - 1) == 125 )
    {
      *(v10 - 1) = 0;
      v12 = split_string(&v37[1], 44, v39, 30);
      v13 = v12 <= 0;
      v14 = 4 * v12;
      if ( !v13 )
      {
        v15 = v39;
        v16 = &v39[v14];
        v17 = 0;
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v21 = 0;
        do
        {
          for ( i = *(char **)v15; ; ++i )
          {
            v23 = *i;
            if ( v23 != 32 && v23 != 9 )
              break;
          }
          if ( i[1] == 58 )
          {
            switch ( (char)v23 )
            {
              case 'I':
                v21 = (int)(i + 2);
                break;
              case 'M':
                v20 = (int)(i + 2);
                break;
              case 'd':
                v18 = (int)(i + 2);
                break;
              case 'n':
                v19 = (int)(i + 2);
                break;
              case 't':
                v17 = i + 2;
                break;
              default:
                break;
            }
          }
          v15 += 4;
        }
        while ( v15 != v16 );
        if ( v21 && v20 && v18 )
        {
          if ( !v19 )
            v19 = (int)(v41 + 25836);
          v24 = "1";
          if ( v17 )
          {
            v45 = v19;
            v44 = v20;
            v43 = v21;
            v42 = v18;
            v25 = strcmp(v17, v40);
            v18 = v42;
            v21 = v43;
            v20 = v44;
            v19 = v45;
            v13 = v25 == 0;
            v24 = "2";
            if ( !v13 )
              v24 = "1";
          }
          ++v8;
          arp_st_add(v19, v18, v21, v20, v24);
          if ( v8 >= v5 )
            break;
        }
      }
    }
  }
  _mem_malloc(0x200000, "arpstsfile_cgi", 590);
  v27 = v26;
  if ( !v26 )
  {
    v33 = *(unsigned __int8 *)(a1 + 210102);
    v34 = 0x200000;
    v35 = 4;
LABEL_42:
    v36 = (const char *)_GET_LANG_TEXT(v35, v33, v34);
    v31 = snprintf(v38, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v36);
    if ( v31 < 0x400 )
      return httpd_cgi_ret(a1, v38, v31, 4);
LABEL_43:
    v31 = 1023;
    return httpd_cgi_ret(a1, v38, v31, 4);
  }
  if ( arp_st_get(v26, 0x200000) )
    nvram_set("arp_st", v27);
  else
    nvram_set("arp_st", " ");
  jhl_parm_commit(v28);
  _mem_free(v27);
  v30 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v29);
  v31 = snprintf(v38, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v30);
  if ( v31 >= 0x400 )
    goto LABEL_43;
  return httpd_cgi_ret(a1, v38, v31, 4);
}
// 45E074: variable 'v4' is possibly undefined
// 45E2D4: variable 'v26' is possibly undefined
// 45E320: variable 'v28' is possibly undefined
// 45E358: variable 'v29' is possibly undefined
// 67D0BC: using guessed type int debug_level;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8288: using guessed type int __fastcall arp_st_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A86E0: using guessed type int __fastcall arp_st_get(_DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0045E53C) --------------------------------------------------------
int __fastcall mac_filter_data(int a1)
{
  char *v2; // $v0
  char *v3; // $v0
  char *v4; // $s0
  char *v5; // $s2
  int v6; // $s1
  int v7; // $v0
  int v8; // $s1
  int result; // $v0
  const char *v10; // $v0
  unsigned int v11; // $v0
  char v12[256]; // [sp+20h] [-120h] BYREF
  int v13[8]; // [sp+120h] [-20h] BYREF

  v13[0] = 0;
  v13[1] = 0;
  v13[2] = 0;
  v13[3] = 0;
  v13[4] = 0;
  v13[5] = 0;
  v13[6] = 0;
  v13[7] = 0;
  _mem_malloc(0x200000, "mac_filter_data", 737);
  v4 = v3;
  _mem_malloc(0x100000, "mac_filter_data", 738);
  v5 = v2;
  if ( v4 && v2 )
  {
    jhl_parm_get("macfilterAll", v2, 0x100000);
    jhl_parm_get("macfilterAct", v13, 32);
    if ( !LOBYTE(v13[0]) )
      LOWORD(v13[0]) = 48;
    strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v4, "{\"code\":0,\"error\":\"\",\"da", 24);
    v6 = sprintf(v4 + 29, "\"def\":\"%s\",\"all\":\"%s\"", (const char *)v13, v5) + 29;
    v7 = snprintf(&v4[v6], 0x200000 - v6, "}}");
    if ( v7 >= 0x200000 - v6 )
      v7 = 0x1FFFFF - v6;
    v8 = v7 + v6;
    _mem_free(v5);
    result = httpd_cgi_ret(a1, v4, v8, 8);
  }
  else
  {
    _mem_free(v4);
    _mem_free(v5);
    v10 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v11 = snprintf(v12, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
    if ( v11 >= 0x100 )
      result = httpd_cgi_ret(a1, v12, 255, 4);
    else
      result = httpd_cgi_ret(a1, v12, v11, 4);
  }
  return result;
}
// 45E5C4: variable 'v3' is possibly undefined
// 45E5D0: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (0045E810) --------------------------------------------------------
int __fastcall sub_45E810(int a1)
{
  char *v2; // $a1
  int v3; // $a0

  v2 = httpd_get_parm(a1, "wan_ping");
  if ( v2 )
  {
    nvram_set("wan_ping", v2);
    jhl_parm_commit(v3);
    jhl_setwanxx();
  }
  return wan_ping_data(a1);
}
// 45E870: variable 'v3' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B8: using guessed type int jhl_setwanxx(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0045E8B0) --------------------------------------------------------
int __fastcall sub_45E8B0(int a1)
{
  char *v2; // $s7
  char *v3; // $fp
  char *v4; // $s6
  char *v5; // $v0
  int v6; // $s4
  const char *v7; // $s2
  const char *v8; // $v0
  int v9; // $v0
  _BYTE *v10; // $s3
  void *v11; // $s1
  char *v13; // $fp
  char *v14; // $s7
  char *v15; // $s5
  char *v16; // $s1
  int v17; // $v0
  char *v18; // $s3
  int v19; // $fp
  char *v20; // $s2
  int v21; // $a0
  int *v22; // $v1
  const char *v23; // $v0
  int v24; // $t0
  int v25; // $a3
  int v26; // $a2
  int v27; // $a1
  _BYTE *v28; // $v0
  void *v29; // $v0
  _DWORD *v30; // $s2
  int v31; // $v0
  int v32; // $a0
  int *v33; // $v1
  const char *v34; // $v0
  int v35; // $t0
  int v36; // $a3
  int v37; // $a2
  int v38; // $a1
  __int16 v39; // $a0
  int v40; // $a1
  int v41; // $a2
  int v42; // $a0
  const char *v43; // $v0
  int v44[256]; // [sp+50h] [-668h] BYREF
  int v45[64]; // [sp+450h] [-268h] BYREF
  int s[64]; // [sp+550h] [-168h] BYREF
  char *v47; // [sp+650h] [-68h] BYREF
  const char *v48; // [sp+654h] [-64h]
  const char *v49; // [sp+658h] [-60h]
  char *v50; // [sp+65Ch] [-5Ch]
  const char *v51; // [sp+660h] [-58h]
  const char *v52; // [sp+664h] [-54h]
  char *v53; // [sp+668h] [-50h]
  const char *v54; // [sp+66Ch] [-4Ch]
  const char *v55; // [sp+670h] [-48h]
  char *v56; // [sp+674h] [-44h]
  const char *v57; // [sp+678h] [-40h]
  const char *v58; // [sp+67Ch] [-3Ch]
  char *v59; // [sp+680h] [-38h]
  const char *v60; // [sp+684h] [-34h]
  const char *v61; // [sp+688h] [-30h]
  int v62; // [sp+698h] [-20h]
  char *v63; // [sp+69Ch] [-1Ch]
  char *v64; // [sp+6A0h] [-18h]
  int v65; // [sp+6A4h] [-14h]
  char *v66; // [sp+6A8h] [-10h]
  char *v67; // [sp+6ACh] [-Ch]
  char *v68; // [sp+6B0h] [-8h]

  v64 = httpd_get_parm(a1, "name");
  v65 = (int)httpd_get_parm(a1, "old_name");
  v62 = (int)httpd_get_parm(a1, "en");
  v63 = httpd_get_parm(a1, "user_id");
  v2 = httpd_get_parm(a1, "proto");
  v3 = httpd_get_parm(a1, "num");
  v4 = httpd_get_parm(a1, "time");
  v6 = httpd_get_json_parm(a1, (int)"del_list");
  v5 = httpd_get_parm(a1, "opt");
  if ( !v5 )
  {
LABEL_6:
    v8 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    v9 = snprintf((char *)s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
    if ( (unsigned int)v9 >= 0x100 )
      v9 = 255;
    v10 = 0;
    v11 = 0;
    goto LABEL_9;
  }
  v7 = v5;
  if ( strcmp(v5, (const char *)&off_64712C) )
  {
    v66 = "a";
    if ( strcmp(v7, (const char *)&off_646D8C) && strcmp(v7, (const char *)&off_648DDC) && strcmp(v7, "del") )
      goto LABEL_6;
    _mem_malloc(102400, "ctxz_asp", 2028);
    v11 = v29;
    _mem_malloc(102400, "ctxz_asp", 2029);
    v10 = v28;
    if ( v11 && v28 )
    {
      if ( !strcmp(v7, "del") && v6 )
      {
        v30 = *(_DWORD **)(v6 + 8);
        if ( !v30 )
          goto LABEL_70;
        v31 = v30[4];
        if ( !v31 )
          goto LABEL_70;
        v67 = "a";
        v65 = 0;
        v62 = 102400;
        v63 = "hixz_ct";
        do
        {
          v44[1] = v31;
          v44[0] = (int)"hictxz_del.sh";
          v44[2] = 0;
          eval(v44, 0, 0, 0);
          jhl_parm_get("hixz_ct", v11, v62);
          if ( nvparm_del_str(v11, 60, 10, v30[4], 124, 0, v10) )
          {
            jhl_parm_set(v63, v10);
            v65 = 1;
          }
          v30 = (_DWORD *)*v30;
          if ( !v30 )
            break;
          v31 = v30[4];
        }
        while ( v31 );
LABEL_73:
        if ( v65 )
        {
LABEL_69:
          jhl_parm_set(v67 + 26092, v10);
          jhl_parm_commit(v32);
        }
LABEL_70:
        v33 = s;
        v34 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v35 = *(_DWORD *)v34;
          v36 = *((_DWORD *)v34 + 1);
          v37 = *((_DWORD *)v34 + 2);
          v38 = *((_DWORD *)v34 + 3);
          v34 += 16;
          *v33 = v35;
          v33[1] = v36;
          v33[2] = v37;
          v33[3] = v38;
          v33 += 4;
        }
        while ( v34 != "}" );
        v39 = *(_WORD *)v34;
        v9 = 33;
        *(_WORD *)v33 = v39;
LABEL_9:
        v62 = v9;
        _mem_free(v11);
        _mem_free(v10);
        return httpd_cgi_ret(a1, (char *)s, v62, 4);
      }
      if ( v64 )
      {
        v68 = "1\"";
        if ( !strcmp(v7, (const char *)&off_648DDC) )
        {
          if ( v65 )
          {
            v44[1] = v65;
            v67 = "a";
            v44[0] = (int)"hictxz_del.sh";
            v44[2] = 0;
            eval(v44, 0, 0, 0);
            jhl_parm_get("hixz_ct", v11, 102400);
            v65 = nvparm_del_str(v11, 60, 8, v65, 124, 0, v10) != 0;
            if ( strcmp(v7, v66 + 28044) && strcmp(v7, v68 - 29220) )
              goto LABEL_73;
          }
          else
          {
            v65 = 0;
            v67 = "a";
          }
        }
        else
        {
          if ( strcmp(v7, v66 + 28044) )
            goto LABEL_70;
          v65 = 0;
          v67 = "a";
        }
        memset(v44, 0, sizeof(v44));
        if ( !v62 || !*(_BYTE *)v62 )
          v62 = (int)"1";
        if ( !v63 || !*v63 )
          v63 = "";
        if ( !v2 || !*v2 )
          v2 = "all";
        if ( !v3 || !*v3 )
          v3 = "2000";
        if ( !v4 || !*v4 )
          v4 = "OFF";
        if ( !strcmp(v7, v66 + 28044) )
        {
          v9 = check_rule_num_limit(a1, 11, (int)(v67 + 26092), 60, (char *)s, 0x100u);
          if ( v9 > 0 )
            goto LABEL_9;
        }
        if ( get_time_group(v4, v44, 1024) )
          strlcpy(v44, v4, 1024);
        v45[0] = (int)"hictxz_add.sh";
        v45[2] = v62;
        v45[3] = (int)v63;
        v45[1] = (int)v64;
        v45[4] = (int)v2;
        v45[5] = (int)v3;
        v45[6] = (int)v44;
        v45[7] = (int)v44;
        v45[8] = 0;
        eval(v45, 0, 0, 0);
        sprintf((char *)v11, "%s|%s|%s|%s|%s|%s<", v64, (const char *)v62, v63, v2, v3, v4);
        if ( !v65 )
        {
          jhl_parm_get(v67 + 26092, v10, 102400);
          if ( !strcmp(v10, " ") )
            *v10 = 0;
        }
        strcat(v10, (char *)v11);
        goto LABEL_69;
      }
      v40 = *(unsigned __int8 *)(a1 + 210102);
      v41 = (int)&unk_6442E4;
      v42 = 12;
    }
    else
    {
      v40 = *(unsigned __int8 *)(a1 + 210102);
      v41 = 102400;
      v42 = 4;
    }
    v43 = (const char *)_GET_LANG_TEXT(v42, v40, v41);
    v9 = snprintf((char *)s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v43);
    if ( (unsigned int)v9 >= 0x100 )
      v9 = 255;
    goto LABEL_9;
  }
  memset(v45, 0, sizeof(v45));
  memset(v44, 0, 0x100u);
  v13 = httpd_get_parm(a1, (char *)&off_64712C);
  v14 = httpd_get_parm(a1, "defTcp");
  v15 = httpd_get_parm(a1, "defUdp");
  v16 = httpd_get_parm(a1, "defIcmp");
  v18 = httpd_get_parm(a1, "defOther");
  v17 = jhl_nv_get_def("hixz3");
  strlcpy(v45, v17, 256);
  split_string(v45, 60, &v47, 15);
  if ( !v13 || !strcmp(v47, v13) )
  {
    v19 = 0;
  }
  else
  {
    v47 = v13;
    v19 = 1;
  }
  if ( v14 && strcmp(v50, v14) )
  {
    v50 = v14;
    v19 = 1;
  }
  if ( v15 && strcmp(v53, v15) )
  {
    v53 = v15;
    v19 = 1;
  }
  if ( v16 && strcmp(v56, v16) )
  {
    v56 = v16;
    v20 = v59;
    if ( !v18 || !strcmp(v59, v18) )
      goto LABEL_25;
    v59 = v18;
    goto LABEL_24;
  }
  if ( v18 && strcmp(v59, v18) )
  {
    v16 = v56;
    v59 = v18;
LABEL_24:
    v20 = v18;
LABEL_25:
    sprintf(
      (char *)v44,
      "%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s",
      v47,
      v48,
      v49,
      v50,
      v51,
      v52,
      v53,
      v54,
      v55,
      v16,
      v57,
      v58,
      v20,
      v60,
      v61);
    nvram_set("hixz3", v44);
    s[0] = (int)"wys";
    s[1] = (int)"ctrule";
    s[2] = (int)"defset";
    s[3] = (int)v47;
    s[4] = (int)v48;
    s[5] = (int)v49;
    s[6] = (int)v50;
    s[7] = (int)v51;
    s[8] = (int)v52;
    s[9] = (int)v53;
    s[10] = (int)v54;
    s[11] = (int)v55;
    s[12] = (int)v56;
    s[13] = (int)v57;
    s[14] = (int)v58;
    s[15] = (int)v59;
    s[16] = (int)v60;
    s[18] = 0;
    s[17] = (int)v61;
    eval(s, 0, 0, 0);
    jhl_parm_commit(v21);
    goto LABEL_30;
  }
  if ( v19 )
  {
    v16 = v56;
    v20 = v59;
    goto LABEL_25;
  }
LABEL_30:
  v22 = s;
  v23 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v24 = *(_DWORD *)v23;
    v25 = *((_DWORD *)v23 + 1);
    v26 = *((_DWORD *)v23 + 2);
    v27 = *((_DWORD *)v23 + 3);
    v23 += 16;
    *v22 = v24;
    v22[1] = v25;
    v22[2] = v26;
    v22[3] = v27;
    v22 += 4;
  }
  while ( v23 != "}" );
  *(_WORD *)v22 = *(_WORD *)v23;
  return httpd_cgi_ret(a1, (char *)s, 33, 4);
}
// 45EEA4: variable 'v21' is possibly undefined
// 45EFB0: variable 'v29' is possibly undefined
// 45EFBC: variable 'v28' is possibly undefined
// 45F408: variable 'v32' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8298: using guessed type int __fastcall get_time_group(_DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0045F604) --------------------------------------------------------
int __fastcall sub_45F604(int a1)
{
  char *v2; // $s3
  char *v3; // $s2
  char *v4; // $v0
  char *v5; // $s4
  const char *v6; // $s5
  int v7; // $a2
  const char *v8; // $v0
  unsigned int v9; // $a2
  int v11; // $v0
  int v12; // $a0
  const char *v13; // $v0
  char *v14; // $v0
  const char **v15; // $v1
  const char *v16; // $v0
  const char *v17; // $t0
  const char *v18; // $a3
  const char *v19; // $a2
  const char *v20; // $a1
  char v21[2048]; // [sp+20h] [-C28h] BYREF
  const char *v22; // [sp+820h] [-428h] BYREF
  const char *v23; // [sp+824h] [-424h]
  char *v24; // [sp+828h] [-420h]
  void *v25; // [sp+82Ch] [-41Ch]
  char *v26; // [sp+830h] [-418h]
  int v27; // [sp+834h] [-414h]
  int v28; // [sp+838h] [-410h]
  int v29; // [sp+83Ch] [-40Ch]
  int v30; // [sp+840h] [-408h]
  char *v31; // [sp+844h] [-404h]
  int v32; // [sp+848h] [-400h]
  int v33[5]; // [sp+C20h] [-28h] BYREF
  int v34; // [sp+C34h] [-14h] BYREF
  int v35; // [sp+C38h] [-10h]
  int v36; // [sp+C3Ch] [-Ch]
  int v37; // [sp+C40h] [-8h]

  memset(v21, 0, sizeof(v21));
  v33[0] = 0;
  v33[1] = 0;
  v33[2] = 0;
  v33[3] = 0;
  v33[4] = 0;
  v2 = httpd_get_parm(a1, "fy_en");
  v3 = httpd_get_parm(a1, "fy_rule");
  v5 = httpd_get_parm(a1, "fy_type");
  v4 = httpd_get_parm(a1, "maclist");
  if ( v3 && v2 )
  {
    v6 = v4;
    strlcpy(v21, v3, 2048);
    split_string(v21, 124, &v34, 4);
    if ( J_atoi(v35) && J_atoi(v36) && J_atoi(v37) )
    {
      v11 = J_atoi(v5);
      sprintf((char *)v33, "ddos_fy_rule%d", v11);
      nvram_set(v33, v3);
      nvram_set("ddos_fy_en", v2);
      if ( v6 )
      {
        v13 = (const char *)nvram_get(&unk_646654);
        if ( !v13 || strcmp(v13, v6) )
        {
          nvram_set(&unk_646654, v6);
          v22 = "wys";
          v23 = "ddos_fy";
          v24 = "mac_set";
          v25 = (void *)v6;
          v26 = 0;
          eval(&v22, 0, 0, 0);
        }
      }
      jhl_parm_commit(v12);
      v22 = "wys";
      v24 = "set";
      v27 = v34;
      v28 = v35;
      v23 = "ddos_fy";
      v29 = v36;
      v25 = v2;
      v26 = v5;
      v30 = v37;
      v14 = (char *)nvram_get("lan_hwaddr");
      if ( !v14 )
        v14 = "";
      v31 = v14;
      v32 = 0;
      eval(&v22, 0, 0, 0);
      v15 = &v22;
      v16 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v17 = *(const char **)v16;
        v18 = (const char *)*((_DWORD *)v16 + 1);
        v19 = (const char *)*((_DWORD *)v16 + 2);
        v20 = (const char *)*((_DWORD *)v16 + 3);
        v16 += 16;
        *v15 = v17;
        v15[1] = v18;
        v15[2] = v19;
        v15[3] = v20;
        v15 += 4;
      }
      while ( v16 != "}" );
      v9 = 33;
      *(_WORD *)v15 = *(_WORD *)v16;
      return httpd_cgi_ret(a1, (char *)&v22, v9, 4);
    }
    v8 = (const char *)_GET_LANG_TEXT(207, *(unsigned __int8 *)(a1 + 210102), v7);
  }
  else
  {
    v8 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not fy_rule or not fy_en");
  }
  v9 = snprintf((char *)&v22, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
  if ( v9 >= 0x400 )
    v9 = 1023;
  return httpd_cgi_ret(a1, (char *)&v22, v9, 4);
}
// 45F764: variable 'v7' is possibly undefined
// 45F950: variable 'v12' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0045FA4C) --------------------------------------------------------
int __fastcall sub_45FA4C(int a1)
{
  const char **v2; // $v1
  char **v3; // $v0
  char *v4; // $t0
  const char *v5; // $a3
  const char *v6; // $a2
  const char *v7; // $a1
  int v8; // $s0
  int v9; // $s0
  unsigned int v10; // $v0
  char v12[1024]; // [sp+18h] [-498h] BYREF
  _DWORD v13[25]; // [sp+418h] [-98h] BYREF
  const char *v14[9]; // [sp+47Ch] [-34h] BYREF
  int v15[4]; // [sp+4A0h] [-10h] BYREF

  memset(v13, 0, sizeof(v13));
  v2 = v14;
  v3 = off_670600;
  do
  {
    v4 = *v3;
    v5 = v3[1];
    v6 = v3[2];
    v7 = v3[3];
    v3 += 4;
    *v2 = v4;
    v2[1] = v5;
    v2[2] = v6;
    v2[3] = v7;
    v2 += 4;
  }
  while ( v3 != (char **)&off_670620 );
  *v2 = *v3;
  v15[0] = 0;
  v15[1] = 0;
  v15[2] = 0;
  v15[3] = 0;
  get_memory(v15);
  strcpy(v12, "{\"code\":0,\"error\":\"\",\"data\":{");
  if ( v15[0] >= 0x10000001u )
  {
    strcpy((char *)v13, "500000");
  }
  else if ( v15[0] >= 0x8000001u )
  {
    strcpy((char *)v13, "400000");
  }
  else if ( v15[0] >= 0x4000001u )
  {
    strcpy((char *)v13, "180000");
  }
  else
  {
    if ( v15[0] < 0x2000001u )
      v13[0] = 808464434;
    else
      v13[0] = 808464437;
    strcpy((char *)&v13[1], "0");
  }
  v8 = sprintf(&v12[29], "\"ct_max_def\":\"%s\",", (const char *)v13) + 29;
  v9 = v8 + get_nvarms(v14, (int)&v12[v8], 1024 - v8) - 1;
  v10 = snprintf(&v12[v9], 1024 - v9, "}}");
  if ( v10 >= 1024 - v9 )
    v10 = 1023 - v9;
  return httpd_cgi_ret(a1, v12, v10 + v9, 4);
}
// 642164: using guessed type __int16 word_642164;
// 670600: using guessed type char *off_670600[7];
// 670620: using guessed type void *off_670620;
// 6A85CC: using guessed type int __fastcall get_memory(_DWORD);

//----- (0045FCC4) --------------------------------------------------------
int __fastcall sub_45FCC4(int a1)
{
  int v2; // $a0
  char *v3; // $v1
  const char *v4; // $v0
  int v5; // $t0
  int v6; // $a3
  int v7; // $a2
  int v8; // $a1
  unsigned int v9; // $a2
  char *v11; // $v0
  char v12[516]; // [sp+20h] [-204h] BYREF

  if ( save_variables(a1, 0) )
  {
    if ( save_variables(a1, 1) )
      jhl_parm_commit(v2);
    exec_service("ctnf-restart");
    v3 = v12;
    v4 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v5 = *(_DWORD *)v4;
      v6 = *((_DWORD *)v4 + 1);
      v7 = *((_DWORD *)v4 + 2);
      v8 = *((_DWORD *)v4 + 3);
      v4 += 16;
      *(_DWORD *)v3 = v5;
      *((_DWORD *)v3 + 1) = v6;
      *((_DWORD *)v3 + 2) = v7;
      *((_DWORD *)v3 + 3) = v8;
      v3 += 16;
    }
    while ( v4 != "}" );
    v9 = 33;
    *(_WORD *)v3 = *(_WORD *)v4;
  }
  else
  {
    v11 = resmsg_get();
    v9 = snprintf(v12, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
    if ( v9 >= 0x200 )
      v9 = 511;
  }
  return httpd_cgi_ret(a1, v12, v9, 4);
}
// 45FDB0: variable 'v2' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);

//----- (0045FE14) --------------------------------------------------------
int __fastcall sub_45FE14(int a1)
{
  char *v2; // $s7
  char *v3; // $s4
  char *v4; // $s1
  _BYTE *v6; // $v0
  void *v7; // $v0
  void *v8; // $s2
  _BYTE *v9; // $s3
  _DWORD *v10; // $s6
  char *v11; // $s1
  const char *v12; // $v0
  int v13; // $a0
  const char *v14; // $v0
  char *v15; // $v1
  int v16; // $t0
  int v17; // $a3
  int v18; // $a2
  int v19; // $a1
  const char *v20; // $s1
  int v21; // $a0
  const char *v22; // $v0
  int v23; // $fp
  int v24; // $a1
  int v25; // $a2
  int v26; // $a0
  const char *v27; // $v0
  const char *v28; // [sp+28h] [-240h] BYREF
  const char *v29; // [sp+2Ch] [-23Ch]
  const char *v30; // [sp+30h] [-238h]
  int v31; // [sp+34h] [-234h]
  int v32; // [sp+38h] [-230h]
  int v33; // [sp+3Ch] [-22Ch]
  char v34[256]; // [sp+128h] [-140h] BYREF
  int v35[8]; // [sp+228h] [-40h] BYREF
  int v36; // [sp+248h] [-20h]
  char *v37; // [sp+24Ch] [-1Ch]
  char *v38; // [sp+250h] [-18h]
  char *v39; // [sp+254h] [-14h]
  char *v40; // [sp+258h] [-10h]
  void *s; // [sp+25Ch] [-Ch]
  char *v42; // [sp+260h] [-8h]

  v40 = httpd_get_parm(a1, "en");
  v2 = httpd_get_parm(a1, "name");
  v39 = httpd_get_parm(a1, "old_name");
  v3 = httpd_get_parm(a1, "macs");
  v4 = httpd_get_parm(a1, "opt");
  v38 = httpd_get_parm(a1, "act");
  v37 = httpd_get_parm(a1, "time");
  v36 = httpd_get_json_parm(a1, (int)"del_list");
  if ( !v4 )
    goto LABEL_56;
  if ( !strcmp(v4, (const char *)&off_646D8C) || !strcmp(v4, (const char *)&off_648DDC) || !strcmp(v4, "del") )
  {
    if ( !strcmp(v4, "delall") )
      goto LABEL_7;
    if ( !strcmp(v4, (const char *)&off_64712C) )
    {
LABEL_23:
      v11 = httpd_get_parm(a1, (char *)&off_64712C);
      if ( v11 )
      {
        v12 = (const char *)nvram_get("macfilterAct");
        if ( !v12 || strcmp(v12, v11) )
        {
          nvram_set("macfilterAct", v11);
          v28 = "wys";
          v29 = "macfilter";
          v30 = "defaut_set";
          v31 = jhl_nv_get_def("macfilterAct");
          v32 = jhl_nv_get_def("macfilterWAN");
          v33 = 0;
          eval(&v28, 0, 0, 0);
          jhl_parm_commit(v13);
        }
      }
      v14 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      v15 = v34;
      do
      {
        v16 = *(_DWORD *)v14;
        v17 = *((_DWORD *)v14 + 1);
        v18 = *((_DWORD *)v14 + 2);
        v19 = *((_DWORD *)v14 + 3);
        v14 += 16;
        *(_DWORD *)v15 = v16;
        *((_DWORD *)v15 + 1) = v17;
        *((_DWORD *)v15 + 2) = v18;
        *((_DWORD *)v15 + 3) = v19;
        v15 += 16;
      }
      while ( v14 != "}" );
      JUMPOUT(0x46007C);
    }
    _mem_malloc(0x200000, "mac_filter_asp", 888);
    v8 = v7;
    _mem_malloc(0x200000, "mac_filter_asp", 889);
    v9 = v6;
    if ( v8 && v6 )
    {
      if ( !strcmp(v4, "del") && v36 && cJSON_IsArray(v36) )
      {
        v10 = *(_DWORD **)(v36 + 8);
        if ( !v10 || !v10[4] )
          goto LABEL_49;
        v42 = "a";
        v36 = 0;
        do
        {
          jhl_parm_get("macfilterAll", v8, 0x200000);
          if ( nvparm_del_str_too_loog(v8, 60, 6, v10[4], 124, 0, v9) )
          {
            v28 = "macfilter_del.sh";
            v29 = (const char *)v10[4];
            v30 = 0;
            eval(&v28, 0, 0, 0);
            jhl_parm_set("macfilterAll", v9);
            v36 = 1;
          }
          v10 = (_DWORD *)*v10;
        }
        while ( v10 && v10[4] );
LABEL_54:
        if ( !v36 )
          goto LABEL_49;
        goto LABEL_48;
      }
      if ( v2 || !strcmp(v4, (const char *)&off_64712C) )
      {
        if ( !strcmp(v4, (const char *)&off_648DDC) )
        {
          v42 = "a";
          jhl_parm_get("macfilterAll", v8, 0x200000);
          if ( v39 )
          {
            s = &v28;
            v28 = "macfilter_del.sh";
            v36 = nvparm_del_str_too_loog(v8, 60, 6, v39, 124, 0, v9) != 0;
            v29 = v39;
          }
          else
          {
            v36 = nvparm_del_str_too_loog(v8, 60, 6, v2, 124, 0, v9) != 0;
            s = &v28;
            v28 = "macfilter_del.sh";
            v29 = v2;
          }
          v30 = 0;
          eval(&v28, 0, 0, 0);
          if ( strcmp(v4, (const char *)&off_646D8C) && strcmp(v4, (const char *)&off_648DDC) )
            goto LABEL_54;
        }
        else
        {
          if ( strcmp(v4, (const char *)&off_646D8C) )
          {
LABEL_49:
            _mem_free(v8);
            _mem_free(v9);
            mac_filter_data(a1);
            goto LABEL_72;
          }
          v36 = 0;
          s = &v28;
        }
        memset(s, 0, 0x100u);
        if ( v3 && *v3 )
        {
          if ( !strcmp(v4, (const char *)&off_646D8C) )
          {
            v42 = "a";
            v23 = check_rule_num_limit(a1, 10, (int)"macfilterAll", 60, v34, 0x100u);
            if ( v23 > 0 )
            {
LABEL_59:
              _mem_free(v8);
              _mem_free(v9);
              httpd_cgi_ret(a1, v34, v23, 4);
LABEL_72:
              JUMPOUT(0x46009C);
            }
          }
          else
          {
            v42 = "a";
          }
          if ( !v38 || !*v38 )
            v38 = "1";
          if ( !v37 )
            v37 = "OFF";
          sprintf((char *)v8, "%s|%s|%s|%s|%s<", v2, v40, v3, v37, v38);
          if ( !v36 )
          {
            jhl_parm_get(v42 + 25912, v9, 0x200000);
            if ( !strcmp(v9, " ") )
              *v9 = 0;
          }
          strcat(v9, (char *)v8);
          v20 = (const char *)s;
          if ( !get_time_group(v37, s, 256) )
            v37 = (char *)v20;
          v35[0] = (int)"macfilter_add.sh";
          v35[1] = (int)v40;
          v35[4] = (int)v38;
          v35[2] = (int)v2;
          v35[3] = (int)v3;
          v35[5] = (int)v37;
          v35[6] = 0;
          eval(v35, 0, 0, 0);
LABEL_48:
          jhl_parm_set(v42 + 25912, v9);
          jhl_parm_commit(v21);
          goto LABEL_49;
        }
        v24 = *(unsigned __int8 *)(a1 + 210102);
        v25 = (int)&unk_646720;
      }
      else
      {
        v24 = *(unsigned __int8 *)(a1 + 210102);
        v25 = (int)&unk_6442E4;
      }
      v26 = 12;
    }
    else
    {
      v24 = *(unsigned __int8 *)(a1 + 210102);
      v25 = 0x200000;
      v26 = 4;
    }
    v27 = (const char *)_GET_LANG_TEXT(v26, v24, v25);
    v23 = snprintf(v34, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
    if ( (unsigned int)v23 >= 0x100 )
      v23 = 255;
    goto LABEL_59;
  }
  if ( !strcmp(v4, (const char *)&off_64712C) )
  {
    if ( !strcmp(v4, "delall") )
      goto LABEL_7;
    goto LABEL_23;
  }
  if ( strcmp(v4, "delall") )
  {
LABEL_56:
    v22 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    v23 = snprintf(v34, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v22);
    if ( (unsigned int)v23 >= 0x100 )
      v23 = 255;
    v9 = 0;
    v8 = 0;
    goto LABEL_59;
  }
LABEL_7:
  v28 = "macfilter_delall.sh";
  v29 = 0;
  eval(&v28, 0, 0, 0);
  return sub_460000();
}
// 4603F4: control flows out of bounds to 46007C
// 460650: control flows out of bounds to 46009C
// 460138: variable 'v7' is possibly undefined
// 460144: variable 'v6' is possibly undefined
// 4603A4: variable 'v13' is possibly undefined
// 4605FC: variable 'v21' is possibly undefined
// 460000: using guessed type int sub_460000(void);
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8298: using guessed type int __fastcall get_time_group(_DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A87F8: using guessed type int __fastcall nvparm_del_str_too_loog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00460000) --------------------------------------------------------
void sub_460000()
{
  int v0; // $s0
  int v1; // $a0
  unsigned int *v2; // $v1
  const char *v3; // $v0
  unsigned int v4; // $t0
  unsigned int v5; // $a3
  unsigned int v6; // $a2
  unsigned int v7; // $a1

  jhl_parm_set("macfilterAll", " ");
  jhl_parm_commit(v1);
  v2 = &STACK[0x128];
  v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v4 = *(_DWORD *)v3;
    v5 = *((_DWORD *)v3 + 1);
    v6 = *((_DWORD *)v3 + 2);
    v7 = *((_DWORD *)v3 + 3);
    v3 += 16;
    *v2 = v4;
    v2[1] = v5;
    v2[2] = v6;
    v2[3] = v7;
    v2 += 4;
  }
  while ( v3 != "}" );
  *(_WORD *)v2 = *(_WORD *)v3;
  httpd_cgi_ret(v0, (char *)&STACK[0x128], 33, 4);
  __asm { jr      $ra }
}
// 460030: variable 'v1' is possibly undefined
// 460094: variable 'v0' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);

//----- (00460998) --------------------------------------------------------
int __fastcall arp_st_getfile(void *a1, signed int a2)
{
  char *v4; // $v0
  int v5; // $a2
  char *v6; // $s2
  int v7; // $s0
  const char *v9; // $s1
  int v10; // $s5
  int v11; // $v0
  int v12; // $v0
  int v13; // $v0
  int v14; // $s3
  int v15; // $s0
  int v16; // $v0
  int v17; // $v0
  char v18[32]; // [sp+20h] [-60h] BYREF
  char v19[32]; // [sp+40h] [-40h] BYREF
  int v20; // [sp+60h] [-20h]
  int v21; // [sp+64h] [-1Ch]
  char *v22; // [sp+68h] [-18h]
  char *v23; // [sp+6Ch] [-14h]
  char *v24; // [sp+70h] [-10h]
  char *v25; // [sp+74h] [-Ch]
  char *v26; // [sp+78h] [-8h]
  char *format; // [sp+7Ch] [-4h]

  v24 = "a";
  _mem_malloc(0x200000, "arp_st_getfile", 645);
  v6 = v4;
  if ( !v4 )
    return 0;
  *(_DWORD *)v4 = 3;
  *((_DWORD *)v4 + 3) = 7;
  *((_DWORD *)v4 + 1) = 0x200000;
  v7 = 0;
  if ( !jianhl_order_opt_fun(v4, 0x200000, v5) )
  {
    memset(a1, 0, a2);
    v7 = snprintf((char *)a1, a2, aIIpaddrMMacadd);
    if ( v7 >= a2 )
      v7 = a2 - 1;
    v9 = v6 + 76;
    if ( *((int *)v6 + 5) > 0 )
    {
      v22 = "a";
      v10 = 0;
      v23 = "a";
      v26 = "a";
      v21 = a2 - 149;
      format = ",t:only";
      v25 = "undefine";
      do
      {
        v20 = IpToStr(v19, *((_DWORD *)v9 - 13));
        v12 = MacToStr(v18, v9 - 40);
        v13 = snprintf((char *)a1 + v7, a2 - v7, v22 + 26548, v20, v12, v9 - 24);
        if ( v13 >= a2 - v7 )
          v13 = a2 - v7 - 1;
        v14 = v13 + v7;
        if ( *((_DWORD *)v9 - 7) == 4 )
        {
          v17 = snprintf((char *)a1 + v14, a2 - v14, format);
          if ( v17 >= a2 - v14 )
            v17 = a2 - v14 - 1;
          v14 += v17;
        }
        if ( *v9 )
        {
          v15 = a2 - v14;
          if ( strcmp(v9, v25) )
          {
            v16 = snprintf((char *)a1 + v14, a2 - v14, v26 + 26572, v9);
            if ( v16 >= v15 )
              v16 = v15 - 1;
            v14 += v16;
          }
        }
        v11 = snprintf((char *)a1 + v14, a2 - v14, v23 + 26580);
        if ( v11 >= a2 - v14 )
          v11 = a2 - v14 - 1;
        v7 = v14 + v11;
        ++v10;
        if ( v14 + v11 >= v21 )
          break;
        v9 += 96;
      }
      while ( v10 < *((_DWORD *)v6 + 5) );
    }
  }
  _mem_free(v6);
  return v7;
}
// 460A00: variable 'v4' is possibly undefined
// 460A24: variable 'v5' is possibly undefined
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00460CA4) --------------------------------------------------------
int __fastcall sub_460CA4(int a1)
{
  void *v2; // $v0
  int v3; // $v0
  void *v4; // $s1
  int result; // $v0
  const char *v6; // $v0
  unsigned int v7; // $v0
  char v8[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "arpsts_txt", 712);
  if ( v2 )
  {
    v4 = v2;
    v3 = arp_st_getfile(v2, 0x200000);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v3);
  }
  else
  {
    v6 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v7 = snprintf(v8, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v6);
    if ( v7 >= 0x100 )
      v7 = 255;
    result = httpd_cgi_ret(a1, v8, v7, 4);
  }
  return result;
}
// 460CE4: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00460DC4) --------------------------------------------------------
int __fastcall sub_460DC4(int a1)
{
  void *v2; // $v0
  int v3; // $v0
  void *v4; // $s1
  int *v5; // $s0
  int v6; // $s3
  int v7; // $s2
  int v8; // $s1
  int v9; // $v0
  char *v10; // $s1
  int v12[4096]; // [sp+28h] [-4158h] BYREF
  char v13[256]; // [sp+4028h] [-158h] BYREF
  int v14[7]; // [sp+4128h] [-58h] BYREF
  int v15; // [sp+4144h] [-3Ch] BYREF
  int v16; // [sp+4148h] [-38h]
  int v17; // [sp+414Ch] [-34h]
  int v18; // [sp+4150h] [-30h]
  int v19; // [sp+4154h] [-2Ch]
  int v20; // [sp+4160h] [-20h]
  char *v21; // [sp+4164h] [-1Ch]
  char *format; // [sp+4168h] [-18h]
  const char *v23; // [sp+416Ch] [-14h]
  void *v24; // [sp+4170h] [-10h]
  char *v25; // [sp+4174h] [-Ch]
  char *v26; // [sp+4178h] [-8h]

  v26 = "a";
  memset(v13, 0, sizeof(v13));
  _mem_malloc(0x200000, "mac_filter_change_def", 786);
  v24 = v2;
  v4 = v2;
  _mem_malloc(0x200000, "mac_filter_change_def", 787);
  v21 = (char *)v3;
  if ( !v4 )
    return -1;
  v5 = v12;
  if ( !v3 )
    return -1;
  v25 = "a";
  v12[0] = (int)"macfilter_delall.sh";
  v12[1] = 0;
  eval(v12, 0, 0, 0);
  jhl_parm_get("macfilterAll", v4, 0x200000);
  v6 = split_string(v4, 60, v12, 4096);
  if ( v6 > 0 )
  {
    format = "%s|%s|%s|%s|%s<";
    v7 = 0;
    v8 = 0;
    v23 = "macfilter_add.sh";
    do
    {
      while ( split_string(*v5, 124, &v15, 5) < 5 )
      {
        ++v8;
        ++v5;
        if ( v6 == v8 )
          goto LABEL_12;
      }
      v20 = 0x200000 - v7;
      v19 = a1;
      v9 = snprintf(&v21[v7], 0x200000 - v7, format, v15, v16, v17, v18, a1);
      if ( v9 >= v20 )
        v9 = 0x1FFFFF - v7;
      v7 += v9;
      if ( get_time_group(v18, v13, 256) )
        strlcpy(v13, v18, 256);
      v14[0] = (int)v23;
      v14[1] = v16;
      v14[2] = v15;
      v14[3] = v17;
      v14[4] = v19;
      v14[5] = (int)v13;
      v14[6] = 0;
      ++v8;
      eval(v14, 0, 0, 0);
      ++v5;
    }
    while ( v6 != v8 );
  }
LABEL_12:
  v10 = v21;
  jhl_parm_set(v25 + 25912, v21);
  _mem_free(v24);
  _mem_free(v10);
  return 0;
}
// 460E54: variable 'v2' is possibly undefined
// 460E60: variable 'v3' is possibly undefined
// 6A8298: using guessed type int __fastcall get_time_group(_DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004610D0) --------------------------------------------------------
void __fastcall format_ddos_rule_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 7 )
    snprintf(
      a3,
      a4,
      "{\"name\":\"%s\",\"en\":%s,\"user\":\"%s\",\"proto\":\"%s\",\"num\":%s,\"interval\":%s,\"time\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6]);
}

//----- (00461178) --------------------------------------------------------
int __fastcall ddos_data(int a1)
{
  char *v1; // $v0
  char *v2; // $s0
  int v3; // $v0
  _BYTE *v4; // $s3
  int v5; // $s1
  const char **v6; // $s2
  void *v7; // $v0
  _DWORD *v8; // $s7
  int v9; // $a1
  void *v10; // $s1
  int v11; // $s5
  _DWORD *v12; // $fp
  int v13; // $s1
  int i; // $s6
  int v15; // $v0
  int v16; // $v0
  int v17; // $s4
  char *v18; // $a0
  int v19; // $v0
  const char *v20; // $s4
  const char *v21; // $s5
  const char *v22; // $s7
  const char *v23; // $fp
  int v24; // $s1
  const char *v25; // $v0
  int v26; // $s1
  int v27; // $v0
  int v28; // $s1
  int v29; // $a2
  const char *v31; // $v0
  unsigned int v32; // $v0
  char v33[256]; // [sp+50h] [-228h] BYREF
  char v34[4]; // [sp+150h] [-128h] BYREF
  const char *v35; // [sp+154h] [-124h]
  const char *v36; // [sp+158h] [-120h]
  const char *v37; // [sp+160h] [-118h]
  const char *v38; // [sp+164h] [-114h]
  const char *v39; // [sp+16Ch] [-10Ch]
  const char *v40; // [sp+170h] [-108h]
  const char *v41; // [sp+178h] [-100h]
  const char *v42; // [sp+17Ch] [-FCh]
  const char *v43; // [sp+184h] [-F4h]
  const char *v44; // [sp+188h] [-F0h]
  void *ptr; // [sp+250h] [-28h]
  const char *v46; // [sp+254h] [-24h]
  const char *v47; // [sp+258h] [-20h]
  const char *v48; // [sp+25Ch] [-1Ch]
  const char *v49; // [sp+260h] [-18h]
  const char *v50; // [sp+264h] [-14h]
  const char *v51; // [sp+268h] [-10h]
  const char *v52; // [sp+26Ch] [-Ch]
  const char *v53; // [sp+270h] [-8h]
  const char *v54; // [sp+274h] [-4h]

  memset(v33, 0, sizeof(v33));
  _mem_malloc(102400, "ddos_data", 1079);
  v2 = v1;
  if ( v1 )
  {
    strcpy(v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v1, "{\"code\":0,\"error\":\"\"", 20);
    v3 = jhl_nv_get_def("hixz3");
    strlcpy(v33, v3, 256);
    split_string(v33, 60, v34, 15);
    v2[32] = 108;
    *(_DWORD *)(v2 + 29) = 1819042082;
    v2[33] = 34;
    v2[34] = 58;
    v2[35] = 0;
    v4 = v2 + 35;
    v5 = nvram_get("hixz_ddos");
    v2[35] = 91;
    v2[36] = 0;
    if ( v5 )
    {
      v6 = (const char **)malloc(0x24u);
      v8 = malloc(0x4008u);
      v7 = malloc(0x200000u);
      ptr = v7;
      if ( v7 )
      {
        if ( v6
          && (v9 = v5, v8)
          && (v10 = v7, strlcpy(v7, v9, 0x200000), v11 = split_string(v10, 60, v8, 4096), v11 > 0) )
        {
          v12 = v8;
          v13 = 1;
          for ( i = 0; i != v11; ++i )
          {
            v15 = split_string(*v12, 124, v6, 7);
            format_ddos_rule_data(v6, v15, &v4[v13], 102365 - v13);
            v13 += v16;
            ++v12;
          }
          v17 = v13;
        }
        else
        {
          v17 = 1;
          v13 = 1;
        }
        free(ptr);
      }
      else
      {
        v17 = 1;
        v13 = 1;
      }
      if ( v6 )
        free(v6);
      if ( v8 )
        free(v8);
      if ( v13 <= 0 )
      {
        v18 = &v4[v17];
        goto LABEL_17;
      }
      v18 = &v4[v17];
      if ( v4[v17 - 1] != 44 )
      {
LABEL_17:
        *v18 = 0;
        v19 = snprintf(v18, 102365 - v13, &byte_6445A0);
        if ( v19 >= 102365 - v13 )
          v19 = 102364 - v13;
        v54 = v39;
        v53 = v40;
        v52 = v41;
        v51 = v42;
        v50 = v43;
        v49 = v44;
        v20 = v35;
        v21 = v36;
        v22 = v37;
        v23 = v38;
        v24 = v13 + v19;
        v48 = (const char *)jhl_nv_get_def("ddos_maclist");
        v47 = (const char *)jhl_nv_get_def("ddos_wan_reconn_en");
        v46 = (const char *)jhl_nv_get_def("ddos_wan_reconn_limit");
        ptr = (void *)jhl_nv_get_def("drop_broadcast");
        v25 = (const char *)jhl_nv_get_def("drop_foreign_ip");
        v26 = v24 + 35;
        v27 = snprintf(
                &v2[v26],
                102400 - v26,
                ",\"def_max\":%s,\"def_time\":%s,\"def_tcp_max\":%s,\"def_tcp_time\":%s,\"def_udp_max\":%s,\"def_udp_time"
                "\":%s,\"def_icmp_max\":%s,\"def_icmp_time\":%s,\"def_other_max\":%s,\"def_other_time\":%s,\"maclist\":\""
                "%s\",\"reconn_en\":%s,\"reconn_limit\":%s,\"drop_broadcast\":%s,\"drop_foreign_ip\":%s",
                v20,
                v21,
                v22,
                v23,
                v54,
                v53,
                v52,
                v51,
                v50,
                v49,
                v48,
                v47,
                v46,
                (const char *)ptr,
                v25);
        if ( v27 >= 102400 - v26 )
          v27 = 102399 - v26;
        v28 = v27 + v26;
        v29 = snprintf(&v2[v28], 102400 - v28, "}}");
        if ( v29 >= 102400 - v28 )
          v29 = 102399 - v28;
        return httpd_cgi_ret(a1, v2, v29 + v28, 8);
      }
    }
    else
    {
      v18 = v2 + 36;
      v13 = 1;
      if ( *v4 != 44 )
        goto LABEL_17;
    }
    v18 = &v4[--v13];
    goto LABEL_17;
  }
  v31 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v32 = snprintf(v34, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
  if ( v32 >= 0x100 )
    v32 = 255;
  return httpd_cgi_ret(a1, v34, v32, 4);
}
// 4611F8: variable 'v1' is possibly undefined
// 4613F4: variable 'v16' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6459A8: using guessed type int dword_6459A8;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046175C) --------------------------------------------------------
int __fastcall sub_46175C(int a1)
{
  char *v2; // $s5
  char *v3; // $s7
  char *v4; // $fp
  char *v5; // $v0
  int v6; // $s4
  const char *v7; // $s2
  const char *v8; // $v0
  unsigned int v9; // $s6
  char *v11; // $fp
  char *v12; // $s7
  char *v13; // $s2
  char *v14; // $s3
  char *v15; // $s5
  char *v16; // $s6
  int v17; // $v0
  int v18; // $a0
  char *v19; // $s1
  int v20; // $s1
  char *v21; // $s7
  char *v22; // $s7
  char *v23; // $s7
  char *v24; // $s7
  char *v25; // $s7
  char *v26; // $s1
  const char *v27; // $v0
  char *v28; // $s2
  char *v29; // $s1
  const char *v30; // $s2
  const char *v31; // $v0
  int v32; // $s2
  const char *v33; // $v0
  _BYTE *v34; // $v0
  void *v35; // $v0
  void *v36; // $s1
  _BYTE *v37; // $s3
  _DWORD *v38; // $fp
  int v39; // $v0
  int v40; // $v0
  const char *v41; // $s6
  int v42; // $a0
  char *v43; // $v1
  const char *v44; // $v0
  int v45; // $t0
  int v46; // $a3
  int v47; // $a2
  int v48; // $a1
  int v49; // $a1
  int v50; // $a2
  int v51; // $a0
  const char *v52; // $v0
  const char *v53; // $v0
  const char *v54; // [sp+40h] [-5D0h]
  int v55[256]; // [sp+50h] [-5C0h] BYREF
  char s[256]; // [sp+450h] [-1C0h] BYREF
  const char *v57; // [sp+550h] [-C0h] BYREF
  const char *v58; // [sp+554h] [-BCh]
  const char *v59; // [sp+558h] [-B8h]
  char *v60; // [sp+55Ch] [-B4h]
  char *v61; // [sp+560h] [-B0h]
  char *v62; // [sp+564h] [-ACh]
  const char *v63; // [sp+568h] [-A8h]
  char *v64; // [sp+56Ch] [-A4h]
  char *v65; // [sp+570h] [-A0h]
  const char *v66; // [sp+574h] [-9Ch]
  char *v67; // [sp+578h] [-98h]
  char *v68; // [sp+57Ch] [-94h]
  const char *v69; // [sp+580h] [-90h]
  char *v70; // [sp+584h] [-8Ch]
  char *v71; // [sp+588h] [-88h]
  const char *v72; // [sp+58Ch] [-84h]
  char *v73; // [sp+590h] [-80h]
  char *v74; // [sp+594h] [-7Ch]
  int v75; // [sp+598h] [-78h]
  char *v76; // [sp+59Ch] [-74h] BYREF
  char *v77; // [sp+5A0h] [-70h]
  char *v78; // [sp+5A4h] [-6Ch]
  const char *v79; // [sp+5A8h] [-68h]
  char *v80; // [sp+5ACh] [-64h]
  char *v81; // [sp+5B0h] [-60h]
  const char *v82; // [sp+5B4h] [-5Ch]
  char *v83; // [sp+5B8h] [-58h]
  char *v84; // [sp+5BCh] [-54h]
  const char *v85; // [sp+5C0h] [-50h]
  char *v86; // [sp+5C4h] [-4Ch]
  char *v87; // [sp+5C8h] [-48h]
  const char *v88; // [sp+5CCh] [-44h]
  char *v89; // [sp+5D0h] [-40h]
  char *v90; // [sp+5D4h] [-3Ch]
  char *v91; // [sp+5E0h] [-30h]
  char *v92; // [sp+5E4h] [-2Ch]
  char *v93; // [sp+5E8h] [-28h]
  char *v94; // [sp+5ECh] [-24h]
  int v95; // [sp+5F0h] [-20h]
  char *v96; // [sp+5F4h] [-1Ch]
  char *v97; // [sp+5F8h] [-18h]
  char *v98; // [sp+5FCh] [-14h]
  char *v99; // [sp+600h] [-10h]
  char *v100; // [sp+604h] [-Ch]
  char *v101; // [sp+608h] [-8h]
  char *v102; // [sp+60Ch] [-4h]

  v2 = httpd_get_parm(a1, "name");
  v95 = (int)httpd_get_parm(a1, "old_name");
  v91 = httpd_get_parm(a1, "en");
  v92 = httpd_get_parm(a1, "user_id");
  v93 = httpd_get_parm(a1, "proto");
  v94 = httpd_get_parm(a1, "num");
  v3 = httpd_get_parm(a1, "c");
  v4 = httpd_get_parm(a1, "time");
  v6 = httpd_get_json_parm(a1, (int)"del_list");
  v5 = httpd_get_parm(a1, "opt");
  if ( !v5 )
    goto LABEL_6;
  v7 = v5;
  if ( strcmp(v5, (const char *)&off_64712C) )
  {
    v97 = "a";
    if ( strcmp(v7, (const char *)&off_646D8C) && strcmp(v7, (const char *)&off_648DDC) && strcmp(v7, "del") )
    {
LABEL_6:
      v8 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
      v9 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
      if ( v9 >= 0x100 )
        v9 = 255;
      return httpd_cgi_ret(a1, s, v9, 4);
    }
    v96 = "a";
    _mem_malloc(102400, "ddos_asp", 1346);
    v36 = v35;
    _mem_malloc(102400, "ddos_asp", 1347);
    v37 = v34;
    if ( !v36 )
    {
      v53 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
      v9 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v53);
      if ( v9 >= 0x100 )
        v9 = 255;
      goto LABEL_105;
    }
    if ( v34 )
    {
      if ( !strcmp(v7, "del") && v6 )
      {
        v38 = *(_DWORD **)(v6 + 8);
        if ( !v38 )
          goto LABEL_101;
        v39 = v38[4];
        if ( !v39 )
          goto LABEL_101;
        v98 = "a";
        v95 = 0;
        v91 = "hixz_ddos";
        do
        {
          v55[1] = v39;
          v55[0] = (int)"hixzddos_del.sh";
          v55[2] = 0;
          eval(v55, 0, 0, 0);
          jhl_parm_get("hixz_ddos", v36, 102400);
          if ( nvparm_del_str(v36, 60, 10, v38[4], 124, 0, v37) )
          {
            jhl_parm_set(v91, v37);
            v95 = 1;
          }
          v38 = (_DWORD *)*v38;
          if ( !v38 )
            break;
          v39 = v38[4];
        }
        while ( v39 );
LABEL_108:
        if ( v95 )
        {
LABEL_100:
          jhl_parm_set(v98 + 26668, v37);
          jhl_parm_commit(v42);
        }
LABEL_101:
        v43 = s;
        v44 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v45 = *(_DWORD *)v44;
          v46 = *((_DWORD *)v44 + 1);
          v47 = *((_DWORD *)v44 + 2);
          v48 = *((_DWORD *)v44 + 3);
          v44 += 16;
          *(_DWORD *)v43 = v45;
          *((_DWORD *)v43 + 1) = v46;
          *((_DWORD *)v43 + 2) = v47;
          *((_DWORD *)v43 + 3) = v48;
          v43 += 16;
        }
        while ( v44 != "}" );
        v9 = 33;
        *(_WORD *)v43 = *(_WORD *)v44;
LABEL_104:
        _mem_free(v36);
LABEL_105:
        if ( v37 )
          _mem_free(v37);
        return httpd_cgi_ret(a1, s, v9, 4);
      }
      if ( v2 )
      {
        if ( !strcmp(v7, (const char *)&off_648DDC) )
        {
          if ( v95 )
          {
            v55[1] = v95;
            v98 = "a";
            v55[2] = 0;
            v55[0] = (int)"hixzddos_del.sh";
            eval(v55, 0, 0, 0);
            jhl_parm_get("hixz_ddos", v36, 102400);
            v40 = nvparm_del_str(v36, 60, 10, v95, 124, 0, v37);
          }
          else
          {
            v55[1] = (int)v2;
            v98 = "a";
            v55[2] = 0;
            v55[0] = (int)"hixzddos_del.sh";
            eval(v55, 0, 0, 0);
            jhl_parm_get(v98 + 26668, v36, 102400);
            v40 = nvparm_del_str(v36, 60, 10, v2, 124, 0, v37);
          }
          v95 = v40 != 0;
          if ( strcmp(v7, v97 + 28044) && strcmp(v7, (const char *)&off_648DDC) )
            goto LABEL_108;
        }
        else
        {
          if ( strcmp(v7, v97 + 28044) )
            goto LABEL_101;
          v95 = 0;
          v98 = "a";
        }
        memset(v55, 0, sizeof(v55));
        if ( v91 )
          v99 = v91;
        else
          v99 = "1";
        if ( v92 )
          v91 = v92;
        else
          v91 = "0";
        if ( v93 )
          v92 = v93;
        else
          v92 = "all";
        if ( v94 )
        {
          v93 = v94;
          if ( v3 )
          {
LABEL_93:
            if ( !v4 )
              v4 = "OFF";
            strlcpy(v55, v4, 1024);
            if ( !strcmp(v7, v97 + 28044) )
            {
              v9 = check_rule_num_limit(a1, 12, (int)(v98 + 26668), 60, s, 0x100u);
              if ( (int)v9 > 0 )
                goto LABEL_104;
            }
            if ( get_time_group(v4, v55, 1024) )
              strlcpy(v55, v4, 1024);
            v41 = v99;
            v57 = "hixzddos_add.sh";
            v61 = v92;
            v62 = v93;
            v58 = v2;
            v59 = v99;
            v60 = v91;
            v63 = v3;
            v64 = (char *)v55;
            v65 = (char *)v55;
            v66 = 0;
            eval(&v57, 0, 0, 0);
            sprintf((char *)v36, "%s|%s|%s|%s|%s|%s|%s<", v2, v41, v91, v92, v93, v3, v4);
            if ( !v95 )
            {
              jhl_parm_get(v98 + 26668, v37, 102400);
              if ( !strcmp(v37, " ") )
                *v37 = 0;
            }
            strcat(v37, (char *)v36);
            goto LABEL_100;
          }
        }
        else
        {
          v93 = "50";
          if ( v3 )
            goto LABEL_93;
        }
        v3 = "1";
        goto LABEL_93;
      }
      v49 = *(unsigned __int8 *)(a1 + 210102);
      v50 = (int)&unk_6442E4;
      v51 = 12;
    }
    else
    {
      v49 = *(unsigned __int8 *)(a1 + 210102);
      v50 = 102400;
      v51 = 4;
    }
    v52 = (const char *)_GET_LANG_TEXT(v51, v49, v50);
    v9 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v52);
    if ( v9 >= 0x100 )
      v9 = 255;
    goto LABEL_104;
  }
  v94 = httpd_get_parm(a1, "def_max");
  v11 = httpd_get_parm(a1, "def_time");
  v12 = httpd_get_parm(a1, "def_tcp_max");
  v95 = (int)httpd_get_parm(a1, "def_tcp_time");
  v96 = httpd_get_parm(a1, "def_udp_max");
  v97 = httpd_get_parm(a1, "def_udp_time");
  v98 = httpd_get_parm(a1, "def_icmp_max");
  v99 = httpd_get_parm(a1, "def_icmp_time");
  v13 = httpd_get_parm(a1, "def_other_max");
  v14 = httpd_get_parm(a1, "def_other_time");
  v15 = httpd_get_parm(a1, "maclist");
  v92 = "a";
  v100 = httpd_get_parm(a1, "reconn_en");
  v93 = "a";
  v101 = httpd_get_parm(a1, "reconn_limit");
  v91 = httpd_get_parm(a1, "drop_broadcast");
  v16 = httpd_get_parm(a1, "drop_foreign_ip");
  memset(s, 0, sizeof(s));
  v102 = "a";
  memset(v55, 0, 0x100u);
  v17 = jhl_nv_get_def("hixz3");
  strlcpy(s, v17, 256);
  split_string(s, 60, &v76, 15);
  v19 = v94;
  if ( !v94 || !strcmp(v77, v94) )
  {
    v20 = 0;
  }
  else
  {
    v77 = v19;
    v20 = 1;
  }
  if ( v11 && strcmp(v78, v11) )
  {
    v78 = v11;
    v20 = 1;
  }
  if ( v12 && strcmp(v80, v12) )
  {
    v80 = v12;
    v20 = 1;
  }
  v21 = (char *)v95;
  if ( v95 && strcmp(v81, (const char *)v95) )
  {
    v81 = v21;
    v20 = 1;
  }
  v22 = v96;
  if ( v96 && strcmp(v83, v96) )
  {
    v83 = v22;
    v20 = 1;
  }
  v23 = v97;
  if ( v97 && strcmp(v84, v97) )
  {
    v84 = v23;
    v20 = 1;
  }
  v24 = v98;
  if ( v98 && strcmp(v86, v98) )
  {
    v86 = v24;
    v20 = 1;
  }
  v25 = v99;
  if ( v99 && strcmp(v87, v99) )
  {
    v87 = v25;
    v20 = 1;
  }
  if ( v13 && strcmp(v89, v13) )
  {
    v89 = v13;
    v26 = v90;
    if ( !v14 || !strcmp(v90, v14) )
      goto LABEL_39;
    v90 = v14;
    goto LABEL_38;
  }
  if ( v14 && strcmp(v90, v14) )
  {
    v13 = v89;
    v90 = v14;
LABEL_38:
    v26 = v14;
    goto LABEL_39;
  }
  if ( !v20 )
    goto LABEL_40;
  v13 = v89;
  v26 = v90;
LABEL_39:
  v54 = v26;
  v20 = 1;
  sprintf(
    (char *)v55,
    "%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s",
    v76,
    v77,
    v78,
    v79,
    v80,
    v81,
    v82,
    v83,
    v84,
    v85,
    v86,
    v87,
    v88,
    v13,
    v54);
  nvram_set("hixz3", v55);
  v57 = "wys";
  v58 = "ctrule";
  v59 = "defset";
  v60 = v76;
  v61 = v77;
  v62 = v78;
  v63 = v79;
  v64 = v80;
  v65 = v81;
  v66 = v82;
  v67 = v83;
  v68 = v84;
  v69 = v85;
  v70 = v86;
  v71 = v87;
  v72 = v88;
  v73 = v89;
  v75 = 0;
  v74 = v90;
  eval(&v57, 0, 0, 0);
LABEL_40:
  if ( v15 )
  {
    v27 = (const char *)nvram_get("ddos_maclist");
    if ( !v27 || strcmp(v27, v15) )
    {
      nvram_set("ddos_maclist", v15);
      v57 = "wys";
      v58 = "ddos";
      v59 = "mac_set";
      v60 = v15;
      v61 = 0;
      eval(&v57, 0, 0, 0);
      v20 = 1;
    }
  }
  if ( v100 )
  {
    v28 = v101;
    if ( v101 )
    {
      v29 = v100;
      nvram_set("ddos_wan_reconn_en", v100);
      nvram_set("ddos_wan_reconn_limit", v28);
      v61 = v29;
      v57 = "wys";
      v58 = "ddos";
      v59 = "wan_attack";
      v60 = "set";
      v62 = v28;
      v63 = 0;
      eval(&v57, 0, 0, 0);
      v20 = 1;
    }
  }
  v30 = v91;
  if ( v91 )
  {
    v31 = (const char *)nvram_get(v92 + 26740);
    if ( v31 && !strcmp(v31, v30) )
    {
      v32 = 0;
      if ( !v16 )
        goto LABEL_57;
    }
    else
    {
      nvram_set(v92 + 26740, v91);
      v20 = 1;
      if ( !v16 )
        goto LABEL_55;
      v32 = 1;
    }
  }
  else
  {
    v32 = 0;
    if ( !v16 )
      goto LABEL_57;
  }
  v33 = (const char *)nvram_get(v93 + 26756);
  if ( v33 && !strcmp(v33, v16) )
  {
    if ( !v32 )
      goto LABEL_57;
    goto LABEL_56;
  }
  nvram_set(v93 + 26756, v16);
LABEL_55:
  v20 = 1;
LABEL_56:
  jhl_setwanxx();
LABEL_57:
  if ( v20 )
    jhl_parm_commit(v18);
  return ddos_data(a1);
}
// 46217C: variable 'v18' is possibly undefined
// 46224C: variable 'v35' is possibly undefined
// 462258: variable 'v34' is possibly undefined
// 462680: variable 'v42' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8298: using guessed type int __fastcall get_time_group(_DWORD, _DWORD, _DWORD);
// 6A82B8: using guessed type int jhl_setwanxx(void);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004629EC) --------------------------------------------------------
int __fastcall ddos_fy_black_list(char *a1, int a2)
{
  _DWORD *v4; // $v0
  int v5; // $a2
  _DWORD *v6; // $s2
  char *v7; // $s3
  int v8; // $s1
  _DWORD *v10; // $s0
  int v11; // $s4
  int v12; // $s1
  int v13; // $s7
  int v14; // $v0
  int v15; // $v1

  *(_WORD *)a1 = 91;
  _mem_malloc(102400, "ddos_fy_black_list", 1482);
  v6 = v4;
  if ( !v4 )
  {
    *(_WORD *)(a1 + 1) = 93;
    return 2;
  }
  *v4 = 12;
  v4[3] = 2;
  v4[1] = 102400;
  if ( !jianhl_order_opt_fun(v4, 102400, v5) && !v6[2] )
  {
    v10 = v6 + 6;
    if ( (int)v6[5] <= 0 )
    {
      v15 = 0;
      v14 = 1;
      v12 = 1;
    }
    else
    {
      v11 = a2 - 49;
      v12 = 1;
      v13 = 0;
      do
      {
        ++v13;
        v12 += sprintf(
                 &a1[v12],
                 "{\"m\":\"%02X:%02X:%02X:%02X:%02X:%02X\",\"type\":%d,\"time\":%d},",
                 *((unsigned __int8 *)v10 + 24),
                 *((unsigned __int8 *)v10 + 25),
                 *((unsigned __int8 *)v10 + 26),
                 *((unsigned __int8 *)v10 + 27),
                 *((unsigned __int8 *)v10 + 28),
                 *((unsigned __int8 *)v10 + 29),
                 v10[1],
                 v10[5]);
        if ( v12 >= v11 )
          break;
        v10 += 8;
      }
      while ( v13 < v6[5] );
      v14 = v12;
      if ( v12 <= 0 )
        goto LABEL_15;
      v15 = v12 - 1;
    }
    if ( a1[v15] == 44 )
      v14 = --v12;
LABEL_15:
    v7 = &a1[v14];
    *v7 = 0;
    v8 = v12 + 1;
    goto LABEL_4;
  }
  v7 = a1 + 1;
  v8 = 2;
LABEL_4:
  *(_WORD *)v7 = 93;
  _mem_free(v6);
  return v8;
}
// 462A5C: variable 'v4' is possibly undefined
// 462A7C: variable 'v5' is possibly undefined
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00462BF4) --------------------------------------------------------
int __fastcall sub_462BF4(int a1)
{
  char *v1; // $v0
  int v3; // $s4
  const char *v4; // $s3
  const char *v5; // $s4
  const char *v6; // $v0
  unsigned int v7; // $v0
  int v8; // $s0
  unsigned int v9; // $v0
  char v11[102400]; // [sp+20h] [-19018h] BYREF
  _DWORD v12[6]; // [sp+19020h] [-18h] BYREF

  v12[0] = 0;
  v12[1] = 0;
  v12[2] = 0;
  v12[3] = 0;
  v12[4] = 0;
  v1 = httpd_get_parm(a1, "fy_type");
  if ( !v1 )
    v1 = "0";
  v3 = atoi(v1);
  v4 = (const char *)jhl_nv_get_def("ddos_fy_en");
  if ( !v4 )
    v4 = "0";
  sprintf((char *)v12, "ddos_fy_rule%d", v3);
  v5 = (const char *)jhl_nv_get_def(v12);
  if ( !v5 )
    v5 = "0|2|1000|10";
  strcpy(v11, "{\"code\":0,\"error\":\"\",\"data\":{");
  v6 = (const char *)jhl_nv_get_def(&unk_646654);
  v7 = snprintf(&v11[29], 102371, "\"fy_en\":%s,\"fy_rule\":\"%s\",\"maclist\":\"%s\",\"all\":", v4, v5, v6);
  if ( v7 >= 0x18FE3 )
    v7 = 102370;
  v8 = v7 + 29 + ddos_fy_black_list(&v11[v7 + 29], 102400 - (v7 + 29));
  v9 = snprintf(&v11[v8], 102400 - v8, "}}");
  if ( v9 >= 102400 - v8 )
    v9 = 102399 - v8;
  return httpd_cgi_ret(a1, v11, v9 + v8, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (00462E40) --------------------------------------------------------
void __fastcall format_ctxz_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 6 )
    snprintf(
      a3,
      a4,
      "{\"name\":\"%s\",\"en\":%s,\"user_id\":\"%s\",\"proto\":\"%s\",\"num\":%s,\"time\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5]);
}

//----- (00462EE0) --------------------------------------------------------
int __fastcall sub_462EE0(int a1)
{
  int v1; // $v0
  char *v2; // $fp
  int v3; // $v0
  const char *v4; // $s1
  const char *v5; // $s2
  const char *v6; // $s3
  const char *v7; // $s4
  const char *v8; // $s5
  const char *v9; // $v0
  int v10; // $v0
  int v11; // $s3
  int v12; // $s1
  char *v13; // $s4
  int v14; // $s5
  int v15; // $s0
  const char **v16; // $s2
  void *v17; // $v0
  _DWORD *v18; // $s6
  int v19; // $a1
  void *v20; // $s5
  int v21; // $s5
  int i; // $s7
  int v23; // $v0
  int v24; // $v0
  char *v25; // $a0
  int v26; // $s1
  int v27; // $v0
  int v28; // $s3
  int v29; // $v0
  int v30; // $a2
  int result; // $v0
  const char *v32; // $v0
  unsigned int v33; // $v0
  char v34[256]; // [sp+30h] [-208h] BYREF
  int v35[64]; // [sp+130h] [-108h] BYREF
  _DWORD *v36; // [sp+230h] [-8h]
  void *ptr; // [sp+234h] [-4h]

  memset(v34, 0, sizeof(v34));
  _mem_malloc(102400, "ctxz_data", 1858);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    v3 = jhl_nv_get_def("hixz3");
    strlcpy(v34, v3, 256);
    split_string(v34, 60, v35, 15);
    v4 = (const char *)v35[0];
    v5 = (const char *)v35[3];
    v6 = (const char *)v35[6];
    v7 = (const char *)v35[9];
    v8 = (const char *)v35[12];
    v9 = (const char *)nvram_get("ct_max");
    if ( !v9 )
      v9 = "";
    v10 = snprintf(
            v2 + 29,
            102371,
            "\"def\":%s,\"defTcp\":%s,\"defUdp\":%s,\"defIcmp\":%s,\"defOther\":%s,\"ct_max\":%s,\"all\":",
            v4,
            v5,
            v6,
            v7,
            v8,
            v9);
    if ( v10 >= 102371 )
      v10 = 102370;
    v11 = v10 + 29;
    v12 = 102400 - (v10 + 29);
    v13 = &v2[v10 + 29];
    v14 = nvram_get("hixz_ct");
    v15 = snprintf(&v2[v11], 102400 - v11, (char *)&word_642A04);
    if ( v15 >= 102400 - v11 )
      v15 = 102399 - v11;
    if ( v14 )
    {
      v16 = (const char **)malloc(0x20u);
      v36 = malloc(0x4008u);
      v18 = v36;
      v17 = malloc(0x200000u);
      ptr = v17;
      if ( v17 )
      {
        if ( v16 )
        {
          v19 = v14;
          if ( v18 )
          {
            v20 = v17;
            strlcpy(v17, v19, 0x200000);
            v21 = split_string(v20, 60, v18, 4096);
            if ( v21 > 0 )
            {
              for ( i = 0; i != v21; ++i )
              {
                v23 = split_string(*v18, 124, v16, 6);
                format_ctxz_data(v16, v23, &v13[v15], v12 - v15);
                v15 += v24;
                ++v18;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v16 )
        free(v16);
      if ( v36 )
        free(v36);
    }
    v25 = &v13[v15];
    if ( v15 > 0 && *(v25 - 1) == 44 )
      v25 = &v13[--v15];
    v26 = v12 - v15;
    *v25 = 0;
    v27 = snprintf(v25, v26, &byte_6445A0);
    if ( v27 >= v26 )
      v27 = v26 - 1;
    v28 = v15 + v27 + v11;
    v29 = snprintf(&v2[v28], 102400 - v28, "}}");
    if ( v29 >= 102400 - v28 )
      v30 = 102399 - v28;
    else
      v30 = v29;
    result = httpd_cgi_ret(a1, v2, v30 + v28, 8);
  }
  else
  {
    v32 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v33 = snprintf((char *)v35, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v32);
    if ( v33 >= 0x100 )
      v33 = 255;
    result = httpd_cgi_ret(a1, 0, v33, 4);
  }
  return result;
}
// 462F60: variable 'v1' is possibly undefined
// 4631C8: variable 'v24' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004633B0) --------------------------------------------------------
int __fastcall sub_4633B0(const char *a1, int a2)
{
  const char **v2; // $s0
  int v4; // $s2
  int v5; // $s1
  char v7[2052]; // [sp+18h] [-804h] BYREF

  v2 = (const char **)v7;
  v4 = split_string(a2, 44, v7, 510);
  if ( v4 <= 0 )
    return 0;
  v5 = 0;
  while ( 1 )
  {
    ++v5;
    if ( !strcmp(a1, *v2) )
      break;
    ++v2;
    if ( v4 == v5 )
      return 0;
  }
  return 1;
}
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00463474) --------------------------------------------------------
int __fastcall check_ips_group_contain(const char *a1, const char *a2)
{
  char *v4; // $v0
  int v5; // $v0
  int result; // $v0

  v4 = strchr(a2, 62);
  if ( !v4 || (*v4 = 0, v5 = J_atoi(v4 + 1), v5 == 1) || v5 == 4 )
    result = 0;
  else
    result = sub_4633B0(a1, (int)a2);
  return result;
}
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00463518) --------------------------------------------------------
void __fastcall check_time_group_contain(const char *a1, const char *a2)
{
  if ( *a2 && strcmp(a2, "OFF") && !strchr(a2, 59) )
    strcmp(a1, a2);
}
// 4635C0: ignored the value written to the shadow area of the succeeding call

//----- (004635C4) --------------------------------------------------------
int __fastcall mrprot_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5)
{
  int v8; // $s2
  _DWORD *v9; // $s0
  int v10; // $s3
  int v11; // $fp
  int v12; // $s1
  int v13; // $v0
  _DWORD v15[4096]; // [sp+18h] [-4040h] BYREF
  int v16[14]; // [sp+4018h] [-40h] BYREF
  int (__fastcall *v17)(int, _DWORD); // [sp+4050h] [-8h]

  if ( a2 )
  {
    v8 = 3;
    v17 = (int (__fastcall *)(int, _DWORD))check_time_group_contain;
  }
  else
  {
    v8 = 2;
    v17 = (int (__fastcall *)(int, _DWORD))check_ips_group_contain;
  }
  memset(a3, 0, a4);
  jhl_parm_get("mrprot2", a3, a4);
  v9 = v15;
  v10 = split_string(a3, 60, v15, 4096);
  if ( v10 <= 0 )
    return 0;
  v11 = 0;
  v12 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      ++v12;
      if ( v8 < split_string(*v9, 124, v16, 12) )
      {
        if ( v17(a1, v15[v8 + 4096]) )
          break;
      }
      ++v9;
      if ( v10 == v12 )
        return v11;
    }
    if ( !a5 )
      break;
    v11 = 118;
    v13 = cJSON_CreateString(v16[0]);
    cJSON_AddItemToArray(a5, v13);
    ++v9;
    if ( v10 == v12 )
      return v11;
  }
  return 118;
}
// 6A83FC: using guessed type int __fastcall cJSON_CreateString(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (00463774) --------------------------------------------------------
int __fastcall ddos_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5)
{
  int v8; // $s2
  _DWORD *v9; // $s0
  int v10; // $s3
  int v11; // $fp
  int v12; // $s1
  int v13; // $v0
  _DWORD v15[4096]; // [sp+18h] [-4030h] BYREF
  int v16[10]; // [sp+4018h] [-30h] BYREF
  int (__fastcall *v17)(int, _DWORD); // [sp+4040h] [-8h]

  if ( a2 )
  {
    v8 = 6;
    v17 = (int (__fastcall *)(int, _DWORD))check_time_group_contain;
  }
  else
  {
    v8 = 2;
    v17 = (int (__fastcall *)(int, _DWORD))check_ips_group_contain;
  }
  memset(a3, 0, a4);
  jhl_parm_get("hixz_ddos", a3, a4);
  v9 = v15;
  v10 = split_string(a3, 60, v15, 4096);
  if ( v10 <= 0 )
    return 0;
  v11 = 0;
  v12 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      ++v12;
      if ( v8 < split_string(*v9, 124, v16, 7) )
      {
        if ( v17(a1, v15[v8 + 4096]) )
          break;
      }
      ++v9;
      if ( v10 == v12 )
        return v11;
    }
    if ( !a5 )
      break;
    v11 = 119;
    v13 = cJSON_CreateString(v16[0]);
    cJSON_AddItemToArray(a5, v13);
    ++v9;
    if ( v10 == v12 )
      return v11;
  }
  return 119;
}
// 6A83FC: using guessed type int __fastcall cJSON_CreateString(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (00463924) --------------------------------------------------------
int __fastcall xwgl_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5)
{
  int v8; // $s2
  _DWORD *v9; // $s0
  int v10; // $s3
  int v11; // $fp
  int v12; // $s1
  int v13; // $v0
  _DWORD v15[4096]; // [sp+18h] [-4030h] BYREF
  int v16[10]; // [sp+4018h] [-30h] BYREF
  int (__fastcall *v17)(int, _DWORD); // [sp+4040h] [-8h]

  if ( a2 )
  {
    v8 = 4;
    v17 = (int (__fastcall *)(int, _DWORD))check_time_group_contain;
  }
  else
  {
    v8 = 2;
    v17 = (int (__fastcall *)(int, _DWORD))check_ips_group_contain;
  }
  memset(a3, 0, a4);
  jhl_parm_get("xwgl_all", a3, a4);
  v9 = v15;
  v10 = split_string(a3, 60, v15, 4096);
  if ( v10 <= 0 )
    return 0;
  v11 = 0;
  v12 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      ++v12;
      if ( v8 < split_string(*v9, 124, v16, 7) )
      {
        if ( v17(a1, v15[v8 + 4096]) )
          break;
      }
      ++v9;
      if ( v10 == v12 )
        return v11;
    }
    if ( !a5 )
      break;
    v11 = 120;
    v13 = cJSON_CreateString(v16[0]);
    cJSON_AddItemToArray(a5, v13);
    ++v9;
    if ( v10 == v12 )
      return v11;
  }
  return 120;
}
// 6A83FC: using guessed type int __fastcall cJSON_CreateString(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (00463AD4) --------------------------------------------------------
int __fastcall url_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5)
{
  int v8; // $s2
  _DWORD *v9; // $s0
  int v10; // $s3
  int v11; // $fp
  int v12; // $s1
  int v13; // $v0
  _DWORD v15[4096]; // [sp+18h] [-4038h] BYREF
  int v16[12]; // [sp+4018h] [-38h] BYREF
  int (__fastcall *v17)(int, _DWORD); // [sp+4048h] [-8h]

  if ( a2 )
  {
    v8 = 4;
    v17 = (int (__fastcall *)(int, _DWORD))check_time_group_contain;
  }
  else
  {
    v8 = 2;
    v17 = (int (__fastcall *)(int, _DWORD))check_ips_group_contain;
  }
  memset(a3, 0, a4);
  jhl_parm_get("url_rules", a3, a4);
  v9 = v15;
  v10 = split_string(a3, 60, v15, 4096);
  if ( v10 <= 0 )
    return 0;
  v11 = 0;
  v12 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      ++v12;
      if ( v8 < split_string(*v9, 124, v16, 9) )
      {
        if ( v17(a1, v15[v8 + 4096]) )
          break;
      }
      ++v9;
      if ( v10 == v12 )
        return v11;
    }
    if ( !a5 )
      break;
    v11 = 121;
    v13 = cJSON_CreateString(v16[0]);
    cJSON_AddItemToArray(a5, v13);
    ++v9;
    if ( v10 == v12 )
      return v11;
  }
  return 121;
}
// 6A83FC: using guessed type int __fastcall cJSON_CreateString(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (00463C84) --------------------------------------------------------
int __fastcall qq_rule_check_used_group(const char *a1, void *a2, size_t a3, int a4)
{
  char *v8; // $s0
  int v9; // $s2
  int v10; // $s6
  int v11; // $s1
  int v12; // $v0
  int v13; // $v0
  char v15[16384]; // [sp+18h] [-4018h] BYREF
  int v16[6]; // [sp+4018h] [-18h] BYREF

  memset(a2, 0, a3);
  jhl_parm_get("hbmd_all_commqq", a2, a3);
  v8 = v15;
  v9 = split_string(a2, 60, v15, 4096);
  if ( v9 <= 0 )
    return 0;
  v10 = 0;
  v11 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      ++v11;
      if ( split_string(*(_DWORD *)v8, 124, v16, 3) >= 3 )
      {
        check_time_group_contain(a1, (const char *)v16[2]);
        if ( v12 )
          break;
      }
      v8 += 4;
      if ( v9 == v11 )
        return v10;
    }
    if ( !a4 )
      break;
    v10 = 122;
    v13 = cJSON_CreateString(v16[0]);
    cJSON_AddItemToArray(a4, v13);
    v8 += 4;
    if ( v9 == v11 )
      return v10;
  }
  return 122;
}
// 463D7C: variable 'v12' is possibly undefined
// 6A83FC: using guessed type int __fastcall cJSON_CreateString(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (00463DF8) --------------------------------------------------------
int __fastcall qos_rule_check_used_group(int a1, int a2, int a3, int a4, size_t n, int a6)
{
  int v8; // $s2
  _DWORD *v9; // $s0
  int v10; // $s3
  int v11; // $fp
  int v12; // $s1
  int v13; // $v0
  _DWORD v15[4096]; // [sp+18h] [-4098h] BYREF
  int v16[19]; // [sp+4018h] [-98h] BYREF
  char v17[68]; // [sp+4064h] [-4Ch] BYREF
  int (__fastcall *v18)(int, _DWORD); // [sp+40A8h] [-8h]

  if ( a3 )
  {
    v8 = 15;
    v18 = (int (__fastcall *)(int, _DWORD))check_time_group_contain;
  }
  else
  {
    v8 = 10;
    v18 = (int (__fastcall *)(int, _DWORD))check_ips_group_contain;
  }
  snprintf(v17, 64, "sqos_%s", (const char *)a1);
  memset((void *)a4, 0, n);
  jhl_parm_get(v17, a4, n);
  v9 = v15;
  v10 = split_string(a4, 60, v15, 4096);
  if ( v10 <= 0 )
    return 0;
  v11 = 0;
  v12 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      ++v12;
      if ( v8 < split_string(*v9, 124, v16, 17) )
      {
        if ( v18(a2, v15[v8 + 4096]) )
          break;
      }
      ++v9;
      if ( v10 == v12 )
        return v11;
    }
    if ( !a6 )
      break;
    v11 = 123;
    v13 = cJSON_CreateString(v16[0]);
    cJSON_AddItemToArray(a6, v13);
    ++v9;
    if ( v10 == v12 )
      return v11;
  }
  return 123;
}
// 6A83FC: using guessed type int __fastcall cJSON_CreateString(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (00463FC4) --------------------------------------------------------
int __fastcall ctxz_rule_check_used_group(int a1, int a2, void *a3, size_t a4, int a5)
{
  int v8; // $s2
  _DWORD *v9; // $s0
  int v10; // $s3
  int v11; // $fp
  int v12; // $s1
  int v13; // $v0
  _DWORD v15[4096]; // [sp+18h] [-4028h] BYREF
  int v16[8]; // [sp+4018h] [-28h] BYREF
  int (__fastcall *v17)(int, _DWORD); // [sp+4038h] [-8h]

  if ( a2 )
  {
    v8 = 5;
    v17 = (int (__fastcall *)(int, _DWORD))check_time_group_contain;
  }
  else
  {
    v8 = 2;
    v17 = (int (__fastcall *)(int, _DWORD))check_ips_group_contain;
  }
  memset(a3, 0, a4);
  jhl_parm_get("hixz_ct", a3, a4);
  v9 = v15;
  v10 = split_string(a3, 60, v15, 4096);
  if ( v10 <= 0 )
    return 0;
  v11 = 0;
  v12 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      ++v12;
      if ( v8 < split_string(*v9, 124, v16, 6) )
      {
        if ( v17(a1, v15[v8 + 4096]) )
          break;
      }
      ++v9;
      if ( v10 == v12 )
        return v11;
    }
    if ( !a5 )
      break;
    v11 = 126;
    v13 = cJSON_CreateString(v16[0]);
    cJSON_AddItemToArray(a5, v13);
    ++v9;
    if ( v10 == v12 )
      return v11;
  }
  return 126;
}
// 6A83FC: using guessed type int __fastcall cJSON_CreateString(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (00464174) --------------------------------------------------------
int __fastcall macfilter_rule_check_used_group(const char *a1, void *a2, size_t a3, int a4)
{
  char *v8; // $s0
  int v9; // $s2
  int v10; // $s6
  int v11; // $s1
  int v12; // $v0
  int v13; // $v0
  char v15[16384]; // [sp+18h] [-4020h] BYREF
  int v16[8]; // [sp+4018h] [-20h] BYREF

  memset(a2, 0, a3);
  jhl_parm_get("macfilterAll", a2, a3);
  v8 = v15;
  v9 = split_string(a2, 60, v15, 4096);
  if ( v9 <= 0 )
    return 0;
  v10 = 0;
  v11 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      ++v11;
      if ( split_string(*(_DWORD *)v8, 124, v16, 5) >= 4 )
      {
        check_time_group_contain(a1, (const char *)v16[3]);
        if ( v12 )
          break;
      }
      v8 += 4;
      if ( v9 == v11 )
        return v10;
    }
    if ( !a4 )
      break;
    v10 = 127;
    v13 = cJSON_CreateString(v16[0]);
    cJSON_AddItemToArray(a4, v13);
    v8 += 4;
    if ( v9 == v11 )
      return v10;
  }
  return 127;
}
// 46426C: variable 'v12' is possibly undefined
// 6A83FC: using guessed type int __fastcall cJSON_CreateString(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (004642E8) --------------------------------------------------------
int _get_timer_man_list()
{
  int v0; // $s3
  FILE *v1; // $v0
  FILE *v2; // $s1
  int v3; // $v0
  int v4; // $s6
  int v5; // $v1
  char v7[1024]; // [sp+18h] [-420h] BYREF
  char v8[8]; // [sp+418h] [-20h] BYREF
  const void *v9; // [sp+420h] [-18h]

  memset(v7, 0, sizeof(v7));
  v0 = cJSON_CreateArray();
  v1 = fopen("/root/timer_man.cfg", "r");
  if ( v1 )
  {
    v2 = v1;
    if ( v0 )
    {
      while ( fgets(v7, 1024, v2) )
      {
        if ( v7[0] == 100 )
        {
          split_string(v7, 59, v8, 8);
          if ( v9 )
          {
            if ( !memcmp(v9, "wys", 3u) )
            {
              v4 = cJSON_CreateObject();
              v3 = atoi(&v7[1]);
              cJSON_AddNumberToObject(v4, &off_646D54, v3, v5);
              cJSON_AddStringToObject(v4, &off_646D58, v9);
              cJSON_AddItemToArray(v0, v4);
            }
          }
        }
        memset(v7, 0, sizeof(v7));
      }
    }
    fclose(v2);
  }
  return v0;
}
// 46447C: variable 'v5' is possibly undefined
// 646D54: using guessed type void *off_646D54;
// 646D58: using guessed type void *off_646D58;
// 6A8258: using guessed type int cJSON_CreateObject(void);
// 6A83A8: using guessed type int __fastcall cJSON_AddStringToObject(_DWORD, _DWORD, _DWORD);
// 6A8490: using guessed type int cJSON_CreateArray(void);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A87C8: using guessed type int __fastcall cJSON_AddNumberToObject(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);

//----- (004644FC) --------------------------------------------------------
_DWORD *__fastcall _get_timer_man_tid(int a1, const char *a2, const char *a3)
{
  int v6; // $s2
  size_t v7; // $s7
  _DWORD *v8; // $s0
  const char *v9; // $s1
  int v10; // $v0
  char v12[64]; // [sp+18h] [-40h] BYREF

  memset(v12, 0, sizeof(v12));
  v6 = 0;
  v7 = strlen(a2);
  snprintf(v12, 64, "\"%s\"", a3);
  v8 = *(_DWORD **)(a1 + 8);
  if ( v8 )
  {
    do
    {
      v9 = (const char *)GetJSONItemValueAsString(v8, &off_646D58);
      if ( !memcmp(v9, a2, v7) )
      {
        if ( strstr(v9, v12) )
        {
          v10 = GetJSONItemValueAsIntDef(v8, &off_646D54, 0);
          if ( v10 )
            dword_67D500[v6++] = v10;
        }
      }
      v8 = (_DWORD *)*v8;
    }
    while ( v8 && v6 < 4095 );
  }
  dword_67D500[v6] = 0;
  return dword_67D500;
}
// 646D54: using guessed type void *off_646D54;
// 646D58: using guessed type void *off_646D58;
// 6A84CC: using guessed type int __fastcall GetJSONItemValueAsIntDef(_DWORD, _DWORD, _DWORD);
// 6A887C: using guessed type int __fastcall GetJSONItemValueAsString(_DWORD, _DWORD);

//----- (00464698) --------------------------------------------------------
int __fastcall time_group_modify(int a1, int a2)
{
  FILE *v3; // $v0
  FILE *v4; // $s1
  int v5; // $s6
  void *v6; // $v0
  void *v7; // $s7
  int v8; // $s4
  int v9; // $v0
  int v10; // $s4
  int v11; // $v0
  int v12; // $s4
  int v13; // $v0
  int v14; // $s4
  int v15; // $v0
  int v16; // $s4
  int v17; // $v0
  int v18; // $s4
  int v19; // $v0
  int v20; // $s4
  int v21; // $v0
  int v22; // $s4
  int v23; // $v0
  int v24; // $s4
  int v25; // $v0
  int v26; // $s4
  int v27; // $v0
  int v28; // $v0
  _DWORD *v29; // $s5
  int v30; // $s6
  int v31; // $fp
  int v32; // $v0
  int v33; // $s4
  _BYTE *v34; // $v0
  int v35; // $v0
  int **v36; // $s0
  int *v37; // $s7
  int *v38; // $s2
  int v39; // $a3
  int v42[4]; // [sp+20h] [-28h] BYREF
  void **v43; // [sp+30h] [-18h]
  int v44; // [sp+34h] [-14h]
  char *v45; // [sp+38h] [-10h]
  void *v46; // [sp+3Ch] [-Ch]
  char *v47; // [sp+40h] [-8h]
  const char *v48; // [sp+44h] [-4h]

  v45 = "a";
  v3 = fopen("/root/time_group/time_vue.cfg", "w");
  if ( v3 && (v4 = v3, v5 = cJSON_CreateArray(), (v44 = v5) != 0) )
  {
    v47 = "a";
    _mem_malloc(0x200000, "time_group_modify", 611);
    v7 = v6;
    v46 = v6;
    if ( v6 )
    {
      v8 = cJSON_CreateObject();
      cJSON_AddStringToObject(v8, &off_646D58, &unk_646D7C);
      v9 = cJSON_AddArrayToObject(v8, "list");
      mrprot_rule_check_used_group(a1, 1, v7, 0x200000u, v9);
      cJSON_AddItemToArray(v5, v8);
      v10 = cJSON_CreateObject();
      cJSON_AddStringToObject(v10, &off_646D58, "wys macfilter add");
      v11 = cJSON_AddArrayToObject(v10, "list");
      macfilter_rule_check_used_group((const char *)a1, v7, 0x200000u, v11);
      cJSON_AddItemToArray(v5, v10);
      v12 = cJSON_CreateObject();
      cJSON_AddStringToObject(v12, &off_646D58, "wys ctrule add ddos");
      v13 = cJSON_AddArrayToObject(v12, "list");
      ddos_rule_check_used_group(a1, 1, v7, 0x200000u, v13);
      cJSON_AddItemToArray(v5, v12);
      v14 = cJSON_CreateObject();
      cJSON_AddStringToObject(v14, &off_646D58, "wys lvrule add");
      v15 = cJSON_AddArrayToObject(v14, "list");
      xwgl_rule_check_used_group(a1, 1, v7, 0x200000u, v15);
      cJSON_AddItemToArray(v5, v14);
      v16 = cJSON_CreateObject();
      cJSON_AddStringToObject(v16, &off_646D58, "wys url add");
      v17 = cJSON_AddArrayToObject(v16, "list");
      url_rule_check_used_group(a1, 1, v7, 0x200000u, v17);
      cJSON_AddItemToArray(v5, v16);
      v18 = cJSON_CreateObject();
      cJSON_AddStringToObject(v18, &off_646D58, "wys lvrule hbmd");
      v19 = cJSON_AddArrayToObject(v18, "list");
      qq_rule_check_used_group((const char *)a1, v7, 0x200000u, v19);
      cJSON_AddItemToArray(v5, v18);
      v20 = cJSON_CreateObject();
      cJSON_AddStringToObject(v20, &off_646D58, "wys qos sprule add \"pri\"");
      v21 = cJSON_AddArrayToObject(v20, "list");
      qos_rule_check_used_group((int)&off_645B94, a1, 1, (int)v7, 0x200000u, v21);
      cJSON_AddItemToArray(v5, v20);
      v22 = cJSON_CreateObject();
      cJSON_AddStringToObject(v22, &off_646D58, "wys qos sprule add \"xz\"");
      v23 = cJSON_AddArrayToObject(v22, "list");
      qos_rule_check_used_group((int)"xz", a1, 1, (int)v7, 0x200000u, v23);
      cJSON_AddItemToArray(v5, v22);
      v24 = cJSON_CreateObject();
      cJSON_AddStringToObject(v24, &off_646D58, "wys qos sprule add \"bz\"");
      v25 = cJSON_AddArrayToObject(v24, "list");
      qos_rule_check_used_group((int)"bz", a1, 1, (int)v7, 0x200000u, v25);
      cJSON_AddItemToArray(v5, v24);
      v26 = cJSON_CreateObject();
      cJSON_AddStringToObject(v26, &off_646D58, "wys ctrule add ct");
      v27 = cJSON_AddArrayToObject(v26, "list");
      ctxz_rule_check_used_group(a1, 1, v7, 0x200000u, v27);
      cJSON_AddItemToArray(v5, v26);
      v28 = _get_timer_man_list();
      v29 = *(_DWORD **)(v5 + 8);
      v30 = v28;
      if ( v29 )
      {
        v43 = &off_646D58;
        v31 = 0;
        v48 = "list";
        do
        {
          while ( 1 )
          {
            v32 = cJSON_GetObjectItem(v29, v43);
            v33 = v32;
            if ( v32 )
            {
              v34 = *(_BYTE **)(v32 + 16);
              if ( v34 )
              {
                if ( *v34 )
                {
                  v35 = cJSON_GetObjectItem(v29, v48);
                  if ( v35 )
                  {
                    v36 = *(int ***)(v35 + 8);
                    if ( v36 )
                      break;
                  }
                }
              }
            }
            v29 = (_DWORD *)*v29;
            if ( !v29 )
              goto LABEL_17;
          }
          do
          {
            v37 = _get_timer_man_tid(v30, *(const char **)(v33 + 16), (const char *)v36[4]);
            v38 = v37 + 4096;
            do
            {
              v39 = *v37;
              if ( *v37++ == 0 )
                break;
              v31 = 1;
              fprintf(v4, "mr_%s=%d\n", (const char *)v36[4], v39);
            }
            while ( v38 != v37 );
            v36 = (int **)*v36;
          }
          while ( v36 );
          v29 = (_DWORD *)*v29;
        }
        while ( v29 );
LABEL_17:
        fclose(v4);
        if ( v31 )
        {
          v42[0] = (int)"timer_mod.sh";
          v42[1] = (int)"vue";
          v42[2] = a2;
          v42[3] = 0;
          eval(v42, 0, 0, 0);
        }
      }
      else
      {
        fclose(v4);
      }
    }
    else
    {
      v30 = 0;
    }
  }
  else
  {
    v30 = 0;
    v44 = 0;
    v46 = 0;
    v47 = "a";
  }
  unlink(v45 + 27996);
  cJSON_Delete(v44);
  cJSON_Delete(v30);
  _mem_free(v46);
  return 0;
}
// 464740: variable 'v6' is possibly undefined
// 645B94: using guessed type void *off_645B94;
// 646D58: using guessed type void *off_646D58;
// 6A8258: using guessed type int cJSON_CreateObject(void);
// 6A83A8: using guessed type int __fastcall cJSON_AddStringToObject(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8490: using guessed type int cJSON_CreateArray(void);
// 6A86D4: using guessed type int __fastcall cJSON_AddArrayToObject(_DWORD, _DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (00464F10) --------------------------------------------------------
int __fastcall ips_group_is_used(int a1)
{
  void *v2; // $v0
  void *v3; // $s0
  int v4; // $v0
  int v6; // $v0
  bool v7; // dc
  int v8; // $v0
  int v9; // [sp+20h] [-Ch]

  _mem_malloc(0x200000, "ips_group_is_used", 729);
  v3 = v2;
  if ( v2 )
  {
    v4 = mrprot_rule_check_used_group(a1, 0, v2, 0x200000u, 0);
    if ( !v4 )
    {
      v4 = ddos_rule_check_used_group(a1, 0, v3, 0x200000u, 0);
      if ( !v4 )
      {
        v4 = xwgl_rule_check_used_group(a1, 0, v3, 0x200000u, 0);
        if ( !v4 )
        {
          v4 = url_rule_check_used_group(a1, 0, v3, 0x200000u, 0);
          if ( !v4 )
          {
            v4 = qos_rule_check_used_group((int)&off_645B94, a1, 0, (int)v3, 0x200000u, 0);
            if ( !v4 )
            {
              v6 = qos_rule_check_used_group((int)"xz", a1, 0, (int)v3, 0x200000u, 0);
              v7 = v6 == 0;
              v4 = v6 + 1;
              if ( v7 )
              {
                v8 = qos_rule_check_used_group((int)"bz", a1, 0, (int)v3, 0x200000u, 0);
                if ( v8 )
                  v4 = v8 + 2;
                else
                  v4 = ctxz_rule_check_used_group(a1, 0, v3, 0x200000u, 0);
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v4 = 0;
  }
  v9 = v4;
  _mem_free(v3);
  return v9;
}
// 464F5C: variable 'v2' is possibly undefined
// 645B94: using guessed type void *off_645B94;

//----- (004650F4) --------------------------------------------------------
int __fastcall time_group_is_used(const char *a1)
{
  void *v2; // $v0
  void *v3; // $s0
  int v4; // $v0
  int v6; // $v0
  bool v7; // dc
  int v8; // $v0
  int v9; // [sp+20h] [-Ch]

  _mem_malloc(0x200000, "time_group_is_used", 793);
  v3 = v2;
  if ( v2 )
  {
    v4 = mrprot_rule_check_used_group((int)a1, 1, v2, 0x200000u, 0);
    if ( !v4 )
    {
      v4 = macfilter_rule_check_used_group(a1, v3, 0x200000u, 0);
      if ( !v4 )
      {
        v4 = ddos_rule_check_used_group((int)a1, 1, v3, 0x200000u, 0);
        if ( !v4 )
        {
          v4 = xwgl_rule_check_used_group((int)a1, 1, v3, 0x200000u, 0);
          if ( !v4 )
          {
            v4 = url_rule_check_used_group((int)a1, 1, v3, 0x200000u, 0);
            if ( !v4 )
            {
              v4 = qq_rule_check_used_group(a1, v3, 0x200000u, 0);
              if ( !v4 )
              {
                v4 = qos_rule_check_used_group((int)&off_645B94, (int)a1, 1, (int)v3, 0x200000u, 0);
                if ( !v4 )
                {
                  v6 = qos_rule_check_used_group((int)"xz", (int)a1, 1, (int)v3, 0x200000u, 0);
                  v7 = v6 == 0;
                  v4 = v6 + 1;
                  if ( v7 )
                  {
                    v8 = qos_rule_check_used_group((int)"bz", (int)a1, 1, (int)v3, 0x200000u, 0);
                    if ( v8 )
                      v4 = v8 + 2;
                    else
                      v4 = ctxz_rule_check_used_group((int)a1, 1, v3, 0x200000u, 0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v4 = 0;
  }
  v9 = v4;
  _mem_free(v3);
  return v9;
}
// 465140: variable 'v2' is possibly undefined
// 645B94: using guessed type void *off_645B94;

//----- (00465318) --------------------------------------------------------
void __fastcall format_ips_group_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 3 )
    snprintf(a3, a4, "{\"name\":\"%s\",\"ips\":\"%s\",\"id\":\"%s\"},", *a1, a1[2], a1[1]);
}

//----- (004653A0) --------------------------------------------------------
int __fastcall get_ips_group_data(char *a1, int a2)
{
  int v4; // $s2
  int v5; // $s0
  const char **v6; // $s4
  void *v7; // $v0
  _DWORD *v8; // $s7
  void *v9; // $fp
  int v10; // $s6
  _DWORD *v11; // $s3
  int i; // $s2
  int v13; // $v0
  int v14; // $v0
  char *v15; // $a0
  int v16; // $s1
  int v17; // $v0

  v4 = nvram_get("dns_more_hitype");
  v5 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v5 >= a2 )
    v5 = a2 - 1;
  if ( v4 )
  {
    v6 = (const char **)malloc(0x14u);
    v8 = malloc(0x4008u);
    v7 = malloc(0x200000u);
    v9 = v7;
    if ( v7 )
    {
      if ( v6 )
      {
        if ( v8 )
        {
          strlcpy(v7, v4, 0x200000);
          v10 = split_string(v9, 60, v8, 4096);
          if ( v10 > 0 )
          {
            v11 = v8;
            for ( i = 0; i != v10; ++i )
            {
              v13 = split_string(*v11, 124, v6, 3);
              format_ips_group_data(v6, v13, &a1[v5], a2 - v5);
              v5 += v14;
              ++v11;
            }
          }
        }
      }
      free(v9);
    }
    if ( v6 )
      free(v6);
    if ( v8 )
      free(v8);
  }
  v15 = &a1[v5];
  if ( v5 > 0 && *(v15 - 1) == 44 )
    v15 = &a1[--v5];
  v16 = a2 - v5;
  *v15 = 0;
  v17 = snprintf(v15, v16, &byte_6445A0);
  if ( v17 >= v16 )
    v17 = v16 - 1;
  return v5 + v17;
}
// 46550C: variable 'v14' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004655E8) --------------------------------------------------------
int __fastcall sub_4655E8(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $s4
  int v5; // $v0
  int v6; // $a2
  int result; // $v0
  const char *v8; // $v0
  unsigned int v9; // $v0
  char v10[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(1024000, "ips_group_data", 926);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\"", 20);
    v4 = get_ips_group_data(v2 + 28, 1023972) + 28;
    v5 = snprintf(&v3[v4], 1024000 - v4, "}");
    if ( v5 >= 1024000 - v4 )
      v6 = 1023999 - v4;
    else
      v6 = v5;
    result = httpd_cgi_ret(a1, v3, v6 + v4, 8);
  }
  else
  {
    v8 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v9 = snprintf(v10, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
    if ( v9 >= 0x100 )
      v9 = 255;
    result = httpd_cgi_ret(a1, v10, v9, 4);
  }
  return result;
}
// 46563C: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004657C0) --------------------------------------------------------
int __fastcall sub_4657C0(int a1)
{
  char *v2; // $s7
  int v3; // $s6
  char *v4; // $s0
  char *v5; // $v0
  void *v6; // $v0
  void *v7; // $s1
  char *v8; // $s2
  int v9; // $a1
  char *v10; // $a2
  int v11; // $a0
  int v12; // $s5
  const char *v13; // $v0
  int v14; // $s6
  _DWORD *v16; // $s0
  int v17; // $v0
  int v18; // $s6
  int v19; // $s7
  int v20; // $a0
  int v21; // $v0
  char *v22; // $v1
  const char *v23; // $v0
  int v24; // $t0
  int v25; // $a3
  int v26; // $a2
  int v27; // $a1
  int v28; // $fp
  int v29; // $a0
  const char *v30; // $v0
  int v31; // $v0
  char s[1024]; // [sp+28h] [-430h] BYREF
  char *v33; // [sp+428h] [-30h] BYREF
  char *v34; // [sp+42Ch] [-2Ch]
  char *v35; // [sp+430h] [-28h]
  int v36; // [sp+434h] [-24h]
  int v37; // [sp+438h] [-20h]
  char *v38; // [sp+440h] [-18h]
  char *v39; // [sp+444h] [-14h]
  char *v40; // [sp+448h] [-10h]
  int v41; // [sp+44Ch] [-Ch]
  int v42; // [sp+450h] [-8h]

  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v2 = httpd_get_parm(a1, "name");
  v39 = httpd_get_parm(a1, "old_name");
  v38 = httpd_get_parm(a1, "ips");
  v3 = httpd_get_json_parm(a1, (int)"del_list");
  v4 = httpd_get_parm(a1, "opt");
  _mem_malloc(1024000, "ips_group_asp", 969);
  v7 = v6;
  _mem_malloc(1024000, "ips_group_asp", 970);
  v8 = v5;
  if ( v7 )
  {
    if ( !v5 )
    {
      v9 = *(unsigned __int8 *)(a1 + 210102);
      v10 = (char *)1024000;
      v11 = 4;
      goto LABEL_16;
    }
    if ( !v4 )
    {
LABEL_8:
      v9 = *(unsigned __int8 *)(a1 + 210102);
      v10 = "not opt";
      v11 = 12;
      goto LABEL_16;
    }
    if ( !strcmp(v4, (const char *)&off_646D8C) || (v40 = "1\"", !strcmp(v4, (const char *)&off_648DDC)) )
    {
      if ( strcmp(v4, "delall") )
      {
        v42 = 0;
LABEL_11:
        if ( !strcmp(v4, "del") && v3 )
        {
          v16 = *(_DWORD **)(v3 + 8);
          if ( v16 )
            goto LABEL_26;
          goto LABEL_35;
        }
        v12 = strcmp(v4, (const char *)&off_646D8C);
        if ( v12 && strcmp(v4, (const char *)&off_648DDC) )
          goto LABEL_35;
        goto LABEL_13;
      }
    }
    else if ( !strcmp(v4, "del") )
    {
      if ( strcmp(v4, "delall") )
      {
        if ( v3 )
        {
          v16 = *(_DWORD **)(v3 + 8);
          v42 = 0;
          if ( v16 )
          {
LABEL_26:
            v39 = "a";
            v40 = "a";
            v41 = 1024000;
            v38 = "dns_more_hitype";
            while ( 1 )
            {
              v18 = cJSON_GetObjectItem(v16, v39 + 28312);
              v17 = cJSON_GetObjectItem(v16, v40 + 28320);
              v19 = v17;
              if ( !v18 )
              {
                v9 = *(unsigned __int8 *)(a1 + 210102);
                v10 = "not i";
                v11 = 12;
                goto LABEL_16;
              }
              if ( !v17 )
              {
                v9 = *(unsigned __int8 *)(a1 + 210102);
                v10 = "not n";
                v11 = 12;
                goto LABEL_16;
              }
              v20 = *(_DWORD *)(v18 + 16);
              v33 = *(char **)(v17 + 16);
              v21 = ips_group_is_used(v20);
              if ( v21 )
              {
                v10 = *(char **)(v19 + 16);
                v9 = *(unsigned __int8 *)(a1 + 210102);
                v11 = v21;
                goto LABEL_16;
              }
              if ( set_dns_more_hitype_to_kernel("del", &v33) < 0 )
                break;
              jhl_parm_get(v38, v7, v41);
              if ( nvparm_del_str(v7, 60, 3, v33, 124, 0, v8) )
              {
                jhl_parm_set(v38, v8);
                v42 = 1;
              }
              v16 = (_DWORD *)*v16;
              if ( !v16 )
                goto LABEL_35;
            }
            if ( v42 )
              jhl_parm_commit(v38);
            v10 = v33;
            v9 = *(unsigned __int8 *)(a1 + 210102);
            v11 = 31;
            goto LABEL_16;
          }
          goto LABEL_36;
        }
        v12 = strcmp(v4, (const char *)&off_646D8C);
        if ( strcmp(v4, v40 - 29220) )
        {
LABEL_36:
          v22 = s;
          v23 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          do
          {
            v24 = *(_DWORD *)v23;
            v25 = *((_DWORD *)v23 + 1);
            v26 = *((_DWORD *)v23 + 2);
            v27 = *((_DWORD *)v23 + 3);
            v23 += 16;
            *(_DWORD *)v22 = v24;
            *((_DWORD *)v22 + 1) = v25;
            *((_DWORD *)v22 + 2) = v26;
            *((_DWORD *)v22 + 3) = v27;
            v22 += 16;
          }
          while ( v23 != "}" );
          v14 = 33;
          *(_WORD *)v22 = *(_WORD *)v23;
LABEL_18:
          _mem_free(v7);
          goto LABEL_19;
        }
        v42 = 0;
LABEL_13:
        if ( v2 && *v2 )
        {
          if ( v38 && strlen(v38) >= 7 )
          {
            if ( !v12 )
            {
              v14 = check_rule_num_limit(a1, 18, (int)"dns_more_hitype", 60, s, 0x400u);
              if ( v14 > 0 )
                goto LABEL_18;
            }
            v33 = v2;
            v34 = "0";
            v35 = v38;
            if ( v39 )
            {
              dns_more_hitype_del(v39, &v33);
              v28 = dns_more_hitype_add(v33, v34, v35);
            }
            else
            {
              v28 = set_dns_more_hitype_to_kernel(v4, &v33);
            }
            if ( v28 >= 0 )
            {
              if ( !strcmp(v4, (const char *)&off_648DDC)
                && ((jhl_parm_get("dns_more_hitype", v7, 1024000), !v39) ? (v31 = nvparm_del_str(
                                                                                    v7,
                                                                                    60,
                                                                                    5,
                                                                                    v2,
                                                                                    124,
                                                                                    0,
                                                                                    v8)) : (v31 = nvparm_del_str(
                                                                                                    v7,
                                                                                                    60,
                                                                                                    5,
                                                                                                    v39,
                                                                                                    124,
                                                                                                    0,
                                                                                                    v8)),
                    v31) )
              {
                sprintf((char *)v7, "%s|%d|%s<", v33, v28, v35);
              }
              else
              {
                sprintf((char *)v7, "%s|%d|%s<", v33, v28, v35);
                if ( !v42 )
                {
                  jhl_parm_get("dns_more_hitype", v8, 1024000);
                  if ( !strcmp(v8, " ") )
                    *v8 = 0;
                }
              }
              strcat(v8, (char *)v7);
LABEL_50:
              jhl_parm_set("dns_more_hitype", v8);
              jhl_parm_commit(v29);
              goto LABEL_36;
            }
LABEL_35:
            if ( !v42 )
              goto LABEL_36;
            goto LABEL_50;
          }
          v9 = *(unsigned __int8 *)(a1 + 210102);
          v10 = "not ips";
          v11 = 12;
        }
        else
        {
          v9 = *(unsigned __int8 *)(a1 + 210102);
          v10 = (char *)&unk_6442E4;
          v11 = 12;
        }
LABEL_16:
        v13 = (const char *)_GET_LANG_TEXT(v11, v9, v10);
        v14 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
        if ( (unsigned int)v14 >= 0x400 )
          v14 = 1023;
        goto LABEL_18;
      }
    }
    else if ( strcmp(v4, "delall") )
    {
      goto LABEL_8;
    }
    if ( dns_more_hitype_delall() < 0 )
    {
      v9 = *(unsigned __int8 *)(a1 + 210102);
      v10 = "";
      v11 = 31;
      goto LABEL_16;
    }
    memset(v8, 0, 0xFA000u);
    v42 = 1;
    goto LABEL_11;
  }
  v30 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
  v14 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v30);
  if ( (unsigned int)v14 >= 0x400 )
    v14 = 1023;
LABEL_19:
  if ( v8 )
    _mem_free(v8);
  return httpd_cgi_ret(a1, s, v14, 4);
}
// 4658D0: variable 'v6' is possibly undefined
// 4658DC: variable 'v5' is possibly undefined
// 465E68: variable 'v29' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81A0: using guessed type int __fastcall dns_more_hitype_del(_DWORD, _DWORD);
// 6A8230: using guessed type int dns_more_hitype_delall(void);
// 6A82D4: using guessed type int __fastcall set_dns_more_hitype_to_kernel(_DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A87DC: using guessed type int __fastcall dns_more_hitype_add(_DWORD, _DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (00466138) --------------------------------------------------------
int __fastcall time_group_get_id(int a1)
{
  char *v1; // $s0
  int v2; // $s2
  unsigned int v3; // $s4
  int v4; // $s1
  unsigned int v5; // $v0
  char v7[16384]; // [sp+18h] [-4018h] BYREF
  int v8[6]; // [sp+4018h] [-18h] BYREF

  v1 = v7;
  v2 = split_string(a1, 60, v7, 4096);
  if ( v2 <= 0 )
    return 1;
  v3 = 0;
  v4 = 0;
  do
  {
    while ( 1 )
    {
      ++v4;
      if ( split_string(*(_DWORD *)v1, 124, v8, 3) >= 3 )
      {
        v5 = J_atoi(v8[0]);
        if ( v3 < v5 )
          break;
      }
      v1 += 4;
      if ( v2 == v4 )
        return v3 + 1;
    }
    v3 = v5;
    v1 += 4;
  }
  while ( v2 != v4 );
  return v3 + 1;
}
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00466220) --------------------------------------------------------
void __fastcall format_time_group_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 3 )
    snprintf(a3, a4, "{\"n\":\"%s\",\"t\":\"%s\",\"id\":\"%s\"},", a1[2], a1[1], *a1);
}

//----- (004662A8) --------------------------------------------------------
int __fastcall get_time_group_data(char *a1, int a2)
{
  int v4; // $s2
  int v5; // $s0
  const char **v6; // $s4
  void *v7; // $v0
  _DWORD *v8; // $s7
  void *v9; // $fp
  int v10; // $s6
  _DWORD *v11; // $s3
  int i; // $s2
  int v13; // $v0
  int v14; // $v0
  char *v15; // $a0
  int v16; // $s1
  int v17; // $v0

  v4 = nvram_get("time_group");
  v5 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v5 >= a2 )
    v5 = a2 - 1;
  if ( v4 )
  {
    v6 = (const char **)malloc(0x14u);
    v8 = malloc(0x4008u);
    v7 = malloc(0x200000u);
    v9 = v7;
    if ( v7 )
    {
      if ( v6 )
      {
        if ( v8 )
        {
          strlcpy(v7, v4, 0x200000);
          v10 = split_string(v9, 60, v8, 4096);
          if ( v10 > 0 )
          {
            v11 = v8;
            for ( i = 0; i != v10; ++i )
            {
              v13 = split_string(*v11, 124, v6, 3);
              format_time_group_data(v6, v13, &a1[v5], a2 - v5);
              v5 += v14;
              ++v11;
            }
          }
        }
      }
      free(v9);
    }
    if ( v6 )
      free(v6);
    if ( v8 )
      free(v8);
  }
  v15 = &a1[v5];
  if ( v5 > 0 && *(v15 - 1) == 44 )
    v15 = &a1[--v5];
  v16 = a2 - v5;
  *v15 = 0;
  v17 = snprintf(v15, v16, &byte_6445A0);
  if ( v17 >= v16 )
    v17 = v16 - 1;
  return v5 + v17;
}
// 466414: variable 'v14' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004664F0) --------------------------------------------------------
int __fastcall sub_4664F0(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $s4
  int v5; // $v0
  int v6; // $a2
  int result; // $v0
  const char *v8; // $v0
  unsigned int v9; // $v0
  char v10[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(102400, "time_group_data", 1201);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\"", 20);
    v4 = get_time_group_data(v2 + 28, 102372) + 28;
    v5 = snprintf(&v3[v4], 102400 - v4, "}");
    if ( v5 >= 102400 - v4 )
      v6 = 102399 - v4;
    else
      v6 = v5;
    result = httpd_cgi_ret(a1, v3, v6 + v4, 8);
  }
  else
  {
    v8 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v9 = snprintf(v10, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
    if ( v9 >= 0x100 )
      v9 = 255;
    result = httpd_cgi_ret(a1, v10, v9, 4);
  }
  return result;
}
// 466544: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004666C8) --------------------------------------------------------
int __fastcall sub_4666C8(int a1)
{
  char *v2; // $s6
  char *v3; // $s7
  int v4; // $fp
  char *v5; // $s3
  char *v6; // $v0
  void *v7; // $v0
  void *v8; // $s0
  char *v9; // $s1
  int v10; // $s5
  int v11; // $a1
  char *v12; // $a2
  int v13; // $a0
  const char *v14; // $v0
  unsigned int v15; // $s3
  const char *v17; // $v0
  _DWORD *v18; // $s3
  int v19; // $v0
  int v20; // $s6
  int v21; // $s7
  const char *v22; // $a0
  int v23; // $v0
  char *v24; // $v1
  const char *v25; // $v0
  char *v26; // $a0
  int v27; // $t0
  int v28; // $a3
  int v29; // $a2
  int v30; // $a1
  const char *v31; // $v0
  int v32; // $a1
  const char *v33; // $a2
  int v34; // $a0
  const char *v35; // $v0
  char s[256]; // [sp+28h] [-128h] BYREF
  const char *v37; // [sp+128h] [-28h] BYREF
  char *v38; // [sp+12Ch] [-24h]
  char *v39; // [sp+130h] [-20h]
  char *v40; // [sp+140h] [-10h]
  int v41; // [sp+144h] [-Ch]
  int v42; // [sp+148h] [-8h]

  v2 = httpd_get_parm(a1, "name");
  v40 = httpd_get_parm(a1, "old_name");
  v3 = httpd_get_parm(a1, "time");
  v4 = httpd_get_json_parm(a1, (int)"del_list");
  v5 = httpd_get_parm(a1, "opt");
  _mem_malloc(102400, "time_group_asp", 1248);
  v8 = v7;
  _mem_malloc(102400, "time_group_asp", 1249);
  v9 = v6;
  if ( v8 )
  {
    if ( !v6 )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = (char *)102400;
      v13 = 4;
      goto LABEL_9;
    }
    if ( !v5 )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = "not opt";
      goto LABEL_8;
    }
    v41 = (int)"a";
    v10 = strcmp(v5, (const char *)&off_646D8C);
    if ( !v10 || !strcmp(v5, (const char *)&off_648DDC) )
    {
      if ( strcmp(v5, "del") )
        goto LABEL_17;
    }
    else if ( strcmp(v5, "del") )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = v5;
LABEL_8:
      v13 = 12;
LABEL_9:
      v14 = (const char *)_GET_LANG_TEXT(v13, v11, v12);
      goto LABEL_10;
    }
    if ( v4 )
    {
      v18 = *(_DWORD **)(v4 + 8);
      if ( v18 )
      {
        v40 = "i";
        v42 = 0;
        v41 = 102400;
        while ( 1 )
        {
          v20 = cJSON_GetObjectItem(v18, v40);
          v19 = cJSON_GetObjectItem(v18, "n");
          v21 = v19;
          if ( !v20 )
          {
            v32 = *(unsigned __int8 *)(a1 + 210102);
            v33 = "not i";
            v34 = 12;
            goto LABEL_59;
          }
          if ( !v19 )
          {
            v32 = *(unsigned __int8 *)(a1 + 210102);
            v33 = "not n";
            v34 = 12;
            goto LABEL_59;
          }
          v22 = *(const char **)(v20 + 16);
          v39 = *(char **)(v19 + 16);
          v37 = v22;
          v23 = time_group_is_used(v22);
          if ( v23 )
            break;
          jhl_parm_get("time_group", v8, v41);
          if ( nvparm_del_str(v8, 60, 5, v39, 124, 2, v9) )
          {
            jhl_parm_set("time_group", v9);
            v42 = 1;
          }
          v18 = (_DWORD *)*v18;
          if ( !v18 )
            goto LABEL_47;
        }
        v33 = *(const char **)(v21 + 16);
        v32 = *(unsigned __int8 *)(a1 + 210102);
        v34 = v23;
LABEL_59:
        v35 = (const char *)_GET_LANG_TEXT(v34, v32, v33);
        v15 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v35);
        if ( v15 >= 0x100 )
          v15 = 255;
        goto LABEL_50;
      }
      goto LABEL_46;
    }
LABEL_17:
    if ( !v2 )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = (char *)&unk_6442E4;
      v13 = 12;
      goto LABEL_9;
    }
    if ( !v3 )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = (char *)&unk_646EE4;
      v13 = 12;
      goto LABEL_9;
    }
    if ( v10 )
    {
      if ( strcmp(v5, (const char *)&off_648DDC) )
        goto LABEL_46;
    }
    else
    {
      jhl_parm_get("time_group", v8, 102400);
      if ( nvparm_find_str(v8, 60, 3, v2, 124, 2) )
        goto LABEL_64;
      if ( strcmp(v5, (const char *)&off_648DDC) )
      {
        v42 = 0;
        if ( strcmp(v5, (const char *)(v41 + 28044)) )
          goto LABEL_46;
        goto LABEL_54;
      }
    }
    if ( !v40 )
    {
      v40 = v2;
      goto LABEL_24;
    }
    if ( !strcmp(v40, v2) || (jhl_parm_get("time_group", v8, 102400), !nvparm_find_str(v8, 60, 3, v2, 124, 2)) )
    {
LABEL_24:
      jhl_parm_get("time_group", v8, 102400);
      if ( nvparm_get_str(v8, 60, 3, v40, 124, 2, &v37) )
      {
        v42 = J_atoi(v37);
        if ( strcmp(v38, v3) )
          time_group_modify((int)v37, (int)v3);
        jhl_parm_get("time_group", v8, 102400);
        nvparm_del_str(v8, 60, 3, v40, 124, 2, v9);
        jhl_parm_set("time_group", v9);
      }
      else
      {
        v42 = 0;
      }
      if ( strcmp(v5, (const char *)(v41 + 28044)) )
      {
        if ( !strcmp(v5, (const char *)&off_648DDC) )
        {
LABEL_28:
          v39 = v2;
          v38 = v3;
          jhl_parm_get("time_group", v8, 102400);
          if ( nvparm_find_str(v8, 60, 3, v2, 124, 2) )
          {
            v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "same name");
LABEL_10:
            v15 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
            if ( v15 >= 0x100 )
              v15 = 255;
            goto LABEL_12;
          }
          if ( !v42 )
          {
            jhl_parm_get("time_group", v8, 102400);
            v42 = time_group_get_id((int)v8);
          }
          v17 = (const char *)nvram_get("time_group");
          if ( !v17 )
            v17 = "";
          snprintf(v9, 102400, "%s%u|%s|%s<", v17, v42, v3, v2);
          jhl_parm_set("time_group", v9);
          v42 = 1;
          goto LABEL_47;
        }
LABEL_46:
        v42 = 0;
LABEL_47:
        v24 = s;
        v25 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        v26 = "}";
        do
        {
          v27 = *(_DWORD *)v25;
          v28 = *((_DWORD *)v25 + 1);
          v29 = *((_DWORD *)v25 + 2);
          v30 = *((_DWORD *)v25 + 3);
          v25 += 16;
          *(_DWORD *)v24 = v27;
          *((_DWORD *)v24 + 1) = v28;
          *((_DWORD *)v24 + 2) = v29;
          *((_DWORD *)v24 + 3) = v30;
          v24 += 16;
        }
        while ( v25 != "}" );
        v15 = 33;
        *(_WORD *)v24 = *(_WORD *)v25;
LABEL_50:
        if ( v42 )
          jhl_parm_commit(v26);
        goto LABEL_12;
      }
LABEL_54:
      v15 = check_rule_num_limit(a1, 19, (int)"time_group", 60, s, 0x100u);
      if ( (int)v15 > 0 )
      {
LABEL_12:
        _mem_free(v8);
        goto LABEL_13;
      }
      goto LABEL_28;
    }
LABEL_64:
    v11 = *(unsigned __int8 *)(a1 + 210102);
    v12 = "same name";
    v13 = 12;
    goto LABEL_9;
  }
  v31 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v15 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
  if ( v15 >= 0x100 )
    v15 = 255;
LABEL_13:
  if ( v9 )
    _mem_free(v9);
  return httpd_cgi_ret(a1, s, v15, 4);
}
// 4667C4: variable 'v7' is possibly undefined
// 4667D0: variable 'v6' is possibly undefined
// 466D90: variable 'v26' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86B0: using guessed type int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00467090) --------------------------------------------------------
int __fastcall sub_467090(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $s1
  int v5; // $v0
  int v6; // $s1
  int v7; // $v0
  int v8; // $s1
  int v9; // $v0
  int v10; // $s1
  int v11; // $v0
  int v12; // $a2
  int result; // $v0
  const char *v14; // $v0
  unsigned int v15; // $v0
  char v16[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(1024000, "group_all_data", 1419);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{\"ips\":");
    qmemcpy((void *)v2, "{\"code\":0,\"error", 16);
    *(_DWORD *)(v2 + 24) = 975331700;
    *(_BYTE *)(v2 + 32) = 115;
    v4 = get_ips_group_data((char *)(v2 + 35), 1023965) + 35;
    v5 = snprintf(&v3[v4], 1024000 - v4, ",\"times\":");
    if ( v5 >= 1024000 - v4 )
      v5 = 1023999 - v4;
    v6 = v5 + v4 + get_time_group_data(&v3[v5 + v4], 1024000 - (v5 + v4));
    v7 = snprintf(&v3[v6], 1024000 - v6, ",\"dnszu\":");
    if ( v7 >= 1024000 - v6 )
      v7 = 1023999 - v6;
    v8 = v7 + v6 + dns_more_dnstype_get_json(&v3[v7 + v6], 1024000 - (v7 + v6));
    v9 = snprintf(&v3[v8], 1024000 - v8, ",\"dnsout\":");
    if ( v9 >= 1024000 - v8 )
      v9 = 1023999 - v8;
    v10 = v9 + v8 + get_dns_more_dnswan_data(&v3[v9 + v8], 1024000 - (v9 + v8));
    v11 = snprintf(&v3[v10], 1024000 - v10, "}}");
    if ( v11 >= 1024000 - v10 )
      v12 = 1023999 - v10;
    else
      v12 = v11;
    result = httpd_cgi_ret(a1, v3, v12 + v10, 8);
  }
  else
  {
    v14 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v15 = snprintf(v16, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v15 >= 0x100 )
      v15 = 255;
    result = httpd_cgi_ret(a1, v16, v15, 4);
  }
  return result;
}
// 4670E4: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8934: using guessed type int __fastcall dns_more_dnstype_get_json(_DWORD, _DWORD);

//----- (004673A4) --------------------------------------------------------
void __fastcall format_hbmd_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 3 )
    snprintf(a3, a4, "{\"n\":\"%s\",\"qq\":\"%s\",\"t\":\"%s\"},", *a1, a1[1], a1[2]);
}

//----- (0046742C) --------------------------------------------------------
int __fastcall get_hbmd_data(const char *a1, char *a2, int a3)
{
  int v5; // $s2
  int v6; // $s0
  const char **v7; // $s4
  void *v8; // $v0
  _DWORD *v9; // $s7
  void *v10; // $fp
  int v11; // $s6
  _DWORD *v12; // $s3
  int i; // $s2
  int v14; // $v0
  int v15; // $v0
  char *v16; // $a0
  int v17; // $s1
  int v18; // $v0
  char v20[64]; // [sp+18h] [-40h] BYREF

  snprintf(v20, 64, "hbmd_all_%s", a1);
  v5 = nvram_get(v20);
  v6 = snprintf(a2, a3, (char *)&word_642A04);
  if ( v6 >= a3 )
    v6 = a3 - 1;
  if ( v5 )
  {
    v7 = (const char **)malloc(0x14u);
    v9 = malloc(0x1008u);
    v8 = malloc(0x200000u);
    v10 = v8;
    if ( v8 )
    {
      if ( v7 )
      {
        if ( v9 )
        {
          strlcpy(v8, v5, 0x200000);
          v11 = split_string(v10, 60, v9, 1024);
          if ( v11 > 0 )
          {
            v12 = v9;
            for ( i = 0; i != v11; ++i )
            {
              v14 = split_string(*v12, 124, v7, 3);
              format_hbmd_data(v7, v14, &a2[v6], a3 - v6);
              v6 += v15;
              ++v12;
            }
          }
        }
      }
      free(v10);
    }
    if ( v7 )
      free(v7);
    if ( v9 )
      free(v9);
  }
  v16 = &a2[v6];
  if ( v6 > 0 && *(v16 - 1) == 44 )
    v16 = &a2[--v6];
  v17 = a3 - v6;
  *v16 = 0;
  v18 = snprintf(v16, v17, &byte_6445A0);
  if ( v18 >= v17 )
    v18 = v17 - 1;
  return v6 + v18;
}
// 4675C0: variable 'v15' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046769C) --------------------------------------------------------
int __fastcall sub_46769C(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s2
  const char *v5; // $v0
  int v6; // $v0
  int v7; // $s1
  int v8; // $v0
  int v9; // $a2
  int result; // $v0
  const char *v11; // $v0
  unsigned int v12; // $v0
  char v13[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(102400, "qq_hbmd_data", 1513);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\"", 20);
    v4 = (const char *)jhl_nv_get_def("hbmd_def_commqq");
    v5 = (const char *)jhl_nv_get_def(&unk_646F64);
    v6 = snprintf(v3 + 29, 102371, "\"act\":\"%s\",\"log\":\"%s\",\"account_log\":\"%d\",\"all\":", v4, v5, 1);
    if ( v6 >= 102371 )
      v6 = 102370;
    v7 = v6 + 29 + get_hbmd_data("commqq", &v3[v6 + 29], 102400 - (v6 + 29));
    v8 = snprintf(&v3[v7], 102400 - v7, "}}");
    if ( v8 >= 102400 - v7 )
      v9 = 102399 - v7;
    else
      v9 = v8;
    result = httpd_cgi_ret(a1, v3, v9 + v7, 8);
  }
  else
  {
    v11 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v12 = snprintf(v13, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
    if ( v12 >= 0x100 )
      v12 = 255;
    result = httpd_cgi_ret(a1, 0, v12, 4);
  }
  return result;
}
// 4676F0: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (00467900) --------------------------------------------------------
int __fastcall sub_467900(int a1)
{
  int v2; // $v0
  int v3; // $s2
  char *v4; // $s3
  char *v5; // $v0
  char *v6; // $v0
  char *v7; // $s0
  char *v8; // $s5
  char *v9; // $v0
  const char *v10; // $v0
  int v11; // $a0
  char *v12; // $v1
  const char *v13; // $v0
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  int v18; // $s2
  char *v19; // $s4
  char *v20; // $s7
  char *v21; // $v0
  char *v22; // $v0
  int v23; // $a0
  _DWORD *v24; // $s7
  int v25; // $v0
  int v26; // $a1
  const char *v27; // $a2
  int v28; // $a0
  const char *v29; // $v0
  char *v30; // $a0
  char v32[512]; // [sp+28h] [-248h] BYREF
  char *v33; // [sp+228h] [-48h] BYREF
  char *v34; // [sp+22Ch] [-44h]
  const char *v35; // [sp+230h] [-40h]
  char *v36; // [sp+234h] [-3Ch]
  char *v37; // [sp+238h] [-38h]
  char *s; // [sp+240h] [-30h]
  char *v39; // [sp+244h] [-2Ch]
  char *v40; // [sp+248h] [-28h]
  char *v41; // [sp+24Ch] [-24h]
  char *v42; // [sp+250h] [-20h]
  char *v43; // [sp+254h] [-1Ch]
  char *v44; // [sp+258h] [-18h]
  char *v45; // [sp+25Ch] [-14h]
  const char *v46; // [sp+260h] [-10h]
  int v47; // [sp+264h] [-Ch]
  char *v48; // [sp+268h] [-8h]

  s = v32;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  memset(v32, 0, sizeof(v32));
  v41 = httpd_get_parm(a1, "qq");
  v40 = httpd_get_parm(a1, "name");
  v45 = httpd_get_parm(a1, "old_name");
  v48 = httpd_get_parm(a1, "time");
  v2 = httpd_get_json_parm(a1, (int)"del_list");
  v42 = "a";
  v3 = v2;
  v4 = httpd_get_parm(a1, "opt");
  _mem_malloc(102400, "qq_hbmd_asp", 1561);
  v7 = v6;
  _mem_malloc(102400, "qq_hbmd_asp", 1562);
  v8 = v5;
  if ( v7 && v5 )
  {
    if ( v4 )
    {
      v43 = "a";
      if ( !strcmp(v4, (const char *)&off_646D8C) )
      {
        v44 = "1\"";
LABEL_6:
        if ( strcmp(v4, (const char *)&off_64712C) )
        {
          v39 = "1\"";
          goto LABEL_8;
        }
        v39 = "1\"";
        goto LABEL_29;
      }
      v44 = "1\"";
      if ( !strcmp(v4, (const char *)&off_648DDC) )
        goto LABEL_6;
      v39 = "1\"";
      if ( !strcmp(v4, "del") )
      {
        if ( strcmp(v4, (const char *)&off_64712C) )
        {
LABEL_35:
          if ( v3 )
          {
            v24 = *(_DWORD **)(v3 + 8);
            if ( v24 )
            {
              v25 = v24[4];
              if ( v25 )
              {
                v47 = 0;
                v46 = "hbmd_all_commqq";
                do
                {
                  v33 = (char *)v25;
                  jhl_parm_get("hbmd_all_commqq", v7, 102400);
                  if ( nvparm_get_str(v7, 60, 7, v33, 124, 0, &v33) )
                  {
                    common_qq_val_edt(v39 - 15196, &v33);
                    jhl_parm_get(v46, v7, 102400);
                    if ( nvparm_del_str(v7, 60, 7, v33, 124, 0, v8) )
                    {
                      common_qq_val_edt(v39 - 15196, &v33);
                      jhl_parm_set("hbmd_all_commqq", v8);
                      v47 = 1;
                    }
                  }
                  v24 = (_DWORD *)*v24;
                  if ( !v24 )
                    break;
                  v25 = v24[4];
                }
                while ( v25 );
LABEL_10:
                if ( !strcmp(v4, v44 - 29220) )
                {
                  if ( v40 )
                  {
                    v9 = v45;
                    if ( !v45 )
                      v9 = v40;
                    v33 = v9;
                    jhl_parm_get("hbmd_all_commqq", v7, 102400);
                    if ( nvparm_get_str(v7, 60, 7, v33, 124, 0, &v33) )
                    {
                      jhl_parm_get("hbmd_all_commqq", v7, 102400);
                      if ( nvparm_del_str(v7, 60, 7, v33, 124, 0, v8) )
                      {
                        common_qq_val_edt(v39 - 15196, &v33);
                        jhl_parm_set("hbmd_all_commqq", v8);
                        v47 = 1;
                      }
                    }
                    if ( strcmp(v4, v43 + 28044) )
                    {
                      if ( !strcmp(v4, v44 - 29220) )
                      {
                        if ( v41 )
                        {
LABEL_18:
                          jhl_parm_get("hbmd_all_commqq", v8, 102400);
                          if ( !nvparm_find_str(v8, 60, 7, v40, 124, 0) )
                          {
                            v33 = v40;
                            v34 = v41;
                            v10 = v48;
                            if ( !v48 )
                              v10 = "OFF";
                            v35 = v10;
                            sprintf(v7, "%s|%s|%s<", v40, v41, v10);
                            strcat(v8, v7);
                            common_qq_val_edt(v43 + 28044, &v33);
                            goto LABEL_22;
                          }
                          v26 = *(unsigned __int8 *)(a1 + 210102);
                          v27 = "same name";
                          goto LABEL_48;
                        }
                        goto LABEL_47;
                      }
LABEL_51:
                      if ( !v47 )
                      {
LABEL_23:
                        v12 = s;
                        v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
                        do
                        {
                          v14 = *(_DWORD *)v13;
                          v15 = *((_DWORD *)v13 + 1);
                          v16 = *((_DWORD *)v13 + 2);
                          v17 = *((_DWORD *)v13 + 3);
                          v13 += 16;
                          *(_DWORD *)v12 = v14;
                          *((_DWORD *)v12 + 1) = v15;
                          *((_DWORD *)v12 + 2) = v16;
                          *((_DWORD *)v12 + 3) = v17;
                          v12 += 16;
                        }
                        while ( v13 != "}" );
                        v18 = 33;
                        *(_WORD *)v12 = *(_WORD *)v13;
                        goto LABEL_55;
                      }
LABEL_22:
                      jhl_parm_set("hbmd_all_commqq", v8);
                      jhl_parm_commit(v11);
                      goto LABEL_23;
                    }
                    if ( v41 )
                    {
LABEL_54:
                      v18 = check_rule_num_limit(a1, 17, (int)"hbmd_all_commqq", 60, s, 0x200u);
                      if ( v18 > 0 )
                      {
LABEL_55:
                        v30 = v7;
                        goto LABEL_56;
                      }
                      goto LABEL_18;
                    }
LABEL_47:
                    v26 = *(unsigned __int8 *)(a1 + 210102);
                    v27 = "not qqval";
LABEL_48:
                    v28 = 12;
                    goto LABEL_49;
                  }
                }
                else
                {
                  if ( strcmp(v4, v43 + 28044) )
                    goto LABEL_51;
                  if ( v40 )
                  {
                    if ( v41 )
                      goto LABEL_54;
                    goto LABEL_47;
                  }
                }
                v26 = *(unsigned __int8 *)(a1 + 210102);
                v27 = (const char *)&unk_6442E4;
                goto LABEL_48;
              }
            }
          }
LABEL_9:
          v47 = 0;
          goto LABEL_10;
        }
        goto LABEL_29;
      }
      if ( !strcmp(v4, (const char *)&off_64712C) )
      {
LABEL_29:
        v19 = httpd_get_parm(a1, "act");
        v20 = httpd_get_parm(a1, (char *)&off_64E034);
        if ( v19 )
          v21 = v19;
        else
          v21 = "0";
        v36 = v21;
        nvram_set("hbmd_def_commqq", v21);
        nvram_set("hbmd_def_qq", v36);
        nvram_set("hbmd_def_mqq", v36);
        common_qq_val_edt(&off_64712C, &v33);
        if ( v20 )
          v22 = v20;
        else
          v22 = "0";
        v37 = v22;
        nvram_set(&unk_646F64, v22);
        nvram_set("hbmd_log_qq", v37);
        nvram_set("hbmd_log_mqq", v37);
        common_qq_val_edt(&off_64E034, &v33);
        jhl_parm_commit(v23);
LABEL_8:
        if ( strcmp(v4, v39 - 15196) )
          goto LABEL_9;
        goto LABEL_35;
      }
    }
    v26 = *(unsigned __int8 *)(a1 + 210102);
    v27 = "not opt";
    goto LABEL_48;
  }
  v26 = *(unsigned __int8 *)(a1 + 210102);
  v27 = (const char *)102400;
  v28 = 4;
LABEL_49:
  v29 = (const char *)_GET_LANG_TEXT(v28, v26, v27);
  v18 = snprintf(s, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v29);
  v30 = v7;
  if ( (unsigned int)v18 >= 0x200 )
    v18 = 511;
LABEL_56:
  _mem_free(v30);
  _mem_free(v8);
  return httpd_cgi_ret(a1, s, v18, 4);
}
// 467A5C: variable 'v6' is possibly undefined
// 467A68: variable 'v5' is possibly undefined
// 467CD8: variable 'v11' is possibly undefined
// 467EC8: variable 'v23' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 64E034: using guessed type int (**off_64E034)();
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83BC: using guessed type int __fastcall common_qq_val_edt(_DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86B0: using guessed type int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004682EC) --------------------------------------------------------
void __fastcall format_xwgl_ref_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 10 )
    snprintf(
      a3,
      a4,
      "{\"name\":\"%s\",\"en\":%s,\"user_id\":\"%s\",\"shibie_name\":\"%s\",\"time\":\"%s\",\"act\":%s,\"log\":%s,\"rpri\""
      ":%s,\"ipport\":\"%s\",\"ruleips\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7],
      a1[8],
      a1[9]);
}

//----- (004683AC) --------------------------------------------------------
int __fastcall sub_4683AC(int a1)
{
  char *v1; // $v0
  char *v2; // $fp
  const char *v3; // $v0
  int v4; // $v0
  int v5; // $s3
  int v6; // $s1
  char *v7; // $s4
  int v8; // $s5
  int v9; // $s0
  const char **v10; // $s2
  void *v11; // $v0
  _DWORD *v12; // $s6
  int v13; // $a1
  void *v14; // $s5
  int v15; // $s5
  int i; // $s7
  int v17; // $v0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $s1
  int v21; // $v0
  int v22; // $s3
  int v23; // $v0
  int v24; // $a2
  int result; // $v0
  const char *v26; // $v0
  unsigned int v27; // $v0
  char v28[256]; // [sp+20h] [-108h] BYREF
  _DWORD *v29; // [sp+120h] [-8h]
  void *ptr; // [sp+124h] [-4h]

  _mem_malloc(0x200000, "xwgl_ref_data", 1769);
  v2 = v1;
  if ( v1 )
  {
    strcpy(v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v1, "{\"code\":0,\"error", 16);
    v3 = (const char *)nvram_get("xwgl_def");
    if ( !v3 )
      v3 = "1";
    v4 = snprintf(v2 + 29, 2097123, "\"def\":\"%s\",\"all\":", v3);
    if ( v4 >= 2097123 )
      v4 = 2097122;
    v5 = v4 + 29;
    v6 = 0x200000 - (v4 + 29);
    v7 = &v2[v4 + 29];
    v8 = nvram_get("xwgl_all");
    v9 = snprintf(&v2[v5], 0x200000 - v5, (char *)&word_642A04);
    if ( v9 >= 0x200000 - v5 )
      v9 = 0x1FFFFF - v5;
    if ( v8 )
    {
      v10 = (const char **)malloc(0x30u);
      v29 = malloc(0x4008u);
      v12 = v29;
      v11 = malloc(0x200000u);
      ptr = v11;
      if ( v11 )
      {
        if ( v10 )
        {
          v13 = v8;
          if ( v29 )
          {
            v14 = v11;
            strlcpy(v11, v13, 0x200000);
            v15 = split_string(v14, 60, v29, 4096);
            if ( v15 > 0 )
            {
              for ( i = 0; i != v15; ++i )
              {
                v17 = split_string(*v12, 124, v10, 10);
                format_xwgl_ref_data(v10, v17, &v7[v9], v6 - v9);
                v9 += v18;
                ++v12;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v10 )
        free(v10);
      if ( v29 )
        free(v29);
    }
    v19 = &v7[v9];
    if ( v9 > 0 && *(v19 - 1) == 44 )
      v19 = &v7[--v9];
    v20 = v6 - v9;
    *v19 = 0;
    v21 = snprintf(v19, v20, &byte_6445A0);
    if ( v21 >= v20 )
      v21 = v20 - 1;
    v22 = v9 + v21 + v5;
    v23 = snprintf(&v2[v22], 0x200000 - v22, "}}");
    if ( v23 >= 0x200000 - v22 )
      v24 = 0x1FFFFF - v22;
    else
      v24 = v23;
    result = httpd_cgi_ret(a1, v2, v24 + v22, 8);
  }
  else
  {
    v26 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v27 = snprintf(v28, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v26);
    if ( v27 >= 0x100 )
      v27 = 255;
    result = httpd_cgi_ret(a1, v28, v27, 4);
  }
  return result;
}
// 46840C: variable 'v1' is possibly undefined
// 468600: variable 'v18' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004687E0) --------------------------------------------------------
int __fastcall sub_4687E0(int a1)
{
  char *v2; // $fp
  int v3; // $s5
  char *v4; // $s1
  char *v5; // $v0
  char *v6; // $v0
  char *v7; // $s4
  char *v8; // $s2
  int v9; // $v0
  char *v10; // $v1
  int v11; // $a1
  const char *v12; // $a2
  int v13; // $a0
  char *v14; // $s5
  char *v15; // $v1
  const char *v16; // $v0
  int v17; // $t0
  int v18; // $a3
  int v19; // $a2
  int v20; // $a1
  int v21; // $s7
  int v23; // $a0
  _DWORD *v24; // $fp
  const char *v25; // $v0
  int v26; // $a0
  const char *v27; // $v0
  const char *v28; // $v0
  int v29; // $v0
  char v30[1024]; // [sp+38h] [-5D8h] BYREF
  char s[256]; // [sp+438h] [-1D8h] BYREF
  char v32[64]; // [sp+538h] [-D8h] BYREF
  const char *v33; // [sp+578h] [-98h] BYREF
  char *v34; // [sp+57Ch] [-94h]
  const char *v35; // [sp+580h] [-90h]
  const char *v36; // [sp+584h] [-8Ch]
  char *v37; // [sp+588h] [-88h]
  const char *v38; // [sp+58Ch] [-84h]
  char *v39; // [sp+590h] [-80h]
  const char *v40; // [sp+594h] [-7Ch]
  const char *v41; // [sp+598h] [-78h]
  const char *v42; // [sp+59Ch] [-74h]
  const char *v43; // [sp+5A0h] [-70h]
  const char *v44; // [sp+5A4h] [-6Ch]
  int v45; // [sp+5A8h] [-68h]
  char *v46; // [sp+5ACh] [-64h] BYREF
  char *v47; // [sp+5B0h] [-60h]
  char *v48; // [sp+5B4h] [-5Ch]
  char *v49; // [sp+5B8h] [-58h]
  char *v50; // [sp+5BCh] [-54h]
  char *v51; // [sp+5C0h] [-50h]
  char *v52; // [sp+5C4h] [-4Ch]
  char *v53; // [sp+5C8h] [-48h]
  char *v54; // [sp+5CCh] [-44h]
  char *v55; // [sp+5D0h] [-40h]
  int v56; // [sp+5D4h] [-3Ch]
  int v57; // [sp+5D8h] [-38h]
  char *v58; // [sp+5E0h] [-30h]
  char *v59; // [sp+5E4h] [-2Ch]
  char *v60; // [sp+5E8h] [-28h]
  char *v61; // [sp+5ECh] [-24h]
  char *v62; // [sp+5F0h] [-20h]
  char *v63; // [sp+5F4h] [-1Ch]
  char *v64; // [sp+5F8h] [-18h]
  char *v65; // [sp+5FCh] [-14h]
  char *v66; // [sp+600h] [-10h]
  char *v67; // [sp+604h] [-Ch]
  char *v68; // [sp+608h] [-8h]
  char *v69; // [sp+60Ch] [-4h]

  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  memset(v32, 0, sizeof(v32));
  v58 = httpd_get_parm(a1, "name");
  v67 = httpd_get_parm(a1, "old_name");
  v59 = httpd_get_parm(a1, "en");
  v60 = httpd_get_parm(a1, "user_id");
  v61 = httpd_get_parm(a1, "shibie_name");
  v2 = httpd_get_parm(a1, "time");
  v62 = httpd_get_parm(a1, "act");
  v63 = httpd_get_parm(a1, (char *)&off_64E034);
  v64 = httpd_get_parm(a1, "rpri");
  v65 = httpd_get_parm(a1, "ipport");
  v66 = httpd_get_parm(a1, "ruleips");
  v3 = httpd_get_json_parm(a1, (int)"del_list");
  v4 = httpd_get_parm(a1, "opt");
  _mem_malloc(0x200000, "xwgl_ref_asp", 1835);
  v7 = v6;
  _mem_malloc(0x200000, "xwgl_ref_asp", 1836);
  v8 = v5;
  if ( v7 )
  {
    if ( v5 )
    {
      if ( !v4 )
      {
LABEL_9:
        v11 = *(unsigned __int8 *)(a1 + 210102);
        v12 = "not opt";
        v13 = 12;
        goto LABEL_75;
      }
      if ( strcmp(v4, (const char *)&off_646D8C) && strcmp(v4, (const char *)&off_648DDC) && strcmp(v4, "del") )
      {
        if ( strcmp(v4, "delall") )
        {
          v58 = "a";
          v9 = strcmp(v4, (const char *)&off_64712C);
          v10 = v58;
          if ( v9 )
            goto LABEL_9;
          goto LABEL_13;
        }
        goto LABEL_22;
      }
      if ( !strcmp(v4, "delall") )
      {
LABEL_22:
        if ( set_xwgl_ref_to_kernel(v4, &v46) )
          goto LABEL_15;
        *v8 = 0;
        v68 = "a";
LABEL_24:
        jhl_parm_set(v68 + 27928, v8);
        jhl_parm_commit(v23);
LABEL_15:
        v15 = s;
        v16 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v17 = *(_DWORD *)v16;
          v18 = *((_DWORD *)v16 + 1);
          v19 = *((_DWORD *)v16 + 2);
          v20 = *((_DWORD *)v16 + 3);
          v16 += 16;
          *(_DWORD *)v15 = v17;
          *((_DWORD *)v15 + 1) = v18;
          *((_DWORD *)v15 + 2) = v19;
          *((_DWORD *)v15 + 3) = v20;
          v15 += 16;
        }
        while ( v16 != "}" );
        v21 = 33;
        *(_WORD *)v15 = *(_WORD *)v16;
        goto LABEL_18;
      }
      v68 = "a";
      if ( !strcmp(v4, (const char *)&off_64712C) )
      {
        v10 = v68;
LABEL_13:
        v46 = httpd_get_parm(a1, v10 + 28972);
        v14 = v46;
        if ( !set_xwgl_ref_to_kernel(v4, &v46) )
        {
          jhl_parm_set("xwgl_def", v14);
          jhl_parm_commit(v26);
        }
        goto LABEL_15;
      }
      v68 = "a";
      strcpy(v32, "xwgl_all");
      if ( !strcmp(v4, "del") && v3 && cJSON_IsArray(v3) )
      {
        v24 = *(_DWORD **)(v3 + 8);
        if ( !v24 )
          goto LABEL_15;
        v25 = (const char *)v24[4];
        if ( !v25 )
          goto LABEL_15;
        v58 = 0;
        do
        {
          v46 = (char *)v25;
          if ( !set_xwgl_ref_to_kernel(v4, &v46) )
          {
            jhl_parm_get(v32, v7, 0x200000);
            if ( nvparm_del_str(v7, 60, 12, v24[4], 124, 0, v8) )
            {
              jhl_parm_set(v32, v8);
              v58 = (char *)1;
            }
          }
          v24 = (_DWORD *)*v24;
          if ( !v24 )
            break;
          v25 = (const char *)v24[4];
        }
        while ( v25 );
        if ( !v58 )
          goto LABEL_15;
        goto LABEL_24;
      }
      if ( v58 )
      {
        v46 = v58;
        if ( strcmp(v4, (const char *)&off_646D8C) && strcmp(v4, (const char *)&off_648DDC) )
          goto LABEL_15;
        v69 = v30;
        memset(v30, 0, sizeof(v30));
        if ( strcmp(v4, (const char *)&off_646D8C) )
        {
LABEL_40:
          if ( !v59 || !*v59 )
            v59 = "1";
          v47 = v59;
          if ( !v60 || !*v60 )
            v60 = "";
          v48 = v60;
          if ( !v61 || !*v61 )
            v61 = "0";
          v49 = v61;
          if ( !v2 || !*v2 )
            v2 = "OFF";
          v50 = v2;
          if ( !v62 || !*v62 )
            v62 = "1";
          v51 = v62;
          if ( !v63 || !*v63 )
            v63 = "1";
          v52 = v63;
          if ( !v64 || !*v64 )
            v64 = "1";
          v53 = v64;
          if ( !v65 || !*v65 )
            v65 = "";
          v54 = v65;
          if ( !v66 || !*v66 )
            v66 = "";
          v55 = v66;
          if ( get_time_group(v2, v69, 1024) )
            strlcpy(v69, v50, 1024);
          if ( v67 )
          {
            v34 = v67;
            v33 = "xwgl_ref_del.sh";
            v35 = 0;
            eval(&v33, 0, 0, 0);
            v33 = "xwgl_ref_add.sh";
            v34 = v46;
            v35 = v47;
            v36 = v48;
            v45 = 0;
            v37 = "0";
            v38 = v49;
            v39 = v69;
            v40 = v51;
            v41 = v52;
            v42 = v53;
            v43 = v54;
            v44 = v55;
            eval(&v33, 0, 0, 0);
            if ( strcmp(v4, (const char *)&off_648DDC) )
              goto LABEL_62;
            jhl_parm_get(v32, v7, 0x200000);
            v29 = nvparm_del_str(v7, 60, 12, v67, 124, 0, v8);
          }
          else
          {
            set_xwgl_ref_to_kernel(v4, &v46);
            if ( strcmp(v4, (const char *)&off_648DDC) )
              goto LABEL_62;
            jhl_parm_get(v32, v7, 0x200000);
            v29 = nvparm_del_str(v7, 60, 12, v58, 124, 0, v8);
          }
          if ( v29 )
          {
            sprintf(v7, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<", v46, v47, v48, v49, v50, v51, v52, v53, v54, v55);
LABEL_64:
            strcat(v8, v7);
            goto LABEL_24;
          }
LABEL_62:
          sprintf(v7, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<", v46, v47, v48, v49, v50, v51, v52, v53, v54, v55);
          jhl_parm_get(v32, v8, 0x200000);
          if ( !strcmp(v8, " ") )
            *v8 = 0;
          goto LABEL_64;
        }
        jhl_parm_get(v32, v8, 0x200000);
        if ( !nvparm_find_str(v8, 60, 12, v58, 124, 0) )
        {
          v21 = check_rule_num_limit(a1, 13, (int)v32, 60, s, 0x100u);
          if ( v21 > 0 )
          {
LABEL_18:
            _mem_free(v7);
            goto LABEL_19;
          }
          goto LABEL_40;
        }
        v11 = *(unsigned __int8 *)(a1 + 210102);
        v12 = "same name";
        v13 = 12;
      }
      else
      {
        v11 = *(unsigned __int8 *)(a1 + 210102);
        v12 = (const char *)&unk_6442E4;
        v13 = 12;
      }
    }
    else
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = (const char *)0x200000;
      v13 = 4;
    }
LABEL_75:
    v27 = (const char *)_GET_LANG_TEXT(v13, v11, v12);
    v21 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
    if ( (unsigned int)v21 >= 0x100 )
      v21 = 255;
    goto LABEL_18;
  }
  v28 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v21 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v28);
  if ( (unsigned int)v21 >= 0x100 )
    v21 = 255;
LABEL_19:
  if ( v8 )
    _mem_free(v8);
  return httpd_cgi_ret(a1, s, v21, 4);
}
// 468A0C: variable 'v6' is possibly undefined
// 468A18: variable 'v5' is possibly undefined
// 4691DC: variable 'v26' is possibly undefined
// 468C88: variable 'v23' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 64E034: using guessed type int (**off_64E034)();
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8298: using guessed type int __fastcall get_time_group(_DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86A4: using guessed type int __fastcall set_xwgl_ref_to_kernel(_DWORD, _DWORD);

//----- (00469574) --------------------------------------------------------
int __fastcall sub_469574(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "xwgl_ref_txt", 2015);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("xwgl_all");
    if ( !v3 )
      v3 = "";
    v5 = sprintf(v4, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 4695B4: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004696C4) --------------------------------------------------------
int __fastcall sub_4696C4(int a1)
{
  int v1; // $s5
  char *v2; // $v0
  char *v3; // $s0
  char *v4; // $s3
  char *v5; // $a1
  char *v6; // $v0
  int v7; // $a1
  int v8; // $v1
  _BOOL4 v9; // $a3
  char *v10; // $t0
  char *v11; // $s3
  char *v12; // $s5
  int v13; // $s4
  int v14; // $s0
  const char **v15; // $s7
  int v16; // $fp
  int v17; // $s6
  char *v18; // $s1
  char *v19; // $s1
  int v20; // $a0
  int v21; // $a2
  const char *v22; // $v0
  unsigned int v23; // $v0
  unsigned int v24; // $a2
  const char *v26; // $v0
  char v27[102400]; // [sp+20h] [-36620h] BYREF
  _BYTE v28[102400]; // [sp+19020h] [-1D620h] BYREF
  _BYTE v29[10240]; // [sp+32020h] [-4620h] BYREF
  int v30; // [sp+36620h] [-20h]
  char *v31; // [sp+36624h] [-1Ch]
  int v32; // [sp+36628h] [-18h]
  char *v33; // [sp+3662Ch] [-14h]
  char *v34; // [sp+36630h] [-10h]
  char **v35; // [sp+36634h] [-Ch]
  char *v36; // [sp+36638h] [-8h]

  v33 = v27;
  memset(v28, 0, sizeof(v28));
  memset(v27, 0, sizeof(v27));
  memset(v29, 0, sizeof(v29));
  v1 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( v2 )
  {
    v3 = v2;
    v4 = find_file_end(a1, v2, *(_DWORD *)(a1 + 205564) + v1 - (_DWORD)v2);
    if ( v4 )
    {
      v36 = "a";
      v5 = v33;
      *v4 = 0;
      jhl_parm_get("xwgl_all", v5, 102400);
      v6 = v3;
      if ( v4 - v3 <= 0 )
      {
        v7 = 0;
      }
      else
      {
        v7 = 0;
        do
        {
          v8 = *v6++;
          v9 = v7 + 1 < 102399;
          if ( v8 != 13 && v8 != 10 )
          {
            v28[v7++] = v8;
            if ( !v9 )
              break;
          }
        }
        while ( v4 != v6 );
      }
      v10 = v33;
      v11 = v33 + 220160;
      v33[v7 + 102400] = 0;
      v30 = split_string(v10 + 102400, 60, v11, 512);
      if ( v30 > 0 )
      {
        v31 = v33 + 215040;
        v12 = v33 + 222208;
        v34 = v33 + 196608;
        v13 = 0;
        v35 = &off_646D8C;
        do
        {
          while ( 1 )
          {
            strlcpy(v31, *(_DWORD *)v11, 5120);
            v14 = split_string(*(_DWORD *)v11, 124, v12, 128);
            if ( v14 >= 6 )
            {
              v32 = *((_DWORD *)v34 + 6400);
              if ( !nvparm_find_str(v33, 60, 9, v32, 124, 0) )
                break;
            }
            ++v13;
            v11 += 4;
            if ( v30 == v13 )
              goto LABEL_17;
          }
          set_xwgl_ref_to_kernel(v35, v12);
          v15 = (const char **)v12;
          v16 = 0;
          v17 = 0;
          v18 = v33 + 204800;
          do
          {
            ++v17;
            v16 += sprintf(&v18[v16], "%s|", *v15++);
          }
          while ( v14 != v17 );
          *(_WORD *)&v18[v16 - 1] = 60;
          strcat(v33, v18);
          ++v13;
          v11 += 4;
        }
        while ( v30 != v13 );
      }
LABEL_17:
      v19 = v33;
      jhl_parm_set(v36 + 27928, v33);
      jhl_parm_commit(v20);
      v22 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v21);
      v23 = snprintf(v19 + 215040, 5120, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v22);
      if ( v23 < 0x1400 )
        goto LABEL_18;
      goto LABEL_23;
    }
    if ( debug_level > 0 )
      printf("%s:%d find_file_end err \n", "xwgl_ref_cgi", 2071);
  }
  else if ( debug_level > 0 )
  {
    printf("%s:%d find_file_head err  \n", "xwgl_ref_cgi", 2064);
  }
  v26 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
  v24 = snprintf(v33 + 215040, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v26);
  if ( v24 < 0x1400 )
    return httpd_cgi_ret(a1, v33 + 215040, v24, 4);
LABEL_23:
  v23 = 5119;
LABEL_18:
  v24 = v23;
  return httpd_cgi_ret(a1, v33 + 215040, v24, 4);
}
// 4697D4: variable 'v2' is possibly undefined
// 469B34: variable 'v20' is possibly undefined
// 469B64: variable 'v21' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 67D0BC: using guessed type int debug_level;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86A4: using guessed type int __fastcall set_xwgl_ref_to_kernel(_DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00469D18) --------------------------------------------------------
int dns_acc_delall()
{
  void *v0; // $v0
  void *v1; // $s3
  char *v2; // $s0
  int v3; // $v0
  int v4; // $s2
  int v5; // $s1
  int v6; // $s0
  char v8[16384]; // [sp+18h] [-4000h] BYREF

  _mem_malloc(0x200000, "dns_acc_delall", 2136);
  if ( !v0 )
    return -1;
  v1 = v0;
  jhl_parm_get("dnsAcc", v0, 0x200000);
  v2 = v8;
  v3 = split_string(v1, 60, v8, 4096);
  v4 = v3 - 1;
  if ( v3 < 2 )
  {
LABEL_7:
    v6 = 0;
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      ++v5;
      if ( dns_acc_del(*(_DWORD *)v2) )
        break;
      v2 += 4;
      if ( v5 == v4 )
        goto LABEL_7;
    }
    v6 = -1;
  }
  _mem_free(v1);
  return v6;
}
// 469D60: variable 'v0' is possibly undefined
// 6A81D4: using guessed type int __fastcall dns_acc_del(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00469E28) --------------------------------------------------------
int dns_url_delall()
{
  void *v0; // $v0
  void *v1; // $s3
  char *v2; // $s0
  int v3; // $v0
  int v4; // $s2
  int v5; // $s1
  int v6; // $s0
  char v8[16384]; // [sp+18h] [-4014h] BYREF
  int v9[5]; // [sp+4018h] [-14h] BYREF

  _mem_malloc(0x200000, "dns_url_delall", 2176);
  if ( !v0 )
    return -1;
  v1 = v0;
  jhl_parm_get("dnsUrl", v0, 0x200000);
  v2 = v8;
  v3 = split_string(v1, 60, v8, 4096);
  v4 = v3 - 1;
  if ( v3 < 2 )
  {
LABEL_7:
    v6 = 0;
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      split_string(*(_DWORD *)v2, 58, v9, 2);
      ++v5;
      if ( dns_url_del(v9[0]) )
        break;
      v2 += 4;
      if ( v5 == v4 )
        goto LABEL_7;
    }
    v6 = -1;
  }
  _mem_free(v1);
  return v6;
}
// 469E74: variable 'v0' is possibly undefined
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8884: using guessed type int __fastcall dns_url_del(_DWORD);

//----- (00469F64) --------------------------------------------------------
int __fastcall sub_469F64(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "dns_acc_txt", 2218);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("dnsAcc");
    if ( !v3 )
      v3 = "";
    v5 = sprintf(v4, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 469FA4: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0046A0B4) --------------------------------------------------------
int __fastcall sub_46A0B4(int a1)
{
  _BYTE *v2; // $v0
  int v3; // $s2
  int v4; // $s6
  char *v5; // $v0
  _BYTE *v6; // $s1
  char *v7; // $s0
  char *v8; // $v0
  char *v9; // $s5
  int v10; // $s6
  char *v11; // $v0
  int v12; // $a0
  int v13; // $v1
  _BOOL4 v14; // $a2
  char *v15; // $s5
  int v16; // $v0
  int v17; // $a0
  int v18; // $s6
  int v19; // $s0
  const char *v20; // $v0
  unsigned int v21; // $s0
  int v23; // $a2
  const char *v24; // $v0
  const char *v25; // $v0
  unsigned int v26; // $v0
  char v27[16384]; // [sp+20h] [-5400h] BYREF
  char v28[5120]; // [sp+4020h] [-1400h] BYREF

  v3 = get_rule_num_limit(32);
  _mem_malloc(0x200000, "dns_acc_cgi", 2250);
  if ( v2 )
  {
    v4 = *(_DWORD *)(a1 + 205364);
    v6 = v2;
    find_file_head(a1, *(const char **)(a1 + 205564));
    v7 = v5;
    if ( v5 )
    {
      v8 = find_file_end(a1, v5, *(_DWORD *)(a1 + 205564) + v4 - (_DWORD)v5);
      v9 = v8;
      if ( v8 )
      {
        *v8 = 0;
        v10 = v8 - v7;
        dns_acc_delall();
        if ( v10 <= 0 )
        {
          v12 = 0;
        }
        else
        {
          v11 = v7;
          v12 = 0;
          do
          {
            v13 = *v11++;
            v14 = v12 + 1 < 0x1FFFFF;
            if ( v13 != 13 && v13 != 10 )
            {
              v6[v12++] = v13;
              if ( !v14 )
                break;
            }
          }
          while ( v9 != v11 );
        }
        v6[v12] = 0;
        jhl_parm_set("dnsAcc", v6);
        v15 = v27;
        v16 = split_string(v6, 60, v27, 4096);
        v18 = v16 - 1;
        if ( v16 < 2 )
        {
LABEL_18:
          jhl_parm_commit(v17);
          v24 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v23);
          v21 = snprintf(v28, 5120, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v24);
          if ( v21 < 0x1400 )
            goto LABEL_16;
          goto LABEL_19;
        }
        v19 = 0;
        while ( 1 )
        {
          ++v19;
          if ( dns_acc_add(*(_DWORD *)v15) )
            break;
          if ( v19 < v3 )
          {
            v15 += 4;
            if ( v19 != v18 )
              continue;
          }
          goto LABEL_18;
        }
      }
      else if ( debug_level > 0 )
      {
        printf("%s:%d find_file_end err \n", "dns_acc_cgi", 2269);
      }
    }
    else if ( debug_level > 0 )
    {
      printf("%s:%d find_file_head err  \n", "dns_acc_cgi", 2262);
    }
    v20 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
    v21 = snprintf(v28, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v20);
    if ( v21 < 0x1400 )
    {
LABEL_16:
      _mem_free(v6);
      return httpd_cgi_ret(a1, v28, v21, 4);
    }
LABEL_19:
    v21 = 5119;
    goto LABEL_16;
  }
  v25 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v26 = snprintf(v28, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v25);
  if ( v26 >= 0x1400 )
    v26 = 5119;
  return httpd_cgi_ret(a1, v28, v26, 4);
}
// 46A11C: variable 'v2' is possibly undefined
// 46A14C: variable 'v5' is possibly undefined
// 46A318: variable 'v17' is possibly undefined
// 46A338: variable 'v23' is possibly undefined
// 67D0BC: using guessed type int debug_level;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8784: using guessed type int __fastcall dns_acc_add(_DWORD);

//----- (0046A46C) --------------------------------------------------------
int __fastcall sub_46A46C(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "dns_url_txt", 2339);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("dnsUrl");
    if ( !v3 )
      v3 = "";
    v5 = sprintf(v4, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 46A4AC: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0046A5BC) --------------------------------------------------------
int __fastcall sub_46A5BC(int a1)
{
  int v2; // $s4
  _BYTE *v3; // $v0
  void *v4; // $v0
  void *v5; // $s5
  _BYTE *v6; // $s1
  int v7; // $s7
  char *v8; // $v0
  char *v9; // $s0
  char *v10; // $v0
  char *v11; // $a1
  int v12; // $a0
  int v13; // $v1
  _BOOL4 v14; // $a3
  char *v15; // $s6
  int v16; // $v0
  int v17; // $a0
  int v18; // $s7
  int v19; // $s0
  const char *v20; // $v0
  unsigned int v21; // $s4
  int result; // $v0
  int v23; // $a2
  const char *v24; // $v0
  const char *v25; // $v0
  unsigned int v26; // $v0
  char v27[16384]; // [sp+20h] [-5410h] BYREF
  char v28[5120]; // [sp+4020h] [-1410h] BYREF
  int v29[4]; // [sp+5420h] [-10h] BYREF

  v2 = get_rule_num_limit(31);
  _mem_malloc(0x200000, "dns_url_cgi", 2374);
  v5 = v4;
  _mem_malloc(0x200000, "dns_url_cgi", 2375);
  v6 = v3;
  if ( v5 && v3 )
  {
    v7 = *(_DWORD *)(a1 + 205364);
    find_file_head(a1, *(const char **)(a1 + 205564));
    v9 = v8;
    if ( v8 )
    {
      v10 = find_file_end(a1, v8, *(_DWORD *)(a1 + 205564) + v7 - (_DWORD)v8);
      if ( v10 )
      {
        *v10 = 0;
        if ( v10 - v9 <= 0 )
        {
          v12 = 0;
        }
        else
        {
          v11 = v9;
          v12 = 0;
          do
          {
            v13 = *v11++;
            v14 = v12 + 1 < 0x1FFFFF;
            if ( v13 != 13 && v13 != 10 )
            {
              v6[v12++] = v13;
              if ( !v14 )
                break;
            }
          }
          while ( v10 != v11 );
        }
        v6[v12] = 0;
        if ( dns_url_delall() >= 0 )
        {
          jhl_parm_set("dnsUrl", v6);
          v15 = v27;
          v16 = split_string(v6, 60, v27, 4096);
          v18 = v16 - 1;
          if ( v16 < 2 )
          {
LABEL_20:
            jhl_parm_commit(v17);
            v24 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v23);
            v21 = snprintf(v28, 5120, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v24);
            if ( v21 < 0x1400 )
              goto LABEL_18;
            goto LABEL_21;
          }
          v19 = 0;
          while ( 1 )
          {
            split_string(*(_DWORD *)v15, 58, v29, 2);
            ++v19;
            if ( dns_url_add(v29[0], v29[1], 0) )
              break;
            if ( v19 < v2 )
            {
              v15 += 4;
              if ( v19 != v18 )
                continue;
            }
            goto LABEL_20;
          }
        }
      }
      else if ( debug_level > 0 )
      {
        printf("%s:%d find_file_end err \n", "dns_url_cgi", 2396);
      }
    }
    else if ( debug_level > 0 )
    {
      printf("%s:%d find_file_head err  \n", "dns_url_cgi", 2389);
    }
    v20 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
    v21 = snprintf(v28, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v20);
    if ( v21 < 0x1400 )
    {
LABEL_18:
      _mem_free(v5);
      _mem_free(v6);
      return httpd_cgi_ret(a1, v28, v21, 4);
    }
LABEL_21:
    v21 = 5119;
    goto LABEL_18;
  }
  _mem_free(v3);
  _mem_free(v5);
  v25 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v26 = snprintf(v28, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v25);
  if ( v26 >= 0x1400 )
    result = httpd_cgi_ret(a1, v28, 5119, 4);
  else
    result = httpd_cgi_ret(a1, v28, v26, 4);
  return result;
}
// 46A640: variable 'v4' is possibly undefined
// 46A64C: variable 'v3' is possibly undefined
// 46A67C: variable 'v8' is possibly undefined
// 46A894: variable 'v17' is possibly undefined
// 46A8B4: variable 'v23' is possibly undefined
// 67D0BC: using guessed type int debug_level;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8548: using guessed type int __fastcall dns_url_add(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046AA30) --------------------------------------------------------
signed int __fastcall dns_acc_get(char *a1, size_t a2)
{
  char *v4; // $v0
  int v5; // $a2
  char *v6; // $s6
  signed int v7; // $s0
  const char *v9; // $s5
  int v10; // $fp
  int v11; // $v0

  _mem_malloc(0x200000, "dns_acc_get", 2471);
  v6 = v4;
  if ( !v4 )
    return 0;
  *(_DWORD *)v4 = 4;
  *((_DWORD *)v4 + 3) = 10;
  *((_DWORD *)v4 + 1) = 0x200000;
  if ( jianhl_order_opt_fun(v4, 0x200000, v5) || (memset(a1, 0, a2), v9 = v6 + 16, *((int *)v6 + 2) <= 0) )
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    v10 = 0;
    do
    {
      v11 = snprintf(&a1[v7], a2 - v7, "%s<", v9);
      if ( v11 >= (int)(a2 - v7) )
        v11 = a2 - v7 - 1;
      v7 += v11;
      ++v10;
      if ( v7 >= (int)(a2 - 49) )
        break;
      v9 += 128;
    }
    while ( v10 < *((_DWORD *)v6 + 2) );
  }
  _mem_free(v6);
  return v7;
}
// 46AA94: variable 'v4' is possibly undefined
// 46AAB8: variable 'v5' is possibly undefined
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0046ABC0) --------------------------------------------------------
void __fastcall format_dns_acc_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 > 0 )
    snprintf(a3, a4, "\"%s\",", *a1);
}

//----- (0046AC30) --------------------------------------------------------
int __fastcall sub_46AC30(int a1)
{
  int v1; // $v0
  char *v2; // $fp
  const char *v3; // $v0
  int v4; // $v0
  int v5; // $s3
  int v6; // $s1
  char *v7; // $s4
  int v8; // $s5
  int v9; // $s0
  const char **v10; // $s2
  void *v11; // $v0
  _DWORD *v12; // $s6
  int v13; // $a1
  void *v14; // $s5
  int v15; // $s5
  int i; // $s7
  int v17; // $v0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $s1
  int v21; // $v0
  int v22; // $s3
  char *v23; // $a0
  int v24; // $v0
  int v25; // $a2
  int result; // $v0
  const char *v27; // $v0
  unsigned int v28; // $v0
  char v29[256]; // [sp+20h] [-108h] BYREF
  _DWORD *v30; // [sp+120h] [-8h]
  void *ptr; // [sp+124h] [-4h]

  _mem_malloc(0x200000, "dns_acc_data", 2528);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    v3 = (const char *)jhl_nv_get_def("dnsDef");
    v4 = snprintf(v2 + 29, 2097123, "\"def\":%s,\"all\":", v3);
    if ( v4 >= 2097123 )
      v4 = 2097122;
    v5 = v4 + 29;
    v6 = 0x200000 - (v4 + 29);
    v7 = &v2[v4 + 29];
    v8 = nvram_get("dnsAcc");
    v9 = snprintf(&v2[v5], 0x200000 - v5, (char *)&word_642A04);
    if ( v9 >= 0x200000 - v5 )
      v9 = 0x1FFFFF - v5;
    if ( v8 )
    {
      v10 = (const char **)malloc(0xCu);
      v30 = malloc(0x4008u);
      v12 = v30;
      v11 = malloc(0x200000u);
      ptr = v11;
      if ( v11 )
      {
        if ( v10 )
        {
          v13 = v8;
          if ( v30 )
          {
            v14 = v11;
            strlcpy(v11, v13, 0x200000);
            v15 = split_string(v14, 60, v30, 4096);
            if ( v15 > 0 )
            {
              for ( i = 0; i != v15; ++i )
              {
                v17 = split_string(*v12, 124, v10, 1);
                format_dns_acc_data(v10, v17, &v7[v9], v6 - v9);
                v9 += v18;
                ++v12;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v10 )
        free(v10);
      if ( v30 )
        free(v30);
    }
    v19 = &v7[v9];
    if ( v9 > 0 && *(v19 - 1) == 44 )
      v19 = &v7[--v9];
    v20 = v6 - v9;
    *v19 = 0;
    v21 = snprintf(v19, v20, &byte_6445A0);
    if ( v21 >= v20 )
      v21 = v20 - 1;
    v22 = v9 + v21 + v5;
    v23 = &v2[v22];
    if ( v22 > 0 && *(v23 - 1) == 44 )
      v23 = &v2[--v22];
    *v23 = 0;
    v24 = snprintf(v23, 0x200000 - v22, "}}");
    if ( v24 >= 0x200000 - v22 )
      v25 = 0x1FFFFF - v22;
    else
      v25 = v24;
    result = httpd_cgi_ret(a1, v2, v22 + v25, 8);
  }
  else
  {
    v27 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v28 = snprintf(v29, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
    if ( v28 >= 0x100 )
      v28 = 255;
    result = httpd_cgi_ret(a1, v29, v28, 4);
  }
  return result;
}
// 46AC90: variable 'v1' is possibly undefined
// 46AE80: variable 'v18' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046B078) --------------------------------------------------------
void __fastcall format_dns_url_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 2 )
    snprintf(a3, a4, "{\"src\":\"%s\",\"dst\":\"%s\"},", *a1, a1[1]);
}

//----- (0046B0F4) --------------------------------------------------------
int __fastcall sub_46B0F4(int a1)
{
  char *v1; // $v0
  char *v2; // $s0
  _BYTE *v3; // $s3
  int v4; // $s1
  const char **v5; // $s2
  void *v6; // $v0
  _DWORD *v7; // $s6
  int v8; // $a1
  void *v9; // $s1
  int v10; // $s5
  _DWORD *v11; // $s7
  int v12; // $s1
  int i; // $fp
  int v14; // $v0
  int v15; // $v0
  int v16; // $s4
  char *v17; // $a0
  int v18; // $v0
  int v19; // $s1
  int v20; // $s2
  char *v21; // $a0
  int v22; // $a2
  const char *v24; // $v0
  unsigned int v25; // $v0
  char v26[256]; // [sp+20h] [-108h] BYREF
  void *ptr; // [sp+120h] [-8h]

  _mem_malloc(0x200000, "dns_url_data", 2573);
  v2 = v1;
  if ( v1 )
  {
    strcpy(v1, "{\"code\":0,\"error\":\"\",\"data\":");
    qmemcpy(v1, "{\"code\":0,\"error", 16);
    v3 = v1 + 28;
    v4 = nvram_get("dnsUrl");
    v2[28] = 91;
    v2[29] = 0;
    if ( v4 )
    {
      v5 = (const char **)malloc(0x10u);
      v7 = malloc(0x4008u);
      v6 = malloc(0x200000u);
      ptr = v6;
      if ( v6 )
      {
        if ( v5 && (v8 = v4, v7) && (v9 = v6, strlcpy(v6, v8, 0x200000), v10 = split_string(v9, 60, v7, 4096), v10 > 0) )
        {
          v11 = v7;
          v12 = 1;
          for ( i = 0; i != v10; ++i )
          {
            v14 = split_string(*v11, 58, v5, 2);
            format_dns_url_data(v5, v14, &v3[v12], 2097124 - v12);
            v12 += v15;
            ++v11;
          }
          v16 = v12;
        }
        else
        {
          v16 = 1;
          v12 = 1;
        }
        free(ptr);
      }
      else
      {
        v16 = 1;
        v12 = 1;
      }
      if ( v5 )
        free(v5);
      if ( v7 )
        free(v7);
      if ( v12 <= 0 )
      {
        v17 = &v3[v16];
        goto LABEL_17;
      }
      v17 = &v3[v16];
      if ( v3[v16 - 1] != 44 )
      {
LABEL_17:
        *v17 = 0;
        v18 = snprintf(v17, 2097124 - v12, &byte_6445A0);
        if ( v18 >= 2097124 - v12 )
          v18 = 2097123 - v12;
        v19 = v12 + v18;
        v20 = v19 + 28;
        v21 = &v2[v19 + 28];
        if ( v19 + 28 > 0 && *(v21 - 1) == 44 )
        {
          v20 = v19 + 27;
          v21 = &v2[v19 + 27];
        }
        *v21 = 0;
        v22 = snprintf(v21, 0x200000 - v20, "}");
        if ( v22 >= 0x200000 - v20 )
          v22 = 0x1FFFFF - v20;
        return httpd_cgi_ret(a1, v2, v20 + v22, 8);
      }
    }
    else
    {
      v17 = v2 + 29;
      v12 = 1;
      if ( *v3 != 44 )
        goto LABEL_17;
    }
    v17 = &v3[--v12];
    goto LABEL_17;
  }
  v24 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v25 = snprintf(v26, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
  if ( v25 >= 0x100 )
    v25 = 255;
  return httpd_cgi_ret(a1, v26, v25, 4);
}
// 46B154: variable 'v1' is possibly undefined
// 46B2D4: variable 'v15' is possibly undefined
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046B4F4) --------------------------------------------------------
int __fastcall sub_46B4F4(int a1)
{
  char *v2; // $s5
  char *v3; // $s3
  int v4; // $v0
  char *v5; // $s0
  int v6; // $s6
  const char *v7; // $v0
  int v8; // $v0
  _DWORD *v10; // $s0
  int v11; // $a0
  unsigned int v12; // $v0
  int *v13; // $s0
  struct in_addr v14; // $a0
  char *v15; // $v0
  struct in_addr v16; // $a0
  char *v17; // $v0
  int v18; // $v0
  int v19; // $v0
  char *v20; // $v0
  char *v21; // $s2
  int v22; // $a0
  char *v23; // $v1
  const char *v24; // $v0
  int v25; // $t0
  int v26; // $a3
  int v27; // $a2
  int v28; // $a1
  unsigned int v29; // $v0
  int v30; // $a1
  int v31; // $a2
  int v32; // $a0
  int v33; // $a2
  char *v34; // $v0
  const char *v35; // $a2
  char s[128]; // [sp+20h] [-1A0h] BYREF
  char v37[100]; // [sp+A0h] [-120h] BYREF
  _WORD v38[50]; // [sp+104h] [-BCh] BYREF
  int v39[11]; // [sp+168h] [-58h] BYREF
  _DWORD v40[5]; // [sp+194h] [-2Ch] BYREF
  _DWORD v41[6]; // [sp+1A8h] [-18h] BYREF

  v2 = httpd_get_parm(a1, "name");
  v3 = httpd_get_parm(a1, (char *)&off_64712C);
  v5 = httpd_get_parm(a1, "opt");
  v4 = httpd_get_json_parm(a1, (int)"del_list");
  if ( !v5 )
    goto LABEL_6;
  v6 = v4;
  if ( strcmp(v5, (const char *)&off_646D8C) && strcmp(v5, "del") )
  {
    if ( strcmp(v5, (const char *)&off_64712C) )
    {
      if ( strcmp(v5, "delall") )
      {
LABEL_6:
        v7 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
        goto LABEL_7;
      }
      goto LABEL_48;
    }
    goto LABEL_23;
  }
  if ( !strcmp(v5, (const char *)&off_64712C) )
  {
LABEL_23:
    v41[0] = 0;
    v41[1] = 0;
    v41[2] = 0;
    v41[3] = 0;
    v41[4] = 0;
    v40[0] = 0;
    v40[1] = 0;
    v40[2] = 0;
    v40[3] = 0;
    v40[4] = 0;
    if ( !v3 )
    {
      v7 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_647128);
      goto LABEL_7;
    }
    jhl_parm_get("dnsEn", v38, 100);
    jhl_parm_get("lan_ifname", v37, 100);
    if ( strcmp((const char *)v38, "1") && strcmp((const char *)v38, "0") )
      v38[0] = 49;
    v13 = (int *)wys_get_dns();
    if ( *v13 <= 0 )
    {
      strcpy((char *)v40, "114.114.114.114");
      strcpy((char *)v41, "8.8.8.8");
    }
    else
    {
      v14.s_addr = v13[1];
      if ( *v13 == 1 )
      {
        v34 = inet_ntoa(v14);
        strcpy((char *)v41, v34);
        v16.s_addr = v13[1];
      }
      else
      {
        v15 = inet_ntoa(v14);
        strcpy((char *)v41, v15);
        v16.s_addr = v13[2];
      }
      v17 = inet_ntoa(v16);
      strcpy((char *)v40, v17);
    }
    sprintf(s, "%s,%s", (const char *)v41, (const char *)v40);
    v39[0] = (int)"wys";
    v39[1] = (int)"dns";
    v39[2] = (int)"set";
    v18 = jhl_nv_get_def("dnsEn");
    v39[4] = (int)v3;
    v39[3] = v18;
    v39[5] = jhl_nv_get_def("dnsMintm");
    v39[6] = jhl_nv_get_def("dnsMaxtm");
    v19 = jhl_nv_get_def("dnsShowct");
    v39[9] = (int)"240c::6666 240c::6644";
    v39[8] = (int)s;
    v39[7] = v19;
    v39[10] = 0;
    eval(v39, 0, 0, 0);
    jhl_parm_set("dnsDef", v3);
    goto LABEL_32;
  }
  if ( !strcmp(v5, "delall") )
  {
LABEL_48:
    if ( dns_acc_delall() >= 0 )
    {
      jhl_parm_set("dnsAcc", "");
      goto LABEL_32;
    }
    v7 = (const char *)_GET_LANG_TEXT(113, *(unsigned __int8 *)(a1 + 210102), v33);
LABEL_7:
    v8 = snprintf(s, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( (unsigned int)v8 >= 0x80 )
      v8 = 127;
    return httpd_cgi_ret(a1, s, v8, 4);
  }
  if ( !strcmp(v5, "del") && v6 && cJSON_IsArray(v6) )
  {
    v10 = *(_DWORD **)(v6 + 8);
    if ( v10 )
    {
      v11 = v10[4];
      if ( v11 )
      {
        while ( 1 )
        {
          v12 = dns_acc_del(v11);
          if ( v12 == -1 )
          {
            v7 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), &unk_647158);
            goto LABEL_7;
          }
          if ( v12 )
            break;
          v10 = (_DWORD *)*v10;
          if ( v10 )
          {
            v11 = v10[4];
            if ( v11 )
              continue;
          }
          goto LABEL_32;
        }
        if ( v12 >= 0x33 || (v35 = (const char *)jhlret_err_str[v12]) == 0 )
          v35 = "not find err!";
        v7 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), v35);
        goto LABEL_7;
      }
    }
  }
  else
  {
    if ( !v2 )
    {
      v7 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_6442E4);
      goto LABEL_7;
    }
    if ( !strcmp(v5, (const char *)&off_646D8C) )
    {
      v8 = check_rule_num_limit(a1, 32, (int)"dnsAcc", 60, s, 0x80u);
      if ( v8 > 0 )
        return httpd_cgi_ret(a1, s, v8, 4);
      v29 = dns_acc_add(v2);
      if ( v29 == -1 )
      {
        v30 = *(unsigned __int8 *)(a1 + 210102);
        v31 = (int)&unk_647158;
        v32 = 3;
        goto LABEL_51;
      }
      if ( v29 )
      {
        v30 = *(unsigned __int8 *)(a1 + 210102);
        if ( v29 >= 0x33 || (v31 = jhlret_err_str[v29]) == 0 )
          v31 = (int)"not find err!";
        v32 = 3;
        goto LABEL_51;
      }
    }
  }
LABEL_32:
  _mem_malloc(0x200000, "dns_acc_asp", 2719);
  v21 = v20;
  if ( !v20 )
  {
    v30 = *(unsigned __int8 *)(a1 + 210102);
    v31 = 0x200000;
    v32 = 4;
LABEL_51:
    v7 = (const char *)_GET_LANG_TEXT(v32, v30, v31);
    goto LABEL_7;
  }
  if ( dns_acc_get(v20, 0x200000u) )
    jhl_parm_set("dnsAcc", v21);
  else
    jhl_parm_set("dnsAcc", "");
  _mem_free(v21);
  jhl_parm_commit(v22);
  v23 = s;
  v24 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v25 = *(_DWORD *)v24;
    v26 = *((_DWORD *)v24 + 1);
    v27 = *((_DWORD *)v24 + 2);
    v28 = *((_DWORD *)v24 + 3);
    v24 += 16;
    *(_DWORD *)v23 = v25;
    *((_DWORD *)v23 + 1) = v26;
    *((_DWORD *)v23 + 2) = v27;
    *((_DWORD *)v23 + 3) = v28;
    v23 += 16;
  }
  while ( v24 != "}" );
  *(_WORD *)v23 = *(_WORD *)v24;
  return httpd_cgi_ret(a1, s, 33, 4);
}
// 46BA18: variable 'v20' is possibly undefined
// 46BA7C: variable 'v22' is possibly undefined
// 46BD10: variable 'v33' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81D4: using guessed type int __fastcall dns_acc_del(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8784: using guessed type int __fastcall dns_acc_add(_DWORD);
// 6A88B4: using guessed type int wys_get_dns(void);

//----- (0046BDD4) --------------------------------------------------------
int __fastcall sub_46BDD4(int a1)
{
  char *v2; // $s3
  char *v3; // $s4
  char *v4; // $s1
  int v5; // $v0
  char *v6; // $s6
  int v7; // $s5
  const char *v8; // $v0
  int v9; // $v0
  unsigned int v10; // $v0
  unsigned int v11; // $v0
  int v12; // $a1
  int v13; // $a2
  int v14; // $a0
  _DWORD *v15; // $s1
  int v16; // $a0
  int v17; // $a2
  void *v18; // $v0
  void *v19; // $s2
  int v20; // $a0
  char *v21; // $v1
  const char *v22; // $v0
  int v23; // $t0
  int v24; // $a3
  int v25; // $a2
  int v26; // $a1
  const char *v28; // $a2
  int v29; // $s1
  int v30; // $v0
  char s[128]; // [sp+20h] [-80h] BYREF

  v2 = httpd_get_parm(a1, (char *)&off_647174);
  v3 = httpd_get_parm(a1, "dst");
  v4 = httpd_get_parm(a1, "opt");
  v6 = httpd_get_parm(a1, "old_src");
  v5 = httpd_get_json_parm(a1, (int)"del_list");
  if ( !v4 )
    goto LABEL_6;
  v7 = v5;
  if ( !strcmp(v4, (const char *)&off_646D8C) )
  {
    if ( !strcmp(v4, "delall") )
      goto LABEL_36;
    if ( strcmp(v4, "del") )
      goto LABEL_11;
  }
  else
  {
    if ( strcmp(v4, "del") )
    {
      if ( strcmp(v4, "delall") )
      {
        if ( strcmp(v4, (const char *)&off_648DDC) )
        {
LABEL_6:
          v8 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
          goto LABEL_7;
        }
        goto LABEL_11;
      }
LABEL_36:
      if ( dns_url_delall() < 0 )
      {
        v29 = *(unsigned __int8 *)(a1 + 210102);
        v30 = _GET_LANG_TEXT(113, v29, v17);
        v8 = (const char *)_GET_LANG_TEXT(12, v29, v30);
        goto LABEL_7;
      }
      jhl_parm_set("dnsUrl", "");
      goto LABEL_38;
    }
    if ( !strcmp(v4, "delall") )
      goto LABEL_36;
  }
  if ( v7 && cJSON_IsArray(v7) )
  {
    v15 = *(_DWORD **)(v7 + 8);
    if ( !v15 )
      goto LABEL_38;
    v16 = v15[4];
    if ( !v16 )
      goto LABEL_38;
    while ( 1 )
    {
      v10 = dns_url_del(v16);
      if ( v10 == -1 )
        goto LABEL_35;
      if ( v10 )
        goto LABEL_48;
      v15 = (_DWORD *)*v15;
      if ( v15 )
      {
        v16 = v15[4];
        if ( v16 )
          continue;
      }
      goto LABEL_38;
    }
  }
LABEL_11:
  if ( !v2 )
  {
    v8 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_647170);
    goto LABEL_7;
  }
  if ( strcmp(v4, (const char *)&off_648DDC) )
  {
    if ( strcmp(v4, (const char *)&off_646D8C) )
      goto LABEL_38;
    goto LABEL_45;
  }
  if ( v6 )
    v10 = dns_url_del(v6);
  else
    v10 = dns_url_del(v2);
  if ( v10 == -1 )
  {
LABEL_35:
    v8 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), &unk_647158);
    goto LABEL_7;
  }
  if ( v10 )
  {
LABEL_48:
    if ( v10 >= 0x33 || (v28 = (const char *)jhlret_err_str[v10]) == 0 )
      v28 = "not find err!";
    v8 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), v28);
    goto LABEL_7;
  }
  if ( strcmp(v4, (const char *)&off_646D8C) )
  {
    if ( strcmp(v4, (const char *)&off_648DDC) )
      goto LABEL_38;
    if ( v3 )
      goto LABEL_20;
    goto LABEL_62;
  }
LABEL_45:
  if ( !v3 )
  {
LABEL_62:
    v8 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not dst");
LABEL_7:
    v9 = snprintf(s, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
    if ( (unsigned int)v9 >= 0x80 )
      v9 = 127;
    return httpd_cgi_ret(a1, s, v9, 4);
  }
  v9 = check_rule_num_limit(a1, 31, (int)"dnsUrl", 60, s, 0x80u);
  if ( v9 > 0 )
    return httpd_cgi_ret(a1, s, v9, 4);
LABEL_20:
  v11 = dns_url_add(v2, v3, 0);
  if ( v11 == -1 )
  {
    v12 = *(unsigned __int8 *)(a1 + 210102);
    v13 = (int)&unk_647158;
    v14 = 3;
    goto LABEL_56;
  }
  if ( v11 )
  {
    v12 = *(unsigned __int8 *)(a1 + 210102);
    if ( v11 >= 0x33 || (v13 = jhlret_err_str[v11]) == 0 )
      v13 = (int)"not find err!";
    v14 = 3;
    goto LABEL_56;
  }
LABEL_38:
  _mem_malloc(0x200000, "dns_url_asp", 2860);
  v19 = v18;
  if ( !v18 )
  {
    v12 = *(unsigned __int8 *)(a1 + 210102);
    v13 = 0x200000;
    v14 = 4;
LABEL_56:
    v8 = (const char *)_GET_LANG_TEXT(v14, v12, v13);
    goto LABEL_7;
  }
  if ( dns_url_get(v18, 0x200000) )
    jhl_parm_set("dnsUrl", v19);
  else
    jhl_parm_set("dnsUrl", "");
  jhl_parm_commit(v20);
  _mem_free(v19);
  dns_redirect_write_hosts();
  v21 = s;
  v22 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v23 = *(_DWORD *)v22;
    v24 = *((_DWORD *)v22 + 1);
    v25 = *((_DWORD *)v22 + 2);
    v26 = *((_DWORD *)v22 + 3);
    v22 += 16;
    *(_DWORD *)v21 = v23;
    *((_DWORD *)v21 + 1) = v24;
    *((_DWORD *)v21 + 2) = v25;
    *((_DWORD *)v21 + 3) = v26;
    v21 += 16;
  }
  while ( v22 != "}" );
  *(_WORD *)v21 = *(_WORD *)v22;
  return httpd_cgi_ret(a1, s, 33, 4);
}
// 46C1CC: variable 'v18' is possibly undefined
// 46C214: variable 'v20' is possibly undefined
// 46C3B4: variable 'v17' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 647174: using guessed type void *off_647174;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8548: using guessed type int __fastcall dns_url_add(_DWORD, _DWORD, _DWORD);
// 6A8634: using guessed type int dns_redirect_write_hosts(void);
// 6A8840: using guessed type int __fastcall dns_url_get(_DWORD, _DWORD);
// 6A8884: using guessed type int __fastcall dns_url_del(_DWORD);

//----- (0046C4EC) --------------------------------------------------------
int __fastcall sub_46C4EC(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "acc_txt", 2909);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("accAll2");
    if ( !v3 )
      v3 = " ";
    v5 = snprintf(v4, 0x200000, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    if ( v5 >= 0x200000 )
      v5 = 0x1FFFFF;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 46C52C: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0046C654) --------------------------------------------------------
int __fastcall sub_46C654(int a1)
{
  int v1; // $s1
  int v2; // $s2
  char *v3; // $v0
  char *v4; // $s0
  char *v5; // $s1
  char *v6; // $v0
  int v7; // $a1
  int v8; // $v1
  _BOOL4 v9; // $a2
  char *v10; // $t0
  char *v11; // $s3
  char *v12; // $s5
  int v13; // $s4
  int v14; // $s0
  const char **v15; // $s7
  int v16; // $fp
  int v17; // $s6
  char *v18; // $s1
  char *v19; // $s1
  int v20; // $a0
  int v21; // $a2
  const char *v22; // $v0
  unsigned int v23; // $v0
  unsigned int v24; // $a2
  const char *v26; // $v0
  char v27[215040]; // [sp+20h] [-36618h] BYREF
  char v28[7680]; // [sp+34820h] [-1E18h] BYREF
  int v29; // [sp+36620h] [-18h]
  char *v30; // [sp+36624h] [-14h]
  char *v31; // [sp+36628h] [-10h]
  char **v32; // [sp+3662Ch] [-Ch]
  char *v33; // [sp+36630h] [-8h]
  char *v34; // [sp+36634h] [-4h]

  v1 = a1 + 196608;
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  v4 = v3;
  if ( v3 && (v5 = find_file_end(a1, v3, *(_DWORD *)(v1 + 8956) + v2 - (_DWORD)v3)) != 0 )
  {
    v34 = "a";
    v31 = v27;
    *v5 = 0;
    jhl_parm_get("accAll2", v27, 102400);
    if ( v5 - v4 <= 0 )
    {
      v7 = 0;
    }
    else
    {
      v6 = v4;
      v7 = 0;
      do
      {
        v8 = *v6++;
        v9 = v7 + 1 < 102399;
        if ( v8 != 13 && v8 != 10 )
        {
          v27[v7++ + 102400] = v8;
          if ( !v9 )
            break;
        }
      }
      while ( v5 != v6 );
    }
    v10 = v31;
    v11 = v31 + 220160;
    v31[v7 + 102400] = 0;
    v29 = split_string(v10 + 102400, 60, v11, 512);
    if ( v29 > 0 )
    {
      v33 = "a";
      v30 = v31 + 215040;
      v12 = v31 + 222208;
      v13 = 0;
      v32 = &off_646D8C;
      do
      {
        while ( 1 )
        {
          strlcpy(v30, *(_DWORD *)v11, 5120);
          v14 = split_string(*(_DWORD *)v11, 124, v12, 128);
          if ( v14 >= 10 && !nvparm_find_str(v31, 60, 15, *((_DWORD *)v31 + 55552), 124, 0) )
            break;
          ++v13;
          v11 += 4;
          if ( v29 == v13 )
            goto LABEL_17;
        }
        set_rule_to_kernel(v33 + 19092, v32, v12);
        v15 = (const char **)v12;
        v16 = 0;
        v17 = 0;
        v18 = v31 + 204800;
        do
        {
          ++v17;
          v16 += sprintf(&v18[v16], "%s|", *v15++);
        }
        while ( v14 != v17 );
        *(_WORD *)&v18[v16 - 1] = 60;
        strcat(v31, v18);
        ++v13;
        v11 += 4;
      }
      while ( v29 != v13 );
    }
LABEL_17:
    v19 = v31;
    jhl_parm_set(v34 + 29056, v31);
    jhl_parm_commit(v20);
    v22 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v21);
    v23 = snprintf(v19 + 215040, 5120, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v22);
    if ( v23 < 0x1400 )
      goto LABEL_18;
  }
  else
  {
    v26 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
    v31 = v27;
    v24 = snprintf(v28, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v26);
    if ( v24 < 0x1400 )
      return httpd_cgi_ret(a1, v31 + 215040, v24, 4);
  }
  v23 = 5119;
LABEL_18:
  v24 = v23;
  return httpd_cgi_ret(a1, v31 + 215040, v24, 4);
}
// 46C6D4: variable 'v3' is possibly undefined
// 46CA40: variable 'v20' is possibly undefined
// 46CA70: variable 'v21' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A832C: using guessed type int __fastcall set_rule_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046CBB8) --------------------------------------------------------
void __fastcall format_acc_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 11 )
    snprintf(
      a3,
      a4,
      "{\"name\":\"%s\",\"en\":%s,\"ips\":\"%s\",\"time\":\"%s\",\"log\":\"%s\",\"rpri\":\"%s\",\"act\":\"%s\",\"thd_type"
      "\":\"%s\",\"thd\":\"%s\",\"ipport\":\"%s\",\"ruleips\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7],
      a1[8],
      a1[9],
      a1[10]);
}

//----- (0046CC80) --------------------------------------------------------
int __fastcall sub_46CC80(int a1)
{
  char *v1; // $v0
  const char *v2; // $v0
  char *v3; // $fp
  int v4; // $v0
  int v5; // $s3
  int v6; // $s1
  char *v7; // $s4
  int v8; // $s5
  int v9; // $s0
  const char **v10; // $s2
  void *v11; // $v0
  _DWORD *v12; // $s6
  int v13; // $a1
  void *v14; // $s5
  int v15; // $s5
  int i; // $s7
  int v17; // $v0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $s1
  int v21; // $v0
  int v22; // $s3
  int v23; // $v0
  int v24; // $a2
  int result; // $v0
  const char *v26; // $v0
  unsigned int v27; // $v0
  char v28[128]; // [sp+20h] [-88h] BYREF
  _DWORD *v29; // [sp+A0h] [-8h]
  void *ptr; // [sp+A4h] [-4h]

  _mem_malloc(0x200000, "acc_data", 3087);
  if ( v1 )
  {
    v3 = v1;
    v2 = (const char *)nvram_get("accAct");
    if ( !v2 || !*v2 )
      v2 = (const char *)&off_63F984;
    strcpy(v3, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v3, "{\"code\":0,\"error", 16);
    v4 = snprintf(v3 + 29, 2097123, "\"def\":\"%s\",\"sys_type_flag\":%d,\"all\":", v2, 1);
    if ( v4 >= 2097123 )
      v4 = 2097122;
    v5 = v4 + 29;
    v6 = 0x200000 - (v4 + 29);
    v7 = &v3[v4 + 29];
    v8 = nvram_get("accAll2");
    v9 = snprintf(&v3[v5], 0x200000 - v5, (char *)&word_642A04);
    if ( v9 >= 0x200000 - v5 )
      v9 = 0x1FFFFF - v5;
    if ( v8 )
    {
      v10 = (const char **)malloc(0x34u);
      v29 = malloc(0x4008u);
      v12 = v29;
      v11 = malloc(0x200000u);
      ptr = v11;
      if ( v11 )
      {
        if ( v10 )
        {
          v13 = v8;
          if ( v29 )
          {
            v14 = v11;
            strlcpy(v11, v13, 0x200000);
            v15 = split_string(v14, 60, v29, 4096);
            if ( v15 > 0 )
            {
              for ( i = 0; i != v15; ++i )
              {
                v17 = split_string(*v12, 124, v10, 11);
                format_acc_data(v10, v17, &v7[v9], v6 - v9);
                v9 += v18;
                ++v12;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v10 )
        free(v10);
      if ( v29 )
        free(v29);
    }
    v19 = &v7[v9];
    if ( v9 > 0 && *(v19 - 1) == 44 )
      v19 = &v7[--v9];
    v20 = v6 - v9;
    *v19 = 0;
    v21 = snprintf(v19, v20, &byte_6445A0);
    if ( v21 >= v20 )
      v21 = v20 - 1;
    v22 = v9 + v21 + v5;
    v23 = snprintf(&v3[v22], 0x200000 - v22, "}}");
    if ( v23 >= 0x200000 - v22 )
      v24 = 0x1FFFFF - v22;
    else
      v24 = v23;
    result = httpd_cgi_ret(a1, v3, v24 + v22, 8);
  }
  else
  {
    v26 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v27 = snprintf(v28, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v26);
    if ( v27 >= 0x80 )
      v27 = 127;
    result = httpd_cgi_ret(a1, v28, v27, 4);
  }
  return result;
}
// 46CCDC: variable 'v1' is possibly undefined
// 46CF00: variable 'v18' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0046D0D0) --------------------------------------------------------
int __fastcall sub_46D0D0(int a1)
{
  char *v2; // $s4
  char *v3; // $s5
  char *v4; // $s6
  char *v5; // $s7
  char *v6; // $fp
  char *v7; // $s2
  int v8; // $a1
  const char *v9; // $a2
  int v10; // $a0
  int v11; // $v0
  char *v12; // $v1
  int v13; // $s3
  int v14; // $v0
  int v15; // $a0
  const char *v16; // $v0
  char *v17; // $v1
  int v18; // $t0
  int v19; // $a3
  int v20; // $a2
  int v21; // $a1
  unsigned int v22; // $a2
  char *v24; // $v0
  const char *v25; // $s3
  int v26; // $a0
  const char *v27; // $v1
  char *v28; // $v0
  int v29; // $t0
  int v30; // $a3
  int v31; // $a2
  int v32; // $a1
  const char *v33; // $v0
  int v34; // $v0
  int v35[25600]; // [sp+40h] [-32060h] BYREF
  char v36[102400]; // [sp+19040h] [-19060h] BYREF
  const char *v37; // [sp+32040h] [-60h] BYREF
  char *v38; // [sp+32044h] [-5Ch]
  char *v39; // [sp+32048h] [-58h]
  char *v40; // [sp+3204Ch] [-54h]
  char *v41; // [sp+32050h] [-50h]
  char *v42; // [sp+32054h] [-4Ch]
  char *v43; // [sp+32058h] [-48h]
  char *v44; // [sp+3205Ch] [-44h]
  char *v45; // [sp+32060h] [-40h]
  char *v46; // [sp+32064h] [-3Ch]
  char *v47; // [sp+32068h] [-38h]
  int v48; // [sp+3206Ch] [-34h]
  int v49; // [sp+32070h] [-30h]
  char *v50; // [sp+32078h] [-28h]
  char *v51; // [sp+3207Ch] [-24h]
  char *v52; // [sp+32080h] [-20h]
  char *v53; // [sp+32084h] [-1Ch]
  char *v54; // [sp+32088h] [-18h]
  char *v55; // [sp+3208Ch] [-14h]
  char *v56; // [sp+32090h] [-10h]
  int v57; // [sp+32094h] [-Ch]
  char *v58; // [sp+32098h] [-8h]

  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v51 = httpd_get_parm(a1, "name");
  v56 = httpd_get_parm(a1, "old_name");
  v50 = httpd_get_parm(a1, "en");
  v52 = httpd_get_parm(a1, "ips");
  v53 = httpd_get_parm(a1, "time");
  v54 = httpd_get_parm(a1, (char *)&off_64E034);
  v55 = httpd_get_parm(a1, "rpri");
  v2 = httpd_get_parm(a1, "act");
  v3 = httpd_get_parm(a1, "thd_type");
  v4 = httpd_get_parm(a1, (char *)&off_645A5C);
  v5 = httpd_get_parm(a1, "ipport");
  v6 = httpd_get_parm(a1, "ruleips");
  v7 = httpd_get_parm(a1, "opt");
  v57 = httpd_get_json_parm(a1, (int)"del_list");
  if ( !v7 )
    goto LABEL_7;
  if ( strcmp(v7, (const char *)&off_646D8C) && strcmp(v7, (const char *)&off_648DDC) && strcmp(v7, "del") )
  {
    v50 = "a";
    if ( strcmp(v7, (const char *)&off_64712C) )
    {
      if ( strcmp(v7, "delall") )
      {
LABEL_7:
        v8 = *(unsigned __int8 *)(a1 + 210102);
        v9 = "not opt";
        v10 = 12;
        goto LABEL_75;
      }
      goto LABEL_49;
    }
    v14 = strcmp(v7, "delall");
    v12 = v50;
    if ( !v14 )
    {
LABEL_49:
      if ( set_rule_to_kernel(&off_644A94, v7, &v37) )
        goto LABEL_52;
      strlcpy(v35, "", 102400);
LABEL_51:
      jhl_parm_set("accAll2", v35);
      jhl_parm_commit(v15);
LABEL_52:
      v16 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      v17 = v36;
      do
      {
        v18 = *(_DWORD *)v16;
        v19 = *((_DWORD *)v16 + 1);
        v20 = *((_DWORD *)v16 + 2);
        v21 = *((_DWORD *)v16 + 3);
        v16 += 16;
        *(_DWORD *)v17 = v18;
        *((_DWORD *)v17 + 1) = v19;
        *((_DWORD *)v17 + 2) = v20;
        *((_DWORD *)v17 + 3) = v21;
        v17 += 16;
      }
      while ( v16 != "}" );
      v22 = 33;
      *(_WORD *)v17 = *(_WORD *)v16;
      return httpd_cgi_ret(a1, v36, v22, 4);
    }
    goto LABEL_56;
  }
  if ( !strcmp(v7, "delall") )
    goto LABEL_49;
  v58 = "a";
  v11 = strcmp(v7, (const char *)&off_64712C);
  v12 = "a";
  if ( v11 )
  {
    if ( !strcmp(v7, "del") && v57 && cJSON_IsArray(v57) )
    {
      v13 = *(_DWORD *)(v57 + 8);
      if ( !v13 )
        goto LABEL_52;
      if ( !*(_DWORD *)(v13 + 16) )
        goto LABEL_52;
      v37 = *(const char **)(v13 + 16);
      if ( set_rule_to_kernel(&off_644A94, v7, &v37) )
        goto LABEL_52;
      jhl_parm_get("accAll2", v36, 102400);
      if ( !nvparm_del_str(v36, 60, 13, *(_DWORD *)(v13 + 16), 124, 0, v35) )
        goto LABEL_52;
      jhl_parm_set("accAll2", v35);
      goto LABEL_51;
    }
    if ( !v51 )
    {
      v8 = *(unsigned __int8 *)(a1 + 210102);
      v9 = "error name";
      v10 = 12;
      goto LABEL_75;
    }
    v37 = v51;
    if ( v56 )
    {
      if ( strcmp(v7, (const char *)&off_648DDC) )
      {
        if ( strcmp(v7, (const char *)&off_646D8C) )
          goto LABEL_52;
        goto LABEL_22;
      }
      v35[0] = (int)"acc_del.sh";
      v35[1] = (int)v56;
      v35[2] = 0;
      eval(v35, 0, 0, 0);
    }
    if ( strcmp(v7, (const char *)&off_646D8C) && strcmp(v7, (const char *)&off_648DDC) )
      goto LABEL_52;
LABEL_22:
    if ( !v50 || !*v50 )
      v50 = "1";
    v38 = v50;
    if ( !v52 || !*v52 )
      v52 = "";
    v39 = v52;
    if ( !v53 || !*v53 )
      v53 = "OFF";
    v40 = v53;
    if ( !v54 || !*v54 )
      v54 = "0";
    v41 = v54;
    if ( !v55 || !*v55 )
      v55 = "1";
    v42 = v55;
    if ( !v2 || !*v2 )
      v2 = "1";
    v43 = v2;
    if ( !v3 || !*v3 )
      v3 = "0";
    v44 = v3;
    if ( !v4 || !*v4 )
      v4 = "";
    v45 = v4;
    if ( !v5 || !*v5 )
      v5 = "";
    v46 = v5;
    if ( !v6 || !*v6 )
      v6 = "0";
    v47 = v6;
    if ( !set_rule_to_kernel(&off_644A94, v7, &v37) )
    {
      if ( !strcmp(v7, (const char *)&off_648DDC)
        && ((jhl_parm_get("accAll2", v36, 102400), !v56) ? (v34 = nvparm_del_str(v36, 60, 13, v51, 124, 0, v35)) : (v34 = nvparm_del_str(v36, 60, 13, v56, 124, 0, v35)),
            v34) )
      {
        sprintf(v36, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<", v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);
        strcat((char *)v35, v36);
      }
      else
      {
        sprintf(v36, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<", v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);
        jhl_parm_get("accAll2", v35, 102400);
        if ( !strcmp((const char *)v35, " ") )
          LOBYTE(v35[0]) = 0;
        strcat((char *)v35, v36);
      }
      goto LABEL_51;
    }
    v8 = *(unsigned __int8 *)(a1 + 210102);
    v9 = v7;
    v10 = 3;
LABEL_75:
    v33 = (const char *)_GET_LANG_TEXT(v10, v8, v9);
    v22 = snprintf(v36, 102400, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v33);
    if ( v22 >= 0x19000 )
      v22 = 102399;
    return httpd_cgi_ret(a1, v36, v22, 4);
  }
LABEL_56:
  v24 = httpd_get_parm(a1, v12 + 28972);
  v25 = v24;
  if ( !v24 || strcmp(v24, (const char *)&off_63F984) && strcmp(v25, "accept") && strcmp(v25, "drop") )
  {
    v8 = *(unsigned __int8 *)(a1 + 210102);
    v9 = "error def";
    v10 = 12;
    goto LABEL_75;
  }
  v37 = v25;
  if ( !set_rule_to_kernel(&off_644A94, v7, &v37) )
  {
    jhl_parm_set("accAct", v25);
    jhl_parm_commit(v26);
  }
  v27 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v28 = v36;
  do
  {
    v29 = *(_DWORD *)v27;
    v30 = *((_DWORD *)v27 + 1);
    v31 = *((_DWORD *)v27 + 2);
    v32 = *((_DWORD *)v27 + 3);
    v27 += 16;
    *(_DWORD *)v28 = v29;
    *((_DWORD *)v28 + 1) = v30;
    *((_DWORD *)v28 + 2) = v31;
    *((_DWORD *)v28 + 3) = v32;
    v28 += 16;
  }
  while ( v27 != "}" );
  *(_WORD *)v28 = *(_WORD *)v27;
  v22 = 33;
  return httpd_cgi_ret(a1, v36, v22, 4);
}
// 46DA1C: variable 'v15' is possibly undefined
// 46DBA8: variable 'v26' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 644A94: using guessed type void *off_644A94;
// 645A5C: using guessed type char *off_645A5C;
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 64E034: using guessed type int (**off_64E034)();
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A832C: using guessed type int __fastcall set_rule_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (0046DF20) --------------------------------------------------------
int __fastcall sub_46DF20(int a1)
{
  char v2[516]; // [sp+18h] [-204h] BYREF

  strcpy(v2, "{\"ret\":0,\"msg\":\"ok\"}");
  return httpd_cgi_ret(a1, v2, 20, 4);
}

//----- (0046DF94) --------------------------------------------------------
int __fastcall sub_46DF94(int a1)
{
  const char *v2; // $s0
  const char *v3; // $s1
  const char *v4; // $s4
  const char *v5; // $s5
  const char *v6; // $s6
  const char *v7; // $s7
  const char *v8; // $fp
  const char *v9; // $v0
  unsigned int v10; // $v0
  int v11; // $s0
  unsigned int v12; // $v0
  char v14[1024]; // [sp+48h] [-410h] BYREF
  const char *v15; // [sp+448h] [-10h]
  const char *v16; // [sp+44Ch] [-Ch]
  const char *v17; // [sp+450h] [-8h]
  const char *v18; // [sp+454h] [-4h]

  memset(v14, 0, sizeof(v14));
  strcpy(v14, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("wtQR_SrvEnable");
  v3 = (const char *)jhl_nv_get_def("wtQR_AdsEnable");
  v4 = (const char *)jhl_nv_get_def("wtQR_ShareEnable");
  v5 = (const char *)jhl_nv_get_def("wtQR_SlaveMode");
  v6 = (const char *)jhl_nv_get_def("SSID1");
  v7 = (const char *)jhl_nv_get_def("wtQR_JumpUrl");
  v8 = (const char *)jhl_nv_get_def("wtQR_SuperCode");
  v18 = (const char *)jhl_nv_get_def("wtQR_ScanCnt");
  v17 = (const char *)jhl_nv_get_def("wtQR_CltNmae");
  v16 = (const char *)jhl_nv_get_def("wtQR_Tips");
  v15 = (const char *)jhl_nv_get_def("wtQR_Support");
  v9 = (const char *)jhl_nv_get_def("wtQR_WanLanInfor");
  v10 = snprintf(
          &v14[29],
          995,
          "\"wtqr_ServerEnable\":\"%s\",\"wtqr_AdsEnable\":\"%s\",\"wtqr_ShareEnable\":\"%s\",\"wtqr_SlaveMode\":\"%s\",\""
          "wtqr_Ssid\":\"%s\",\"wtqr_JumpUrl\":\"%s\",\"wtqr_SuperCode\":\"%s\",\"wtqr_ScanCnt\":\"%s\",\"wtqr_CltNmae\":"
          "\"%s\",\"wtqr_Tips\":\"%s\",\"wtqr_Support\":\"%s\",\"wtqr_WanLanInfor\":\"%s\"",
          v2,
          v3,
          v4,
          v5,
          v6,
          v7,
          v8,
          v18,
          v17,
          v16,
          v15,
          v9);
  v11 = v10 + 29;
  if ( v10 >= 0x3E3 )
    v11 = 1023;
  v12 = snprintf(&v14[v11], 1024 - v11, "}}");
  if ( v12 >= 1024 - v11 )
    v12 = 1023 - v11;
  return httpd_cgi_ret(a1, v14, v12 + v11, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0046E274) --------------------------------------------------------
int __fastcall sub_46E274(int a1)
{
  const char *v2; // $v0
  unsigned int v3; // $v0
  int v4; // $s0
  unsigned int v5; // $v0
  char v7[1028]; // [sp+18h] [-404h] BYREF

  strcpy(v7, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("user_list_enable");
  v3 = snprintf(&v7[29], 995, "\"en\":\"%s\"", v2);
  v4 = v3 + 29;
  if ( v3 >= 0x3E3 )
    v4 = 1023;
  v5 = snprintf(&v7[v4], 1024 - v4, "}}");
  if ( v5 >= 1024 - v4 )
    v5 = 1023 - v4;
  return httpd_cgi_ret(a1, v7, v5 + v4, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0046E3A0) --------------------------------------------------------
int __fastcall sub_46E3A0(int a1)
{
  const char *v2; // $s0
  const char *v3; // $v0
  unsigned int v4; // $v0
  int v5; // $s0
  unsigned int v6; // $v0
  char v8[1028]; // [sp+20h] [-404h] BYREF

  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("billing_rid");
  v3 = (const char *)nvram_get("agent_host");
  if ( !v3 )
    v3 = "";
  v4 = snprintf(&v8[29], 995, "\"ret\":0,\"rid\":\"%s\",\"srv\":\"%s\"", v2, v3);
  v5 = v4 + 29;
  if ( v4 >= 0x3E3 )
    v5 = 1023;
  v6 = snprintf(&v8[v5], 1024 - v5, "}}");
  if ( v6 >= 1024 - v5 )
    v6 = 1023 - v5;
  return httpd_cgi_ret(a1, v8, v6 + v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0046E500) --------------------------------------------------------
int __fastcall sub_46E500(int a1)
{
  int v1; // $v0
  char *v2; // $s2
  const char *v3; // $s0
  const char *v4; // $s1
  const char *v5; // $s3
  const char *v6; // $s4
  const char *v7; // $s5
  const char *v8; // $s6
  const char *v9; // $s7
  const char *v10; // $a1
  const char *v11; // $v0
  int v12; // $s0
  const char *v13; // $s1
  const char *v14; // $s3
  const char *v15; // $s4
  const char *v16; // $s5
  const char *v17; // $s6
  const char *v18; // $s7
  const char *v19; // $v0
  int v20; // $s0
  int v21; // $v0
  int v22; // $a2
  int result; // $v0
  const char *v24; // $v0
  unsigned int v25; // $v0
  char v26[256]; // [sp+78h] [-140h] BYREF
  const char *v27; // [sp+178h] [-40h]
  const char *v28; // [sp+17Ch] [-3Ch]
  const char *v29; // [sp+180h] [-38h]
  const char *v30; // [sp+184h] [-34h]
  const char *v31; // [sp+188h] [-30h]
  const char *v32; // [sp+18Ch] [-2Ch]
  const char *v33; // [sp+190h] [-28h]
  const char *v34; // [sp+194h] [-24h]
  const char *v35; // [sp+198h] [-20h]
  const char *v36; // [sp+19Ch] [-1Ch]
  const char *v37; // [sp+1A0h] [-18h]
  const char *v38; // [sp+1A4h] [-14h]
  const char *v39; // [sp+1A8h] [-10h]
  const char *v40; // [sp+1ACh] [-Ch]
  const char *v41; // [sp+1B0h] [-8h]

  _mem_malloc(10240, "wtclient_data", 3236);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    v27 = (const char *)jhl_nv_get_def("wt_base_enable");
    v28 = (const char *)jhl_nv_get_def("wt_base_addr");
    v29 = (const char *)jhl_nv_get_def("wt_base_port");
    v3 = (const char *)nvram_get("wt_state");
    if ( !v3 )
      v3 = "";
    v30 = (const char *)jhl_nv_get_def("wt_dev_routerid");
    v31 = (const char *)jhl_nv_get_def("wt_dev_addr");
    v32 = (const char *)jhl_nv_get_def("wt_dev_cont");
    v33 = (const char *)jhl_nv_get_def("wt_dev_tel");
    v34 = (const char *)jhl_nv_get_def("wt_dev_name");
    v35 = (const char *)jhl_nv_get_def("wt_dev_dinate");
    v36 = (const char *)jhl_nv_get_def("wt_agent_id");
    v37 = (const char *)jhl_nv_get_def("wt_dev_pwd");
    v38 = (const char *)jhl_nv_get_def("wt_route_type");
    v39 = (const char *)jhl_nv_get_def("wt_dev_replace_id");
    v40 = (const char *)jhl_nv_get_def("wt_dev_randid");
    v4 = (const char *)nvram_get("ac_mng_state");
    if ( !v4 )
      v4 = "";
    v5 = (const char *)jhl_nv_get_def("wt_dev_type");
    v6 = (const char *)jhl_nv_get_def("wt_dev_offlinenotauth");
    v7 = (const char *)jhl_nv_get_def("wt_third_agent_id");
    v8 = (const char *)jhl_nv_get_def("wt_nofeel_auth_id");
    v9 = (const char *)jhl_nv_get_def("rzgl_pc_no_auth");
    v10 = (const char *)nvram_get("wt_dev_server_fbs");
    if ( !v10 )
      v10 = "0";
    v41 = v10;
    v11 = (const char *)jhl_nv_get_def("wtQR_SrvEnable");
    v12 = sprintf(
            v2 + 29,
            "\"en\":\"%s\",\"addr\":\"%s\",\"port\":\"%s\",\"state\":\"%s\",\"route_id\":\"%s\",\"router_addr\":\"%s\",\""
            "router_cont\":\"%s\",\"router_tel\":\"%s\",\"router_name\":\"%s\",\"router_dinate\":\"%s\",\"router_agents\""
            ":\"%s\",\"router_pwd\":\"%s\", \"route_type\":\"%s\",\"route_replace_id\":\"%s\", \"wt_dev_randid\":\"%s\",\""
            "ac_mng_state\":\"%s\",\"wt_dev_type\":\"%s\", \"wt_dev_offlinenotauth\":\"%s\",\"new_router_agents\":\"%s\","
            "\"wt_nofeel_auth_id\":\"%s\",\"rzgl_pc_no_auth\":\"%s\", \"fbs_en\":\"%s\",\"lan_state\":\"%d\",\"wtqr_Serve"
            "rEnable\":\"%s\",\"bridge\":\"%d\"",
            v27,
            v28,
            v29,
            v3,
            v30,
            v31,
            v32,
            v33,
            v34,
            v35,
            v36,
            v37,
            v38,
            v39,
            v40,
            v4,
            v5,
            v6,
            v7,
            v8,
            v9,
            v41,
            1,
            v11,
            0)
        + 29;
    v13 = (const char *)nvram_get("wt_server_mode");
    if ( !v13 )
      v13 = "2";
    v14 = (const char *)jhl_nv_get_def("ac_mng_srv_host");
    v15 = (const char *)jhl_nv_get_def("ac_mng_srv_port");
    v16 = (const char *)jhl_nv_get_def("wt_base_addr_custom");
    v17 = (const char *)jhl_nv_get_def("wt_base_port_custom");
    v18 = (const char *)jhl_nv_get_def("ac_mng_srv_host_custom");
    v19 = (const char *)jhl_nv_get_def("ac_mng_srv_port_custom");
    v20 = v12
        + sprintf(
            &v2[v12],
            ",\"mode_show\":\"012\",\"server_mode\":\"%s\",\"ac_mng_srv_host\":\"%s\",\"ac_mng_srv_port\":\"%s\",\"wt_bas"
            "e_addr_custom\":\"%s\",\"wt_base_port_custom\":\"%s\",\"ac_mng_srv_host_custom\":\"%s\",\"ac_mng_srv_port_custom\":\"%s\"",
            v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            v19);
    v21 = snprintf(&v2[v20], 10240 - v20, "}}");
    if ( v21 >= 10240 - v20 )
      v22 = 10239 - v20;
    else
      v22 = v21;
    result = httpd_cgi_ret(a1, v2, v22 + v20, 8);
  }
  else
  {
    v24 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v25 = snprintf(v26, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
    if ( v25 >= 0x100 )
      v25 = 255;
    result = httpd_cgi_ret(a1, v26, v25, 4);
  }
  return result;
}
// 46E560: variable 'v1' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0046EB48) --------------------------------------------------------
int __fastcall sub_46EB48(int a1)
{
  int v2; // $v0
  char *v3; // $s3
  const char *v4; // $fp
  const char *v5; // $s0
  const char *v6; // $s4
  const char *v7; // $s5
  const char *v8; // $s6
  const char *v9; // $s1
  const char *v10; // $a1
  const char *v11; // $v0
  int v12; // $s1
  int v13; // $v0
  int v14; // $a2
  int result; // $v0
  const char *v16; // $v0
  unsigned int v17; // $v0
  char v18[256]; // [sp+60h] [-138h] BYREF
  const char *v19; // [sp+160h] [-38h]
  const char *v20; // [sp+164h] [-34h]
  const char *v21; // [sp+168h] [-30h]
  const char *v22; // [sp+16Ch] [-2Ch]
  const char *v23; // [sp+170h] [-28h]
  const char *v24; // [sp+174h] [-24h]
  const char *v25; // [sp+178h] [-20h]
  const char *v26; // [sp+17Ch] [-1Ch]
  const char *v27; // [sp+180h] [-18h]
  const char *v28; // [sp+184h] [-14h]
  const char *v29; // [sp+188h] [-10h]
  const char *v30; // [sp+18Ch] [-Ch]
  const char *v31; // [sp+190h] [-8h]

  _mem_malloc(10240, "mng_platform_data", 3882);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v4 = (const char *)jhl_nv_get_def("wt_base_enable");
    v19 = (const char *)jhl_nv_get_def("ac_mng_srv_host");
    v20 = (const char *)jhl_nv_get_def("ac_mng_srv_port");
    v5 = (const char *)nvram_get("ac_mng_state");
    if ( !v5 )
      v5 = "";
    v21 = (const char *)jhl_nv_get_def("wt_dev_routerid");
    v22 = (const char *)jhl_nv_get_def("wt_dev_addr");
    v23 = (const char *)jhl_nv_get_def("wt_dev_cont");
    v24 = (const char *)jhl_nv_get_def("wt_dev_tel");
    v25 = (const char *)jhl_nv_get_def("wt_dev_name");
    v26 = (const char *)jhl_nv_get_def("wt_dev_dinate");
    v27 = (const char *)jhl_nv_get_def("wt_agent_id");
    v6 = (const char *)jhl_nv_get_def("wt_dev_pwd");
    v7 = (const char *)jhl_nv_get_def("wt_route_type");
    v8 = (const char *)jhl_nv_get_def("wt_dev_replace_id");
    v9 = (const char *)jhl_nv_get_def("wt_dev_randid");
    v10 = (const char *)nvram_get("ac_mng_state");
    if ( !v10 )
      v10 = "";
    v31 = v10;
    v30 = (const char *)jhl_nv_get_def("wt_dev_type");
    v29 = (const char *)jhl_nv_get_def("wt_dev_offlinenotauth");
    v28 = (const char *)jhl_nv_get_def("wt_third_agent_id");
    v11 = (const char *)jhl_nv_get_def("wt_nofeel_auth_id");
    v12 = sprintf(
            v3 + 29,
            "\"en\":\"%s\",\"addr\":\"%s\",\"port\":\"%s\",\"state\":\"%s\",\"route_id\":\"%s\",\"router_addr\":\"%s\",\""
            "router_cont\":\"%s\",\"router_tel\":\"%s\",\"router_name\":\"%s\",\"router_dinate\":\"%s\",\"router_agents\""
            ":\"%s\",\"router_pwd\":\"%s\", \"route_type\":\"%s\",\"route_replace_id\":\"%s\", \"wt_dev_randid\":\"%s\",\""
            "ac_mng_state\":\"%s\",\"wt_dev_type\":\"%s\", \"wt_dev_offlinenotauth\":\"%s\",\"new_router_agents\":\"%s\","
            "\"wt_nofeel_auth_id\":\"%s\"",
            v4,
            v19,
            v20,
            v5,
            v21,
            v22,
            v23,
            v24,
            v25,
            v26,
            v27,
            v6,
            v7,
            v8,
            v9,
            v31,
            v30,
            v29,
            v28,
            v11)
        + 29;
    v13 = snprintf(&v3[v12], 10240 - v12, "}}");
    if ( v13 >= 10240 - v12 )
      v14 = 10239 - v12;
    else
      v14 = v13;
    result = httpd_cgi_ret(a1, v3, v14 + v12, 8);
  }
  else
  {
    v16 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v17 = snprintf(v18, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v16);
    if ( v17 >= 0x100 )
      v17 = 255;
    result = httpd_cgi_ret(a1, v18, v17, 4);
  }
  return result;
}
// 46EBA8: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0046EFF8) --------------------------------------------------------
int __fastcall sub_46EFF8(int a1)
{
  const char *v2; // $s0
  const char *v3; // $v0
  int v4; // $s0
  const char *v5; // $v0
  int v6; // $s0
  const char *v7; // $v0
  int v8; // $s0
  unsigned int v9; // $v0
  char v11[516]; // [sp+18h] [-204h] BYREF

  memset(v11, 0, 0x200u);
  strcpy(v11, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("mqtt_cbg_svr_host");
  v3 = (const char *)jhl_nv_get_def("mqtt_cbg_svr_port");
  v4 = sprintf(&v11[29], "\"svr_host\":\"%s\",\"svr_port\":\"%s\"", v2, v3) + 29;
  v5 = (const char *)jhl_nv_get_def("billing_api_port");
  v6 = v4 + sprintf(&v11[v4], ",\"api_port\":\"%s\"", v5);
  v7 = (const char *)jhl_nv_get_def("billing_api_type");
  v8 = v6 + sprintf(&v11[v6], ",\"api_type\":\"%s\"", v7);
  v9 = snprintf(&v11[v8], 512 - v8, "}}");
  if ( v9 >= 512 - v8 )
    v9 = 511 - v8;
  return httpd_cgi_ret(a1, v11, v9 + v8, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0046F1B8) --------------------------------------------------------
int __fastcall sub_46F1B8(int a1)
{
  const char *v2; // $s6
  const char *v3; // $s7
  const char *v4; // $s0
  const char *v5; // $s3
  const char *v6; // $s4
  const char *v7; // $s5
  const char *v8; // $v0
  int v9; // $s0
  const char *v10; // $v0
  unsigned int v11; // $v0
  const char *v12; // $v0
  unsigned int v13; // $s0
  unsigned int v14; // $v0
  const char *v15; // $v0
  unsigned int v16; // $s0
  unsigned int v17; // $v0
  unsigned int v18; // $s0
  unsigned int v19; // $v0
  char v21[516]; // [sp+30h] [-204h] BYREF

  memset(v21, 0, 0x200u);
  strcpy(v21, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("billing_en");
  v3 = (const char *)jhl_nv_get_def("billing_rname");
  v4 = (const char *)jhl_nv_get_def("billing_dev_pwd");
  v5 = (const char *)jhl_nv_get_def("billing_state");
  v6 = (const char *)jhl_nv_get_def("billing_scene");
  v7 = (const char *)jhl_nv_get_def("billing_syn_state");
  v8 = (const char *)jhl_nv_get_def("billing_no_ipoff");
  v9 = sprintf(
         &v21[29],
         "\"en\":\"%s\",\"rname\":\"%s\",\"dev_pwd\":\"%s\",\"state\":\"%s\",\"scene\":\"%s\",\"syn_state\":\"%s\",\"ipoff_en\":\"%s\"",
         v2,
         v3,
         v4,
         v5,
         v6,
         v7,
         v8)
     + 29;
  v10 = (const char *)jhl_nv_get_def("mqtt_cbg_svr_host");
  v11 = snprintf(&v21[v9], 512 - v9, ",\"cbg_url\":\"%s\"", v10);
  if ( v11 >= 512 - v9 )
    v11 = 511 - v9;
  v13 = v11 + v9;
  v12 = (const char *)jhl_nv_get_def("billing_api_port");
  v14 = snprintf(&v21[v13], 512 - v13, ",\"api_port\":\"%s\"", v12);
  if ( v14 >= 512 - v13 )
    v14 = 511 - v13;
  v16 = v14 + v13;
  v15 = (const char *)jhl_nv_get_def("billing_api_type");
  v17 = snprintf(&v21[v16], 512 - v16, ",\"api_type\":\"%s\"", v15);
  if ( v17 >= 512 - v16 )
    v17 = 511 - v16;
  v18 = v17 + v16;
  v19 = snprintf(&v21[v18], 512 - v18, "}}");
  if ( v19 >= 512 - v18 )
    v19 = 511 - v18;
  return httpd_cgi_ret(a1, v21, v19 + v18, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0046F4CC) --------------------------------------------------------
int __fastcall sub_46F4CC(int a1)
{
  const char *v2; // $s0
  const char *v3; // $s1
  const char *v4; // $s2
  const char *v5; // $s4
  const char *v6; // $s5
  const char *v7; // $s6
  const char *v8; // $s7
  const char *v9; // $fp
  const char *v10; // $v0
  int v11; // $s1
  unsigned int v12; // $v0
  char v14[1024]; // [sp+40h] [-408h] BYREF
  const char *v15; // [sp+440h] [-8h]
  const char *v16; // [sp+444h] [-4h]

  strcpy(v14, "{\"code\":0,\"error\":\"\",\"data\":{");
  v16 = (const char *)jhl_nv_get_def("rd_en");
  v2 = (const char *)jhl_nv_get_def("rd_auth");
  v3 = (const char *)jhl_nv_get_def("rd_acct");
  v4 = (const char *)jhl_nv_get_def("rd_key");
  v5 = (const char *)jhl_nv_get_def("rd_ip");
  v6 = (const char *)jhl_nv_get_def("rd_id");
  v7 = (const char *)jhl_nv_get_def("rd_coa");
  v8 = (const char *)jhl_nv_get_def("rd_dev");
  v9 = (const char *)jhl_nv_get_def("rd_get_user");
  v15 = (const char *)jhl_nv_get_def(&unk_647E00);
  v10 = (const char *)jhl_nv_get_def("rd_list");
  v11 = sprintf(
          &v14[29],
          "\"en\":\"%s\",\"auth\":\"%s\",\"acct\":\"%s\",\"key\":\"%s\",\"ip\":\"%s\",\"id\":\"%s\",\"coa\":\"%s\",\"dev\""
          ":\"%s\",\"get_user\":\"%s\",\"auth_mode\":\"%s\",\"list\":\"%s\"",
          v16,
          v2,
          v3,
          v4,
          v5,
          v6,
          v7,
          v8,
          v9,
          v15,
          v10)
      + 29;
  v12 = snprintf(&v14[v11], 1024 - v11, "}}");
  if ( v12 >= 1024 - v11 )
    v12 = 1023 - v11;
  return httpd_cgi_ret(a1, v14, v12 + v11, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0046F750) --------------------------------------------------------
int __fastcall sub_46F750(int a1)
{
  int v2; // $a2
  int v3; // $v0
  int v5; // $v0
  char v6[1024]; // [sp+18h] [-A00h] BYREF
  char v7[1024]; // [sp+418h] [-600h] BYREF
  __int16 v8[256]; // [sp+818h] [-200h] BYREF

  jhl_parm_get("rzglMsg", v6, 1024);
  jhl_parm_get("rzglLx", v8, 512);
  if ( !v6[0] )
  {
    v5 = _GET_LANG_TEXT(75, *(unsigned __int8 *)(a1 + 210102), v2);
    strlcpy(v6, v5, 1024);
  }
  if ( !LOBYTE(v8[0]) )
    v8[0] = 32;
  v3 = sprintf(v7, "{\"msg\":\"%s\",\"lx\":\"%s\"}", v6, (const char *)v8);
  return httpd_cgi_ret(a1, v7, v3, 4);
}
// 46F838: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (0046F864) --------------------------------------------------------
int __fastcall sub_46F864(int a1)
{
  char *v1; // $v0
  char *v2; // $s0
  int v3; // $a2
  const char *v4; // $fp
  const char *v5; // $s1
  const char *v6; // $s2
  const char *v7; // $s3
  const char *v8; // $s4
  const char *v9; // $s5
  const char *v10; // $s6
  const char *v11; // $s7
  const char *v12; // $v1
  const char *v13; // $v0
  int v14; // $s1
  int v15; // $s1
  int v16; // $s1
  int v17; // $s1
  int v18; // $s1
  const char *v19; // $s7
  const char *v20; // $s2
  const char *v21; // $s3
  const char *v22; // $s4
  const char *v23; // $s5
  const char *v24; // $s6
  const char *v25; // $v0
  int v26; // $s1
  const char *v27; // $s2
  const char *v28; // $v0
  int v29; // $s1
  const char *v30; // $s3
  const char *v31; // $v0
  int v32; // $s1
  const char *v33; // $s3
  const char *v34; // $v0
  char *v36; // $v0
  const char *v37; // $v0
  unsigned int v38; // $v0
  char v39[2048]; // [sp+70h] [-1188h] BYREF
  char v40[1024]; // [sp+870h] [-988h] BYREF
  __int16 v41[256]; // [sp+C70h] [-588h] BYREF
  __int16 v42[128]; // [sp+E70h] [-388h] BYREF
  __int16 v43[128]; // [sp+F70h] [-288h] BYREF
  __int16 v44[128]; // [sp+1070h] [-188h] BYREF
  int v45[8]; // [sp+1170h] [-88h] BYREF
  int v46[14]; // [sp+1190h] [-68h] BYREF
  char *dest; // [sp+11C8h] [-30h]
  char *v48; // [sp+11CCh] [-2Ch]
  char *v49; // [sp+11D0h] [-28h]
  const char *v50; // [sp+11D4h] [-24h]
  char *v51; // [sp+11D8h] [-20h]
  const char *v52; // [sp+11DCh] [-1Ch]
  const char *v53; // [sp+11E0h] [-18h]
  const char *v54; // [sp+11E4h] [-14h]
  const char *v55; // [sp+11E8h] [-10h]
  const char *v56; // [sp+11ECh] [-Ch]
  const char *v57; // [sp+11F0h] [-8h]

  v46[0] = 48;
  v45[0] = 48;
  v46[1] = 0;
  v46[2] = 0;
  v46[3] = 0;
  v46[4] = 0;
  v46[5] = 0;
  v46[6] = 0;
  v46[7] = 0;
  v45[1] = 0;
  v45[2] = 0;
  v45[3] = 0;
  v45[4] = 0;
  v45[5] = 0;
  v45[6] = 0;
  v45[7] = 0;
  v51 = (char *)jhl_nv_get_def("dual_lan_mode");
  _mem_malloc(102400, "rzgl_data", 173);
  v2 = v1;
  if ( !v1 )
  {
    v37 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v38 = snprintf(v39, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v37);
    if ( v38 >= 0x100 )
      v38 = 255;
    httpd_cgi_ret(a1, v39, v38, 4);
    JUMPOUT(0x4701A8);
  }
  v55 = (const char *)v44;
  jhl_parm_get("rzglType", v44, 256);
  v53 = (const char *)v42;
  jhl_parm_get("rzglTq", v42, 256);
  dest = v40;
  jhl_parm_get("rzglMsg", v40, 1024);
  v56 = (const char *)v41;
  jhl_parm_get("rzglLx", v41, 512);
  v54 = (const char *)v43;
  jhl_parm_get("rzglAtype", v43, 256);
  if ( !LOBYTE(v43[0]) )
    v43[0] = 48;
  if ( !LOBYTE(v44[0]) )
    v44[0] = 48;
  if ( !LOBYTE(v42[0]) )
    v42[0] = 55;
  if ( !v40[0] )
  {
    v36 = (char *)_GET_LANG_TEXT(51, *(unsigned __int8 *)(a1 + 210102), v3);
    strcpy(dest, v36);
  }
  if ( !LOBYTE(v41[0]) )
    v41[0] = 32;
  strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
  qmemcpy(v2, "{\"code\":0,\"error", 16);
  v4 = (const char *)nvram_get("rzglUnline");
  v48 = v2 + 29;
  if ( !v4 )
    v4 = "0";
  v48 = (char *)nvram_get("web_exit");
  if ( !v48 )
    v48 = "0";
  v49 = (char *)nvram_get("web_anyuser");
  if ( !v49 )
    v49 = "0";
  v50 = (const char *)nvram_get("rzglFip");
  if ( !v50 )
    v50 = "not";
  v52 = (const char *)jhl_nv_get_def("rzglDns");
  v5 = (const char *)nvram_get("rzglHost");
  if ( !v5 )
    v5 = "not";
  v6 = (const char *)nvram_get("rzglMac");
  if ( !v6 )
    v6 = "not";
  v7 = (const char *)nvram_get("rzgl_web_ageing_time");
  if ( !v7 )
    v7 = "15";
  v8 = (const char *)nvram_get("rzgl_redirct_url");
  if ( !v8 )
    v8 = "http://";
  v9 = (const char *)nvram_get("rzgl_redirct_en");
  if ( !v9 )
    v9 = "0";
  v10 = (const char *)nvram_get("rzgl_third_url");
  if ( !v10 )
    v10 = "http://";
  v11 = (const char *)nvram_get("rzgl_third_timeout");
  if ( !v11 )
    v11 = (const char *)&unk_4D15F8;
  v12 = (const char *)nvram_get("vmiandan_checktime");
  if ( !v12 )
    v12 = "0";
  v57 = v12;
  v13 = (const char *)nvram_get("vmiandan_checkcount");
  if ( !v13 )
    v13 = "3";
  v14 = sprintf(
          v2 + 29,
          "\"type\":%s,\"tq\":%s,\"unline\":%s,\"msg\":\"%s\",\"lx\":\"%s\",\"auto_type\":%s,\"web_exit\":%s,\"web_anyuse"
          "r\":%s,\"web_type\":\"%s\",\"pppoe_type\":\"%s\",\"fip\":\"%s\",\"dns\":\"%s\",\"host\":\"%s\",\"mac\":\"%s\","
          "\"timeout\":\"%s\",\"redirct_url\":\"%s\",\"redirct_en\":\"%s\",\"third_url\":\"%s\",\"third_timeout\":\"%s\","
          "\"vmiandan_checktime\":\"%s\",\"vmiandan_checkcount\":\"%s\",\"third_enable\":\"%d\",\"web_rztz_show\":%d",
          v55,
          v53,
          v4,
          dest,
          v56,
          v54,
          v48,
          v49,
          (const char *)v46,
          (const char *)v45,
          v50,
          v52,
          v5,
          v6,
          v7,
          v8,
          v9,
          v10,
          v11,
          v57,
          v13,
          1,
          1)
      + 29;
  v15 = v14 + sprintf(&v2[v14], ",\"rzgl_localMac\":\"%d\",\"flag\":\"%d\"", 1, 0);
  v16 = v15 + sprintf(&v2[v15], ",\"rzgl_localIp\":\"%d\"", 1);
  v17 = v16 + sprintf(&v2[v16], ",\"userinfo_en\":\"%d\"", 0);
  v18 = v17 + sprintf(&v2[v17], ",\"any_user\":%d", 1);
  v19 = (const char *)jhl_nv_get_def("rzgl_pc_no_auth");
  v20 = (const char *)jhl_nv_get_def("rzgl_noauth_pc");
  v21 = (const char *)jhl_nv_get_def("rzgl_noauth_ssid1");
  v22 = (const char *)jhl_nv_get_def("rzgl_noauth_ssid2");
  v23 = (const char *)jhl_nv_get_def("rzgl_noauth_ssid3");
  v24 = (const char *)jhl_nv_get_def("rzgl_noauth_ssid4");
  v25 = (const char *)jhl_nv_get_def("rzgl_noauth_ssid5");
  v26 = v18
      + sprintf(
          &v2[v18],
          ",\"noauth_show\":\"%d\",\"noauth_en\":%s,\"noauth_pc\":%s,\"noauth_ssid1\":%s,\"noauth_ssid2\":%s,\"noauth_ssi"
          "d3\":%s,\"noauth_ssid4\":%s,\"noauth_ssid5\":%s",
          1,
          v19,
          v20,
          v21,
          v22,
          v23,
          v24,
          v25);
  v27 = (const char *)jhl_nv_get_def("rzgl_mac_en");
  v28 = (const char *)jhl_nv_get_def("rzgl_mac_timeout");
  v29 = v26 + sprintf(&v2[v26], ",\"mac_show\":\"%d\",\"mac_en\":%s,\"mac_timeout\":\"%s\"", 1, v27, v28);
  if ( !strcmp(v51, "1") )
    JUMPOUT(0x4701D8);
  strcpy(&v2[v29], ",\"iface_show\":\"0\"");
  qmemcpy(&v2[v29], ",\"iface_show", 12);
  v30 = (const char *)jhl_nv_get_def("tggl_port");
  v31 = (const char *)jhl_nv_get_def("save_auth_log_usb");
  v32 = v29 + 17 + sprintf(&v2[v29 + 17], ",\"tggl_port\":\"%s\",\"usblog_show\":\"%d\",\"usblog\":\"%s\"", v30, 1, v31);
  v33 = (const char *)jhl_nv_get_def("rzgl_second_auth_en");
  v34 = (const char *)jhl_nv_get_def("rzgl_second_auth_url");
  sprintf(&v2[v32], ",\"second_auth_show\":\"%d\",\"second_auth_en\":\"%s\",\"second_auth_url\":\"%s\"", 0, v33, v34);
  return sub_470000();
}
// 47045C: control flows out of bounds to 4701A8
// 46FEF8: control flows out of bounds to 4701D8
// 46F924: variable 'v1' is possibly undefined
// 4702F0: variable 'v3' is possibly undefined
// 470000: using guessed type int sub_470000(void);
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (00470000) --------------------------------------------------------
#error "470024: call analysis failed (funcsize=112)"

//----- (00470464) --------------------------------------------------------
int __fastcall sub_470464(int a1)
{
  char *v1; // $v0
  int v3; // $a0
  char *v4; // $v1
  const char *v5; // $v0
  int v6; // $t1
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  char v11[1024]; // [sp+18h] [-400h] BYREF

  v1 = httpd_get_parm(a1, "lx");
  if ( !v1 )
    v1 = " ";
  jhl_parm_set("rzglLx", v1);
  jhl_parm_commit(v3);
  v4 = v11;
  v5 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v6 = *(_DWORD *)v5;
    v7 = *((_DWORD *)v5 + 1);
    v8 = *((_DWORD *)v5 + 2);
    v9 = *((_DWORD *)v5 + 3);
    v5 += 16;
    *(_DWORD *)v4 = v6;
    *((_DWORD *)v4 + 1) = v7;
    *((_DWORD *)v4 + 2) = v8;
    *((_DWORD *)v4 + 3) = v9;
    v4 += 16;
  }
  while ( v5 != "}" );
  *(_WORD *)v4 = *(_WORD *)v5;
  return httpd_cgi_ret(a1, v11, 33, 4);
}
// 4704C4: variable 'v3' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);

//----- (00470548) --------------------------------------------------------
int __fastcall sub_470548(int a1)
{
  char *v2; // $s3
  char *v3; // $s2
  char *v4; // $s4
  int v5; // $a2
  int v6; // $a2
  int v7; // $a1
  int v8; // $a0
  const char *v9; // $v0
  const char *v10; // $a2
  unsigned int v11; // $a2
  int v13[256]; // [sp+20h] [-600h] BYREF
  char v14[512]; // [sp+420h] [-200h] BYREF

  v2 = httpd_get_parm(a1, (char *)&off_649194);
  v3 = httpd_get_parm(a1, "old_pwd");
  v4 = httpd_get_parm(a1, "u");
  memset(v13, 0, sizeof(v13));
  v13[0] = 16;
  v13[3] = 51;
  v13[1] = 1024;
  strlcpy(&v13[4], v4, 64);
  strlcpy(&v13[36], v2, 64);
  strlcpy(&v13[20], v3, 64);
  if ( jianhl_order_opt_fun(v13, v13[1], v5) )
  {
    v9 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
  }
  else
  {
    if ( !v13[2] )
    {
      if ( v13[62] == 1 )
      {
        v7 = *(unsigned __int8 *)(a1 + 210102);
        v8 = 78;
        goto LABEL_8;
      }
      if ( v13[62] < 2 )
      {
        if ( !v13[62] )
        {
          v7 = *(unsigned __int8 *)(a1 + 210102);
          v8 = 79;
          goto LABEL_8;
        }
      }
      else
      {
        if ( v13[62] == 2 )
        {
          v7 = *(unsigned __int8 *)(a1 + 210102);
          v8 = 76;
          goto LABEL_8;
        }
        if ( v13[62] == 13 )
        {
          v7 = *(unsigned __int8 *)(a1 + 210102);
          v8 = 77;
LABEL_8:
          v9 = (const char *)_GET_LANG_TEXT(v8, v7, v6);
          goto LABEL_13;
        }
      }
      v7 = *(unsigned __int8 *)(a1 + 210102);
      v8 = 80;
      goto LABEL_8;
    }
    if ( v13[2] >= 0x33u || (v10 = (const char *)jhlret_err_str[v13[2]]) == 0 )
      v10 = "not find err!";
    v9 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), v10);
  }
LABEL_13:
  v11 = snprintf(v14, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
  if ( v11 >= 0x200 )
    v11 = 511;
  return httpd_cgi_ret(a1, v14, v11, 4);
}
// 470650: variable 'v5' is possibly undefined
// 4706B0: variable 'v6' is possibly undefined
// 649194: using guessed type char *off_649194;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00470820) --------------------------------------------------------
int __fastcall user_lock_asp(int a1)
{
  char *v2; // $v0
  char *v3; // $s2
  char *v4; // $s3
  int v5; // $s1
  int v6; // $v0
  const char **v7; // $s2
  int v8; // $s6
  int v9; // $s3
  int v10; // $s5
  const char *v11; // $s4
  size_t v12; // $v0
  size_t v13; // $v0
  const char **v15; // $s2
  int v16; // $s6
  int v17; // $s3
  int v18; // $s5
  const char *v19; // $s4
  size_t v20; // $v0
  size_t v21; // $v0
  char v22[4096]; // [sp+18h] [-1804h] BYREF
  char v23[1024]; // [sp+1018h] [-804h] BYREF
  char v24[1028]; // [sp+1418h] [-404h] BYREF

  memset(v23, 0, sizeof(v23));
  v3 = httpd_get_parm(a1, "mode");
  v2 = httpd_get_parm(a1, "user");
  if ( !v3 )
    return -1;
  v4 = v2;
  v5 = strcmp(v3, "lock_all");
  if ( !v5 )
  {
    user_lock(1, 0, 1);
    return v5;
  }
  if ( !strcmp(v3, "lock_sel") )
  {
    v15 = (const char **)v22;
    v16 = split_string(v4, 44, v22, 1024);
    if ( v16 > 0 )
    {
      v17 = 0;
      v18 = a1 + 196608;
      do
      {
        memset(v24, 0, 0x400u);
        if ( *(_BYTE *)(v18 + 13492) == 2 )
        {
          strlcpy(v24, *v15, 1024);
        }
        else
        {
          memset(v23, 0, sizeof(v23));
          v19 = *v15;
          v20 = strlen(*v15);
          base64_decode(v19, v23, v20);
          v21 = strlen(v23);
          str_to_gb2312(v23, v21, v24, 1024);
        }
        ++v17;
        user_lock(0, v24, 1);
        ++v15;
      }
      while ( v16 != v17 );
    }
    return 0;
  }
  v5 = strcmp(v3, "unlock_all");
  if ( !v5 )
  {
    user_lock(1, 0, 0);
    return v5;
  }
  v6 = strcmp(v3, "unlock_sel");
  v7 = (const char **)v22;
  if ( v6 )
    return -1;
  v8 = split_string(v4, 44, v22, 1024);
  if ( v8 > 0 )
  {
    v9 = 0;
    v10 = a1 + 196608;
    do
    {
      memset(v24, 0, 0x400u);
      if ( *(_BYTE *)(v10 + 13492) == 2 )
      {
        strlcpy(v24, *v7, 1024);
      }
      else
      {
        memset(v23, 0, sizeof(v23));
        v11 = *v7;
        v12 = strlen(*v7);
        base64_decode(v11, v23, v12);
        v13 = strlen(v23);
        str_to_gb2312(v23, v13, v24, 1024);
      }
      ++v9;
      user_lock(0, v24, 0);
      ++v7;
    }
    while ( v8 != v9 );
  }
  return 0;
}
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8604: using guessed type int __fastcall user_lock(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A88A4: using guessed type int __fastcall str_to_gb2312(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00470BEC) --------------------------------------------------------
int __fastcall sub_470BEC(int a1)
{
  char *v2; // $v0
  char *v3; // $s2
  char *v4; // $s3
  _BOOL4 v5; // $s4
  unsigned int v6; // $a2
  unsigned int v7; // $a0
  unsigned int v8; // $v1
  int v9; // $a2
  int v10; // $a1
  char *v11; // $a2
  int v12; // $a0
  const char *v13; // $v0
  int v14; // $a2
  int v16; // $a2
  int v17; // $v0
  int v18; // $a2
  int v19; // $v0
  const char *v20; // $v0
  _BOOL4 v21; // $v1
  int v22; // $v0
  int v23; // $v0
  char v24[2048]; // [sp+50h] [-125Ch] BYREF
  __int16 v25[512]; // [sp+850h] [-A5Ch] BYREF
  _QWORD v26[128]; // [sp+C50h] [-65Ch] BYREF
  __int16 v27[256]; // [sp+1050h] [-25Ch] BYREF
  char v28[64]; // [sp+1250h] [-5Ch] BYREF
  unsigned int v29; // [sp+1290h] [-1Ch] BYREF
  __int64 v30; // [sp+1294h] [-18h]
  __int64 v31; // [sp+129Ch] [-10h]

  v3 = httpd_get_parm(a1, "i");
  v2 = httpd_get_parm(a1, "u");
  if ( !v2 || !v3 )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = "not user or ipaddr";
    v12 = 12;
    goto LABEL_17;
  }
  v29 = 0;
  v30 = 0LL;
  v31 = 0LL;
  v4 = v2;
  if ( strchr(v3, 46) || strchr(v3, 58) )
    StrToIpaddr(v3, &v29);
  else
    LODWORD(v30) = J_atoi(v3);
  if ( !nvram_match_def("jf_en", "1") || (v5 = 1, !sq_file_get_state_new("wys_jf")) )
    v5 = nvram_match_def("billing_en", "1") != 0;
  memset(v26, 0, sizeof(v26));
  v26[0] = 0x40000000010LL;
  HIDWORD(v26[1]) = 22;
  v26[13] = v30;
  v26[14] = v31;
  v6 = *(_DWORD *)(a1 + 205468);
  v7 = *(_DWORD *)(a1 + 205472);
  v8 = *(_DWORD *)(a1 + 205476);
  v26[10] = *(_QWORD *)(a1 + 205460);
  v26[11] = __PAIR64__(v7, v6);
  v26[12] = __PAIR64__(v29, v8);
  strlcpy(&v26[2], v4, 64);
  if ( jianhl_order_opt_fun(v26, HIDWORD(v26[0]), v9) )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = "";
    v12 = 3;
    goto LABEL_17;
  }
  if ( LODWORD(v26[1]) )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    if ( LODWORD(v26[1]) >= 0x33 || (v11 = (char *)jhlret_err_str[LODWORD(v26[1])]) == 0 )
      v11 = "not find err!";
    v12 = 3;
    goto LABEL_17;
  }
  if ( LODWORD(v26[20]) != 17 )
  {
    sprintf((char *)v25, "%d", LODWORD(v26[20]));
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = (char *)v25;
    v12 = 3;
LABEL_17:
    v13 = (const char *)_GET_LANG_TEXT(v12, v10, v11);
    v14 = sprintf(v24, "{\"ret\":1,\"msg\":\"%s\"}", v13);
    return httpd_cgi_ret(a1, v24, v14, 4);
  }
  jhl_parm_get("rzglLx", v27, 512);
  if ( !LOBYTE(v27[0]) )
    v27[0] = 32;
  if ( HIDWORD(v26[19]) == 2 )
  {
    jhl_parm_get("rzglMsg", v25, 1024);
    if ( LOBYTE(v25[0]) )
      goto LABEL_27;
  }
  else if ( HIDWORD(v26[19]) == 1 )
  {
    v23 = _GET_LANG_TEXT(75, *(unsigned __int8 *)(a1 + 210102), v16);
    strlcpy(v25, v23, 1024);
    goto LABEL_27;
  }
  v25[0] = 32;
LABEL_27:
  v17 = _GET_LANG_TEXT(81, *(unsigned __int8 *)(a1 + 210102), v16);
  strlcpy(v28, v17, 64);
  check_client_is_or_not_mobile(a1);
  if ( v19 )
  {
    v22 = _GET_LANG_TEXT(82, *(unsigned __int8 *)(a1 + 210102), v18);
    strlcpy(v28, v22, 64);
  }
  v20 = (const char *)nvram_get("web_exit");
  if ( !v20 )
    v20 = "0";
  v21 = 1;
  if ( !v5 )
    v21 = LOBYTE(v26[21]) == 0;
  v14 = sprintf(
          v24,
          "{\"tm\":%u,\"up\":%u,\"down\":%u,\"zup\":%llu,\"zdown\":%llu,\"dtm\":%u,\"state\":%d,\"msg\":\"%s\",\"lx\":\"%"
          "s\",\"exit\":\"%s\",\"client_type\":\"%s\",\"dis_mod_pwd\":\"%d\",\"dis_contact_admin\":\"%d\",\"callAdmin\":\"1\"}",
          LODWORD(v26[15]),
          HIDWORD(v26[15]),
          LODWORD(v26[16]),
          v26[17],
          v26[18],
          LODWORD(v26[19]),
          HIDWORD(v26[20]),
          (const char *)v25,
          (const char *)v27,
          v20,
          v28,
          v21,
          0);
  return httpd_cgi_ret(a1, v24, v14, 4);
}
// 470DB4: variable 'v9' is possibly undefined
// 470FA4: variable 'v16' is possibly undefined
// 470FE4: variable 'v19' is possibly undefined
// 4710C0: variable 'v18' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8284: using guessed type int __fastcall StrToIpaddr(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8848: using guessed type int __fastcall sq_file_get_state_new(_DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00471174) --------------------------------------------------------
int __fastcall sub_471174(int a1)
{
  char *v2; // $s6
  char *v3; // $s5
  char *v4; // $s1
  char *v5; // $v0
  char *v6; // $s3
  char *v7; // $s4
  int v8; // $v0
  int v9; // $a2
  int v11; // $a1
  char *v12; // $a2
  int v13; // $a0
  const char *v14; // $v0
  int v15; // $a2
  int v16; // $a1
  int v17; // $a0
  const char *v18; // $v0
  int v19; // $t0
  int v20; // $a3
  int v21; // $a2
  int v22; // $a0
  int v23; // $v1
  int v24; // $a2
  int v25[256]; // [sp+18h] [-61Ch] BYREF
  char v26[512]; // [sp+418h] [-21Ch] BYREF
  int v27; // [sp+618h] [-1Ch] BYREF
  int v28; // [sp+61Ch] [-18h]
  int v29; // [sp+620h] [-14h]
  int v30; // [sp+624h] [-10h]
  int v31; // [sp+628h] [-Ch]

  v2 = httpd_get_parm(a1, (char *)&off_649194);
  v3 = httpd_get_parm(a1, "old_pwd");
  v4 = httpd_get_parm(a1, "opt");
  v6 = httpd_get_parm(a1, "i");
  v5 = httpd_get_parm(a1, "u");
  if ( !v4 || (v7 = v5, strcmp(v4, "modpwd")) && strcmp(v4, "down") )
  {
    v11 = *(unsigned __int8 *)(a1 + 210102);
    v12 = "not opt";
LABEL_12:
    v13 = 12;
LABEL_13:
    v14 = (const char *)_GET_LANG_TEXT(v13, v11, v12);
LABEL_14:
    v9 = sprintf(v26, "{\"ret\":1,\"msg\":\"%s\"}", v14);
    return httpd_cgi_ret(a1, v26, v9, 4);
  }
  if ( !v7 || !v6 )
  {
    v11 = *(unsigned __int8 *)(a1 + 210102);
    v12 = "not user or ipaddr";
    goto LABEL_12;
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  if ( strchr(v6, 46) || strchr(v6, 58) )
    StrToIpaddr(v6, &v27);
  else
    v28 = J_atoi(v6);
  if ( !strcmp(v4, "down") )
  {
    user_ipdown_set(&v27, 0);
    v16 = *(unsigned __int8 *)(a1 + 210102);
    v17 = 83;
LABEL_18:
    v18 = (const char *)_GET_LANG_TEXT(v17, v16, v15);
    v9 = sprintf(v26, "{\"ret\":0,\"msg\":\"%s\"}", v18);
    return httpd_cgi_ret(a1, v26, v9, 4);
  }
  v8 = strcmp(v4, "modpwd");
  v9 = 0;
  if ( !v8 )
  {
    memset(v25, 0, sizeof(v25));
    v25[0] = 16;
    v25[3] = 21;
    v25[1] = 1024;
    v25[57] = v27;
    v25[58] = v28;
    v25[59] = v29;
    v25[60] = v30;
    v19 = *(_DWORD *)(a1 + 205460);
    v20 = *(_DWORD *)(a1 + 205464);
    v21 = *(_DWORD *)(a1 + 205468);
    v22 = *(_DWORD *)(a1 + 205472);
    v25[61] = v31;
    v23 = *(_DWORD *)(a1 + 205476);
    v25[52] = v19;
    v25[53] = v20;
    v25[56] = v23;
    v25[54] = v21;
    v25[55] = v22;
    strlcpy(&v25[4], v7, 64);
    strlcpy(&v25[36], v2, 64);
    strlcpy(&v25[20], v3, 64);
    if ( jianhl_order_opt_fun(v25, v25[1], v24) )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = "";
      v13 = 3;
      goto LABEL_13;
    }
    if ( v25[2] )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      if ( v25[2] >= 0x33u || (v12 = (char *)jhlret_err_str[v25[2]]) == 0 )
        v12 = "not find err!";
      v13 = 3;
      goto LABEL_13;
    }
    if ( v25[62] == 1 )
    {
      v16 = *(unsigned __int8 *)(a1 + 210102);
      v17 = 78;
      goto LABEL_18;
    }
    if ( v25[62] < 2 )
    {
      if ( !v25[62] )
      {
        v16 = *(unsigned __int8 *)(a1 + 210102);
        v17 = 79;
        goto LABEL_18;
      }
    }
    else
    {
      if ( v25[62] == 2 )
      {
        v16 = *(unsigned __int8 *)(a1 + 210102);
        v17 = 76;
        goto LABEL_18;
      }
      if ( v25[62] == 13 )
      {
        v16 = *(unsigned __int8 *)(a1 + 210102);
        v17 = 77;
        goto LABEL_18;
      }
    }
    v14 = (const char *)_GET_LANG_TEXT(80, *(unsigned __int8 *)(a1 + 210102), v15);
    goto LABEL_14;
  }
  return httpd_cgi_ret(a1, v26, v9, 4);
}
// 471410: variable 'v15' is possibly undefined
// 471554: variable 'v24' is possibly undefined
// 649194: using guessed type char *off_649194;
// 6A8284: using guessed type int __fastcall StrToIpaddr(_DWORD, _DWORD);
// 6A82C4: using guessed type int __fastcall user_ipdown_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00471680) --------------------------------------------------------
int __fastcall sub_471680(int a1)
{
  char *v2; // $s2
  size_t v3; // $v0
  int v4; // $v0
  int v5; // $v0
  char *v6; // $v1
  const char *v7; // $v0
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  int v11; // $a1
  unsigned int v12; // $a2
  const char *v14; // $v0
  char v15[512]; // [sp+20h] [-240h] BYREF
  char v16[64]; // [sp+220h] [-40h] BYREF

  memset(v16, 0, sizeof(v16));
  v2 = httpd_get_parm(a1, "name");
  if ( v2 )
  {
    if ( *(_BYTE *)(a1 + 210100) == 2 )
    {
      strlcpy(v16, v2, 64);
    }
    else
    {
      v3 = strlen(v2);
      base64_decode(v2, v16, v3);
    }
    v4 = jhl_nv_get_def("macuser_down_del");
    v5 = J_atoi(v4);
    user_namedown_set(v16, v5);
    v6 = v15;
    v7 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v8 = *(_DWORD *)v7;
      v9 = *((_DWORD *)v7 + 1);
      v10 = *((_DWORD *)v7 + 2);
      v11 = *((_DWORD *)v7 + 3);
      v7 += 16;
      *(_DWORD *)v6 = v8;
      *((_DWORD *)v6 + 1) = v9;
      *((_DWORD *)v6 + 2) = v10;
      *((_DWORD *)v6 + 3) = v11;
      v6 += 16;
    }
    while ( v7 != "}" );
    v12 = 33;
    *(_WORD *)v6 = *(_WORD *)v7;
  }
  else
  {
    v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_6442E4);
    v12 = snprintf(v15, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v12 >= 0x200 )
      v12 = 511;
  }
  return httpd_cgi_ret(a1, v15, v12, 4);
}
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8528: using guessed type int __fastcall user_namedown_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00471870) --------------------------------------------------------
int __fastcall sub_471870(int a1)
{
  char *v1; // $s1
  _DWORD *v2; // $v0
  int v3; // $a2
  char *v4; // $v0
  char *v5; // $s0
  _DWORD *v6; // $s3
  _DWORD *v7; // $s5
  int v8; // $s2
  int v9; // $s1
  int v10; // $v0
  char *v11; // $v0
  int v12; // $a2
  const char *v13; // $v0
  int v14; // $s1
  int v15; // $a2
  int result; // $v0
  int v17; // $a0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $v0
  int v21; // $s1
  const char *v22; // $v0
  unsigned int v23; // $a2
  __int16 v24[64]; // [sp+40h] [-170h] BYREF
  char v25[128]; // [sp+C0h] [-F0h] BYREF
  char v26[48]; // [sp+140h] [-70h] BYREF
  char v27[32]; // [sp+170h] [-40h] BYREF
  int v28; // [sp+190h] [-20h]
  uint32_t v29; // [sp+194h] [-1Ch]
  char *s; // [sp+198h] [-18h]
  char *v31; // [sp+19Ch] [-14h]
  char *format; // [sp+1A0h] [-10h]
  char *v33; // [sp+1A4h] [-Ch]
  char *v34; // [sp+1A8h] [-8h]

  v33 = "1\"";
  v1 = httpd_get_parm(a1, "id");
  _mem_malloc(0x200000, "web_user_data", 2975);
  v5 = v4;
  _mem_malloc(0x200000, "web_user_data", 2976);
  v6 = v2;
  if ( v5 && v2 )
  {
    *v2 = 16;
    if ( v1 && J_atoi(v1) == 2 )
      v6[3] = 39;
    else
      v6[3] = 11;
    v6[1] = 0x200000;
    if ( !jianhl_order_opt_fun(v6, 0x200000, v3) )
    {
      strcpy(v5, "{\"code\":0,\"error\":\"\",\"data\":[");
      qmemcpy(v5, "{\"code\":0,\"error", 16);
      v7 = v6 + 4;
      if ( (int)v6[2] <= 0 )
      {
        v18 = 28;
        v17 = 29;
        v9 = 29;
      }
      else
      {
        s = (char *)v24;
        v31 = "1\"";
        v8 = 0;
        format = "%d";
        v9 = 29;
        v34 = "%d.%d";
        do
        {
          v11 = (char *)get_json_data(v7 + 13);
          strcpy(v25, v11);
          if ( *((_WORD *)v7 + 20) )
          {
            v12 = *((unsigned __int16 *)v7 + 20);
            if ( *((_WORD *)v7 + 21) )
              sprintf(s, v34, v12);
            else
              sprintf(s, format, v12);
          }
          else
          {
            v24[0] = 32;
          }
          v29 = ntohl(v7[1]);
          v28 = IpaddrToStr(v26, v7);
          v10 = MacToStr(v27, v7 + 8);
          v9 += sprintf(
                  &v5[v9],
                  v31 - 31052,
                  v29,
                  v28,
                  v10,
                  v7[5],
                  v25,
                  v7[6],
                  v7[7],
                  *((unsigned __int8 *)v7 + 38),
                  s,
                  v7[11],
                  v7[12]);
          ++v8;
          v7 += 29;
        }
        while ( v8 < v6[2] && 0x200000 - v9 >= 100 );
        v17 = v9;
        if ( v9 <= 0 )
          goto LABEL_24;
        v18 = v9 - 1;
      }
      if ( v5[v18] == 44 )
        v17 = --v9;
LABEL_24:
      v19 = &v5[v17];
      *v19 = 0;
      v20 = snprintf(v19, 0x200000 - v9, "]}");
      if ( v20 >= 0x200000 - v9 )
        v20 = 0x1FFFFF - v9;
      v21 = v9 + v20;
      _mem_free(v6);
      return jhl_data_giz(a1, v5, v21, 0x200000);
    }
    v13 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
    v14 = snprintf(v5, 0x200000, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
    _mem_free(v6);
    v15 = v14;
    if ( v14 >= 0x200000 )
      v15 = 0x1FFFFF;
    result = httpd_cgi_ret(a1, v5, v15, 8);
  }
  else
  {
    _mem_free(v5);
    _mem_free(v6);
    v22 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    s = (char *)v24;
    v23 = snprintf((char *)v24, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v22);
    if ( v23 >= 0x80 )
      v23 = 127;
    result = httpd_cgi_ret(a1, s, v23, 4);
  }
  return result;
}
// 471900: variable 'v4' is possibly undefined
// 47190C: variable 'v2' is possibly undefined
// 471958: variable 'v3' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00471DB8) --------------------------------------------------------
int __fastcall sub_471DB8(int a1)
{
  _DWORD *v1; // $v0
  int v2; // $a2
  char *v3; // $v0
  char *v4; // $s1
  _DWORD *v5; // $s6
  _DWORD *v6; // $s0
  int v7; // $fp
  int v8; // $s2
  char *v9; // $v0
  const char *v10; // $v0
  int v11; // $a0
  int v12; // $v0
  char *v13; // $a0
  int v14; // $v0
  int v15; // $s2
  int result; // $v0
  const char *v17; // $v0
  int v18; // $s0
  int v19; // $a2
  const char *v20; // $v0
  unsigned int v21; // $v0
  char v22[128]; // [sp+38h] [-E0h] BYREF
  char v23[48]; // [sp+B8h] [-60h] BYREF
  char v24[32]; // [sp+E8h] [-30h] BYREF
  const char *v25; // [sp+108h] [-10h]
  int v26; // [sp+10Ch] [-Ch]
  char *v27; // [sp+110h] [-8h]

  v27 = "1\"";
  _mem_malloc(0x200000, "pppoe_web_user_data", 3085);
  v4 = v3;
  _mem_malloc(0x200000, "pppoe_web_user_data", 3086);
  v5 = v1;
  if ( !v4 || !v1 )
  {
    _mem_free(v4);
    _mem_free(v5);
    v20 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v21 = snprintf(v22, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v20);
    if ( v21 >= 0x80 )
      result = httpd_cgi_ret(a1, v22, 127, 4);
    else
      result = httpd_cgi_ret(a1, v22, v21, 4);
    return result;
  }
  *v1 = 16;
  v1[3] = 44;
  v1[1] = 0x200000;
  if ( !jianhl_order_opt_fun(v1, 0x200000, v2) )
  {
    strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy(v4, "{\"code\":0,\"error", 16);
    v6 = v5 + 4;
    if ( (int)v5[2] <= 0 )
    {
      v12 = 28;
      v11 = 29;
      v8 = 29;
    }
    else
    {
      v7 = 0;
      v8 = 29;
      do
      {
        v9 = (char *)get_json_data(v6);
        strcpy(v22, v9);
        v26 = v6[16];
        v25 = (const char *)IpaddrToStr(v23, v6 + 22);
        v10 = (const char *)MacToStr(v24, v6 + 27);
        v8 += sprintf(
                &v4[v8],
                "{\"userid\":\"%u\",\"ip\":\"%s\",\"mac\":\"%s\",\"name\":\"%s\",\"speed\":\"%u/%u\",\"total\":\"%u/%u\","
                "\"type\":\"%d\"},",
                v26,
                v25,
                v10,
                v22,
                v6[20],
                v6[21],
                v6[18],
                v6[19],
                *((unsigned __int8 *)v6 + 114));
        ++v7;
        v6 += 29;
      }
      while ( v7 < v5[2] && 0x200000 - v8 >= 100 );
      v11 = v8;
      if ( v8 <= 0 )
      {
LABEL_12:
        v13 = &v4[v11];
        *v13 = 0;
        v14 = snprintf(v13, 0x200000 - v8, "]}");
        if ( v14 >= 0x200000 - v8 )
          v14 = 0x1FFFFF - v8;
        v15 = v8 + v14;
        _mem_free(v5);
        return jhl_data_giz(a1, v4, v15, 0x200000);
      }
      v12 = v8 - 1;
    }
    if ( v4[v12] == 44 )
      v11 = --v8;
    goto LABEL_12;
  }
  v17 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
  v18 = snprintf(v4, 0x200000, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
  _mem_free(v5);
  v19 = v18;
  if ( v18 >= 0x200000 )
    v19 = 0x1FFFFF;
  return httpd_cgi_ret(a1, v4, v19, 8);
}
// 471E30: variable 'v3' is possibly undefined
// 471E3C: variable 'v1' is possibly undefined
// 471E64: variable 'v2' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00472234) --------------------------------------------------------
int __fastcall sub_472234(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  const char *v4; // $s0
  char *v5; // $v1
  const char *v6; // $v0
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  int v10; // $a1
  unsigned int v11; // $a2
  char *v13; // $s0
  const char *v14; // $v0
  const char *v15; // $s1
  char *v16; // $v0
  char *v17; // $v0
  const char *v18; // $s4
  __int64 v19; // $v0
  int v20; // $v0
  int v21; // $v0
  uint32_t v22; // $v0
  int v23[2560]; // [sp+20h] [-291Ch] BYREF
  char v24[256]; // [sp+2820h] [-11Ch] BYREF
  int v25; // [sp+2920h] [-1Ch] BYREF
  int v26; // [sp+2924h] [-18h]
  int v27; // [sp+2928h] [-14h]
  int v28; // [sp+292Ch] [-10h]
  int v29; // [sp+2930h] [-Ch]

  memset(v24, 0, sizeof(v24));
  v3 = httpd_get_parm(a1, "id");
  v2 = httpd_get_parm(a1, "opt");
  if ( v3 )
  {
    v4 = v2;
    if ( v2 )
    {
      if ( strcmp(v2, "all") )
      {
        if ( !strcmp(v4, "select") )
        {
          v15 = (const char *)v23;
          memset(v23, 0, sizeof(v23));
          v16 = httpd_get_parm(a1, "ips");
          if ( v16 )
          {
            strlcpy(v23, v16, 10240);
            while ( 1 )
            {
              if ( !*v15 )
                goto LABEL_5;
              v17 = strchr(v15, 124);
              v18 = 0;
              if ( v17 )
              {
                v18 = v17 + 1;
                *v17 = 0;
              }
              v25 = 0;
              v26 = 0;
              v27 = 0;
              v28 = 0;
              v29 = 0;
              if ( strchr(v15, 46) || strchr(v15, 58) )
              {
                StrToIpaddr(v15, &v25);
                LODWORD(v19) = v26;
              }
              else
              {
                v22 = J_atoi(v15);
                LODWORD(v19) = htonl(v22);
                v26 = v19;
              }
              if ( (_BYTE)v25 )
                break;
              if ( (_DWORD)v19 )
                goto LABEL_27;
LABEL_25:
              if ( !v18 )
                goto LABEL_5;
              v15 = v18;
            }
            HIDWORD(v19) = v27 | v28 | v29;
            if ( !v19 )
              goto LABEL_25;
LABEL_27:
            v20 = jhl_nv_get_def("macuser_down_del");
            v21 = J_atoi(v20);
            user_ipdown_set(&v25, v21);
            goto LABEL_25;
          }
        }
        goto LABEL_5;
      }
      if ( !strcmp(v3, "pppoe") )
      {
        v13 = "pppoe";
      }
      else
      {
        if ( strcmp(v3, "web") )
          goto LABEL_5;
        v13 = "web";
      }
      v23[0] = (int)"wys";
      v23[1] = (int)"user";
      v23[2] = (int)"down_all";
      v23[3] = (int)v13;
      v23[4] = 0;
      eval(v23, 0, 0, 0);
LABEL_5:
      v5 = v24;
      v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v7 = *(_DWORD *)v6;
        v8 = *((_DWORD *)v6 + 1);
        v9 = *((_DWORD *)v6 + 2);
        v10 = *((_DWORD *)v6 + 3);
        v6 += 16;
        *(_DWORD *)v5 = v7;
        *((_DWORD *)v5 + 1) = v8;
        *((_DWORD *)v5 + 2) = v9;
        *((_DWORD *)v5 + 3) = v10;
        v5 += 16;
      }
      while ( v6 != "}" );
      v11 = 33;
      *(_WORD *)v5 = *(_WORD *)v6;
      return httpd_cgi_ret(a1, v24, v11, 4);
    }
  }
  v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not id or opt");
  v11 = snprintf(v24, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
  if ( v11 >= 0x100 )
    v11 = 255;
  return httpd_cgi_ret(a1, v24, v11, 4);
}
// 6A8284: using guessed type int __fastcall StrToIpaddr(_DWORD, _DWORD);
// 6A82C4: using guessed type int __fastcall user_ipdown_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00472668) --------------------------------------------------------
int __fastcall sub_472668(int a1)
{
  int v2; // $a2
  int v3; // $v0
  int v4; // $a0
  char *v5; // $v1
  const char *v6; // $v0
  int v7; // $t1
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  char v12[1024]; // [sp+18h] [-400h] BYREF

  nvram_set("wt_router_id", "");
  nvram_set("wt_dev_addr", "");
  nvram_set("wt_dev_cont", "");
  nvram_set("wt_dev_tel", "");
  nvram_set("wt_dev_name", "");
  nvram_set("wt_dev_dinate", "");
  nvram_set("wt_agent_id", "");
  nvram_set("wt_dev_pwd", "");
  nvram_set("wt_route_type", "0");
  nvram_set("wt_dev_replace_id", "0");
  nvram_set("wt_dev_routerid", "0");
  nvram_set("wt_dev_randid", "0");
  v3 = _GET_LANG_TEXT(53, *(unsigned __int8 *)(a1 + 210102), v2);
  nvram_set("ac_mng_state", v3);
  nvram_set("wt_dev_type", "0");
  nvram_set("wt_dev_offlinenotauth", "65");
  nvram_set("wt_third_agent_id", "");
  nvram_set("wt_nofeel_auth_id", "56");
  nvram_set("rzglType", "0");
  start_rzgl(0);
  wt_client_restart(0);
  mng_client_restart(0);
  jhl_parm_commit(v4);
  v5 = v12;
  v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v7 = *(_DWORD *)v6;
    v8 = *((_DWORD *)v6 + 1);
    v9 = *((_DWORD *)v6 + 2);
    v10 = *((_DWORD *)v6 + 3);
    v6 += 16;
    *(_DWORD *)v5 = v7;
    *((_DWORD *)v5 + 1) = v8;
    *((_DWORD *)v5 + 2) = v9;
    *((_DWORD *)v5 + 3) = v10;
    v5 += 16;
  }
  while ( v6 != "}" );
  *(_WORD *)v5 = *(_WORD *)v6;
  return httpd_cgi_ret(a1, v12, 33, 4);
}
// 4727F8: variable 'v2' is possibly undefined
// 472908: variable 'v4' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8354: using guessed type int __fastcall wt_client_restart(_DWORD);
// 6A83A0: using guessed type int __fastcall mng_client_restart(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (00472988) --------------------------------------------------------
int __fastcall sub_472988(int a1)
{
  int v2; // $a2
  int v3; // $v0
  int v4; // $a0
  char *v5; // $v1
  const char *v6; // $v0
  int v7; // $t1
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  char v12[1024]; // [sp+18h] [-400h] BYREF

  nvram_set("wt_base_enable", "0");
  nvram_set("wt_router_id", "");
  nvram_set("wt_dev_addr", "");
  nvram_set("wt_dev_cont", "");
  nvram_set("wt_dev_tel", "");
  nvram_set("wt_dev_name", "");
  nvram_set("wt_dev_dinate", "");
  nvram_set("wt_agent_id", "");
  nvram_set("wt_dev_pwd", "");
  nvram_set("wt_route_type", "0");
  nvram_set("wt_dev_replace_id", "0");
  nvram_set("wt_dev_routerid", "0");
  nvram_set("wt_dev_randid", "0");
  v3 = _GET_LANG_TEXT(53, *(unsigned __int8 *)(a1 + 210102), v2);
  nvram_set("ac_mng_state", v3);
  nvram_set("wt_dev_type", "0");
  nvram_set("wt_dev_offlinenotauth", "65");
  nvram_set("wt_third_agent_id", "");
  nvram_set("wt_nofeel_auth_id", "56");
  wt_client_restart(0);
  mng_client_restart(0);
  jhl_parm_commit(v4);
  v5 = v12;
  v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v7 = *(_DWORD *)v6;
    v8 = *((_DWORD *)v6 + 1);
    v9 = *((_DWORD *)v6 + 2);
    v10 = *((_DWORD *)v6 + 3);
    v6 += 16;
    *(_DWORD *)v5 = v7;
    *((_DWORD *)v5 + 1) = v8;
    *((_DWORD *)v5 + 2) = v9;
    *((_DWORD *)v5 + 3) = v10;
    v5 += 16;
  }
  while ( v6 != "}" );
  *(_WORD *)v5 = *(_WORD *)v6;
  return httpd_cgi_ret(a1, v12, 33, 4);
}
// 472B34: variable 'v2' is possibly undefined
// 472C10: variable 'v4' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8354: using guessed type int __fastcall wt_client_restart(_DWORD);
// 6A83A0: using guessed type int __fastcall mng_client_restart(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00472C90) --------------------------------------------------------
int __fastcall sub_472C90(int a1)
{
  const char *v2; // $v0
  signed int v3; // $v0
  char *v4; // $s0

  v2 = (const char *)nvram_get("wx_wifi_jump_html");
  if ( !v2 )
    return httpd_send_html_file(a1, "text/html", "", 0);
  v4 = (char *)v2;
  v3 = strlen(v2);
  return httpd_send_html_file(a1, "text/html", v4, v3);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (00472D44) --------------------------------------------------------
int __fastcall sub_472D44(int a1)
{
  const char *v2; // $v0
  const char *v3; // $s0
  int v4; // $v0
  char v6[200]; // [sp+18h] [-11Ch] BYREF
  int v7[12]; // [sp+E0h] [-54h] BYREF
  int v8[5]; // [sp+110h] [-24h] BYREF
  int v9; // [sp+124h] [-10h] BYREF
  __int16 v10; // [sp+128h] [-Ch]

  v9 = 0;
  v10 = 0;
  v7[0] = 0;
  v7[1] = 0;
  v7[2] = 0;
  v7[3] = 0;
  v7[4] = 0;
  v7[5] = 0;
  v7[6] = 0;
  v7[7] = 0;
  v7[8] = 0;
  v7[9] = 0;
  v7[10] = 0;
  v7[11] = 0;
  v8[0] = 0;
  v8[1] = 0;
  v8[2] = 0;
  v8[3] = 0;
  v8[4] = 0;
  find_hs_mac((_DWORD *)a1, (int)&v9, 0);
  v3 = (const char *)IpaddrToStr(v7, a1 + 205460);
  v2 = (const char *)MacToStr(v8, &v9);
  v4 = sprintf(v6, "{\"ip\":\"%s\",\"mac\":\"%s\"}", v3, v2);
  return httpd_cgi_ret(a1, v6, v4, 4);
}
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);

//----- (00472E50) --------------------------------------------------------
int __fastcall sub_472E50(int a1)
{
  char *v2; // $s5
  char *v3; // $s4
  char *v4; // $s3
  char *v5; // $s6
  int v6; // $a0
  char *v7; // $s2
  int v8; // $s5
  int v9; // $s4
  char *v10; // $v1
  const char *v11; // $v0
  int v12; // $t0
  int v13; // $a3
  int v14; // $a2
  int v15; // $a1
  char v17[260]; // [sp+18h] [-104h] BYREF

  memset(v17, 0, 0x100u);
  v2 = httpd_get_parm(a1, "svr_host");
  v3 = httpd_get_parm(a1, "svr_port");
  v4 = httpd_get_parm(a1, "agt_host");
  v5 = httpd_get_parm(a1, "api_port");
  v7 = httpd_get_parm(a1, "api_type");
  if ( v2 && !nvram_match_def("mqtt_cbg_svr_host", v2) )
  {
    nvram_set("mqtt_cbg_svr_host", v2);
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  if ( v3 && !nvram_match_def("mqtt_cbg_svr_port", v3) )
  {
    nvram_set("mqtt_cbg_svr_port", v3);
    v9 = 1;
  }
  else
  {
    v9 = v8;
  }
  if ( v4 && !nvram_match_def(&unk_6487EC, v4) )
  {
    nvram_set(&unk_6487EC, v4);
    v9 = 1;
  }
  if ( !v7 || nvram_match_def("billing_api_type", v7) )
  {
    if ( !v5 || nvram_match_def("billing_api_port", v5) )
    {
      if ( !v9 )
        goto LABEL_15;
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  nvram_set("billing_api_type", v7);
  if ( v5 && !nvram_match_def("billing_api_port", v5) )
LABEL_20:
    nvram_set("billing_api_port", v5);
LABEL_21:
  jhl_parm_commit(v6);
  if ( nvram_match_def("billing_en", "1") )
  {
    start_rzgl(v8);
    restart_wys_billing();
  }
LABEL_15:
  v10 = v17;
  v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v12 = *(_DWORD *)v11;
    v13 = *((_DWORD *)v11 + 1);
    v14 = *((_DWORD *)v11 + 2);
    v15 = *((_DWORD *)v11 + 3);
    v11 += 16;
    *(_DWORD *)v10 = v12;
    *((_DWORD *)v10 + 1) = v13;
    *((_DWORD *)v10 + 2) = v14;
    *((_DWORD *)v10 + 3) = v15;
    v10 += 16;
  }
  while ( v11 != "}" );
  *(_WORD *)v10 = *(_WORD *)v11;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 4730F0: variable 'v6' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82BC: using guessed type int restart_wys_billing(void);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (004731AC) --------------------------------------------------------
int __fastcall sub_4731AC(int a1)
{
  char *v1; // $v0
  int v3; // $v0
  char v5[1024]; // [sp+20h] [-414h] BYREF
  int v6; // [sp+420h] [-14h] BYREF
  int v7; // [sp+424h] [-10h] BYREF
  int v8[3]; // [sp+428h] [-Ch] BYREF

  v8[0] = 0;
  v7 = 0;
  v6 = 0;
  v1 = httpd_get_parm(a1, "name");
  if ( v1 )
    user_get_ddate(v1, v8, &v7, &v6);
  v3 = sprintf(v5, "{\"tm\":%u,\"login_num\":%u,\"state\":%u}", v8[0], v7, v6);
  return httpd_cgi_ret(a1, v5, v3, 4);
}
// 6A8980: using guessed type int __fastcall user_get_ddate(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00473268) --------------------------------------------------------
int __fastcall sub_473268(int a1)
{
  char *v1; // $v0
  const char *v3; // $s0
  const char *v4; // $v0
  char *v5; // $v1
  int v6; // $t1
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  char v11[132]; // [sp+18h] [-84h] BYREF

  v1 = httpd_get_parm(a1, "fn");
  if ( v1 )
  {
    v3 = v1;
    if ( !strcmp(v1, "notify_htm")
      || !strcmp(v3, "auth_htm")
      || !strcmp(v3, "ddate_htm")
      || !strcmp(v3, "install_htm")
      || !strcmp(v3, "jdauth_htm")
      || !strcmp(v3, "ddate_notify_htm")
      || !strcmp(v3, "userinfo_htm")
      || !strcmp(v3, "second_auth_htm") )
    {
      nvram_unset(v3);
      nvram_commit();
    }
    if ( !strcmp(v3, "auth_pic") )
    {
      system("rm -rf /tmp/auth_pic");
      if ( check_usb_state() )
        system("rm -rf /tmp/mnt/sda1/auth_pic");
    }
    else if ( !strcmp(v3, "auth_html") )
    {
      system("rm -rf /tmp/auth_html");
      if ( check_usb_state() )
        system("rm -rf /tmp/mnt/sda1/auth_html");
    }
  }
  v4 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v5 = v11;
  do
  {
    v6 = *(_DWORD *)v4;
    v7 = *((_DWORD *)v4 + 1);
    v8 = *((_DWORD *)v4 + 2);
    v9 = *((_DWORD *)v4 + 3);
    v4 += 16;
    *(_DWORD *)v5 = v6;
    *((_DWORD *)v5 + 1) = v7;
    *((_DWORD *)v5 + 2) = v8;
    *((_DWORD *)v5 + 3) = v9;
    v5 += 16;
  }
  while ( v4 != "}" );
  *(_WORD *)v5 = *(_WORD *)v4;
  return httpd_cgi_ret(a1, v11, 33, 4);
}
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A87C4: using guessed type int nvram_commit(void);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (00473540) --------------------------------------------------------
int __fastcall sub_473540(int a1)
{
  signed int v2; // $s2
  char *v3; // $v0
  char *v4; // $s3
  char *v5; // $v0
  int v6; // $a2
  const char *v7; // $v0
  unsigned int v8; // $v0
  const char *v10; // $v0
  int v11; // $v0
  char v12[1024]; // [sp+20h] [-484h] BYREF
  char v13[132]; // [sp+420h] [-84h] BYREF

  strcpy(v13, "Error reading file");
  memset(&v13[19], 0, 0x6Du);
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  v4 = v3;
  if ( v3 )
  {
    v2 = *(_DWORD *)(a1 + 205564) + v2 - (_DWORD)v3;
    v5 = find_file_end(a1, v3, v2);
    if ( v5 )
    {
      v2 = v5 - v4;
      if ( v5 - v4 < 10241 )
      {
        *v5 = 0;
        jhl_parm_set("auth_htm", v4);
        nvram_commit();
        v13[0] = 0;
        goto LABEL_5;
      }
      v11 = _GET_LANG_TEXT(137, *(unsigned __int8 *)(a1 + 210102), 16);
      strlcpy(v13, v11, 128);
    }
    else
    {
      v6 = 4945;
      if ( debug_level > 0 )
        printf("%s:%d find_file_end err \n", "webauthfile_cgi", 4945);
    }
  }
  else
  {
    v6 = 4938;
    if ( debug_level > 0 )
      printf("%s:%d find_file_head err  \n", "webauthfile_cgi", 4938);
  }
  if ( v13[0] )
  {
    if ( write_tg_html_to_usb(v4, v2, "webauthfile") )
    {
      if ( v13[0] )
      {
        v10 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v13);
        v8 = snprintf(v12, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
        if ( v8 < 0x400 )
          return httpd_cgi_ret(a1, v12, v8, 4);
LABEL_13:
        v8 = 1023;
        return httpd_cgi_ret(a1, v12, v8, 4);
      }
    }
    else
    {
      jhl_parm_set("auth_htm", &off_4CFA50);
      v13[0] = 0;
    }
  }
LABEL_5:
  v7 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v6);
  v8 = snprintf(v12, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v7);
  if ( v8 >= 0x400 )
    goto LABEL_13;
  return httpd_cgi_ret(a1, v12, v8, 4);
}
// 4735E4: variable 'v3' is possibly undefined
// 473668: variable 'v6' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 67D0BC: using guessed type int debug_level;
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8338: using guessed type int __fastcall write_tg_html_to_usb(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A87C4: using guessed type int nvram_commit(void);

//----- (0047383C) --------------------------------------------------------
int __fastcall sub_47383C(int a1)
{
  signed int v2; // $s2
  char *v3; // $v0
  char *v4; // $s3
  char *v5; // $v0
  int v6; // $a2
  const char *v7; // $v0
  unsigned int v8; // $v0
  const char *v10; // $v0
  int v11; // $v0
  char v12[1024]; // [sp+20h] [-484h] BYREF
  char v13[132]; // [sp+420h] [-84h] BYREF

  strcpy(v13, "Error reading file");
  memset(&v13[19], 0, 0x6Du);
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  v4 = v3;
  if ( v3 )
  {
    v2 = *(_DWORD *)(a1 + 205564) + v2 - (_DWORD)v3;
    v5 = find_file_end(a1, v3, v2);
    if ( v5 )
    {
      v2 = v5 - v4;
      if ( v5 - v4 < 10241 )
      {
        *v5 = 0;
        jhl_parm_set("ddate_htm", v4);
        nvram_commit();
        v13[0] = 0;
        goto LABEL_5;
      }
      v11 = _GET_LANG_TEXT(137, *(unsigned __int8 *)(a1 + 210102), 10);
      strlcpy(v13, v11, 128);
    }
    else
    {
      v6 = 5015;
      if ( debug_level > 0 )
        printf("%s:%d find_file_end err \n", "ddatefile_cgi", 5015);
    }
  }
  else
  {
    v6 = 5008;
    if ( debug_level > 0 )
      printf("%s:%d find_file_head err  \n", "ddatefile_cgi", 5008);
  }
  if ( v13[0] )
  {
    if ( write_tg_html_to_usb(v4, v2, "ddatefile") )
    {
      if ( v13[0] )
      {
        v10 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v13);
        v8 = snprintf(v12, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
        if ( v8 < 0x400 )
          return httpd_cgi_ret(a1, v12, v8, 4);
LABEL_13:
        v8 = 1023;
        return httpd_cgi_ret(a1, v12, v8, 4);
      }
    }
    else
    {
      jhl_parm_set("ddate_htm", &off_4CFA50);
      v13[0] = 0;
    }
  }
LABEL_5:
  v7 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v6);
  v8 = snprintf(v12, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v7);
  if ( v8 >= 0x400 )
    goto LABEL_13;
  return httpd_cgi_ret(a1, v12, v8, 4);
}
// 4738E0: variable 'v3' is possibly undefined
// 473964: variable 'v6' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 67D0BC: using guessed type int debug_level;
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8338: using guessed type int __fastcall write_tg_html_to_usb(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A87C4: using guessed type int nvram_commit(void);

//----- (00473B38) --------------------------------------------------------
int __fastcall sub_473B38(int a1)
{
  signed int v2; // $s2
  char *v3; // $v0
  char *v4; // $s3
  char *v5; // $v0
  int v6; // $a2
  const char *v7; // $v0
  unsigned int v8; // $v0
  const char *v10; // $v0
  int v11; // $v0
  char v12[1024]; // [sp+20h] [-484h] BYREF
  char v13[132]; // [sp+420h] [-84h] BYREF

  strcpy(v13, "Error reading file");
  memset(&v13[19], 0, 0x6Du);
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  v4 = v3;
  if ( v3 )
  {
    v2 = *(_DWORD *)(a1 + 205564) + v2 - (_DWORD)v3;
    v5 = find_file_end(a1, v3, v2);
    if ( v5 )
    {
      v2 = v5 - v4;
      if ( v5 - v4 < 10241 )
      {
        *v5 = 0;
        jhl_parm_set("notify_htm", v4);
        nvram_commit();
        v13[0] = 0;
        goto LABEL_5;
      }
      v11 = _GET_LANG_TEXT(137, *(unsigned __int8 *)(a1 + 210102), 10);
      strlcpy(v13, v11, 128);
    }
    else
    {
      v6 = 5082;
      if ( debug_level > 0 )
        printf("%s:%d find_file_end err \n", "tongguang_cgi", 5082);
    }
  }
  else
  {
    v6 = 5075;
    if ( debug_level > 0 )
      printf("%s:%d find_file_head err  \n", "tongguang_cgi", 5075);
  }
  if ( v13[0] )
  {
    if ( write_tg_html_to_usb(v4, v2, "notifyfile") )
    {
      if ( v13[0] )
      {
        v10 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v13);
        v8 = snprintf(v12, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
        if ( v8 < 0x400 )
          return httpd_cgi_ret(a1, v12, v8, 4);
LABEL_13:
        v8 = 1023;
        return httpd_cgi_ret(a1, v12, v8, 4);
      }
    }
    else
    {
      jhl_parm_set("notify_htm", &off_4CFA50);
      v13[0] = 0;
    }
  }
LABEL_5:
  v7 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v6);
  v8 = snprintf(v12, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v7);
  if ( v8 >= 0x400 )
    goto LABEL_13;
  return httpd_cgi_ret(a1, v12, v8, 4);
}
// 473BDC: variable 'v3' is possibly undefined
// 473C60: variable 'v6' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 67D0BC: using guessed type int debug_level;
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8338: using guessed type int __fastcall write_tg_html_to_usb(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A87C4: using guessed type int nvram_commit(void);

//----- (00473E34) --------------------------------------------------------
int __fastcall sub_473E34(int a1)
{
  signed int v2; // $s2
  char *v3; // $v0
  char *v4; // $s3
  char *v5; // $v0
  int v6; // $a2
  const char *v7; // $v0
  unsigned int v8; // $v0
  const char *v10; // $v0
  int v11; // $v0
  char v12[1024]; // [sp+20h] [-484h] BYREF
  char v13[132]; // [sp+420h] [-84h] BYREF

  strcpy(v13, "Error reading file");
  memset(&v13[19], 0, 0x6Du);
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  v4 = v3;
  if ( v3 )
  {
    v2 = *(_DWORD *)(a1 + 205564) + v2 - (_DWORD)v3;
    v5 = find_file_end(a1, v3, v2);
    if ( v5 )
    {
      v2 = v5 - v4;
      if ( v5 - v4 < 10241 )
      {
        *v5 = 0;
        jhl_parm_set("ddate_notify_htm", v4);
        nvram_commit();
        v13[0] = 0;
        goto LABEL_5;
      }
      v11 = _GET_LANG_TEXT(137, *(unsigned __int8 *)(a1 + 210102), 10);
      strlcpy(v13, v11, 128);
    }
    else
    {
      v6 = 5150;
      if ( debug_level > 0 )
        printf("%s:%d find_file_end err \n", "ddate_notifyfile_cgi", 5150);
    }
  }
  else
  {
    v6 = 5143;
    if ( debug_level > 0 )
      printf("%s:%d find_file_head err  \n", "ddate_notifyfile_cgi", 5143);
  }
  if ( v13[0] )
  {
    if ( write_tg_html_to_usb(v4, v2, "ddatenotifyfile") )
    {
      if ( v13[0] )
      {
        v10 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v13);
        v8 = snprintf(v12, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
        if ( v8 < 0x400 )
          return httpd_cgi_ret(a1, v12, v8, 4);
LABEL_13:
        v8 = 1023;
        return httpd_cgi_ret(a1, v12, v8, 4);
      }
    }
    else
    {
      jhl_parm_set("ddate_notify_htm", &off_4CFA50);
      v13[0] = 0;
    }
  }
LABEL_5:
  v7 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v6);
  v8 = snprintf(v12, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v7);
  if ( v8 >= 0x400 )
    goto LABEL_13;
  return httpd_cgi_ret(a1, v12, v8, 4);
}
// 473ED8: variable 'v3' is possibly undefined
// 473F5C: variable 'v6' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 67D0BC: using guessed type int debug_level;
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8338: using guessed type int __fastcall write_tg_html_to_usb(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A87C4: using guessed type int nvram_commit(void);

//----- (00474130) --------------------------------------------------------
int __fastcall sub_474130(int a1)
{
  int v1; // $a2
  int v3; // $a1
  int v4; // $a0
  const char *v5; // $v0
  unsigned int v6; // $a2
  int v8; // $v0
  void *v9; // $a2
  char v10[256]; // [sp+20h] [-10Ch] BYREF
  void *v11; // [sp+120h] [-Ch] BYREF

  if ( check_usb_state() )
  {
    read_file_buf("/tmp/mnt/sda1/auth_html/auth.tar.gz", (int *)&v11);
    if ( v8 >= 0 )
    {
      v9 = v11;
      *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
      return httpd_send_mime_file(a1, "application/binary-file", v9, v8);
    }
    if ( v8 == -3 )
    {
      v5 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), -1);
      goto LABEL_4;
    }
    v3 = *(unsigned __int8 *)(a1 + 210102);
    if ( v8 == -2 )
      v4 = 143;
    else
      v4 = 144;
  }
  else
  {
    v3 = *(unsigned __int8 *)(a1 + 210102);
    v4 = 142;
  }
  v5 = (const char *)_GET_LANG_TEXT(v4, v3, v1);
LABEL_4:
  v6 = snprintf(v10, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v5);
  if ( v6 >= 0x100 )
    v6 = 255;
  return httpd_cgi_ret(a1, v10, v6, 4);
}
// 47417C: variable 'v1' is possibly undefined
// 474204: variable 'v8' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (004742B4) --------------------------------------------------------
int __fastcall sub_4742B4(int a1)
{
  void *v2; // $v0
  char *v3; // $s2
  int v4; // $v0
  void *v5; // $s1
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[256]; // [sp+20h] [-100h] BYREF

  v3 = httpd_get_parm(a1, "id");
  _mem_malloc(0x200000, "users_txt", 1893);
  if ( v2 )
  {
    v5 = v2;
    v4 = user_get_file_csv(v2, 0x200000, v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v5, v4);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 474310: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A86F0: using guessed type int __fastcall user_get_file_csv(_DWORD, _DWORD, _DWORD);

//----- (004743FC) --------------------------------------------------------
int __fastcall sub_4743FC(int a1)
{
  char *v2; // $v0
  char *v3; // $v0
  int result; // $v0
  char v5[1028]; // [sp+18h] [-404h] BYREF

  memset(v5, 0, 0x400u);
  strlcpy(v5, *(_DWORD *)(a1 + 205536), 1024);
  v2 = strchr(v5, 44);
  if ( v2 )
    *v2 = 0;
  v3 = strchr(v5, 59);
  if ( v3 )
    *v3 = 0;
  result = strncmp(v5, "zh", 2u);
  if ( result )
    result = strncmp(v5, "en", 2u) == 0;
  return result;
}
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);

//----- (004744F0) --------------------------------------------------------
int __fastcall sub_4744F0(int a1)
{
  char *v2; // $s0
  const char *v3; // $v0
  char *v4; // $v1
  const char *v5; // $v0
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  int v9; // $a1
  const char *v11; // $v0
  char v12[260]; // [sp+18h] [-104h] BYREF

  memset(v12, 0, 0x100u);
  v2 = httpd_get_parm(a1, "timeout");
  if ( v2 && ((v3 = (const char *)nvram_get("rzgl_mac_timeout")) == 0 || strcmp(v3, v2))
    || (v11 = (const char *)nvram_get("rzgl_mac_en")) == 0
    || strcmp(v11, "2") )
  {
    nvram_set("rzgl_mac_timeout", v2);
    nvram_set("rzgl_mac_en", "2");
    macuser_conf_set();
  }
  v4 = v12;
  v5 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v6 = *(_DWORD *)v5;
    v7 = *((_DWORD *)v5 + 1);
    v8 = *((_DWORD *)v5 + 2);
    v9 = *((_DWORD *)v5 + 3);
    v5 += 16;
    *(_DWORD *)v4 = v6;
    *((_DWORD *)v4 + 1) = v7;
    *((_DWORD *)v4 + 2) = v8;
    *((_DWORD *)v4 + 3) = v9;
    v4 += 16;
  }
  while ( v5 != "}" );
  *(_WORD *)v4 = *(_WORD *)v5;
  return httpd_cgi_ret(a1, v12, 33, 4);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A86DC: using guessed type int macuser_conf_set(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004746CC) --------------------------------------------------------
int __fastcall sub_4746CC(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  const char *v4; // $s1
  int v5; // $a0
  char *v6; // $v1
  const char *v7; // $v0
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  int v11; // $a1
  char v13[260]; // [sp+18h] [-104h] BYREF

  memset(v13, 0, 0x100u);
  v2 = httpd_get_parm(a1, "en");
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("user_list_enable");
    if ( !v3 || strcmp(v3, v4) )
    {
      nvram_set("user_list_enable", v4);
      jhl_parm_commit(v5);
    }
  }
  v6 = v13;
  v7 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v8 = *(_DWORD *)v7;
    v9 = *((_DWORD *)v7 + 1);
    v10 = *((_DWORD *)v7 + 2);
    v11 = *((_DWORD *)v7 + 3);
    v7 += 16;
    *(_DWORD *)v6 = v8;
    *((_DWORD *)v6 + 1) = v9;
    *((_DWORD *)v6 + 2) = v10;
    *((_DWORD *)v6 + 3) = v11;
    v6 += 16;
  }
  while ( v7 != "}" );
  *(_WORD *)v6 = *(_WORD *)v7;
  return httpd_cgi_ret(a1, v13, 33, 4);
}
// 474794: variable 'v5' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0047481C) --------------------------------------------------------
int __fastcall sub_47481C(int a1)
{
  char *v2; // $s2
  char *v3; // $s4
  char *v4; // $s0
  char *v5; // $s1
  const char *v6; // $v0
  int v7; // $s2
  const char *v8; // $v0
  const char *v9; // $v0
  const char *v10; // $v0
  int v11; // $a0
  const char *v12; // $v0
  const char *v13; // $v0
  char *v14; // $v1
  int v15; // $t1
  int v16; // $t0
  int v17; // $a3
  int v18; // $a2
  char v20[1028]; // [sp+18h] [-404h] BYREF

  v2 = httpd_get_parm(a1, "fip");
  v3 = httpd_get_parm(a1, "dns");
  v4 = httpd_get_parm(a1, "host");
  v5 = httpd_get_parm(a1, (char *)&off_646724);
  if ( !v2 )
    goto LABEL_33;
  if ( (*v2 & 0xDF) == 0 )
    v2 = "";
  v6 = (const char *)nvram_get("rzglFip");
  if ( v6 && !strcmp(v6, v2) )
  {
LABEL_33:
    v7 = 0;
  }
  else
  {
    jhl_parm_set("rzglFip", v2);
    v7 = 1;
  }
  if ( v4 )
  {
    if ( (*v4 & 0xDF) == 0 )
      v4 = "";
    v8 = (const char *)nvram_get("rzglDns");
    if ( v8 && v3 && !strcmp(v8, v3) )
    {
      if ( !v5 )
      {
        nvram_get("rzglMac");
LABEL_23:
        jhl_parm_set("rzglMac", v5);
        goto LABEL_24;
      }
      goto LABEL_15;
    }
    jhl_parm_set("rzglDns", v3);
    v7 = 1;
  }
  if ( !v5 )
    goto LABEL_25;
LABEL_15:
  if ( (*v5 & 0xDF) == 0 )
    v5 = "";
  v9 = (const char *)nvram_get("rzglHost");
  if ( v9 && v4 && !strcmp(v9, v4) )
  {
LABEL_25:
    if ( v3 )
    {
      v12 = (const char *)nvram_get("rzglMac");
      if ( !v12 || !v5 || strcmp(v12, v5) )
        goto LABEL_23;
    }
    goto LABEL_29;
  }
  jhl_parm_set("rzglHost", v4);
  if ( v3 )
  {
    v10 = (const char *)nvram_get("rzglMac");
    if ( !v10 )
      goto LABEL_23;
    v7 = 1;
    if ( strcmp(v10, v5) )
      goto LABEL_23;
LABEL_29:
    if ( !v7 )
      goto LABEL_30;
  }
LABEL_24:
  start_rzgl(1);
  restart_third_rzgl();
  jhl_parm_commit(v11);
LABEL_30:
  v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v14 = v20;
  do
  {
    v15 = *(_DWORD *)v13;
    v16 = *((_DWORD *)v13 + 1);
    v17 = *((_DWORD *)v13 + 2);
    v18 = *((_DWORD *)v13 + 3);
    v13 += 16;
    *(_DWORD *)v14 = v15;
    *((_DWORD *)v14 + 1) = v16;
    *((_DWORD *)v14 + 2) = v17;
    *((_DWORD *)v14 + 3) = v18;
    v14 += 16;
  }
  while ( v13 != "}" );
  *(_WORD *)v14 = *(_WORD *)v13;
  return httpd_cgi_ret(a1, v20, 33, 4);
}
// 474AA8: variable 'v11' is possibly undefined
// 646724: using guessed type void *off_646724;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8514: using guessed type int restart_third_rzgl(void);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (00474BE4) --------------------------------------------------------
int __fastcall sub_474BE4(int a1)
{
  char *v2; // $s2
  char *v3; // $s3
  char *v4; // $s4
  char *v5; // $s5
  const char *v6; // $v0
  int v7; // $a0
  const char *v8; // $v0
  int v9; // $s3
  bool v10; // dc
  char *v11; // $v1
  const char *v12; // $v0
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  int v16; // $a1
  int v18; // $v0
  int v19; // $a2
  const char *v20; // $v0
  unsigned int v21; // $v0
  char v22[256]; // [sp+20h] [-100h] BYREF

  memset(v22, 0, sizeof(v22));
  v2 = httpd_get_parm(a1, "en");
  v3 = httpd_get_parm(a1, "rname");
  v4 = httpd_get_parm(a1, "dev_pwd");
  v5 = httpd_get_parm(a1, "ipoff_en");
  v6 = (const char *)jhl_nv_get_def("dual_lan_mode");
  if ( !strcmp(v6, "1") || (v8 = (const char *)nvram_get("wt_base_enable")) == 0 || strcmp(v8, "1") || !J_atoi(v2) )
  {
    if ( v3 && !nvram_match_def("billing_rname", v3) )
    {
      nvram_set("billing_rname", v3);
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    if ( v4 && !nvram_match_def("billing_dev_pwd", v4) )
    {
      nvram_set("billing_dev_pwd", v4);
      v9 = 1;
    }
    if ( v5 && !nvram_match_def("billing_no_ipoff", v5) )
    {
      nvram_set("billing_no_ipoff", v5);
      if ( !v2 || nvram_match_def("billing_en", v2) )
        goto LABEL_21;
    }
    else if ( !v2 || nvram_match_def("billing_en", v2) )
    {
      v10 = v9 != 0;
      v9 = 1;
      if ( !v10 )
      {
LABEL_15:
        v11 = v22;
        v12 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v13 = *(_DWORD *)v12;
          v14 = *((_DWORD *)v12 + 1);
          v15 = *((_DWORD *)v12 + 2);
          v16 = *((_DWORD *)v12 + 3);
          v12 += 16;
          *(_DWORD *)v11 = v13;
          *((_DWORD *)v11 + 1) = v14;
          *((_DWORD *)v11 + 2) = v15;
          *((_DWORD *)v11 + 3) = v16;
          v11 += 16;
        }
        while ( v12 != "}" );
        *(_WORD *)v11 = *(_WORD *)v12;
        return httpd_cgi_ret(a1, v22, 33, 4);
      }
LABEL_21:
      jhl_parm_commit(v7);
      if ( v9 )
        restart_wys_billing();
      goto LABEL_15;
    }
    nvram_set("billing_en", v2);
    v9 = 1;
    v18 = reset_billing_rzgl_parm(v2);
    start_rzgl(v18);
    goto LABEL_21;
  }
  v20 = (const char *)_GET_LANG_TEXT(54, *(unsigned __int8 *)(a1 + 210102), v19);
  v21 = snprintf(v22, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v20);
  if ( v21 >= 0x100 )
    v21 = 255;
  return httpd_cgi_ret(a1, v22, v21, 4);
}
// 474EDC: variable 'v7' is possibly undefined
// 474F6C: variable 'v19' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82B0: using guessed type int __fastcall reset_billing_rzgl_parm(_DWORD);
// 6A82BC: using guessed type int restart_wys_billing(void);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00474FCC) --------------------------------------------------------
int __fastcall sub_474FCC(int a1)
{
  char *v2; // $s2
  char *v3; // $fp
  char *v4; // $s7
  char *v5; // $s3
  const char *v6; // $v0
  const char *v7; // $v0
  int v8; // $s1
  const char *v9; // $v0
  const char *v10; // $v0
  const char *v11; // $v0
  const char *v12; // $v0
  const char *v13; // $v0
  const char *v14; // $v0
  const char *v15; // $v0
  const char *v16; // $v0
  const char *v17; // $v0
  const char *v18; // $v0
  const char *v19; // $v0
  const char *v20; // $v0
  const char *v21; // $v0
  const char *v22; // $v0
  const char *v23; // $v0
  int v24; // $a0
  const char *v25; // $v0
  char *v26; // $v1
  int v27; // $t0
  int v28; // $a3
  int v29; // $a2
  int v30; // $a1
  int v32; // $a2
  const char *v33; // $v0
  unsigned int v34; // $v0
  char v35[1024]; // [sp+20h] [-438h] BYREF
  char *v36; // [sp+420h] [-38h]
  char *v37; // [sp+424h] [-34h]
  char *v38; // [sp+428h] [-30h]
  char *v39; // [sp+42Ch] [-2Ch]
  char *v40; // [sp+430h] [-28h]
  char *v41; // [sp+434h] [-24h]
  char *v42; // [sp+438h] [-20h]
  char *v43; // [sp+43Ch] [-1Ch]
  char *v44; // [sp+440h] [-18h]
  char *v45; // [sp+444h] [-14h]
  char *v46; // [sp+448h] [-10h]
  char *v47; // [sp+44Ch] [-Ch]
  char *v48; // [sp+450h] [-8h]

  v2 = httpd_get_parm(a1, "en");
  v3 = httpd_get_parm(a1, "addr");
  v4 = httpd_get_parm(a1, "port");
  v37 = httpd_get_parm(a1, "router_addr");
  v38 = httpd_get_parm(a1, "router_cont");
  v39 = httpd_get_parm(a1, "router_tel");
  v40 = httpd_get_parm(a1, "router_name");
  v41 = httpd_get_parm(a1, "router_dinate");
  v42 = httpd_get_parm(a1, "router_agents");
  v43 = httpd_get_parm(a1, "router_pwd");
  v44 = httpd_get_parm(a1, "route_type");
  v45 = httpd_get_parm(a1, "route_replace_id");
  v46 = httpd_get_parm(a1, "wt_dev_type");
  v47 = httpd_get_parm(a1, "wt_dev_offlinenotauth");
  v36 = httpd_get_parm(a1, "new_router_agents");
  v5 = httpd_get_parm(a1, "wt_nofeel_auth_id");
  if ( !v2 )
  {
    v8 = 0;
    goto LABEL_7;
  }
  v6 = (const char *)jhl_nv_get_def("dual_lan_mode");
  if ( !strcmp(v6, "1") || !nvram_match_def("billing_en", "1") || !J_atoi(v2) )
  {
    v48 = "a";
    v7 = (const char *)nvram_get("wt_base_enable");
    if ( !v7 || (v8 = 0, strcmp(v7, v2)) )
    {
      nvram_set(v48 + 30268, v2);
      v8 = 1;
    }
    reset_wtclient_rzgl_parm(v2);
    nvram_get(v48 + 30268);
LABEL_7:
    if ( v3 )
    {
      v9 = (const char *)nvram_get("ac_mng_srv_host");
      if ( !v9 || strcmp(v9, v3) )
      {
        nvram_set("ac_mng_srv_host", v3);
        v8 = 1;
      }
    }
    if ( v4 )
    {
      v10 = (const char *)nvram_get("ac_mng_srv_port");
      if ( !v10 || strcmp(v10, v4) )
      {
        nvram_set("ac_mng_srv_port", v4);
        v8 = 1;
      }
    }
    if ( v37 )
    {
      v11 = (const char *)nvram_get("wt_dev_addr");
      if ( !v11 || strcmp(v11, v37) )
      {
        nvram_set("wt_dev_addr", v37);
        v8 = 1;
      }
    }
    if ( v38 )
    {
      v12 = (const char *)nvram_get("wt_dev_cont");
      if ( !v12 || strcmp(v12, v38) )
      {
        nvram_set("wt_dev_cont", v38);
        v8 = 1;
      }
    }
    if ( v39 )
    {
      v13 = (const char *)nvram_get("wt_dev_tel");
      if ( !v13 || strcmp(v13, v39) )
      {
        nvram_set("wt_dev_tel", v39);
        v8 = 1;
      }
    }
    if ( v40 )
    {
      v14 = (const char *)nvram_get("wt_dev_name");
      if ( !v14 || strcmp(v14, v40) )
      {
        nvram_set("wt_dev_name", v40);
        v8 = 1;
      }
    }
    if ( v41 )
    {
      v15 = (const char *)nvram_get("wt_dev_dinate");
      if ( !v15 || strcmp(v15, v41) )
      {
        nvram_set("wt_dev_dinate", v41);
        v8 = 1;
      }
    }
    if ( v42 )
    {
      v16 = (const char *)nvram_get("wt_agent_id");
      if ( !v16 || strcmp(v16, v42) )
      {
        nvram_set("wt_agent_id", v42);
        v8 = 1;
      }
    }
    if ( v43 )
    {
      v17 = (const char *)nvram_get("wt_dev_pwd");
      if ( !v17 || strcmp(v17, v43) )
      {
        nvram_set("wt_dev_pwd", v43);
        v8 = 1;
      }
    }
    if ( v44 )
    {
      v18 = (const char *)nvram_get("wt_route_type");
      if ( !v18 || strcmp(v18, v44) )
      {
        nvram_set("wt_route_type", v44);
        v8 = 1;
      }
    }
    if ( v45 )
    {
      v19 = (const char *)nvram_get("wt_dev_replace_id");
      if ( !v19 || strcmp(v19, v45) )
      {
        nvram_set("wt_dev_replace_id", v45);
        v8 = 1;
      }
    }
    if ( v46 )
    {
      v20 = (const char *)nvram_get("wt_dev_type");
      if ( !v20 || strcmp(v20, v46) )
      {
        nvram_set("wt_dev_type", v46);
        v8 = 1;
      }
    }
    if ( v47 )
    {
      v21 = (const char *)nvram_get("wt_dev_offlinenotauth");
      if ( !v21 || strcmp(v21, v47) )
      {
        nvram_set("wt_dev_offlinenotauth", v47);
        v8 = 1;
      }
    }
    if ( !v36 || (v22 = (const char *)nvram_get("wt_third_agent_id")) != 0 && !strcmp(v22, v36) )
    {
      if ( !v5 )
      {
LABEL_77:
        if ( !v8 )
        {
LABEL_67:
          v25 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          v26 = v35;
          do
          {
            v27 = *(_DWORD *)v25;
            v28 = *((_DWORD *)v25 + 1);
            v29 = *((_DWORD *)v25 + 2);
            v30 = *((_DWORD *)v25 + 3);
            v25 += 16;
            *(_DWORD *)v26 = v27;
            *((_DWORD *)v26 + 1) = v28;
            *((_DWORD *)v26 + 2) = v29;
            *((_DWORD *)v26 + 3) = v30;
            v26 += 16;
          }
          while ( v25 != "}" );
          *(_WORD *)v26 = *(_WORD *)v25;
          return httpd_cgi_ret(a1, v35, 33, 4);
        }
LABEL_66:
        nvram_set("wt_config_modify", "1");
        start_rzgl(0);
        wt_client_restart(0);
        mng_client_restart(0);
        jhl_parm_commit(v24);
        goto LABEL_67;
      }
    }
    else
    {
      nvram_set("wt_third_agent_id", v36);
      v8 = 1;
      if ( !v5 )
        goto LABEL_66;
    }
    v23 = (const char *)nvram_get("wt_nofeel_auth_id");
    if ( !v23 || strcmp(v23, v5) )
    {
      nvram_set("wt_nofeel_auth_id", v5);
      goto LABEL_66;
    }
    goto LABEL_77;
  }
  v33 = (const char *)_GET_LANG_TEXT(52, *(unsigned __int8 *)(a1 + 210102), v32);
  v34 = snprintf(v35, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v33);
  if ( v34 >= 0x400 )
    v34 = 1023;
  return httpd_cgi_ret(a1, v35, v34, 4);
}
// 4758AC: variable 'v24' is possibly undefined
// 475994: variable 'v32' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8354: using guessed type int __fastcall wt_client_restart(_DWORD);
// 6A83A0: using guessed type int __fastcall mng_client_restart(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85F0: using guessed type int __fastcall reset_wtclient_rzgl_parm(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00475A18) --------------------------------------------------------
int __fastcall sub_475A18(int a1)
{
  char *v1; // $v0
  const char *v3; // $v0
  const char *v4; // $s1
  int v5; // $s1
  char *v6; // $s2
  const char *v7; // $v0
  char *v8; // $s2
  const char *v9; // $v0
  char *v10; // $s2
  const char *v11; // $v0
  char *v12; // $s2
  const char *v13; // $v0
  int v14; // $s2
  char *v15; // $s3
  const char *v16; // $v0
  char *v17; // $s3
  const char *v18; // $v0
  char *v19; // $s3
  const char *v20; // $v0
  char *v21; // $s3
  const char *v22; // $v0
  char *v23; // $s3
  const char *v24; // $v0
  int v25; // $a0
  char *v26; // $s3
  const char *v27; // $v0
  int v28; // $a0
  const char **v29; // $v1
  const char *v30; // $v0
  const char *v31; // $t0
  const char *v32; // $a3
  const char *v33; // $a2
  const char *v34; // $a1
  const char *v36; // $v0
  const char *v37; // [sp+18h] [-100h] BYREF
  const char *v38; // [sp+1Ch] [-FCh]
  char *v39; // [sp+20h] [-F8h]
  char *v40; // [sp+24h] [-F4h]
  char *v41; // [sp+28h] [-F0h]
  int v42; // [sp+2Ch] [-ECh]

  v1 = httpd_get_parm(a1, "en");
  if ( !v1 || (v4 = v1, (v3 = (const char *)nvram_get("rd_en")) != 0) && !strcmp(v3, v4) )
  {
    v5 = 0;
  }
  else
  {
    nvram_set("rd_en", v4);
    v5 = 1;
  }
  v6 = httpd_get_parm(a1, "auth");
  if ( v6 )
  {
    v7 = (const char *)nvram_get("rd_auth");
    if ( !v7 || strcmp(v7, v6) )
    {
      nvram_set("rd_auth", v6);
      ++v5;
    }
  }
  v8 = httpd_get_parm(a1, "acct");
  if ( v8 )
  {
    v9 = (const char *)nvram_get("rd_acct");
    if ( !v9 || strcmp(v9, v8) )
    {
      nvram_set("rd_acct", v8);
      ++v5;
    }
  }
  v10 = httpd_get_parm(a1, "key");
  if ( v10 )
  {
    v11 = (const char *)nvram_get("rd_key");
    if ( !v11 || strcmp(v11, v10) )
    {
      nvram_set("rd_key", v10);
      ++v5;
    }
  }
  v12 = httpd_get_parm(a1, "ip");
  if ( !v12 || (v13 = (const char *)nvram_get("rd_ip")) != 0 && !strcmp(v13, v12) )
  {
    v14 = 0;
  }
  else
  {
    nvram_set("rd_ip", v12);
    v14 = 1;
  }
  v15 = httpd_get_parm(a1, "dev");
  if ( v15 )
  {
    v16 = (const char *)nvram_get("rd_dev");
    if ( !v16 || strcmp(v16, v15) )
    {
      nvram_set("rd_dev", v15);
      ++v14;
    }
  }
  v17 = httpd_get_parm(a1, "id");
  if ( v17 )
  {
    v18 = (const char *)nvram_get("rd_id");
    if ( !v18 || strcmp(v18, v17) )
    {
      nvram_set("rd_id", v17);
      ++v5;
    }
  }
  v19 = httpd_get_parm(a1, (char *)&off_6489D8);
  if ( v19 )
  {
    v20 = (const char *)nvram_get("rd_coa");
    if ( !v20 || strcmp(v20, v19) )
    {
      nvram_set("rd_coa", v19);
      ++v5;
    }
  }
  v21 = httpd_get_parm(a1, "get_user");
  if ( v21 )
  {
    v22 = (const char *)nvram_get("rd_get_user");
    if ( !v22 || strcmp(v22, v21) )
    {
      nvram_set("rd_get_user", v21);
      ++v14;
    }
  }
  v23 = httpd_get_parm(a1, "auth_mode");
  if ( v23 )
  {
    v24 = (const char *)nvram_get(&unk_647E00);
    if ( !v24 || strcmp(v24, v23) )
    {
      nvram_set(&unk_647E00, v23);
      ++v14;
    }
  }
  v26 = httpd_get_parm(a1, "list");
  if ( !v26 || (v27 = (const char *)nvram_get("rd_list")) != 0 && !strcmp(v27, v26) )
  {
    if ( v5 )
    {
      jhl_parm_commit(v25);
      if ( !v14 )
        goto LABEL_45;
    }
    else
    {
      if ( !v14 )
        goto LABEL_46;
      jhl_parm_commit(v25);
    }
LABEL_52:
    v36 = (const char *)nvram_get("rd_en");
    if ( v36 && !strcmp(v36, "1") )
    {
      v38 = "radiusset";
      v37 = "wys";
      v39 = "2";
      v40 = (char *)jhl_nv_get_def("rd_get_user");
      v41 = (char *)jhl_nv_get_def(&unk_647E00);
      v42 = 0;
      eval(&v37, 0, 0, 0);
      if ( !v5 )
        goto LABEL_46;
    }
    else
    {
      v37 = "wys";
      v38 = "radiusset";
      v39 = "0";
      v40 = (char *)jhl_nv_get_def("rd_get_user");
      v41 = "0";
      v42 = 0;
      eval(&v37, 0, 0, 0);
      if ( !v5 )
        goto LABEL_46;
    }
    goto LABEL_45;
  }
  nvram_set("rd_list", v26);
  ++v5;
  jhl_parm_commit(v28);
  if ( v14 )
    goto LABEL_52;
LABEL_45:
  jhl_setwanxx();
  v38 = "user";
  v39 = "rd_down_all";
  v37 = "wys";
  v40 = "all";
  v41 = 0;
  eval(&v37, 0, 0, 0);
  sleep(1u);
  radius_server_start();
LABEL_46:
  v29 = &v37;
  v30 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v31 = *(const char **)v30;
    v32 = (const char *)*((_DWORD *)v30 + 1);
    v33 = (const char *)*((_DWORD *)v30 + 2);
    v34 = (const char *)*((_DWORD *)v30 + 3);
    v30 += 16;
    *v29 = v31;
    v29[1] = v32;
    v29[2] = v33;
    v29[3] = v34;
    v29 += 4;
  }
  while ( v30 != "}" );
  *(_WORD *)v29 = *(_WORD *)v30;
  return httpd_cgi_ret(a1, (char *)&v37, 33, 4);
}
// 475F48: variable 'v28' is possibly undefined
// 47608C: variable 'v25' is possibly undefined
// 6489D8: using guessed type void *off_6489D8;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82B8: using guessed type int jhl_setwanxx(void);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8814: using guessed type int radius_server_start(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00476210) --------------------------------------------------------
int __fastcall sub_476210(int a1)
{
  char *v2; // $s2
  char *v3; // $fp
  char *v4; // $s7
  char *v5; // $s6
  char *v6; // $s1
  char *v7; // $s3
  char *v8; // $s4
  char *v9; // $s5
  int v10; // $s2
  const char *v11; // $v0
  char *v12; // $v1
  const char *v13; // $v0
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  int v19; // $a0
  const char *v20; // $v0
  char v21[1024]; // [sp+18h] [-420h] BYREF
  char *v22; // [sp+418h] [-20h]
  char *v23; // [sp+41Ch] [-1Ch]
  char *v24; // [sp+420h] [-18h]
  char *v25; // [sp+424h] [-14h]
  char *v26; // [sp+428h] [-10h]
  char *v27; // [sp+42Ch] [-Ch]
  char *v28; // [sp+430h] [-8h]
  char *v29; // [sp+434h] [-4h]

  v23 = v21;
  memset(v21, 0, sizeof(v21));
  v2 = httpd_get_parm(a1, "wtqr_ServerEnable");
  v3 = httpd_get_parm(a1, "wtqr_AdsEnable");
  v4 = httpd_get_parm(a1, "wtqr_ShareEnable");
  v5 = httpd_get_parm(a1, "wtqr_SlaveMode");
  v6 = httpd_get_parm(a1, "wtqr_Ssid");
  v24 = httpd_get_parm(a1, "wtqr_JumpUrl");
  v25 = httpd_get_parm(a1, "wtqr_SuperCode");
  v26 = httpd_get_parm(a1, "wtqr_ScanCnt");
  v27 = httpd_get_parm(a1, "wtqr_CltNmae");
  v28 = httpd_get_parm(a1, "wtqr_Tips");
  v7 = httpd_get_parm(a1, "wtqr_Support");
  v8 = httpd_get_parm(a1, "wtqr_WanLanInfor");
  v9 = httpd_get_parm(a1, "wtqr_Ipaddr");
  v22 = httpd_get_parm(a1, "wtqr_Netmask");
  if ( v2 && (v29 = "a", !nvram_match_def("wtQR_SrvEnable", v2)) )
  {
    nvram_set(v29 + 29736, v2);
    v10 = 1;
  }
  else
  {
    v10 = 0;
  }
  if ( v3 )
  {
    v29 = "a";
    if ( !nvram_match_def("wtQR_AdsEnable", v3) )
    {
      nvram_set(v29 + 29752, v3);
      v10 = 1;
    }
  }
  if ( v4 && !nvram_match_def("wtQR_ShareEnable", v4) )
  {
    nvram_set("wtQR_ShareEnable", v4);
    v10 = 1;
  }
  if ( v5 && !nvram_match_def("wtQR_SlaveMode", v5) )
  {
    nvram_set("wtQR_SlaveMode", v5);
    v10 = 1;
  }
  if ( v6 )
  {
    v11 = (const char *)nvram_get("SSID1");
    if ( !v11 || strcmp(v11, v6) || (v20 = (const char *)nvram_get("SSID2")) == 0 || strcmp(v20, v6) )
    {
      nvram_set("SSID1", v6);
      nvram_set("SSID2", v6);
      v10 = 1;
      nvram_set("ssid_charset1", "0");
      nvram_set("ssid_charset2", "1");
    }
    if ( !nvram_match_def("wtQR_Ssid", v6) )
    {
      nvram_set("wtQR_Ssid", v6);
      v10 = 1;
    }
  }
  if ( v24 && !nvram_match_def("wtQR_JumpUrl", v24) )
  {
    nvram_set("wtQR_JumpUrl", v24);
    v10 = 1;
  }
  if ( v25 && !nvram_match_def("wtQR_SuperCode", v25) )
  {
    nvram_set("wtQR_SuperCode", v25);
    v10 = 1;
  }
  if ( v26 && !nvram_match_def("wtQR_ScanCnt", v26) )
  {
    nvram_set("wtQR_ScanCnt", v26);
    v10 = 1;
  }
  if ( v27 && !nvram_match_def("wtQRr_CltNmae", v27) )
  {
    nvram_set("wtQR_CltNmae", v27);
    v10 = 1;
  }
  if ( v28 && !nvram_match_def("wtQR_Tips", v28) )
  {
    nvram_set("wtQR_Tips", v28);
    v10 = 1;
  }
  if ( v7 && !nvram_match_def("wtQR_Support", v7) )
  {
    nvram_set("wtQR_Support", v7);
    v10 = 1;
  }
  if ( v8 && !nvram_match_def("wtQR_WanLanInfor", v8) )
  {
    nvram_set("wtQR_WanLanInfor", v8);
    v10 = 1;
  }
  if ( v9 && !nvram_match_def("wtQR_Ipaddr", v9) )
  {
    nvram_set("wtQR_Ipaddr", v9);
    if ( !v22 || nvram_match_def("wtQR_Netmask", v22) )
      goto LABEL_51;
    goto LABEL_50;
  }
  if ( v22 && !nvram_match_def("wtQR_Netmask", v22) )
  {
LABEL_50:
    nvram_set("wtQR_Netmask", v22);
    goto LABEL_51;
  }
  if ( v10 )
  {
LABEL_51:
    nvram_set("wt_config_modify", "1");
    start_rzgl(0);
    wt_client_restart(0);
    mng_client_restart(0);
    jhl_parm_commit(v19);
  }
  v12 = v23;
  v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v14 = *(_DWORD *)v13;
    v15 = *((_DWORD *)v13 + 1);
    v16 = *((_DWORD *)v13 + 2);
    v17 = *((_DWORD *)v13 + 3);
    v13 += 16;
    *(_DWORD *)v12 = v14;
    *((_DWORD *)v12 + 1) = v15;
    *((_DWORD *)v12 + 2) = v16;
    *((_DWORD *)v12 + 3) = v17;
    v12 += 16;
  }
  while ( v13 != "}" );
  *(_WORD *)v12 = *(_WORD *)v13;
  return httpd_cgi_ret(a1, v23, 33, 4);
}
// 476894: variable 'v19' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8354: using guessed type int __fastcall wt_client_restart(_DWORD);
// 6A83A0: using guessed type int __fastcall mng_client_restart(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (00476A24) --------------------------------------------------------
int __fastcall sub_476A24(int a1)
{
  char *v2; // $s1
  char *v3; // $fp
  char *v4; // $v0
  char *v5; // $s7
  char *v6; // $s5
  char *v7; // $s6
  char *v8; // $s4
  char *v9; // $v0
  char *v10; // $v0
  char *v11; // $s2
  char v12; // $s3
  int v13; // $s3
  const char *v14; // $v0
  int v15; // $a2
  int v16; // $v0
  char *v17; // $s3
  int v18; // $a2
  char *v19; // $a1
  const char *v20; // $s3
  const char *v21; // $v0
  const char *v22; // $s3
  const char *v23; // $v0
  const char *v24; // $s3
  const char *v25; // $v0
  const char *v26; // $s3
  const char *v27; // $v0
  const char *v28; // $s3
  const char *v29; // $v0
  const char *v30; // $s3
  const char *v31; // $v0
  const char *v32; // $s3
  const char *v33; // $v0
  const char *v34; // $v0
  int v35; // $s3
  const char *v36; // $v0
  const char *v37; // $s2
  size_t v38; // $v0
  const char *v39; // $s2
  size_t v40; // $v0
  const char *v41; // $v0
  const char *v42; // $v0
  int v43; // $s1
  const char *v44; // $v0
  const char *v45; // $v0
  int v46; // $a0
  char *v47; // $v1
  const char *v48; // $v0
  int v49; // $t0
  int v50; // $a3
  int v51; // $a2
  int v52; // $a1
  int v54; // $a2
  const char *v55; // $v0
  unsigned int v56; // $v0
  const char *v57; // $v0
  char *v58; // $s2
  char *v59; // $s3
  char *v60; // $s2
  char v61[1024]; // [sp+20h] [-EB0h] BYREF
  char v62[1024]; // [sp+420h] [-AB0h] BYREF
  char v63[1024]; // [sp+820h] [-6B0h] BYREF
  char v64[256]; // [sp+C20h] [-2B0h] BYREF
  char v65[256]; // [sp+D20h] [-1B0h] BYREF
  int v66[8]; // [sp+E20h] [-B0h] BYREF
  char *v67; // [sp+E40h] [-90h]
  char *str; // [sp+E44h] [-8Ch]
  char *v69; // [sp+E48h] [-88h]
  const char *v70; // [sp+E4Ch] [-84h]
  char *v71; // [sp+E50h] [-80h]
  char *v72; // [sp+E54h] [-7Ch]
  char *v73; // [sp+E58h] [-78h]
  char *v74; // [sp+E5Ch] [-74h]
  char *v75; // [sp+E60h] [-70h]
  char *v76; // [sp+E64h] [-6Ch]
  char *v77; // [sp+E68h] [-68h]
  char *v78; // [sp+E6Ch] [-64h]
  char *v79; // [sp+E70h] [-60h]
  char *v80; // [sp+E74h] [-5Ch]
  void *s; // [sp+E78h] [-58h]
  char *v82; // [sp+E7Ch] [-54h]
  char *v83; // [sp+E80h] [-50h]
  char *v84; // [sp+E84h] [-4Ch]
  char *v85; // [sp+E88h] [-48h]
  char *v86; // [sp+E8Ch] [-44h]
  char *v87; // [sp+E90h] [-40h]
  char *v88; // [sp+E94h] [-3Ch]
  char *v89; // [sp+E98h] [-38h]
  char *v90; // [sp+E9Ch] [-34h]
  char *v91; // [sp+EA0h] [-30h]
  char *v92; // [sp+EA4h] [-2Ch]
  char *v93; // [sp+EA8h] [-28h]
  char *v94; // [sp+EACh] [-24h]
  char *v95; // [sp+EB0h] [-20h]
  char *v96; // [sp+EB4h] [-1Ch]
  char *v97; // [sp+EB8h] [-18h]
  char *v98; // [sp+EBCh] [-14h]
  char *v99; // [sp+EC0h] [-10h]
  char *v100; // [sp+EC4h] [-Ch]
  char *v101; // [sp+EC8h] [-8h]
  char *v102; // [sp+ECCh] [-4h]

  str = v63;
  memset(v63, 0, sizeof(v63));
  v80 = v65;
  memset(v65, 0, sizeof(v65));
  s = v62;
  memset(v62, 0, sizeof(v62));
  v2 = v61;
  memset(v61, 0, sizeof(v61));
  v3 = httpd_get_parm(a1, "type");
  v69 = httpd_get_parm(a1, "tq");
  v73 = httpd_get_parm(a1, "unline");
  v89 = httpd_get_parm(a1, (char *)&off_64D744);
  httpd_get_parm(a1, "lx");
  v97 = "a";
  v4 = httpd_get_parm(a1, "auto_type");
  v98 = "a";
  v5 = v4;
  v74 = httpd_get_parm(a1, "web_exit");
  v75 = httpd_get_parm(a1, "web_anyuser");
  v6 = httpd_get_parm(a1, "fip");
  v7 = httpd_get_parm(a1, "dns");
  v8 = httpd_get_parm(a1, "host");
  v67 = httpd_get_parm(a1, (char *)&off_646724);
  v76 = httpd_get_parm(a1, "timeout");
  v90 = httpd_get_parm(a1, "redirct_url");
  v91 = httpd_get_parm(a1, "redirct_en");
  v92 = httpd_get_parm(a1, "usblog");
  v9 = httpd_get_parm(a1, "third_url");
  v100 = "a";
  v93 = v9;
  v10 = httpd_get_parm(a1, "third_timeout");
  v101 = "a";
  v70 = v10;
  v94 = httpd_get_parm(a1, "vmiandan_checktime");
  v95 = httpd_get_parm(a1, "vmiandan_checkcount");
  v82 = httpd_get_parm(a1, "noauth_en");
  v83 = httpd_get_parm(a1, "noauth_pc");
  v84 = httpd_get_parm(a1, "noauth_ssid1");
  v85 = httpd_get_parm(a1, "noauth_ssid2");
  v86 = httpd_get_parm(a1, "noauth_ssid3");
  v87 = httpd_get_parm(a1, "noauth_ssid4");
  v88 = httpd_get_parm(a1, "noauth_ssid5");
  v72 = httpd_get_parm(a1, "mac_timeout");
  v79 = httpd_get_parm(a1, "mac_en");
  v99 = v64;
  v96 = (char *)jhl_nv_get_def("dual_lan_mode");
  memset(v64, 0, sizeof(v64));
  v11 = httpd_get_parm(a1, "js_status");
  v77 = httpd_get_parm(a1, "js_time");
  v78 = httpd_get_parm(a1, "js_value");
  if ( v3 )
  {
    v71 = "a";
    if ( !v5 )
      v5 = "0";
    v12 = J_atoi(v5);
    if ( strcmp(v3, v71 + 14076) && (v12 & 6) != 0 )
    {
      v13 = v12 & 0x10;
      goto LABEL_7;
    }
  }
  else
  {
    v71 = "a";
    if ( v5 )
    {
      v12 = J_atoi(v5);
    }
    else
    {
      v5 = "0";
      v12 = J_atoi("0");
    }
    v3 = "0";
  }
  v102 = "a";
  if ( nvram_match_def("jf_en", "1") && sq_file_get_state_new("wys_jf") || nvram_match_def("billing_en", v102 + 9340) )
  {
    v55 = (const char *)_GET_LANG_TEXT(153, *(unsigned __int8 *)(a1 + 210102), v54);
    goto LABEL_127;
  }
  if ( strcmp(v3, v71 + 14076) )
  {
    v13 = v12 & 0x10;
LABEL_7:
    if ( v13 )
      goto LABEL_12;
  }
  v66[0] = 0;
  v66[1] = 0;
  v66[2] = 0;
  v66[3] = 0;
  v66[4] = 0;
  v66[5] = 0;
  v66[6] = 0;
  v66[7] = 0;
  v14 = (const char *)nvram_get("wt_base_enable");
  if ( v14 && !strcmp(v14, "1") )
  {
    v16 = _GET_LANG_TEXT(155, *(unsigned __int8 *)(a1 + 210102), v15);
    strlcpy(v66, v16, 32);
  }
  if ( !LOBYTE(v66[0]) )
  {
LABEL_12:
    if ( !v11 )
      v11 = v71 + 14076;
    if ( !v77 )
      v77 = "0-6;00:01";
    if ( !v78 )
      v78 = "180";
    v17 = v99;
    snprintf(v99, 255, "%s|%s|%s", v11, v77, v78);
    nvram_set("user_js_mod", v17);
    start_user_jsmod();
    if ( !v8 )
      v8 = "";
    if ( !v6 )
      v6 = "";
    if ( !v67 )
      v67 = "";
    if ( !v7 )
      v7 = "";
    if ( (*v6 & 0xDF) == 0 )
      v6 = "";
    if ( (*v8 & 0xDF) == 0 )
      v8 = "";
    if ( (*v67 & 0xDF) == 0 )
      v67 = "";
    if ( (*v7 & 0xDF) == 0 )
      v7 = "";
    if ( v69 )
    {
      if ( (unsigned int)J_atoi(v69) >= 0x65 )
        v69 = "100";
    }
    else
    {
      v69 = "7";
    }
    if ( !v73 )
      v73 = v71 + 14076;
    if ( !v74 )
      v74 = v71 + 14076;
    if ( !v75 )
      v75 = v71 + 14076;
    v19 = v89;
    if ( !v89 )
      v19 = (char *)_GET_LANG_TEXT(51, *(unsigned __int8 *)(a1 + 210102), v18);
    strlcpy(v80, v19, 256);
    if ( !v76 )
      v76 = (char *)&unk_4D15F8;
    v20 = v82;
    if ( v82 )
    {
      v21 = (const char *)nvram_get("rzgl_pc_no_auth");
      if ( !v21 || strcmp(v21, v20) )
        nvram_set("rzgl_pc_no_auth", v82);
    }
    v22 = v83;
    if ( v83 )
    {
      v23 = (const char *)nvram_get("rzgl_noauth_pc");
      if ( !v23 || strcmp(v23, v22) )
        nvram_set("rzgl_noauth_pc", v83);
    }
    v24 = v84;
    if ( v84 )
    {
      v25 = (const char *)nvram_get("rzgl_noauth_ssid1");
      if ( !v25 || strcmp(v25, v24) )
        nvram_set("rzgl_noauth_ssid1", v84);
    }
    v26 = v85;
    if ( v85 )
    {
      v27 = (const char *)nvram_get("rzgl_noauth_ssid2");
      if ( !v27 || strcmp(v27, v26) )
        nvram_set("rzgl_noauth_ssid2", v85);
    }
    v28 = v86;
    if ( v86 )
    {
      v29 = (const char *)nvram_get("rzgl_noauth_ssid3");
      if ( !v29 || strcmp(v29, v28) )
        nvram_set("rzgl_noauth_ssid3", v86);
    }
    v30 = v87;
    if ( v87 )
    {
      v31 = (const char *)nvram_get("rzgl_noauth_ssid4");
      if ( !v31 || strcmp(v31, v30) )
        nvram_set("rzgl_noauth_ssid4", v87);
    }
    v32 = v88;
    if ( v88 )
    {
      v33 = (const char *)nvram_get("rzgl_noauth_ssid5");
      if ( !v33 || strcmp(v33, v32) )
        nvram_set("rzgl_noauth_ssid5", v88);
    }
    if ( !v72 )
      v72 = "24";
    if ( v79 )
    {
      v34 = (const char *)nvram_get("rzgl_mac_en");
      if ( !v34 || (v35 = 0, strcmp(v34, v79)) )
      {
        nvram_set("rzgl_mac_en", v79);
        v35 = 1;
      }
    }
    else
    {
      v35 = 0;
    }
    v36 = (const char *)nvram_get("rzgl_mac_timeout");
    if ( v36 && !strcmp(v36, v72) )
    {
      if ( !v35 )
      {
LABEL_85:
        if ( !strcmp(v96, "1") )
        {
          v72 = httpd_get_parm(a1, "sys_iface_en");
          v71 = httpd_get_parm(a1, "sys_iface_list");
          v59 = httpd_get_parm(a1, "third_iface_en");
          v60 = httpd_get_parm(a1, "third_iface_list");
          if ( v72 )
            nvram_set("webS_iface_en", v72);
          if ( v71 )
            nvram_set("webS_iface_list", v71);
          if ( v59 )
            nvram_set("webT_iface_en", v59);
          if ( v60 )
            nvram_set("webT_iface_list", v60);
        }
        if ( v70 )
        {
          if ( (unsigned int)J_atoi(v70) >= 0x79 )
            v70 = "120";
        }
        else
        {
          v70 = (const char *)&unk_4D15F8;
        }
        jhl_parm_set("rzgl_third_timeout", v70);
        v37 = v93;
        if ( v93 )
        {
          memset(v61, 0, sizeof(v61));
          memset(s, 0, 0x400u);
          v38 = strlen(v37);
          base64_decode(v37, v61, v38);
          if ( !strncmp(v61, "http://", 7u) || !strncmp(v61, "https://", 8u) )
          {
            jhl_parm_set("rzgl_third_url", v61);
          }
          else
          {
            v58 = (char *)s;
            *(_DWORD *)s = *(_DWORD *)"http://";
            strcpy(v58 + 4, "://");
            strcpy(&v62[7], v61);
            jhl_parm_set("rzgl_third_url", v58);
          }
        }
        if ( v95 )
          jhl_parm_set(v101 + 32692, v95);
        if ( v94 )
          jhl_parm_set(v100 + 32672, v94);
        if ( v91 )
          jhl_parm_set("rzgl_redirct_en", v91);
        v39 = v90;
        if ( v90 )
        {
          memset(v61, 0, sizeof(v61));
          memset(s, 0, 0x400u);
          v40 = strlen(v39);
          base64_decode(v39, v61, v40);
          if ( strncmp(v61, "http://", 7u) && strncmp(v61, "https://", 8u) )
          {
            v2 = (char *)s;
            *(_DWORD *)s = *(_DWORD *)"http://";
            strcpy(v2 + 4, "://");
            strcpy(&v62[7], v61);
          }
          jhl_parm_set("rzgl_redirct_url", v2);
        }
        jhl_parm_set("rzglType", v3);
        jhl_parm_set("rzglTq", v69);
        jhl_parm_set("rzglUnline", v73);
        jhl_parm_set("rzglMsg", v80);
        jhl_parm_set("rzglAtype", v5);
        jhl_parm_set(v97 + 32516, v74);
        jhl_parm_set(v98 + 32528, v75);
        jhl_parm_set("rzgl_web_ageing_time", v76);
        v41 = (const char *)nvram_get("rzglFip");
        if ( v41 && !strcmp(v41, v6) )
        {
          v57 = (const char *)nvram_get("rzglDns");
          if ( !v57 || (v43 = 0, strcmp(v57, v7)) )
          {
LABEL_108:
            jhl_parm_set("rzglDns", v7);
            v44 = (const char *)nvram_get("rzglHost");
            v43 = 1;
            if ( !v44 )
              goto LABEL_110;
LABEL_109:
            if ( !strcmp(v44, v8) )
            {
              v45 = (const char *)nvram_get("rzglMac");
              if ( !v45 )
                goto LABEL_112;
LABEL_111:
              if ( !strcmp(v45, v67) )
              {
LABEL_113:
                if ( v92 )
                  nvram_set("save_auth_log_usb", v92);
                start_rzgl(v43);
                restart_third_rzgl();
                jhl_parm_commit(v46);
                v47 = str;
                v48 = "{\"code\":0,\"error\":\"\",\"data\":null}";
                do
                {
                  v49 = *(_DWORD *)v48;
                  v50 = *((_DWORD *)v48 + 1);
                  v51 = *((_DWORD *)v48 + 2);
                  v52 = *((_DWORD *)v48 + 3);
                  v48 += 16;
                  *(_DWORD *)v47 = v49;
                  *((_DWORD *)v47 + 1) = v50;
                  *((_DWORD *)v47 + 2) = v51;
                  *((_DWORD *)v47 + 3) = v52;
                  v47 += 16;
                }
                while ( v48 != "}" );
                *(_WORD *)v47 = *(_WORD *)v48;
                return httpd_cgi_ret(a1, str, 33, 4);
              }
LABEL_112:
              jhl_parm_set("rzglMac", v67);
              v43 = 1;
              goto LABEL_113;
            }
LABEL_110:
            jhl_parm_set("rzglHost", v8);
            v45 = (const char *)nvram_get("rzglMac");
            v43 = 1;
            if ( !v45 )
              goto LABEL_112;
            goto LABEL_111;
          }
        }
        else
        {
          jhl_parm_set("rzglFip", v6);
          v42 = (const char *)nvram_get("rzglDns");
          if ( !v42 )
            goto LABEL_108;
          v43 = 1;
          if ( strcmp(v42, v7) )
            goto LABEL_108;
        }
        v44 = (const char *)nvram_get("rzglHost");
        if ( !v44 )
          goto LABEL_110;
        goto LABEL_109;
      }
    }
    else
    {
      nvram_set("rzgl_mac_timeout", v72);
    }
    macuser_conf_set();
    goto LABEL_85;
  }
  v55 = (const char *)_GET_LANG_TEXT(154, *(unsigned __int8 *)(a1 + 210102), v66);
LABEL_127:
  v56 = snprintf(str, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v55);
  if ( v56 >= 0x400 )
    v56 = 1023;
  return httpd_cgi_ret(a1, str, v56, 4);
}
// 476F88: variable 'v15' is possibly undefined
// 477F58: variable 'v18' is possibly undefined
// 477A3C: variable 'v46' is possibly undefined
// 477B7C: variable 'v54' is possibly undefined
// 646724: using guessed type void *off_646724;
// 64D744: using guessed type void *off_64D744;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8508: using guessed type int start_user_jsmod(void);
// 6A8514: using guessed type int restart_third_rzgl(void);
// 6A86DC: using guessed type int macuser_conf_set(void);
// 6A8848: using guessed type int __fastcall sq_file_get_state_new(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00477F98) --------------------------------------------------------
int __fastcall sub_477F98(int a1)
{
  char *v2; // $s3
  char *v3; // $v0
  int v4; // $a0
  const char **v5; // $v1
  const char *v6; // $v0
  const char *v7; // $t0
  const char *v8; // $a3
  const char *v9; // $a2
  const char *v10; // $a1
  int v12; // $a0
  const char *v13; // $v0
  int v14; // $s2
  const char *v15; // $v0
  const char *v16; // $v0
  const char *v17; // $v0
  const char *v18; // $v0
  const char *v19; // $v0
  const char *v20; // $v0
  const char *v21; // $v0
  const char *v22; // $v0
  const char *v23; // $v0
  const char *v24; // $v0
  const char *v25; // $v0
  const char *v26; // $v0
  const char *v27; // $v0
  const char *v28; // $v0
  const char *v29; // $v0
  const char *v30; // $v0
  const char *v31; // $v0
  const char *v32; // $v0
  const char *v33; // $v0
  const char *v34; // $v0
  const char *v35; // $v0
  const char *v36; // $v0
  const char *v37; // $v0
  const char *v38; // $s6
  const char *v39; // $s5
  const char *v40; // $s7
  const char *v41; // $s4
  const char *v42; // $v0
  const char *v43; // $v0
  const char *v44; // $v0
  const char *v45; // $v0
  int v46; // $a2
  const char *v47; // $v0
  unsigned int v48; // $v0
  const char *v49; // [sp+20h] [-480h] BYREF
  const char *v50; // [sp+24h] [-47Ch]
  const char *v51; // [sp+28h] [-478h]
  char *v52; // [sp+2Ch] [-474h]
  char *v53; // [sp+30h] [-470h]
  int v54; // [sp+34h] [-46Ch]
  int v55; // [sp+38h] [-468h]
  char *v56; // [sp+420h] [-80h]
  char *v57; // [sp+424h] [-7Ch]
  char *v58; // [sp+428h] [-78h]
  char *v59; // [sp+42Ch] [-74h]
  char *v60; // [sp+430h] [-70h]
  char *v61; // [sp+434h] [-6Ch]
  char *v62; // [sp+438h] [-68h]
  char *v63; // [sp+43Ch] [-64h]
  char *v64; // [sp+440h] [-60h]
  char *v65; // [sp+444h] [-5Ch]
  char *v66; // [sp+448h] [-58h]
  char *v67; // [sp+44Ch] [-54h]
  char *v68; // [sp+450h] [-50h]
  char *v69; // [sp+454h] [-4Ch]
  char *v70; // [sp+458h] [-48h]
  char *v71; // [sp+45Ch] [-44h]
  char *v72; // [sp+460h] [-40h]
  char *v73; // [sp+464h] [-3Ch]
  char *v74; // [sp+468h] [-38h]
  char *v75; // [sp+46Ch] [-34h]
  char *v76; // [sp+470h] [-30h]
  char *v77; // [sp+474h] [-2Ch]
  char *v78; // [sp+478h] [-28h]
  char *v79; // [sp+47Ch] [-24h]
  char *v80; // [sp+480h] [-20h]
  char *v81; // [sp+484h] [-1Ch]
  char *v82; // [sp+488h] [-18h]
  char *v83; // [sp+48Ch] [-14h]
  char *v84; // [sp+490h] [-10h]
  char *v85; // [sp+494h] [-Ch]
  char *v86; // [sp+498h] [-8h]

  v66 = httpd_get_parm(a1, "server_mode");
  v67 = httpd_get_parm(a1, "ac_mng_srv_host_custom");
  v68 = httpd_get_parm(a1, "ac_mng_srv_port_custom");
  v69 = httpd_get_parm(a1, "wt_base_addr_custom");
  v70 = httpd_get_parm(a1, "wt_base_port_custom");
  v61 = httpd_get_parm(a1, "hide");
  v59 = httpd_get_parm(a1, "en");
  v62 = httpd_get_parm(a1, "fbs_en");
  v65 = httpd_get_parm(a1, "addr");
  v71 = httpd_get_parm(a1, "port");
  v63 = httpd_get_parm(a1, "router_addr");
  v72 = httpd_get_parm(a1, "router_cont");
  v73 = httpd_get_parm(a1, "router_tel");
  v74 = httpd_get_parm(a1, "router_name");
  v75 = httpd_get_parm(a1, "router_dinate");
  v76 = httpd_get_parm(a1, "router_agents");
  v77 = httpd_get_parm(a1, "router_pwd");
  v85 = "a";
  v78 = httpd_get_parm(a1, "route_type");
  v79 = httpd_get_parm(a1, "route_replace_id");
  v80 = httpd_get_parm(a1, "wt_dev_type");
  v86 = "a";
  v81 = httpd_get_parm(a1, "wt_dev_offlinenotauth");
  v82 = httpd_get_parm(a1, "new_router_agents");
  v83 = httpd_get_parm(a1, "wt_nofeel_auth_id");
  v60 = httpd_get_parm(a1, "rzgl_pc_no_auth");
  v84 = httpd_get_parm(a1, "wtqr_ServerEnable");
  v64 = httpd_get_parm(a1, "re_conn");
  v2 = httpd_get_parm(a1, "debug");
  v56 = httpd_get_parm(a1, "third_mode");
  v58 = httpd_get_parm(a1, "redirct_mode");
  v57 = httpd_get_parm(a1, "redirct_time");
  v3 = httpd_get_parm(a1, "timeout");
  if ( v2 )
  {
    nvram_set("wt_clt_debug", v2);
LABEL_3:
    nvram_set("wt_config_modify", "1");
    start_rzgl(0);
    wt_client_restart(0);
    mng_client_restart(0);
    jhl_parm_commit(v4);
    goto LABEL_4;
  }
  if ( v56 )
  {
    nvram_set("rzgl_third_mode", v56);
    v49 = "wys";
    v50 = "third";
    v51 = "mode";
    v52 = "set";
    v53 = v56;
    v54 = 0;
LABEL_9:
    eval(&v49, 0, 0, 0);
    jhl_parm_commit(v12);
    goto LABEL_4;
  }
  if ( v57 )
  {
    if ( !J_atoi(v57) )
      v57 = "1";
    nvram_set("rzgl_redirct_time", v57);
    if ( !v58 )
      goto LABEL_15;
    goto LABEL_14;
  }
  if ( v58 )
  {
LABEL_14:
    nvram_set("rzgl_redirct_mode", v58);
LABEL_15:
    v49 = "wys";
    v50 = "third";
    v51 = "redirct_mode";
    v52 = "set";
    v53 = (char *)jhl_nv_get_def("rzgl_redirct_mode");
    v54 = jhl_nv_get_def("rzgl_redirct_time");
    v55 = 0;
    goto LABEL_9;
  }
  if ( v3 )
  {
    nvram_set("wt_clt_timeout", v3);
    goto LABEL_3;
  }
  if ( !v60 || (v13 = (const char *)nvram_get("rzgl_pc_no_auth")) != 0 && !strcmp(v13, v60) )
  {
    v14 = 0;
  }
  else
  {
    nvram_set("rzgl_pc_no_auth", v60);
    v14 = 1;
  }
  if ( v64 && !strcmp(v64, "1") )
    goto LABEL_3;
  if ( !v59 )
  {
    if ( !v63 )
      goto LABEL_150;
    goto LABEL_30;
  }
  v15 = (const char *)jhl_nv_get_def("dual_lan_mode");
  if ( !strcmp(v15, "1") || !nvram_match_def("billing_en", "1") || !J_atoi(v59) )
  {
    if ( !v63 )
      goto LABEL_34;
LABEL_30:
    v16 = (const char *)nvram_get("wt_dev_addr");
    if ( !v16 || strcmp(v16, v63) )
    {
      nvram_set("wt_dev_addr", v63);
      v14 = 1;
      nvram_set(&unk_648DD0, "1");
    }
    if ( v59 )
    {
LABEL_34:
      v17 = (const char *)nvram_get("wt_base_enable");
      if ( !v17 || strcmp(v17, v59) )
      {
        nvram_set("wt_base_enable", v59);
        v14 = 1;
      }
      if ( !v62 )
        goto LABEL_42;
      goto LABEL_38;
    }
LABEL_150:
    if ( !v62 )
      goto LABEL_43;
LABEL_38:
    v18 = (const char *)nvram_get("wt_dev_server_fbs");
    if ( !v18 || strcmp(v18, v62) )
    {
      nvram_set("wt_dev_server_fbs", v62);
      v14 = 1;
    }
    if ( !v59 )
    {
LABEL_43:
      if ( v65 )
      {
        v19 = (const char *)nvram_get("wt_base_addr");
        if ( !v19 || strcmp(v19, v65) )
        {
          nvram_set("wt_base_addr", v65);
          if ( !strcmp("yd.wayos.com", v65) )
          {
            nvram_set("ac_mng_srv_host", "acad.wayos.com");
          }
          else if ( !strcmp("client.wamwifi.com", v65) )
          {
            nvram_set("ac_mng_srv_host", "client.wamwifi.com");
          }
          nvram_set("wt_base_srv_ip", "");
          nvram_set("wt_auth_srv_ip", "");
          nvram_set(&unk_648DBC, "");
          v14 = 1;
        }
      }
      if ( v71 )
      {
        v20 = (const char *)nvram_get("wt_base_port");
        if ( !v20 || strcmp(v20, v71) )
        {
          nvram_set("wt_base_port", v71);
          v14 = 1;
          nvram_set("wt_base_srv_ip", "");
          nvram_set("wt_auth_srv_ip", "");
          nvram_set(&unk_648DBC, "");
        }
      }
      if ( v72 )
      {
        v21 = (const char *)nvram_get("wt_dev_cont");
        if ( !v21 || strcmp(v21, v72) )
        {
          nvram_set("wt_dev_cont", v72);
          v14 = 1;
        }
      }
      if ( v73 )
      {
        v22 = (const char *)nvram_get("wt_dev_tel");
        if ( !v22 || strcmp(v22, v73) )
        {
          nvram_set("wt_dev_tel", v73);
          v14 = 1;
        }
      }
      if ( v74 )
      {
        v23 = (const char *)nvram_get("wt_dev_name");
        if ( !v23 || strcmp(v23, v74) )
        {
          nvram_set("wt_dev_name", v74);
          v14 = 1;
        }
      }
      if ( v75 )
      {
        v24 = (const char *)nvram_get("wt_dev_dinate");
        if ( !v24 || strcmp(v24, v75) )
        {
          nvram_set("wt_dev_dinate", v75);
          v14 = 1;
        }
      }
      if ( v76 )
      {
        v25 = (const char *)nvram_get("wt_agent_id");
        if ( !v25 || strcmp(v25, v76) )
        {
          nvram_set("wt_agent_id", v76);
          v14 = 1;
        }
      }
      if ( v77 )
      {
        v26 = (const char *)nvram_get("wt_dev_pwd");
        if ( !v26 || strcmp(v26, v77) )
        {
          nvram_set("wt_dev_pwd", v77);
          v14 = 1;
        }
      }
      if ( v78 )
      {
        v27 = (const char *)nvram_get("wt_route_type");
        if ( !v27 || strcmp(v27, v78) )
        {
          nvram_set("wt_route_type", v78);
          v14 = 1;
        }
      }
      if ( v79 )
      {
        v28 = (const char *)nvram_get("wt_dev_replace_id");
        if ( !v28 || strcmp(v28, v79) )
        {
          nvram_set("wt_dev_replace_id", v79);
          v14 = 1;
        }
      }
      if ( v80 )
      {
        v29 = (const char *)nvram_get(v85 + 30500);
        if ( !v29 || strcmp(v29, v80) )
        {
          nvram_set(v85 + 30500, v80);
          v14 = 1;
        }
      }
      if ( v81 )
      {
        v30 = (const char *)nvram_get("wt_dev_offlinenotauth");
        if ( !v30 || strcmp(v30, v81) )
        {
          nvram_set("wt_dev_offlinenotauth", v81);
          v14 = 1;
        }
      }
      if ( v82 )
      {
        v31 = (const char *)nvram_get("wt_third_agent_id");
        if ( !v31 || strcmp(v31, v82) )
        {
          nvram_set("wt_third_agent_id", v82);
          v14 = 1;
        }
      }
      if ( v83 )
      {
        v32 = (const char *)nvram_get(v86 + 30556);
        if ( !v32 || strcmp(v32, v83) )
        {
          nvram_set(v86 + 30556, v83);
          v14 = 1;
        }
      }
      if ( v84 && !nvram_match_def("wtQR_SrvEnable", v84) )
      {
        if ( J_atoi(v84) == 1 )
          nvram_set("wtQR_SrvEnable", "1");
        else
          nvram_set("wtQR_SrvEnable", "0");
        v14 = 1;
      }
      if ( v66 )
      {
        v33 = (const char *)nvram_get("wt_server_mode");
        if ( !v33 || strcmp(v33, v66) )
        {
          nvram_set("wt_server_mode", v66);
          v14 = 1;
        }
      }
      if ( v67 )
      {
        v34 = (const char *)nvram_get("ac_mng_srv_host_custom");
        if ( !v34 || strcmp(v34, v67) )
        {
          nvram_set("ac_mng_srv_host_custom", v67);
          v14 = 1;
        }
      }
      if ( v68 )
      {
        v35 = (const char *)nvram_get("ac_mng_srv_port_custom");
        if ( !v35 || strcmp(v35, v68) )
        {
          nvram_set("ac_mng_srv_port_custom", v68);
          v14 = 1;
        }
      }
      if ( v69 )
      {
        v36 = (const char *)nvram_get("wt_base_addr_custom");
        if ( !v36 || strcmp(v36, v69) )
        {
          nvram_set("wt_base_addr_custom", v69);
          v14 = 1;
        }
      }
      if ( v70 )
      {
        v37 = (const char *)nvram_get("wt_base_port_custom");
        if ( !v37 || strcmp(v37, v70) )
        {
          nvram_set("wt_base_port_custom", v70);
          v14 = 1;
        }
      }
      if ( v61 && J_atoi(v61) == 1 )
        goto LABEL_145;
      if ( nvram_match_def("wt_server_mode", "1") )
      {
        v38 = (const char *)jhl_nv_get_def("wt_base_addr_custom");
        v39 = (const char *)jhl_nv_get_def("wt_base_port_custom");
        v40 = (const char *)jhl_nv_get_def("ac_mng_srv_host_custom");
        v41 = (const char *)jhl_nv_get_def("ac_mng_srv_port_custom");
        if ( !v38 )
        {
LABEL_131:
          if ( v39 )
          {
            v43 = (const char *)nvram_get("wt_base_port");
            if ( !v43 || strcmp(v43, v39) )
            {
              nvram_set("wt_base_port", v39);
              v14 = 1;
            }
          }
          if ( v40 )
          {
            v44 = (const char *)nvram_get("ac_mng_srv_host");
            if ( !v44 || strcmp(v44, v40) )
            {
              nvram_set("ac_mng_srv_host", v40);
              if ( !v41 )
                goto LABEL_3;
              v14 = 1;
              goto LABEL_140;
            }
          }
          if ( v41 )
          {
LABEL_140:
            v45 = (const char *)nvram_get("ac_mng_srv_port");
            if ( !v45 || strcmp(v45, v41) )
            {
              nvram_set("ac_mng_srv_port", v41);
              goto LABEL_3;
            }
          }
LABEL_145:
          if ( v14 )
            goto LABEL_3;
LABEL_4:
          v5 = &v49;
          v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          do
          {
            v7 = *(const char **)v6;
            v8 = (const char *)*((_DWORD *)v6 + 1);
            v9 = (const char *)*((_DWORD *)v6 + 2);
            v10 = (const char *)*((_DWORD *)v6 + 3);
            v6 += 16;
            *v5 = v7;
            v5[1] = v8;
            v5[2] = v9;
            v5[3] = v10;
            v5 += 4;
          }
          while ( v6 != "}" );
          *(_WORD *)v5 = *(_WORD *)v6;
          return httpd_cgi_ret(a1, (char *)&v49, 33, 4);
        }
      }
      else if ( nvram_match_def("wt_server_mode", "2") )
      {
        v38 = "r.wamwifi.com";
        v41 = "28862";
        v39 = "3800";
        v40 = "r.wamwifi.com";
      }
      else
      {
        v38 = "client.wamwifi.com";
        v41 = "58862";
        v39 = "5500";
        v40 = "client.wamwifi.com";
      }
      v42 = (const char *)nvram_get("wt_base_addr");
      if ( !v42 || strcmp(v42, v38) )
      {
        nvram_set("wt_base_addr", v38);
        v14 = 1;
      }
      goto LABEL_131;
    }
LABEL_42:
    reset_wtclient_rzgl_parm(v59);
    nvram_get("wt_base_enable");
    goto LABEL_43;
  }
  v47 = (const char *)_GET_LANG_TEXT(52, *(unsigned __int8 *)(a1 + 210102), v46);
  v48 = snprintf((char *)&v49, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v47);
  if ( v48 >= 0x400 )
    v48 = 1023;
  return httpd_cgi_ret(a1, (char *)&v49, v48, 4);
}
// 4783D8: variable 'v4' is possibly undefined
// 478504: variable 'v12' is possibly undefined
// 479498: variable 'v46' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8354: using guessed type int __fastcall wt_client_restart(_DWORD);
// 6A83A0: using guessed type int __fastcall mng_client_restart(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85F0: using guessed type int __fastcall reset_wtclient_rzgl_parm(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0047956C) --------------------------------------------------------
int __fastcall _rzgl_ip_asp(int a1, int a2)
{
  uint32_t v2; // $v0
  uint32_t v4; // $v0
  int result; // $v0
  char v6[36]; // [sp+18h] [-24h] BYREF

  v2 = J_atoi(a1);
  v4 = htonl(v2);
  IpToStr(v6, v4);
  result = ApiFindWhiteIp(v6);
  if ( result )
  {
    result = 0;
    if ( !a2 )
    {
      ApiAddWhiteIp(v6);
      result = 1;
    }
  }
  else if ( a2 )
  {
    ApiDelWhiteIp(v6);
    result = 1;
  }
  return result;
}
// 6A82F8: using guessed type int __fastcall ApiDelWhiteIp(_DWORD);
// 6A8310: using guessed type int __fastcall ApiAddWhiteIp(_DWORD);
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A87D8: using guessed type int __fastcall ApiFindWhiteIp(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00479674) --------------------------------------------------------
int __fastcall sub_479674(int a1)
{
  char *v2; // $s1
  char *v3; // $s2
  int v4; // $s0
  int v5; // $s2
  _DWORD *v6; // $s0
  int v7; // $s1
  int v8; // $v0
  int v9; // $a0
  char *v10; // $v1
  const char *v11; // $v0
  int v12; // $t0
  int v13; // $a3
  int v14; // $a2
  int v15; // $a1
  char v17[256]; // [sp+18h] [-100h] BYREF

  memset(v17, 0, sizeof(v17));
  v2 = httpd_get_parm(a1, "ip");
  v3 = httpd_get_parm(a1, "opt");
  v4 = httpd_get_json_parm(a1, (int)"list");
  if ( v3 )
    v5 = strcmp(v3, "ban") == 0;
  else
    v5 = 0;
  if ( !v2 || StrToIp(v2) )
  {
    if ( !v4 )
      goto LABEL_11;
    if ( !cJSON_IsArray(v4) )
      goto LABEL_11;
    v6 = *(_DWORD **)(v4 + 8);
    v7 = 0;
    if ( !v6 )
      goto LABEL_11;
    goto LABEL_8;
  }
  v7 = _rzgl_ip_asp((int)v2, v5);
  if ( v4 )
  {
    if ( cJSON_IsArray(v4) )
    {
      v6 = *(_DWORD **)(v4 + 8);
      if ( v6 )
      {
        do
        {
LABEL_8:
          v8 = _rzgl_ip_asp(v6[4], v5);
          v6 = (_DWORD *)*v6;
          v7 += v8;
        }
        while ( v6 );
        goto LABEL_9;
      }
    }
  }
LABEL_9:
  if ( v7 )
  {
    jhl_parm_commit(v9);
    start_rzgl(1);
  }
LABEL_11:
  v10 = v17;
  v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v12 = *(_DWORD *)v11;
    v13 = *((_DWORD *)v11 + 1);
    v14 = *((_DWORD *)v11 + 2);
    v15 = *((_DWORD *)v11 + 3);
    v11 += 16;
    *(_DWORD *)v10 = v12;
    *((_DWORD *)v10 + 1) = v13;
    *((_DWORD *)v10 + 2) = v14;
    *((_DWORD *)v10 + 3) = v15;
    v10 += 16;
  }
  while ( v11 != "}" );
  *(_WORD *)v10 = *(_WORD *)v11;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 4797C0: variable 'v9' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A862C: using guessed type int __fastcall StrToIp(_DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (004798BC) --------------------------------------------------------
int __fastcall _rzgl_mac_asp(int a1, int a2)
{
  int result; // $v0

  result = ApiFindWhiteMac();
  if ( result )
  {
    result = 0;
    if ( !a2 )
    {
      ApiAddWhiteMac(a1);
      result = 1;
    }
  }
  else if ( a2 )
  {
    ApiDelWhiteMac(a1);
    result = 1;
  }
  return result;
}
// 6A840C: using guessed type int __fastcall ApiAddWhiteMac(_DWORD);
// 6A84E8: using guessed type int ApiFindWhiteMac(void);
// 6A8668: using guessed type int __fastcall ApiDelWhiteMac(_DWORD);

//----- (00479980) --------------------------------------------------------
int __fastcall sub_479980(int a1)
{
  char *v2; // $s1
  char *v3; // $s2
  int v4; // $s0
  int v5; // $s2
  _DWORD *v6; // $s0
  int v7; // $s1
  int v8; // $v0
  int v9; // $a0
  char *v10; // $v1
  const char *v11; // $v0
  int v12; // $t0
  int v13; // $a3
  int v14; // $a2
  int v15; // $a1
  char v17[256]; // [sp+18h] [-108h] BYREF
  int v18[2]; // [sp+118h] [-8h] BYREF

  memset(v17, 0, sizeof(v17));
  v18[0] = 0;
  v18[1] = 0;
  v2 = httpd_get_parm(a1, (char *)&off_646724);
  v3 = httpd_get_parm(a1, "opt");
  v4 = httpd_get_json_parm(a1, (int)"list");
  if ( v3 )
    v5 = strcmp(v3, "ban") == 0;
  else
    v5 = 0;
  if ( !v2 || StrToMac(v2, v18) )
  {
    if ( !v4 )
      goto LABEL_11;
    if ( !cJSON_IsArray(v4) )
      goto LABEL_11;
    v6 = *(_DWORD **)(v4 + 8);
    v7 = 0;
    if ( !v6 )
      goto LABEL_11;
    goto LABEL_8;
  }
  v7 = _rzgl_mac_asp((int)v2, v5);
  if ( v4 )
  {
    if ( cJSON_IsArray(v4) )
    {
      v6 = *(_DWORD **)(v4 + 8);
      if ( v6 )
      {
        do
        {
LABEL_8:
          v8 = _rzgl_mac_asp(v6[4], v5);
          v6 = (_DWORD *)*v6;
          v7 += v8;
        }
        while ( v6 );
        goto LABEL_9;
      }
    }
  }
LABEL_9:
  if ( v7 )
  {
    jhl_parm_commit(v9);
    start_rzgl(1);
  }
LABEL_11:
  v10 = v17;
  v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v12 = *(_DWORD *)v11;
    v13 = *((_DWORD *)v11 + 1);
    v14 = *((_DWORD *)v11 + 2);
    v15 = *((_DWORD *)v11 + 3);
    v11 += 16;
    *(_DWORD *)v10 = v12;
    *((_DWORD *)v10 + 1) = v13;
    *((_DWORD *)v10 + 2) = v14;
    *((_DWORD *)v10 + 3) = v15;
    v10 += 16;
  }
  while ( v11 != "}" );
  *(_WORD *)v10 = *(_WORD *)v11;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 479AD0: variable 'v9' is possibly undefined
// 646724: using guessed type void *off_646724;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A85EC: using guessed type int __fastcall StrToMac(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (00479BCC) --------------------------------------------------------
int __fastcall user_get_state(int a1, char *a2, int a3)
{
  char *v3; // $s3
  char *v4; // $s1
  int v5; // $fp
  _DWORD *v6; // $v0
  int v7; // $a2
  _DWORD *v8; // $s4
  char *v9; // $a0
  int v10; // $v0
  int v11; // $s0
  _DWORD *v13; // $s0
  int v14; // $s3
  int v15; // $lo
  int v16; // $v0
  int v17; // $v1
  int v18; // $s4
  int v19; // $s1
  int v20; // $v0
  int v21; // $v0
  int v22; // $a1
  int v23; // $a1
  size_t v24; // $v0
  size_t v25; // $v0
  size_t v26; // $v0
  size_t v27; // $v0
  size_t v28; // $v0
  size_t v29; // $v0
  __int16 v30; // $a3
  int v31; // $v0
  int v32; // $v0
  int v33; // $v0
  char v34[1024]; // [sp+80h] [-10F0h] BYREF
  char v35[1024]; // [sp+480h] [-CF0h] BYREF
  char v36[1024]; // [sp+880h] [-8F0h] BYREF
  char v37[1024]; // [sp+C80h] [-4F0h] BYREF
  int v38; // [sp+1080h] [-F0h] BYREF
  int v39; // [sp+1084h] [-ECh]
  int v40; // [sp+1088h] [-E8h]
  int v41; // [sp+108Ch] [-E4h]
  int v42; // [sp+1090h] [-E0h]
  int v43; // [sp+1094h] [-DCh]
  int v44; // [sp+1098h] [-D8h]
  int v45; // [sp+109Ch] [-D4h]
  int v46; // [sp+10A0h] [-D0h]
  int v47; // [sp+10A4h] [-CCh]
  int v48; // [sp+10A8h] [-C8h]
  int v49; // [sp+10ACh] [-C4h]
  int v50; // [sp+10B0h] [-C0h] BYREF
  int v51; // [sp+10B4h] [-BCh]
  int v52; // [sp+10B8h] [-B8h]
  int v53; // [sp+10BCh] [-B4h]
  int v54; // [sp+10C0h] [-B0h]
  int v55; // [sp+10C4h] [-ACh]
  int v56; // [sp+10C8h] [-A8h]
  int v57; // [sp+10CCh] [-A4h]
  int v58[8]; // [sp+10D0h] [-A0h] BYREF
  int v59; // [sp+10F0h] [-80h] BYREF
  int v60; // [sp+10F4h] [-7Ch]
  int v61; // [sp+10F8h] [-78h]
  int v62; // [sp+10FCh] [-74h]
  int v63; // [sp+1100h] [-70h]
  int v64; // [sp+1104h] [-6Ch]
  int v65; // [sp+1108h] [-68h]
  int v66; // [sp+110Ch] [-64h]
  int v67; // [sp+1110h] [-60h] BYREF
  int v68; // [sp+1114h] [-5Ch]
  int v69; // [sp+1118h] [-58h]
  int v70; // [sp+111Ch] [-54h]
  int v71; // [sp+1120h] [-50h]
  int v72; // [sp+1124h] [-4Ch]
  int v73; // [sp+1128h] [-48h]
  int v74; // [sp+112Ch] [-44h]
  int v75; // [sp+1130h] [-40h] BYREF
  __int16 v76; // [sp+1134h] [-3Ch]
  char *v77; // [sp+1138h] [-38h]
  char *v78; // [sp+113Ch] [-34h]
  int v79; // [sp+1140h] [-30h]
  char *str; // [sp+1144h] [-2Ch]
  int v81; // [sp+1148h] [-28h]
  _DWORD *v82; // [sp+114Ch] [-24h]
  char *format; // [sp+1150h] [-20h]
  int v84; // [sp+1154h] [-1Ch]
  char *v85; // [sp+1158h] [-18h]
  char *v86; // [sp+115Ch] [-14h]
  char *v87; // [sp+1160h] [-10h]
  char *v88; // [sp+1164h] [-Ch]
  char *v89; // [sp+1168h] [-8h]

  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v58[0] = 0;
  v58[1] = 0;
  v58[2] = 0;
  v58[3] = 0;
  v58[4] = 0;
  v58[5] = 0;
  v58[6] = 0;
  v58[7] = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v77 = v36;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  memset(v37, 0, sizeof(v37));
  memset(v36, 0, sizeof(v36));
  v78 = v35;
  memset(v35, 0, sizeof(v35));
  memset(v34, 0, sizeof(v34));
  v75 = 0;
  v76 = 0;
  v3 = httpd_get_parm(a1, "page");
  v4 = httpd_get_parm(a1, "limit");
  if ( *(_BYTE *)(a1 + 210100) == 2 )
    format = "%u|%s|%s|%s-%s|%s|%u|%u|%s|%u|%u|%u|%d|%d|%d|%d|%s|%d|%d|%s|%d|%s|%s|%d|%d|%d<";
  else
    format = "{\"cstate\":%u,\"user\":\"%s\",\"pwd\":\"%s\",\"ips\":\"%s-%s\",\"mac\":\"%s\",\"gid\":%u,\"ddate\":%u,\"me"
             "m\":\"%s\",\"zup\":%u,\"zdown\":%u,\"tm\":%u,\"state\":%d,\"num\":%d,\"speed_up\":%d,\"speed_down\":%d,\"sp"
             "eed_mode\":\"%s\",\"mod_pwd\":\"%d\",\"vlan\":%d,\"group\":\"%s\",\"vlan2\":%d,\"ip_login\":\"%s\",\"mac_lo"
             "gin\":\"%s\",\"bs_repeat_en\":%d,\"bs_interval\":%d,\"bs_count\":%d},";
  v5 = snprintf(a2, a3, (char *)&word_642A04);
  if ( v5 >= a3 )
    v5 = a3 - 1;
  v88 = "1\"";
  _mem_malloc(0x200000, "user_get_state", 1022);
  v82 = v6;
  if ( v6 )
  {
    *v6 = 16;
    v6[3] = 10;
    v6[1] = 0x200000;
    v8 = v6;
    if ( !jianhl_order_opt_fun(v6, 0x200000, v7) )
    {
      v13 = v8 + 6;
      if ( v3 && v4 )
      {
        v14 = J_atoi(v3);
        v15 = (v14 - 1) * J_atoi(v4);
        v79 = v15;
        v16 = J_atoi(v4);
        v17 = v8[5];
        v84 = v16 - 1 + v15;
      }
      else
      {
        v79 = 0;
        v17 = v82[5];
        v84 = v17;
      }
      if ( v17 > 0 )
      {
        v18 = 0;
        v86 = "1\"";
        v89 = "1\"";
        v87 = "1\"";
        v85 = "%s";
        do
        {
          if ( v18 >= v79 )
          {
            if ( v84 < v18 )
              break;
            v67 = 0;
            v59 = 0;
            v68 = 0;
            v69 = 0;
            v70 = 0;
            v71 = 0;
            v72 = 0;
            v73 = 0;
            v74 = 0;
            v60 = 0;
            v61 = 0;
            v62 = 0;
            v63 = 0;
            v64 = 0;
            v65 = 0;
            v66 = 0;
            memset(v37, 0, sizeof(v37));
            memset(v77, 0, 0x400u);
            memset(v78, 0, 0x400u);
            v21 = v13[77] & 0x21;
            v38 = 0;
            v50 = 0;
            v39 = 0;
            v40 = 0;
            v41 = 0;
            v42 = 0;
            v43 = 0;
            v44 = 0;
            v45 = 0;
            v46 = 0;
            v47 = 0;
            v48 = 0;
            v49 = 0;
            v51 = 0;
            v52 = 0;
            v53 = 0;
            v54 = 0;
            v55 = 0;
            v56 = 0;
            v57 = 0;
            if ( v21 )
            {
              v22 = v13[65];
              if ( v22 )
                IpToStr(&v67, v22);
              v23 = v13[66];
              if ( v23 )
                IpToStr(&v59, v23);
            }
            if ( *(_BYTE *)(a1 + 210100) == 2 )
            {
              v31 = get_json_data(v13);
              snprintf(v37, 1024, v85, v31);
              v32 = get_json_data(v13 + 16);
              snprintf(v77, 1024, v85, v32);
              v33 = get_json_data(v13 + 32);
              snprintf(v78, 1024, v85, v33);
            }
            else
            {
              memset(v34, 0, sizeof(v34));
              v24 = strlen((const char *)v13);
              str_to_utf8(v13, v24, v34, 1024);
              v25 = strlen(v34);
              base64_encode(v34, v37, v25);
              memset(v34, 0, sizeof(v34));
              str = (char *)(v13 + 16);
              v26 = strlen((const char *)v13 + 64);
              str_to_utf8(str, v26, v34, 1024);
              v27 = strlen(v34);
              base64_encode(v34, v77, v27);
              memset(v34, 0, sizeof(v34));
              str = (char *)(v13 + 32);
              v28 = strlen((const char *)v13 + 128);
              str_to_utf8(str, v28, v34, 1024);
              v29 = strlen(v34);
              base64_encode(v34, v78, v29);
            }
            IpaddrToStr2(&v38, v13 + 113);
            str = (char *)(v13 + 118);
            if ( memcmp(v13 + 118, &v75, 6u) )
              MacToStr(&v50, str);
            v30 = *((_WORD *)v13 + 154);
            str = &a2[v5];
            v81 = a3 - v5;
            if ( (v30 & 2) != 0 )
              MacToStr(v58, v13 + 71);
            v19 = v81;
            v20 = snprintf(str, v81, format);
            if ( v20 >= v19 )
              v20 = v19 - 1;
            v5 += v20;
            v13 += 122;
            if ( v5 >= a3 - 49 )
              break;
            v17 = v82[5];
          }
          ++v18;
        }
        while ( v18 < v17 );
      }
    }
  }
  v9 = &a2[v5];
  if ( v5 > 0 && *(v9 - 1) == 44 )
    v9 = &a2[--v5];
  *v9 = 0;
  v10 = snprintf(v9, a3 - v5, &byte_6445A0);
  v11 = v5 + v10;
  if ( v10 >= a3 - v5 )
    v11 = a3 - 1;
  _mem_free(v82);
  return v11;
}
// 479E10: variable 'v6' is possibly undefined
// 479E38: variable 'v7' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A8474: using guessed type int __fastcall base64_encode(_DWORD, _DWORD, _DWORD);
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A87E0: using guessed type int __fastcall IpaddrToStr2(_DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A8904: using guessed type int __fastcall str_to_utf8(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0047A58C) --------------------------------------------------------
int __fastcall user_data(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $s3
  int v5; // $s1
  char *v6; // $s3
  const char *v7; // $s4
  const char *v8; // $s6
  const char *v9; // $s5
  const char *v10; // $v0
  int v11; // $s1
  int v12; // $s1
  int v13; // $s1
  int v14; // $s4
  int v15; // $v0
  int result; // $v0
  const char *v17; // $v0
  unsigned int v18; // $v0
  char v19[256]; // [sp+40h] [-100h] BYREF

  _mem_malloc(0x200000, "user_data", 1161);
  v3 = v2;
  if ( v2 )
  {
    if ( *(_BYTE *)(a1 + 210100) == 2 )
    {
      *(_WORD *)v2 = 123;
      v4 = 1;
      v5 = 1;
    }
    else
    {
      v4 = 29;
      strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
      qmemcpy(v2, "{\"code\":0,\"error", 16);
      v5 = 29;
    }
    v6 = &v2[v4];
    v7 = (const char *)nvram_get("group");
    if ( !v7 )
      v7 = "";
    v8 = (const char *)jhl_nv_get_def("user_deltime");
    v9 = (const char *)nvram_get("user_hide_nouse");
    if ( !v9 )
      v9 = "";
    v10 = (const char *)jhl_nv_get_def("billing_en");
    v11 = v5
        + sprintf(
            v6,
            "\"pppoe_client\":\"%d\",\"pppoe_group\":\"%d\",\"rzgl_web\":\"%d\",\"rzgl\":\"%d\",\"vlan_en\":\"%d\",\"gid\""
            ":\"%s\",\"beizhu_show\":%d,\"type_show_flag\":\"%d\",\"deltime\":\"%s\",\"hide_nouse\":\"%s\",\"billing_en\":%s,\"all\":",
            0,
            1,
            0,
            1,
            0,
            v7,
            1,
            1,
            v8,
            v9,
            v10);
    v12 = v11 + user_get_state(a1, &v3[v11], 0x200000 - v11);
    strcpy(&v3[v12], ",\"type_list\":\";pppoe;\"");
    qmemcpy(&v3[v12], ",\"type_list\":\";p", 16);
    v13 = v12 + 22;
    v14 = 0x200000 - v13;
    if ( *(_BYTE *)(a1 + 210100) == 2 )
    {
      v15 = snprintf(&v3[v13], 0x200000 - v13, "}");
      if ( v15 >= v14 )
        v15 = 0x1FFFFF - v13;
    }
    else
    {
      v15 = snprintf(&v3[v13], 0x200000 - v13, "}}");
      if ( v15 >= v14 )
        v15 = 0x1FFFFF - v13;
    }
    result = jhl_data_giz(a1, v3, v15 + v13, 0x200000);
  }
  else
  {
    v17 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v18 = snprintf(v19, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
    if ( v18 >= 0x100 )
      v18 = 255;
    result = httpd_cgi_ret(a1, v19, v18, 4);
  }
  return result;
}
// 47A5E4: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0047A918) --------------------------------------------------------
int __fastcall sub_47A918(int a1)
{
  char *v2; // $fp
  char *v3; // $s5
  char *v4; // $s7
  char *v5; // $s6
  char *v6; // $s2
  int v7; // $a2
  int v8; // $a1
  const char *v9; // $v0
  unsigned int v10; // $a2
  size_t v12; // $v0
  size_t v13; // $v0
  size_t v14; // $v0
  size_t v15; // $v0
  size_t v16; // $v0
  size_t v17; // $v0
  size_t v18; // $v0
  size_t v19; // $v0
  int v20; // $s5
  int v21; // $a0
  char *v22; // $a1
  const char *v23; // $v0
  int v24; // $s2
  _DWORD *v25; // $s2
  const char *v26; // $s4
  size_t v27; // $v0
  size_t v28; // $v0
  unsigned int v29; // $v0
  int v30; // $a1
  char *v31; // $a2
  int v32; // $a0
  char *v33; // $v0
  char *v34; // $s2
  const char *v35; // $v0
  char *v36; // $v1
  int v37; // $t0
  int v38; // $a3
  int v39; // $a2
  int v40; // $a1
  int v41; // $s5
  int v42; // $v0
  int v43; // $s6
  int v44; // $a0
  int v45; // $v1
  unsigned __int16 v46; // $s4
  int v47; // $s2
  _DWORD *v48; // $fp
  char *v49; // $v0
  char *v50; // $s4
  int v51; // $s0
  int v52; // $s2
  const char *v53; // $s0
  size_t v54; // $v0
  size_t v55; // $v0
  const char *v56; // $s0
  size_t v57; // $v0
  size_t v58; // $v0
  _DWORD *v59; // $s1
  int v60; // $s3
  int v61; // $s2
  _BOOL4 v62; // $v1
  unsigned int v63; // $v0
  unsigned int v64; // $v0
  const char *v65; // $a2
  int v66; // $s2
  _BYTE *v67; // $a1
  int *v68; // $v1
  int v69; // $fp
  int v70; // $t0
  _DWORD v71[1024]; // [sp+58h] [-3560h] BYREF
  int v72[1024]; // [sp+1058h] [-2560h] BYREF
  char v73[1024]; // [sp+2058h] [-1560h] BYREF
  char v74[1024]; // [sp+2458h] [-1160h] BYREF
  char v75[1024]; // [sp+2858h] [-D60h] BYREF
  char v76[1024]; // [sp+2C58h] [-960h] BYREF
  char v77[1024]; // [sp+3058h] [-560h] BYREF
  char v78[256]; // [sp+3458h] [-160h] BYREF
  int v79[2]; // [sp+3558h] [-60h] BYREF
  char *v80; // [sp+3560h] [-58h]
  char *v81; // [sp+3564h] [-54h]
  char *v82; // [sp+3568h] [-50h]
  int v83; // [sp+356Ch] [-4Ch]
  char *v84; // [sp+3570h] [-48h]
  char *v85; // [sp+3574h] [-44h]
  char *v86; // [sp+3578h] [-40h]
  char *v87; // [sp+357Ch] [-3Ch]
  char *v88; // [sp+3580h] [-38h]
  char *v89; // [sp+3584h] [-34h]
  char *v90; // [sp+3588h] [-30h]
  char *v91; // [sp+358Ch] [-2Ch]
  char *v92; // [sp+3590h] [-28h]
  char *v93; // [sp+3594h] [-24h]
  char *v94; // [sp+3598h] [-20h]
  char *v95; // [sp+359Ch] [-1Ch]
  char *v96; // [sp+35A0h] [-18h]
  char *v97; // [sp+35A4h] [-14h]
  char *v98; // [sp+35A8h] [-10h]
  char *v99; // [sp+35ACh] [-Ch]
  char *v100; // [sp+35B0h] [-8h]
  int v101; // [sp+35E0h] [+28h]

  memset(v77, 0, sizeof(v77));
  v80 = v76;
  memset(v76, 0, sizeof(v76));
  v81 = v75;
  memset(v75, 0, sizeof(v75));
  v82 = v74;
  memset(v74, 0, sizeof(v74));
  memset(v73, 0, sizeof(v73));
  v85 = httpd_get_parm(a1, "id");
  v2 = httpd_get_parm(a1, "user");
  v99 = httpd_get_parm(a1, "all_users");
  v100 = httpd_get_parm(a1, "all_mems");
  v3 = httpd_get_parm(a1, "old_user");
  v4 = httpd_get_parm(a1, (char *)&off_649194);
  v86 = httpd_get_parm(a1, "ip_start");
  v87 = httpd_get_parm(a1, "ip_end");
  v84 = httpd_get_parm(a1, (char *)&off_646724);
  v88 = httpd_get_parm(a1, "state");
  v90 = httpd_get_parm(a1, (char *)&off_64918C);
  v91 = httpd_get_parm(a1, "ddate");
  v5 = httpd_get_parm(a1, "mem");
  v89 = httpd_get_parm(a1, "num");
  v92 = httpd_get_parm(a1, "speed_up");
  v93 = httpd_get_parm(a1, "speed_down");
  v94 = httpd_get_parm(a1, "speed_mode");
  v95 = httpd_get_parm(a1, "mod_pwd");
  v96 = httpd_get_parm(a1, "vlan");
  v97 = httpd_get_parm(a1, "vlan2");
  v98 = httpd_get_parm(a1, "group");
  v83 = httpd_get_json_parm(a1, (int)"list");
  v6 = httpd_get_parm(a1, "opt");
  if ( nvram_match_def("jf_en", "1") && sq_file_get_state_new("wys_jf") || nvram_match_def("billing_en", "1") )
  {
    v8 = *(unsigned __int8 *)(a1 + 210102);
    if ( *(_BYTE *)(a1 + 210100) != 2 )
    {
      v9 = (const char *)_GET_LANG_TEXT(74, v8, v7);
      goto LABEL_5;
    }
    v23 = (const char *)_GET_LANG_TEXT(74, v8, v7);
LABEL_30:
    v10 = snprintf(v78, 256, "{\"err\":\"%s\"}", v23);
    if ( v10 < 0x100 )
      return httpd_cgi_ret(a1, v78, v10, 4);
    goto LABEL_31;
  }
  if ( *(_BYTE *)(a1 + 210100) == 2 )
  {
    if ( v2 )
      strlcpy(v77, v2, 1024);
    if ( v4 )
      strlcpy(v80, v4, 1024);
    if ( v5 )
      strlcpy(v81, v5, 1024);
    if ( v3 )
      strlcpy(v82, v3, 1024);
  }
  else
  {
    if ( v2 )
    {
      memset(v73, 0, sizeof(v73));
      v12 = strlen(v2);
      base64_decode(v2, v73, v12);
      v13 = strlen(v73);
      str_to_gb2312(v73, v13, v77, 1024);
    }
    if ( v4 )
    {
      memset(v73, 0, sizeof(v73));
      v14 = strlen(v4);
      base64_decode(v4, v73, v14);
      v15 = strlen(v73);
      str_to_gb2312(v73, v15, v80, 1024);
    }
    if ( v5 )
    {
      memset(v73, 0, sizeof(v73));
      v16 = strlen(v5);
      base64_decode(v5, v73, v16);
      v17 = strlen(v73);
      str_to_gb2312(v73, v17, v81, 1024);
    }
    if ( v3 )
    {
      memset(v73, 0, sizeof(v73));
      v18 = strlen(v3);
      base64_decode(v3, v73, v18);
      v19 = strlen(v73);
      str_to_gb2312(v73, v19, v82, 1024);
    }
  }
  if ( !v6 )
    goto LABEL_69;
  v20 = strcmp(v6, (const char *)&off_646D8C);
  if ( v20
    && strcmp(v6, (const char *)&off_648DDC)
    && strcmp(v6, "del")
    && strcmp(v6, "delall")
    && strcmp(v6, "mod2")
    && strcmp(v6, "lock") )
  {
    if ( strcmp(v6, "deltime") )
    {
      if ( strcmp(v6, "mod_all") )
      {
        if ( !strcmp(v6, "hide") )
          goto LABEL_27;
LABEL_69:
        v30 = *(unsigned __int8 *)(a1 + 210102);
        v31 = "not opt";
        if ( *(_BYTE *)(a1 + 210100) != 2 )
        {
LABEL_70:
          v32 = 12;
          goto LABEL_71;
        }
        goto LABEL_87;
      }
      if ( !strcmp(v6, "hide") )
      {
LABEL_27:
        v22 = httpd_get_parm(a1, "hide_nouse");
        if ( v22 )
          nvram_set("user_hide_nouse", v22);
        goto LABEL_56;
      }
      goto LABEL_35;
    }
    if ( !strcmp(v6, "hide") )
      goto LABEL_27;
LABEL_51:
    memset(v71, 0, 0x100u);
    v34 = httpd_get_parm(a1, "del_status");
    v33 = httpd_get_parm(a1, "del_time");
    if ( !v34 )
      v34 = "0";
    if ( !v33 )
      v33 = "0-6;00:01";
    snprintf((char *)v71, 255, "%s|%s", v34, v33);
    nvram_set("user_deltime", v71);
    start_user_deltime();
    goto LABEL_56;
  }
  if ( !strcmp(v6, "hide") )
    goto LABEL_27;
  if ( !strcmp(v6, "deltime") )
    goto LABEL_51;
  if ( !strcmp(v6, "lock") )
  {
    user_lock_asp(a1);
    goto LABEL_56;
  }
LABEL_35:
  if ( !strcmp(v6, "delall") )
  {
    v29 = user_delall(&off_649144, v85);
    if ( v29 != -1 )
    {
      if ( !v29 )
        goto LABEL_56;
      v45 = a1 + 196608;
      if ( *(_BYTE *)(a1 + 210100) != 2 )
      {
        v30 = *(unsigned __int8 *)(a1 + 210102);
        if ( v29 >= 0x33 || (v31 = (char *)jhlret_err_str[v29]) == 0 )
          v31 = "not find err!";
        v32 = 3;
        goto LABEL_71;
      }
      goto LABEL_135;
    }
    goto LABEL_129;
  }
  if ( strcmp(v6, "del") )
  {
    if ( v74[0] && !strcmp(v6, "mod2") )
    {
      v29 = user_del(v82);
      if ( v29 == -1 )
        goto LABEL_129;
      if ( v29 )
        goto LABEL_145;
      v20 = strcmp(v6, (const char *)&off_646D8C);
    }
    if ( !v20 || !strcmp(v6, (const char *)&off_648DDC) || !strcmp(v6, "mod2") )
    {
      if ( !v77[0] && strcmp(v6, "mod_all") )
      {
        v30 = *(unsigned __int8 *)(a1 + 210102);
        v31 = "not user";
        if ( *(_BYTE *)(a1 + 210100) != 2 )
          goto LABEL_70;
        v44 = 12;
        goto LABEL_88;
      }
    }
    else if ( strcmp(v6, "mod_all") )
    {
      goto LABEL_56;
    }
    v41 = 0;
    if ( v86 )
      v41 = get_ip_from_str(v86);
    if ( v87 && (v42 = get_ip_from_str(v87), (v43 = v42) != 0) )
    {
      if ( !v41 )
        v41 = v42;
    }
    else
    {
      v43 = v41;
    }
    if ( v84 )
    {
      if ( StrToMac(v84, v79) )
      {
        v30 = *(unsigned __int8 *)(a1 + 210102);
        v31 = (char *)&unk_646720;
        if ( *(_BYTE *)(a1 + 210100) != 2 )
          goto LABEL_70;
LABEL_87:
        v44 = 12;
LABEL_88:
        v23 = (const char *)_GET_LANG_TEXT(v44, v30, v31);
        goto LABEL_30;
      }
    }
    else
    {
      v79[0] = 0;
      v79[1] = 0;
    }
    if ( !v88 )
    {
      v30 = *(unsigned __int8 *)(a1 + 210102);
      v31 = (char *)&unk_64917C;
      if ( *(_BYTE *)(a1 + 210100) != 2 )
        goto LABEL_70;
      v44 = 12;
      goto LABEL_88;
    }
    if ( !v90 )
    {
      v30 = *(unsigned __int8 *)(a1 + 210102);
      v31 = (char *)&unk_649188;
      if ( *(_BYTE *)(a1 + 210100) != 2 )
        goto LABEL_70;
      v44 = 12;
      goto LABEL_88;
    }
    if ( !v91 )
      v91 = "0";
    if ( !v89 )
      v89 = "1";
    v46 = J_atoi(v88);
    v84 = (char *)J_atoi(v90);
    v82 = (char *)J_atoi(v91);
    if ( !strcmp(v6, (const char *)&off_646D8C) || !strcmp(v6, "mod2") )
    {
      if ( !v76[0] )
      {
        v30 = *(unsigned __int8 *)(a1 + 210102);
        v31 = (char *)&unk_649190;
        if ( *(_BYTE *)(a1 + 210100) != 2 )
          goto LABEL_70;
        v44 = 12;
        goto LABEL_88;
      }
      v29 = user_add(
              v46,
              (unsigned __int8)v84,
              v77,
              v80,
              v41,
              v43,
              v79,
              v82,
              v81,
              v89,
              v92,
              v93,
              v94,
              v95,
              0,
              0,
              v96,
              v97,
              v98);
    }
    else
    {
      if ( !strcmp(v6, "mod_all") )
      {
        if ( v99 && v100 && *(_BYTE *)(a1 + 210100) == 2 )
        {
          memset(v72, 0, sizeof(v72));
          memset(v71, 0, sizeof(v71));
          v66 = split_string(v99, 44, v72, 1024);
          split_string(v100, 44, v71, 1024);
          if ( v66 <= 0 )
            goto LABEL_56;
          v67 = (_BYTE *)v72[0];
          if ( !v72[0] || !*(_BYTE *)v72[0] )
            goto LABEL_56;
          v83 = (unsigned __int8)v84;
          v68 = &v72[1];
          v69 = 0;
          v70 = -1;
          while ( 1 )
          {
            v84 = (char *)v70;
            v85 = (char *)v68;
            strlcpy(v77, v67, 1024);
            strlcpy(v81, v71[v69], 1024);
            v63 = user_mod(v46, v83, v77, v80, v41, v43, v79, v82, v81, v89, v92, v93, v94, v95, v96, v97, v98);
            v70 = (int)v84;
            ++v69;
            if ( (char *)v63 == v84 )
              goto LABEL_153;
            if ( v63 )
            {
              v62 = v63 < 0x33;
LABEL_162:
              v64 = v63;
              if ( !v62 || (v65 = (const char *)jhlret_err_str[v64]) == 0 )
                v65 = "not find err!";
              v10 = sprintf(v78, "{\"err\":\"%s\"}", v65);
              return httpd_cgi_ret(a1, v78, v10, 4);
            }
            if ( v66 != v69 )
            {
              v67 = *(_BYTE **)v85;
              v68 = (int *)(v85 + 4);
              if ( *(_DWORD *)v85 )
              {
                if ( *v67 )
                  continue;
              }
            }
            goto LABEL_56;
          }
        }
        if ( !v83 )
          goto LABEL_103;
        v47 = v83;
        if ( !cJSON_IsArray(v83) )
          goto LABEL_103;
        v48 = *(_DWORD **)(v47 + 8);
        if ( !v48 )
          goto LABEL_56;
        v101 = a1;
        v83 = (int)"u";
        v85 = "m";
        v84 = (char *)(unsigned __int8)v84;
        v49 = (char *)v46;
        v50 = v81;
        v86 = v49;
        while ( 1 )
        {
          v51 = cJSON_GetObjectItem(v48, v83);
          v52 = cJSON_GetObjectItem(v48, v85);
          if ( v51 )
          {
            memset(v77, 0, sizeof(v77));
            memset(v73, 0, sizeof(v73));
            v53 = *(const char **)(v51 + 16);
            v54 = strlen(v53);
            base64_decode(v53, v73, v54);
            v55 = strlen(v73);
            str_to_gb2312(v73, v55, v77, 1024);
            memset(v50, 0, 0x400u);
            if ( v52 )
            {
              memset(v73, 0, sizeof(v73));
              v56 = *(const char **)(v52 + 16);
              v57 = strlen(v56);
              base64_decode(v56, v73, v57);
              v58 = strlen(v73);
              str_to_gb2312(v73, v58, v50, 1024);
            }
            v29 = user_mod(v86, v84, v77, v80, v41, v43, v79, v82, v50, v89, v92, v93, v94, v95, v96, v97, v98);
            if ( v29 == -1 )
            {
              a1 = v101;
              goto LABEL_48;
            }
            v21 = 196608;
            if ( v29 )
              break;
          }
          v48 = (_DWORD *)*v48;
          if ( !v48 )
          {
            a1 = v101;
            goto LABEL_56;
          }
        }
        a1 = v101;
LABEL_139:
        v30 = *(unsigned __int8 *)(a1 + 210102);
        if ( v29 >= 0x33 )
          goto LABEL_147;
LABEL_140:
        v31 = (char *)jhlret_err_str[v29];
        if ( v31 )
        {
LABEL_141:
          v32 = 3;
          goto LABEL_71;
        }
LABEL_147:
        v31 = "not find err!";
        goto LABEL_141;
      }
      v29 = user_mod(
              v46,
              (unsigned __int8)v84,
              v77,
              v80,
              v41,
              v43,
              v79,
              v82,
              v81,
              v89,
              v92,
              v93,
              v94,
              v95,
              v96,
              v97,
              v98);
    }
    if ( v29 != -1 )
    {
      if ( !v29 )
        goto LABEL_56;
LABEL_145:
      v45 = a1 + 196608;
      if ( *(_BYTE *)(a1 + 210100) != 2 )
      {
        v30 = *(unsigned __int8 *)(a1 + 210102);
        if ( v29 >= 0x33 )
          goto LABEL_147;
        goto LABEL_140;
      }
LABEL_135:
      v30 = *(unsigned __int8 *)(v45 + 13494);
      if ( v29 >= 0x33 || (v31 = (char *)jhlret_err_str[v29]) == 0 )
        v31 = "not find err!";
      v44 = 3;
      goto LABEL_88;
    }
LABEL_129:
    v30 = *(unsigned __int8 *)(a1 + 210102);
    v31 = "";
    if ( *(_BYTE *)(a1 + 210100) == 2 )
    {
      v44 = 3;
      goto LABEL_88;
    }
LABEL_49:
    v32 = 3;
LABEL_71:
    v9 = (const char *)_GET_LANG_TEXT(v32, v30, v31);
LABEL_5:
    v10 = snprintf(v78, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 < 0x100 )
      return httpd_cgi_ret(a1, v78, v10, 4);
LABEL_31:
    v10 = 255;
    return httpd_cgi_ret(a1, v78, v10, 4);
  }
  if ( v77[0] && *(_BYTE *)(a1 + 210100) == 2 )
  {
    v59 = v71;
    v60 = split_string(v77, 44, v71, 512);
    if ( v60 <= 0 )
      goto LABEL_56;
    v61 = 0;
    while ( 1 )
    {
      ++v61;
      v63 = user_del(*v59);
      if ( v63 == -1 )
        break;
      v62 = v63 < 0x33;
      if ( v63 )
        goto LABEL_162;
      ++v59;
      if ( v60 == v61 )
        goto LABEL_56;
    }
LABEL_153:
    strcpy(v78, "{\"err\":\"set_opt false!\"}");
    v10 = 24;
    return httpd_cgi_ret(a1, v78, v10, 4);
  }
  if ( !v83 || (v24 = v83, !cJSON_IsArray(v83)) )
  {
LABEL_103:
    v30 = *(unsigned __int8 *)(a1 + 210102);
    v31 = (char *)&unk_649164;
    v32 = 12;
    goto LABEL_71;
  }
  v25 = *(_DWORD **)(v24 + 8);
  if ( v25 && v25[4] )
  {
    while ( 1 )
    {
      memset(v77, 0, sizeof(v77));
      memset(v73, 0, sizeof(v73));
      v26 = (const char *)v25[4];
      v27 = strlen(v26);
      base64_decode(v26, v73, v27);
      v28 = strlen(v73);
      str_to_gb2312(v73, v28, v77, 1024);
      v29 = user_del(v77);
      if ( v29 == -1 )
        break;
      v21 = 196608;
      if ( v29 )
        goto LABEL_139;
      v25 = (_DWORD *)*v25;
      if ( !v25 || !v25[4] )
        goto LABEL_56;
    }
LABEL_48:
    v30 = *(unsigned __int8 *)(a1 + 210102);
    v31 = "";
    goto LABEL_49;
  }
LABEL_56:
  jhl_parm_commit(v21);
  if ( *(_BYTE *)(a1 + 210100) == 2 )
    return user_data(a1);
  v35 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v36 = v78;
  do
  {
    v37 = *(_DWORD *)v35;
    v38 = *((_DWORD *)v35 + 1);
    v39 = *((_DWORD *)v35 + 2);
    v40 = *((_DWORD *)v35 + 3);
    v35 += 16;
    *(_DWORD *)v36 = v37;
    *((_DWORD *)v36 + 1) = v38;
    *((_DWORD *)v36 + 2) = v39;
    *((_DWORD *)v36 + 3) = v40;
    v36 += 16;
  }
  while ( v35 != "}" );
  *(_WORD *)v36 = *(_WORD *)v35;
  return httpd_cgi_ret(a1, v78, 33, 4);
}
// 47ACD8: variable 'v7' is possibly undefined
// 47B444: variable 'v21' is possibly undefined
// 646724: using guessed type void *off_646724;
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 649144: using guessed type void *off_649144;
// 64918C: using guessed type void *off_64918C;
// 649194: using guessed type char *off_649194;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A82A0: using guessed type int __fastcall user_delall(_DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84DC: using guessed type int __fastcall user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A85EC: using guessed type int __fastcall StrToMac(_DWORD, _DWORD);
// 6A8624: using guessed type int start_user_deltime(void);
// 6A8704: using guessed type int __fastcall user_del(_DWORD);
// 6A8748: using guessed type int __fastcall get_ip_from_str(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8848: using guessed type int __fastcall sq_file_get_state_new(_DWORD);
// 6A88A4: using guessed type int __fastcall str_to_gb2312(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A88D8: using guessed type int __fastcall user_mod(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0047C21C) --------------------------------------------------------
time_t __fastcall timeconvert(char *a1, struct tm *a2)
{
  int v4; // $v0
  int v6; // $v0
  bool v7; // dc
  int v8; // $v0
  int v9; // $v1

  memset(a2, 0, sizeof(struct tm));
  if ( strchr(a1, 45) )
    v4 = sscanf(a1, "%d-%d-%d %d:%d", &a2->tm_year, &a2->tm_mon, &a2->tm_mday, &a2->tm_hour, &a2->tm_min);
  else
    v4 = sscanf(a1, "%d/%d/%d %d:%d", &a2->tm_year, &a2->tm_mon, &a2->tm_mday, &a2->tm_hour, &a2->tm_min);
  if ( v4 != 5 )
    return 0;
  v6 = a2->tm_year;
  v7 = v6 < 1900;
  v8 = v6 - 1900;
  if ( v7 )
    return 0;
  v9 = a2->tm_mon - 1;
  a2->tm_year = v8;
  a2->tm_mon = v9;
  return mktime(a2);
}

//----- (0047C34C) --------------------------------------------------------
int __fastcall sub_47C34C(int a1)
{
  void *v2; // $v0
  void *v3; // $fp
  int v4; // $s1
  char *v5; // $v0
  char *v6; // $s2
  char *v7; // $v0
  int v8; // $a2
  int v9; // $v0
  int v10; // $a2
  const char *v11; // $v0
  unsigned int v12; // $v0
  const char *v14; // $v0
  char *v15; // $a0
  char *v16; // $a3
  char *v17; // $a0
  int v18; // $v0
  int v19; // $v0
  int v20; // $v0
  int v21; // $v0
  char *v22; // $t0
  char *v23; // $t1
  char *i; // $v0
  int v25; // $v1
  unsigned int v26; // $v1
  int v27; // $v0
  bool v28; // dc
  char v29[1024]; // [sp+58h] [-A20h] BYREF
  char v30[1024]; // [sp+458h] [-620h] BYREF
  char v31[256]; // [sp+858h] [-220h] BYREF
  char v32[120]; // [sp+958h] [-120h] BYREF
  char *v33; // [sp+A08h] [-70h]
  int v34; // [sp+A0Ch] [-6Ch]
  int v35; // [sp+A10h] [-68h]
  int v36; // [sp+A14h] [-64h]
  int v37; // [sp+A18h] [-60h]
  char *v38; // [sp+A1Ch] [-5Ch]
  char *v39; // [sp+A20h] [-58h]
  const char *v40; // [sp+A24h] [-54h]
  int v41; // [sp+A28h] [-50h]
  int v42; // [sp+A2Ch] [-4Ch]
  int v43; // [sp+A30h] [-48h]
  int v44; // [sp+A34h] [-44h]
  int v45; // [sp+A38h] [-40h]
  int v46; // [sp+A3Ch] [-3Ch]
  int v47; // [sp+A40h] [-38h]
  int v48; // [sp+A44h] [-34h]
  int v49; // [sp+A48h] [-30h]
  int v50; // [sp+A4Ch] [-2Ch]
  int v51; // [sp+A50h] [-28h]
  int v52; // [sp+A54h] [-24h]
  int v53; // [sp+A58h] [-20h]
  int v54; // [sp+A5Ch] [-1Ch]

  strcpy(v31, "Error reading file");
  memset(&v31[19], 0, 0xEDu);
  _mem_malloc(0x200000, "usersfile_cgi", 1970);
  v3 = v2;
  if ( v2 )
  {
    v4 = *(_DWORD *)(a1 + 205364);
    find_file_head(a1, *(const char **)(a1 + 205564));
    v6 = v5;
    if ( v5 )
    {
      v7 = find_file_end(a1, v5, *(_DWORD *)(a1 + 205564) + v4 - (_DWORD)v5);
      if ( v7 )
      {
        *v7 = 0;
        if ( nvram_match_def("jf_en", "1") && sq_file_get_state_new("wys_jf") || nvram_match_def("billing_en", "1") )
        {
          v9 = _GET_LANG_TEXT(74, *(unsigned __int8 *)(a1 + 210102), v8);
          strlcpy(v31, v9, 256);
          goto LABEL_7;
        }
        v38 = "pppoe";
        v39 = "1\"";
        v33 = "auto";
        v40 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
        while ( 1 )
        {
          while ( 1 )
          {
            if ( !*v6 )
            {
              jhl_parm_commit(v15);
              v31[0] = 0;
              goto LABEL_7;
            }
            memset(v29, 0, sizeof(v29));
            v16 = v6 + 1002;
            v17 = v29;
            while ( 1 )
            {
              v18 = *v6;
              if ( !*v6 )
                break;
              if ( v18 == 10 || v18 == 13 )
                goto LABEL_37;
              *v17++ = v18;
              if ( v6 + 1 == v16 )
              {
                v18 = v6[1];
                v6 = v16;
LABEL_37:
                while ( v18 == 10 || v18 == 13 )
                  v18 = *++v6;
                break;
              }
              ++v6;
            }
            v15 = v17 - 1;
            if ( v29[0] == 123 )
            {
              while ( 1 )
              {
                v19 = *v15;
                if ( v19 != 9 && v19 != 44 )
                  break;
                --v15;
              }
              if ( v19 == 125 )
                break;
            }
          }
          *v15 = 0;
          v20 = split_string(&v29[1], 9, v32, 30);
          if ( v20 < 3 )
          {
            v27 = split_string(&v29[1], 44, v32, 30);
            v28 = v27 > 0;
            v21 = 4 * v27;
            if ( v28 )
              goto LABEL_28;
          }
          else
          {
            v21 = 4 * v20;
LABEL_28:
            v22 = v32;
            v23 = &v32[v21];
            v54 = 0;
            v53 = 0;
            v52 = 0;
            v51 = 0;
            v50 = 0;
            v49 = 0;
            v48 = 0;
            v47 = 0;
            v46 = 0;
            v45 = 0;
            v36 = 0;
            v44 = 0;
            v35 = 0;
            v43 = 0;
            v42 = 0;
            v37 = 0;
            v41 = 0;
            v34 = 0;
            do
            {
              for ( i = *(char **)v22; ; ++i )
              {
                v25 = *i;
                if ( v25 != 32 && v25 != 9 )
                  break;
              }
              v15 = (char *)i[1];
              if ( v15 == (char *)58 )
              {
                v26 = (unsigned __int8)(v25 - 68);
                v15 = (char *)(v26 < 0x34);
                if ( v26 < 0x34 )
                  __asm { jr      $v1 }
              }
              v22 += 4;
            }
            while ( v22 != v23 );
          }
        }
      }
    }
  }
LABEL_7:
  _mem_free(v3);
  if ( v31[0] )
  {
    v14 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v31);
    v12 = snprintf(v30, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v12 < 0x400 )
      return httpd_cgi_ret(a1, v30, v12, 4);
LABEL_11:
    v12 = 1023;
    return httpd_cgi_ret(a1, v30, v12, 4);
  }
  v11 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v10);
  v12 = snprintf(v30, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v11);
  if ( v12 >= 0x400 )
    goto LABEL_11;
  return httpd_cgi_ret(a1, v30, v12, 4);
}
// 47C3FC: variable 'v2' is possibly undefined
// 47C428: variable 'v5' is possibly undefined
// 47C4A8: variable 'v8' is possibly undefined
// 47C500: variable 'v10' is possibly undefined
// 47CBD0: variable 'v15' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84DC: using guessed type int __fastcall user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A85EC: using guessed type int __fastcall StrToMac(_DWORD, _DWORD);
// 6A862C: using guessed type int __fastcall StrToIp(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8848: using guessed type int __fastcall sq_file_get_state_new(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0047CF20) --------------------------------------------------------
int __fastcall sub_47CF20(int a1)
{
  void *v2; // $v0
  void *v3; // $fp
  int v4; // $s1
  char *v5; // $v0
  char *v6; // $s6
  char *v7; // $v0
  int v8; // $a2
  int v9; // $v0
  int v10; // $a2
  const char *v11; // $v0
  unsigned int v12; // $a2
  const char *v14; // $v0
  int v15; // $a0
  char *v16; // $t0
  char *v17; // $a0
  int v18; // $v0
  const char *v19; // $s0
  int v20; // $v0
  const char *v21; // $s1
  const char *v22; // $s2
  const char *v23; // $s3
  const char *v24; // $s4
  char *v25; // $v0
  int v26; // $s4
  int v27; // $s3
  const char *v28; // $s4
  int v29; // $v0
  bool v30; // dc
  int v31; // $v0
  char v32[1024]; // [sp+58h] [-A10h] BYREF
  char v33[1024]; // [sp+458h] [-610h] BYREF
  char v34[256]; // [sp+858h] [-210h] BYREF
  const char *v35; // [sp+958h] [-110h] BYREF
  const char *v36; // [sp+95Ch] [-10Ch]
  const char *v37; // [sp+960h] [-108h]
  const char *v38; // [sp+964h] [-104h]
  const char *v39; // [sp+968h] [-100h]
  const char *v40; // [sp+96Ch] [-FCh]
  const char *v41; // [sp+970h] [-F8h]
  char *v42; // [sp+974h] [-F4h]
  char *v43; // [sp+978h] [-F0h]
  char *v44; // [sp+97Ch] [-ECh]
  int v45; // [sp+980h] [-E8h]
  int v46; // [sp+984h] [-E4h]
  int v47; // [sp+988h] [-E0h]
  int v48; // [sp+98Ch] [-DCh]
  int v49; // [sp+990h] [-D8h]
  const char *v50; // [sp+994h] [-D4h]
  const char *v51; // [sp+998h] [-D0h]
  const char *v52; // [sp+99Ch] [-CCh]
  const char *v53; // [sp+9A0h] [-C8h]
  int v54; // [sp+9A4h] [-C4h]
  struct tm v55; // [sp+9D0h] [-98h] BYREF
  int v56[3]; // [sp+9FCh] [-6Ch] BYREF
  char *v57; // [sp+A08h] [-60h]
  char *v58; // [sp+A0Ch] [-5Ch]
  char *v59; // [sp+A10h] [-58h]
  char *v60; // [sp+A14h] [-54h]
  char *v61; // [sp+A18h] [-50h]
  const char *v62; // [sp+A1Ch] [-4Ch]
  const char *v63; // [sp+A20h] [-48h]
  char *v64; // [sp+A24h] [-44h]
  int v65; // [sp+A28h] [-40h]
  int v66; // [sp+A2Ch] [-3Ch]
  int v67; // [sp+A30h] [-38h]
  int v68; // [sp+A34h] [-34h]
  int v69; // [sp+A38h] [-30h]
  const char *v70; // [sp+A3Ch] [-2Ch]
  const char *v71; // [sp+A40h] [-28h]
  const char *v72; // [sp+A44h] [-24h]
  int v73; // [sp+A48h] [-20h]
  char *v74; // [sp+A4Ch] [-1Ch]
  char *v75; // [sp+A50h] [-18h]
  const char *v76; // [sp+A54h] [-14h]
  int *v77; // [sp+A58h] [-10h]
  char *v78; // [sp+A5Ch] [-Ch]
  char *v79; // [sp+A60h] [-8h]

  strcpy(v34, "Error reading file");
  memset(&v34[19], 0, 0xEDu);
  _mem_malloc(0x200000, "usersfile_csv_cgi", 2336);
  v3 = v2;
  if ( v2 )
  {
    v4 = *(_DWORD *)(a1 + 205364);
    find_file_head(a1, *(const char **)(a1 + 205564));
    v6 = v5;
    if ( v5 )
    {
      v7 = find_file_end(a1, v5, *(_DWORD *)(a1 + 205564) + v4 - (_DWORD)v5);
      if ( v7 )
      {
        v57 = "a";
        *v7 = 0;
        if ( nvram_match_def("jf_en", "1") && sq_file_get_state_new("wys_jf")
          || nvram_match_def("billing_en", v57 + 9340) )
        {
          v9 = _GET_LANG_TEXT(74, *(unsigned __int8 *)(a1 + 210102), v8);
          strlcpy(v34, v9, 256);
          goto LABEL_7;
        }
        v58 = (char *)&unk_649204;
        v61 = "name";
        v78 = "a";
        v79 = "1\"";
        v64 = "auto";
        while ( 1 )
        {
          while ( 1 )
          {
            if ( !*v6 )
            {
              jhl_parm_commit(v15);
              v34[0] = 0;
              goto LABEL_7;
            }
            memset(v32, 0, sizeof(v32));
            v16 = v6 + 1002;
            v17 = v32;
            while ( 1 )
            {
              v18 = *v6;
              ++v17;
              if ( !*v6 )
                break;
              if ( v18 == 10 || v18 == 13 )
                goto LABEL_39;
              *(v17 - 1) = v18;
              if ( v6 + 1 == v16 )
              {
                v18 = v6[1];
                v6 = v16;
LABEL_39:
                while ( v18 == 10 || v18 == 13 )
                  v18 = *++v6;
                break;
              }
              ++v6;
            }
            if ( split_string(v32, 44, &v35, 30) >= 3 )
            {
              v19 = v35;
              v20 = strcmp(v35, v58);
              v21 = v36;
              if ( (v20 || strcmp(v36, byte_64920C)) && (strcmp(v19, v61) || strcmp(v21, "password")) )
              {
                v22 = v53;
                v62 = v39;
                v23 = v37;
                v76 = v40;
                v24 = v38;
                v63 = v41;
                v75 = v42;
                v60 = v43;
                v59 = v44;
                v65 = v45;
                v66 = v46;
                v67 = v47;
                v68 = v48;
                v69 = v49;
                v70 = v50;
                v71 = v51;
                v72 = v52;
                v73 = v54;
                if ( !v53 )
                  goto LABEL_43;
                v25 = strchr(v53, 47);
                if ( v25 )
                {
                  v74 = v25 + 1;
                  *v25 = 0;
                }
                else
                {
LABEL_43:
                  v74 = 0;
                }
                if ( v21 && v23 )
                  break;
              }
            }
          }
          v77 = v56;
          v56[0] = 0;
          v56[1] = 0;
          if ( v24 )
          {
            if ( !strcmp(v24, (const char *)&off_63F984) )
            {
              v26 = 4;
            }
            else if ( !strcmp(v24, "offjs") )
            {
              v26 = 132;
            }
            else if ( !strcmp(v24, "offll") )
            {
              v26 = 260;
            }
            else if ( !strcmp(v24, "offxzjs") )
            {
              v26 = 2052;
            }
            else if ( !strcmp(v24, "js") )
            {
              v26 = 128;
            }
            else
            {
              v26 = !strcmp(v24, "ll") ? 256 : (strcmp(v24, "xzjs") == 0) << 11;
            }
          }
          else
          {
            v26 = 0;
          }
          if ( !strcmp(v23, v78 + 13636) )
            break;
          if ( !strcmp(v23, "web") )
          {
            v27 = v26 | 0x40;
          }
          else
          {
            if ( !strcmp(v23, "mobile") )
            {
              v27 = v26 | 0x400;
              goto LABEL_45;
            }
            if ( !strcmp(v23, "pppoe/mobile") )
            {
              v27 = v26 | 0x420;
            }
            else
            {
              v31 = strcmp(v23, "pppoe/web");
              v27 = v26 | 0x60;
              if ( v31 )
                break;
            }
          }
LABEL_45:
          if ( v62 )
          {
            if ( !strcmp(v62, v64) )
            {
              v27 |= 8u;
              v62 = 0;
              v28 = 0;
            }
            else
            {
              v28 = (const char *)StrToIp(v62);
              if ( v28 )
                v27 |= 1u;
              if ( v76 && strcmp(v76, v64) )
                v62 = (const char *)StrToIp(v76);
              else
                v62 = v28;
            }
          }
          else
          {
            v62 = 0;
            v28 = 0;
          }
          if ( v63 )
          {
            if ( !strcmp(v63, v64) )
            {
              v27 |= 0x10u;
            }
            else if ( !StrToMac(v63, v77) )
            {
              v27 |= 2u;
            }
          }
          v29 = v27 & 0x980;
          if ( v22 )
          {
            if ( !strcmp(v22, v64) )
            {
              v27 |= 0x1000u;
LABEL_54:
              v29 = v27 & 0x980;
              goto LABEL_55;
            }
            v30 = J_atoi(v22) == 0;
            v29 = v27 & 0x980;
            if ( !v30 )
            {
              v27 |= 0x2000u;
              goto LABEL_54;
            }
          }
LABEL_55:
          if ( v29 )
          {
            if ( v75 )
            {
              v63 = (const char *)J_atoi(v75);
              goto LABEL_58;
            }
          }
          else if ( v75 )
          {
            v63 = (const char *)timeconvert(v75, &v55);
            goto LABEL_58;
          }
          v63 = 0;
LABEL_58:
          if ( !v60 )
            v60 = v79 - 10364;
          if ( !v59 )
            v59 = v57 + 9340;
          if ( v69 )
            v69 = J_atoi(v69);
          else
            v69 = 0;
          if ( v70 && !strcmp(v70, v57 + 9340) )
            v27 |= 0x200u;
          if ( v72 && !strcmp(v72, v57 + 9340) )
            v27 |= 0x8000u;
          if ( v71 && !strcmp(v71, v57 + 9340) )
            v27 |= 0x400u;
          user_add(v27, 0, v19, v21, v28, v62, v77, v63, v60, v59, v65, v66, v67, v68, v69, 1, v22, v74, v73);
        }
        v27 = v26 | 0x20;
        goto LABEL_45;
      }
    }
  }
LABEL_7:
  _mem_free(v3);
  if ( v34[0] )
  {
    v14 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v34);
    v12 = snprintf(v33, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v12 < 0x400 )
      return httpd_cgi_ret(a1, v33, v12, 4);
LABEL_11:
    v12 = 1023;
    return httpd_cgi_ret(a1, v33, v12, 4);
  }
  v11 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v10);
  v12 = snprintf(v33, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v11);
  if ( v12 >= 0x400 )
    goto LABEL_11;
  return httpd_cgi_ret(a1, v33, v12, 4);
}
// 47CFD0: variable 'v2' is possibly undefined
// 47CFFC: variable 'v5' is possibly undefined
// 47D080: variable 'v8' is possibly undefined
// 47D0D8: variable 'v10' is possibly undefined
// 47D4F0: variable 'v15' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84DC: using guessed type int __fastcall user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A85EC: using guessed type int __fastcall StrToMac(_DWORD, _DWORD);
// 6A862C: using guessed type int __fastcall StrToIp(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8848: using guessed type int __fastcall sq_file_get_state_new(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0047D9DC) --------------------------------------------------------
int __fastcall tg_url_get(char *a1, int a2, int *a3, int a4)
{
  int v8; // $a1
  int v9; // $a0
  int v10; // $v0
  int v11; // $a2
  int v12; // $v1
  bool v13; // dc
  int result; // $v0
  int v15[128]; // [sp+18h] [-200h] BYREF

  memset(v15, 0, sizeof(v15));
  v8 = a3[2];
  v9 = a3[3];
  v10 = *a3;
  v11 = a3[1];
  v12 = a3[4];
  v15[0] = 27;
  v15[3] = 3;
  v15[6] = v8;
  v15[7] = v9;
  v15[1] = 232;
  v15[4] = v10;
  v15[5] = v11;
  v15[8] = v12;
  v15[9] = a4;
  v13 = jianhl_order_opt_fun(v15, 232, v11) != 0;
  result = 0;
  if ( !v13 )
  {
    result = 0;
    if ( !v15[2] )
    {
      result = snprintf(a1, a2, "%s", (const char *)&v15[10]);
      if ( result >= a2 )
        result = a2 - 1;
    }
  }
  return result;
}
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0047DB24) --------------------------------------------------------
int __fastcall sub_47DB24(int a1)
{
  char *v2; // $s2
  char *v3; // $s4
  char *v4; // $s3
  int v5; // $s3
  int v6; // $a2
  char v8[512]; // [sp+18h] [-318h] BYREF
  char v9[256]; // [sp+218h] [-118h] BYREF
  int v10; // [sp+318h] [-18h] BYREF
  int v11; // [sp+31Ch] [-14h]
  int v12; // [sp+320h] [-10h]
  int v13; // [sp+324h] [-Ch]
  int v14; // [sp+328h] [-8h]

  v2 = httpd_get_parm(a1, "t");
  v3 = httpd_get_parm(a1, "i");
  v4 = httpd_get_parm(a1, (char *)&off_649214);
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( v3 )
    v11 = J_atoi(v3);
  if ( v4 )
    v5 = J_atoi(v4);
  else
    v5 = 0;
  strcpy(v8, "{}");
  if ( (!strcmp(v2, "tg") || !strcmp(v2, (const char *)&off_64D744)) && tg_url_get(v9, 256, &v10, v5) )
    v6 = sprintf(v8, "{\"u\":\"%s\"}", v9);
  else
    v6 = 2;
  return httpd_cgi_ret(a1, v8, v6, 4);
}
// 649214: using guessed type void *off_649214;
// 64D744: using guessed type void *off_64D744;
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0047DCD4) --------------------------------------------------------
int __fastcall get_web_language_type(int a1)
{
  int result; // $v0

  if ( !*(_BYTE *)(a1 + 210103) )
    return *(unsigned __int8 *)(a1 + 210102);
  result = *(_DWORD *)(a1 + 32) & 0x10000000;
  if ( result )
    result = sub_4743FC(a1);
  return result;
}

//----- (0047DD34) --------------------------------------------------------
int __fastcall sub_47DD34(int a1)
{
  char *v2; // $s0
  unsigned int v3; // $v0
  int v4; // $v0
  char *v6; // $s2
  const char *v7; // $s1
  const char *v8; // $v0
  unsigned int v9; // $s1
  size_t v10; // $v0
  const char **v11; // $s2
  int v12; // $s6
  int v13; // $s3
  const char *v14; // $s0
  int v15; // $v1
  const char *v16; // $a3
  char *v17; // $a2
  unsigned int v18; // $v0
  int v19; // $v0
  void *v20; // $v0
  void *v21; // $s0
  int v22; // $v0
  char v23[1024]; // [sp+20h] [-888h] BYREF
  char v24[1024]; // [sp+420h] [-488h] BYREF
  char v25[64]; // [sp+820h] [-88h] BYREF
  char v26[48]; // [sp+860h] [-48h] BYREF
  char *v27; // [sp+890h] [-18h]
  unsigned int v28; // [sp+894h] [-14h]
  char *v29; // [sp+898h] [-10h]
  char *v30; // [sp+89Ch] [-Ch]
  char *v31; // [sp+8A0h] [-8h]

  v2 = (char *)nvram_get("auth_htm");
  if ( nvram_match_def("billing_en", "1") )
  {
    memset(v25, 0, sizeof(v25));
    memset(v24, 0, sizeof(v24));
    v6 = httpd_get_parm(a1, "extend");
    IpaddrToStr(v25, a1 + 205460);
    v7 = (const char *)jhl_nv_get_def("lan_ipaddr");
    v8 = (const char *)jhl_nv_get_def("billing_httpd_port");
    v9 = snprintf(v24, 1024, "%s:%s/index.html?ip=%s", v7, v8, v25);
    if ( v9 >= 0x400 )
      v9 = 1023;
    if ( !v6
      || (memset(v23, 0, sizeof(v23)),
          v10 = strlen(v6),
          base64_decode(v6, v23, v10),
          v11 = (const char **)v26,
          v12 = split_string(v23, 38, v26, 8),
          v12 <= 0) )
    {
LABEL_25:
      v19 = jiffies_get();
      snprintf(&v24[v9], 1024 - v9, "&_t=%lu", v19);
      return httpd_send_redirect(a1, v24);
    }
    v29 = "1\"";
    v31 = "1\"";
    v13 = 0;
    v27 = "v1=";
    v30 = "r=";
    while ( 1 )
    {
      while ( 1 )
      {
        v14 = *v11;
        if ( strncmp(*v11, "m=", 2u) )
          break;
        v15 = 1024 - v9;
        v16 = v14 + 2;
        v17 = "&mac=%s";
LABEL_22:
        v28 = v15;
        v18 = snprintf(&v24[v9], v15, v17, v16);
        if ( v18 >= v28 )
          v18 = 1023 - v9;
        ++v13;
        v9 += v18;
        ++v11;
        if ( v12 == v13 )
          goto LABEL_25;
      }
      if ( !strncmp(v14, "t=", 2u) )
      {
        v15 = 1024 - v9;
        v16 = v14 + 2;
        v17 = "&netType=%s";
        goto LABEL_22;
      }
      if ( !strncmp(v14, v27, 3u) )
      {
        v15 = 1024 - v9;
        v16 = v14 + 3;
        v17 = "&vlan1=%s";
        goto LABEL_22;
      }
      if ( !strncmp(v14, v29 - 28036, 3u) )
      {
        v15 = 1024 - v9;
        v16 = v14 + 3;
        v17 = "&vlan2=%s";
        goto LABEL_22;
      }
      if ( !strncmp(v14, v30, 2u) )
      {
        v15 = 1024 - v9;
        v16 = v14 + 2;
        v17 = v31 - 28016;
        goto LABEL_22;
      }
      ++v13;
      ++v11;
      if ( v12 == v13 )
        goto LABEL_25;
    }
  }
  if ( v2 )
  {
    if ( !strcmp(v2, (const char *)&off_4CFA50) )
    {
      _mem_malloc(0x200000, "auth_htm", 4885);
      v21 = v20;
      if ( v20 )
      {
        v22 = read_tg_html_from_usb(v20, 0x200000, "webauthfile");
        if ( v22 >= 4 )
          return httpd_send_mime_file(a1, "text/html", v21, v22);
        _mem_free(v21);
      }
    }
    else if ( *v2 )
    {
      v3 = strlen(v2);
      if ( v3 >= 4 )
        return httpd_send_html_file(a1, "text/html", v2, v3);
    }
  }
  v4 = get_web_language_type(a1);
  if ( v4 == 1 )
    return httpd_cgi_ret(a1, "/auth_org_en.htm", 0, 2);
  if ( v4 == 99 )
    return httpd_cgi_ret(a1, "/auth_org_ft.htm", 0, 2);
  return httpd_cgi_ret(a1, "/auth_org.htm", 0, 2);
}
// 47E1E0: variable 'v20' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8974: using guessed type int __fastcall read_tg_html_from_usb(_DWORD, _DWORD, _DWORD);

//----- (0047E29C) --------------------------------------------------------
int __fastcall sub_47E29C(int a1)
{
  const char *v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  char *v5; // $a1
  signed int v7; // $v0
  int (__fastcall *v8)(int, const char *, char *, signed int); // $t9
  char *v9; // $v0

  v2 = (const char *)nvram_get("ddate_htm");
  if ( v2 )
  {
    v3 = (char *)v2;
    if ( !strcmp(v2, (const char *)&off_4CFA50) )
    {
      _mem_malloc(0x200000, "ddate_htm", 5324);
      v3 = v9;
      if ( v9 )
      {
        v7 = read_tg_html_from_usb(v9, 0x200000, "ddatefile");
        if ( v7 >= 4 )
        {
          v8 = (int (__fastcall *)(int, const char *, char *, signed int))httpd_send_mime_file;
          return v8(a1, "text/html", v3, v7);
        }
        _mem_free(v3);
      }
    }
    else if ( *v3 )
    {
      v7 = strlen(v3);
      if ( (unsigned int)v7 >= 4 )
      {
        v8 = httpd_send_html_file;
        return v8(a1, "text/html", v3, v7);
      }
    }
  }
  v4 = get_web_language_type(a1);
  if ( v4 == 1 )
  {
    v5 = "/ddate_org_en.htm";
    return httpd_cgi_ret(a1, v5, 0, 2);
  }
  if ( v4 != 99 )
  {
    v5 = "/ddate_org.htm";
    return httpd_cgi_ret(a1, v5, 0, 2);
  }
  return httpd_cgi_ret(a1, "/ddate_org_ft.htm", 0, 2);
}
// 47E3D4: variable 'v9' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8974: using guessed type int __fastcall read_tg_html_from_usb(_DWORD, _DWORD, _DWORD);

//----- (0047E464) --------------------------------------------------------
int __fastcall sub_47E464(int a1)
{
  const char *v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  char *v5; // $a1
  signed int v7; // $v0
  int (__fastcall *v8)(int, const char *, char *, signed int); // $t9
  char *v9; // $v0

  v2 = (const char *)nvram_get("notify_htm");
  if ( v2 )
  {
    v3 = (char *)v2;
    if ( !strcmp(v2, (const char *)&off_4CFA50) )
    {
      _mem_malloc(0x200000, "notify_htm", 5383);
      v3 = v9;
      if ( v9 )
      {
        v7 = read_tg_html_from_usb(v9, 0x200000, "notifyfile");
        if ( v7 >= 4 )
        {
          v8 = (int (__fastcall *)(int, const char *, char *, signed int))httpd_send_mime_file;
          return v8(a1, "text/html", v3, v7);
        }
        _mem_free(v3);
      }
    }
    else if ( *v3 )
    {
      v7 = strlen(v3);
      if ( (unsigned int)v7 >= 4 )
      {
        v8 = httpd_send_html_file;
        return v8(a1, "text/html", v3, v7);
      }
    }
  }
  v4 = get_web_language_type(a1);
  if ( v4 == 1 )
  {
    v5 = "/notify_org_en.htm";
    return httpd_cgi_ret(a1, v5, 0, 2);
  }
  if ( v4 != 99 )
  {
    v5 = "/notify_org.htm";
    return httpd_cgi_ret(a1, v5, 0, 2);
  }
  return httpd_cgi_ret(a1, "/notify_org_ft.htm", 0, 2);
}
// 47E59C: variable 'v9' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8974: using guessed type int __fastcall read_tg_html_from_usb(_DWORD, _DWORD, _DWORD);

//----- (0047E62C) --------------------------------------------------------
int __fastcall sub_47E62C(int a1)
{
  const char *v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  char *v5; // $a1
  signed int v7; // $v0
  int (__fastcall *v8)(int, const char *, char *, signed int); // $t9
  char *v9; // $v0

  v2 = (const char *)nvram_get("userinfo_htm");
  if ( v2 )
  {
    v3 = (char *)v2;
    if ( !strcmp(v2, (const char *)&off_4CFA50) )
    {
      _mem_malloc(0x200000, "userinfo_htm", 5439);
      v3 = v9;
      if ( v9 )
      {
        v7 = read_tg_html_from_usb(v9, 0x200000, "userinfofile");
        if ( v7 >= 4 )
        {
          v8 = (int (__fastcall *)(int, const char *, char *, signed int))httpd_send_mime_file;
          return v8(a1, "text/html", v3, v7);
        }
        _mem_free(v3);
      }
    }
    else if ( *v3 )
    {
      v7 = strlen(v3);
      if ( (unsigned int)v7 >= 4 )
      {
        v8 = httpd_send_html_file;
        return v8(a1, "text/html", v3, v7);
      }
    }
  }
  v4 = get_web_language_type(a1);
  if ( v4 == 1 )
  {
    v5 = "/userinfo_gg_org_en.htm";
    return httpd_cgi_ret(a1, v5, 0, 2);
  }
  if ( v4 != 99 )
  {
    v5 = "/userinfo_gg_org.htm";
    return httpd_cgi_ret(a1, v5, 0, 2);
  }
  return httpd_cgi_ret(a1, "/userinfo_gg_org_ft.htm", 0, 2);
}
// 47E764: variable 'v9' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8974: using guessed type int __fastcall read_tg_html_from_usb(_DWORD, _DWORD, _DWORD);

//----- (0047E7F4) --------------------------------------------------------
int __fastcall sub_47E7F4(int a1)
{
  const char *v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  char *v5; // $a1
  signed int v7; // $v0
  int (__fastcall *v8)(int, const char *, char *, signed int); // $t9
  char *v9; // $v0

  v2 = (const char *)nvram_get("ddate_notify_htm");
  if ( v2 )
  {
    v3 = (char *)v2;
    if ( !strcmp(v2, (const char *)&off_4CFA50) )
    {
      _mem_malloc(0x200000, "ddate_notify_htm", 5496);
      v3 = v9;
      if ( v9 )
      {
        v7 = read_tg_html_from_usb(v9, 0x200000, "ddatenotifyfile");
        if ( v7 >= 4 )
        {
          v8 = (int (__fastcall *)(int, const char *, char *, signed int))httpd_send_mime_file;
          return v8(a1, "text/html", v3, v7);
        }
        _mem_free(v3);
      }
    }
    else if ( *v3 )
    {
      v7 = strlen(v3);
      if ( (unsigned int)v7 >= 4 )
      {
        v8 = httpd_send_html_file;
        return v8(a1, "text/html", v3, v7);
      }
    }
  }
  v4 = get_web_language_type(a1);
  if ( v4 == 1 )
  {
    v5 = "/ddate_notify_org_en.htm";
    return httpd_cgi_ret(a1, v5, 0, 2);
  }
  if ( v4 != 99 )
  {
    v5 = "/ddate_notify_org.htm";
    return httpd_cgi_ret(a1, v5, 0, 2);
  }
  return httpd_cgi_ret(a1, "/ddate_notify_org_ft.htm", 0, 2);
}
// 47E92C: variable 'v9' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8974: using guessed type int __fastcall read_tg_html_from_usb(_DWORD, _DWORD, _DWORD);

//----- (0047E9BC) --------------------------------------------------------
int __fastcall org_html(int a1, int a2)
{
  int v3; // $v0
  int *v5; // $v0
  int v6; // $a2
  int v7; // $a0
  char *v8; // $a2
  signed int v9; // $a3
  int v10; // $v0
  int result; // $v0
  const char *v12; // $v0
  unsigned int v13; // $v0
  char v14[204]; // [sp+20h] [-CCh] BYREF

  v3 = get_name_hash((unsigned __int8 *)a2);
  v5 = httpd_get_file((const char *)a2, v3);
  if ( v5 )
  {
    v7 = *(_DWORD *)v5[8];
    v8 = *(char **)(v7 + 4);
    v9 = *(_DWORD *)(v7 + 8);
    v10 = *(_DWORD *)(a1 + 36) | 0x4000;
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    *(_DWORD *)(a1 + 44) = a2;
    *(_DWORD *)(a1 + 36) = v10;
    result = httpd_send_html_file(a1, "application/binary-file", v8, v9);
  }
  else
  {
    v12 = (const char *)_GET_LANG_TEXT(138, *(unsigned __int8 *)(a1 + 210102), v6);
    v13 = snprintf(v14, 200, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v12);
    if ( v13 >= 0xC8 )
      v13 = 199;
    result = httpd_cgi_ret(a1, v14, v13, 4);
  }
  return result;
}
// 47EA7C: variable 'v6' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0047EAEC) --------------------------------------------------------
int __fastcall sub_47EAEC(int a1)
{
  int v1; // $v0
  const char *v3; // $a1

  v1 = get_web_language_type(a1);
  if ( v1 == 1 )
  {
    v3 = "tg_org_en.htm";
    return org_html(a1, (int)v3);
  }
  if ( v1 != 99 )
  {
    v3 = "tg_org.htm";
    return org_html(a1, (int)v3);
  }
  return org_html(a1, (int)"tg_org_ft.htm");
}

//----- (0047EB78) --------------------------------------------------------
int __fastcall sub_47EB78(int a1)
{
  int v1; // $v0
  const char *v3; // $a1

  v1 = get_web_language_type(a1);
  if ( v1 == 1 )
  {
    v3 = "auth_org_en.htm";
    return org_html(a1, (int)v3);
  }
  if ( v1 != 99 )
  {
    v3 = "auth_org.htm";
    return org_html(a1, (int)v3);
  }
  return org_html(a1, (int)"auth_org_ft.htm");
}

//----- (0047EC04) --------------------------------------------------------
int __fastcall sub_47EC04(int a1)
{
  int v1; // $v0
  const char *v3; // $a1

  v1 = get_web_language_type(a1);
  if ( v1 == 1 )
  {
    v3 = "ddate_notify_org_en.htm";
    return org_html(a1, (int)v3);
  }
  if ( v1 != 99 )
  {
    v3 = "ddate_notify_org.htm";
    return org_html(a1, (int)v3);
  }
  return org_html(a1, (int)"ddate_notify_org_ft.htm");
}

//----- (0047EC90) --------------------------------------------------------
int __fastcall sub_47EC90(int a1)
{
  int v1; // $v0
  const char *v3; // $a1

  v1 = get_web_language_type(a1);
  if ( v1 == 1 )
  {
    v3 = "ddate_org_en.htm";
    return org_html(a1, (int)v3);
  }
  if ( v1 != 99 )
  {
    v3 = "ddate_org.htm";
    return org_html(a1, (int)v3);
  }
  return org_html(a1, (int)"ddate_org_ft.htm");
}

//----- (0047ED1C) --------------------------------------------------------
int __fastcall sub_47ED1C(int a1)
{
  int v1; // $v0
  const char *v3; // $a1

  v1 = get_web_language_type(a1);
  if ( v1 == 1 )
  {
    v3 = "notify_org_en.htm";
    return org_html(a1, (int)v3);
  }
  if ( v1 != 99 )
  {
    v3 = "notify_org.htm";
    return org_html(a1, (int)v3);
  }
  return org_html(a1, (int)"notify_org_ft.htm");
}

//----- (0047EDA8) --------------------------------------------------------
int __fastcall sub_47EDA8(int a1)
{
  int v1; // $v0
  const char *v3; // $a1

  v1 = get_web_language_type(a1);
  if ( v1 == 1 )
  {
    v3 = "block_en.htm";
    return org_html(a1, (int)v3);
  }
  if ( v1 != 99 )
  {
    v3 = "block.htm";
    return org_html(a1, (int)v3);
  }
  return org_html(a1, (int)"block_ft.htm");
}

//----- (0047EE34) --------------------------------------------------------
int __fastcall sub_47EE34(int a1)
{
  return org_html(a1, (int)"userinfo_gg_org.htm");
}

//----- (0047EE54) --------------------------------------------------------
void __fastcall search_str(char *a1, int a2, const void *a3, size_t a4)
{
  char *v5; // $s0
  char *v7; // $s1
  int v8; // $v0

  if ( a4 && (int)(a2 - a4) > 0 )
  {
    v5 = a1;
    v7 = &a1[a2 - a4];
    do
      v8 = memcmp(v5++, a3, a4);
    while ( v8 && v5 != v7 );
  }
}

//----- (0047EF14) --------------------------------------------------------
int __fastcall auth_html_upload_do_rcv(int a1)
{
  int v2; // $a2
  int v3; // $v0
  void *v4; // $a0
  char *v5; // $v0
  int v6; // $a1
  int v7; // $s5
  char *v8; // $s6
  const void *v9; // $s2
  void *v10; // $s5
  int v11; // $v0
  unsigned int v12; // $a2
  int v13; // $s6
  int v14; // $v0
  int v15; // $s6
  int v16; // $v1
  _BYTE *v17; // $a0
  _BYTE *v18; // $a1
  FILE *v19; // $a0
  FILE *v20; // $v0
  int v21; // $s0
  int v22; // $v0
  _BYTE *v23; // $a1
  _BYTE *v24; // $a0
  int v25; // $a2
  int v26; // $a1
  int v27; // $v0
  const void *v28; // $a0
  size_t v29; // $s0
  int v30; // $s4
  size_t v31; // $v0
  int v32; // $a0
  int v33; // $a1
  const char *v34; // $v0
  unsigned int v35; // $s0
  FILE *v36; // $a0
  void *v37; // $a0
  char *v38; // $a0
  int v39; // $a2
  FILE *v40; // $a0
  void *v41; // $a0
  int v42; // $a2
  int v43; // $a1
  const char *v44; // $v0
  int result; // $v0
  int v46; // $v0
  int v47; // $v0
  int v48; // $a1
  void *v49; // $s5
  int v50; // $v0
  int v51; // $s5
  int v52; // $v0
  _BYTE *v53; // $a0
  _BYTE *v54; // $v1
  FILE *v55; // $a0
  FILE *v56; // $v0
  int v57; // $v0
  _BYTE *v58; // $a1
  _BYTE *v59; // $a0
  int v60; // $a2
  _DWORD *v61; // $v0
  _DWORD *v62; // $v1
  _DWORD *v63; // $a0
  int v64; // $a1
  int v65; // $a3
  int v66; // $a2
  int v67; // $v1
  int v68; // $v0
  int v69; // $v0
  int v70; // $s0
  bool v71; // dc
  int v72; // $v0
  int v73; // $s6
  char v74[512]; // [sp+20h] [-280h] BYREF
  char v75[128]; // [sp+220h] [-80h] BYREF

  memset(v75, 0, sizeof(v75));
  memset(v74, 0, sizeof(v74));
  v3 = *(unsigned __int8 *)(a1 + 41);
  if ( !*(_BYTE *)(a1 + 41) )
  {
    v4 = *(void **)(a1 + 209700);
    if ( v4 )
    {
      _mem_free(v4);
      *(_DWORD *)(a1 + 209700) = 0;
    }
    *(_DWORD *)(a1 + 209704) = 0;
    _mem_malloc(102400, "auth_html_upload_do_rcv", 5575);
    *(_DWORD *)(a1 + 209700) = v5;
    if ( !v5 )
    {
      v34 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
      goto LABEL_31;
    }
    v6 = *(_DWORD *)(a1 + 205484);
    v7 = *(_DWORD *)(a1 + 205364) - v6;
    *(_DWORD *)(a1 + 209704) = v7;
    if ( v7 <= 0 )
    {
      v8 = v5;
    }
    else
    {
      memcpy(v5, (void *)(a1 + v6 + 564), v7);
      v8 = *(char **)(a1 + 209700);
      v7 = *(_DWORD *)(a1 + 209704);
    }
    v9 = (const void *)(a1 + 209708);
    *(_DWORD *)(a1 + 205560) = auth_html_upload_do_rcv;
    memset((void *)(a1 + 209708), 0, 0x80u);
    *(_DWORD *)(a1 + 209836) = 0;
    search_str(v8, v7, "\r\n", 2u);
    v10 = *(void **)(a1 + 209700);
    v12 = v11 - (_DWORD)v10;
    if ( v11 )
    {
      if ( v12 >= 0x7D )
      {
        v13 = 126;
        v12 = 124;
      }
      else
      {
        v13 = v12 + 2;
      }
      *(_BYTE *)(a1 + 209708) = 13;
      *(_BYTE *)(a1 + 209709) = 10;
      memcpy((void *)(a1 + 209710), v10, v12);
      *(_DWORD *)(a1 + 209836) = v13;
    }
    search_str((char *)v10, *(_DWORD *)(a1 + 209704), "filename=", 9u);
    v15 = v14;
    if ( !v14 )
      goto LABEL_79;
    memset((void *)(a1 + 209840), 0, 0x80u);
    v16 = *(unsigned __int8 *)(v15 + 10);
    if ( *(_BYTE *)(v15 + 10) )
    {
      v17 = (_BYTE *)(a1 + 209840);
      if ( v16 != 34 )
      {
        v18 = (_BYTE *)(v15 + 10);
        do
        {
          *v17 = v16;
          v16 = (unsigned __int8)*++v18;
          ++v17;
        }
        while ( *v18 && v18 != (_BYTE *)(v15 + 137) && v16 != 34 );
      }
    }
    strcpy(v74, "/tmp/auth_html_tmp/auth.tar.gz");
    create_dir2(v74);
    v19 = *(FILE **)(a1 + 209696);
    if ( v19 )
    {
      fclose(v19);
      *(_DWORD *)(a1 + 209696) = 0;
    }
    v20 = fopen(v74, "wb");
    v21 = a1 + 196608;
    *(_DWORD *)(a1 + 209696) = v20;
    if ( v20 )
    {
      search_str((char *)(v15 + 10), *(_DWORD *)(a1 + 209704) - (v15 + 10 - *(_DWORD *)(a1 + 209700)), "\r\n\r\n", 4u);
      v23 = (_BYTE *)(v22 + 4);
      if ( v22 )
      {
        v24 = *(_BYTE **)(a1 + 209700);
        v25 = *(_DWORD *)(a1 + 209704) - (v23 - v24);
        *(_DWORD *)(a1 + 209704) = v25;
        memmove(v24, v23, v25);
        *(_BYTE *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)) = 0;
        *(_BYTE *)(a1 + 41) = 8;
        v26 = *(_DWORD *)(a1 + 209704);
LABEL_23:
        search_str(*(char **)(a1 + 209700), v26, v9, *(_DWORD *)(a1 + 209836));
        if ( v27 )
        {
          v28 = *(const void **)(a1 + 209700);
          v29 = v27 - (_DWORD)v28;
          v30 = 1;
          if ( v27 - (int)v28 <= 0 )
            goto LABEL_39;
        }
        else
        {
          v69 = *(_DWORD *)(a1 + 209704);
          v70 = *(_DWORD *)(a1 + 209836);
          v71 = v70 >= v69;
          v29 = v69 - v70;
          if ( v71 )
            goto LABEL_78;
          v28 = *(const void **)(a1 + 209700);
          v30 = 0;
        }
        v31 = fwrite(v28, 1u, v29, *(FILE **)(a1 + 209696));
        v32 = 141;
        if ( v31 != v29 )
        {
          v33 = *(unsigned __int8 *)(a1 + 210102);
LABEL_30:
          v34 = (const char *)_GET_LANG_TEXT(v32, v33, v2);
LABEL_31:
          v35 = snprintf(v75, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v34);
          if ( v35 >= 0x80 )
            v35 = 127;
          v36 = *(FILE **)(a1 + 209696);
          if ( v36 )
          {
            fclose(v36);
            *(_DWORD *)(a1 + 209696) = 0;
          }
          v37 = *(void **)(a1 + 209700);
          if ( v37 )
          {
            _mem_free(v37);
            *(_DWORD *)(a1 + 209700) = 0;
          }
          *(_DWORD *)(a1 + 209704) = 0;
LABEL_47:
          system("rm -rf /tmp/auth_html_tmp");
          httpd_release_caches();
          sync();
          return httpd_cgi_ret(a1, v75, v35, 4);
        }
        fflush(*(FILE **)(a1 + 209696));
        v38 = *(char **)(a1 + 209700);
        v39 = *(_DWORD *)(a1 + 209704) - v29;
        *(_DWORD *)(a1 + 209704) = v39;
        memmove(v38, &v38[v29], v39);
        *(_BYTE *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)) = 0;
        if ( v30 )
        {
LABEL_39:
          v40 = *(FILE **)(a1 + 209696);
          if ( v40 )
          {
            fclose(v40);
            *(_DWORD *)(a1 + 209696) = 0;
          }
          v41 = *(void **)(a1 + 209700);
          v42 = 5856;
          if ( v41 )
          {
            _mem_free(v41);
            *(_DWORD *)(a1 + 209700) = 0;
          }
          v43 = *(unsigned __int8 *)(a1 + 210102);
          *(_DWORD *)(a1 + 209704) = 0;
          v44 = (const char *)_GET_LANG_TEXT(34, v43, v42);
          v35 = snprintf(v75, 128, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v44);
          if ( v35 >= 0x80 )
            v35 = 127;
          system("rm -rf /tmp/auth_html");
          system("mkdir -p /tmp/auth_html");
          system("tar -zxf /tmp/auth_html_tmp/auth.tar.gz -C /tmp/auth_html");
          if ( check_usb_state() )
          {
            system("mkdir -p /tmp/mnt/sda1/auth_html/");
            system("mv -f /tmp/auth_html_tmp/auth.tar.gz /tmp/mnt/sda1/auth_html/auth.tar.gz");
          }
          goto LABEL_47;
        }
LABEL_78:
        v68 = jiffies_get();
        mod_timer(a1 + 205540, v68 + 30000);
        return 0;
      }
LABEL_79:
      *(_BYTE *)(a1 + 41) = 7;
      goto LABEL_78;
    }
LABEL_80:
    v33 = *(unsigned __int8 *)(v21 + 13494);
    v32 = 139;
    goto LABEL_30;
  }
  if ( v3 == 7 )
  {
    if ( *(_DWORD *)(a1 + 209984) )
    {
      v47 = https_ssl_read(a1);
      if ( v47 == -2 )
      {
        v48 = *(_DWORD *)(a1 + 209704);
        goto LABEL_60;
      }
    }
    else
    {
      v47 = recv(
              *(_DWORD *)(a1 + 205416),
              (void *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)),
              102400 - *(_DWORD *)(a1 + 209704),
              0);
    }
    if ( v47 <= 0 )
    {
      v33 = *(unsigned __int8 *)(a1 + 210102);
      v32 = 140;
      goto LABEL_30;
    }
    v48 = v47 + *(_DWORD *)(a1 + 209704);
    *(_DWORD *)(a1 + 209704) = v48;
LABEL_60:
    if ( *(_DWORD *)(a1 + 209836) )
    {
      v49 = *(void **)(a1 + 209700);
    }
    else
    {
      search_str(*(char **)(a1 + 209700), v48, "\r\n", 2u);
      v49 = *(void **)(a1 + 209700);
      v73 = v72 - (_DWORD)v49;
      if ( v72 )
      {
        *(_BYTE *)(a1 + 209708) = 13;
        *(_BYTE *)(a1 + 209709) = 10;
        memcpy((void *)(a1 + 209710), v49, v73);
        v48 = *(_DWORD *)(a1 + 209704);
        *(_DWORD *)(a1 + 209836) = v73 + 2;
      }
      else
      {
        v48 = *(_DWORD *)(a1 + 209704);
      }
    }
    search_str((char *)v49, v48, "filename=", 9u);
    v51 = v50;
    if ( v50 )
    {
      memset((void *)(a1 + 209840), 0, 0x80u);
      v52 = *(unsigned __int8 *)(v51 + 10);
      if ( *(_BYTE *)(v51 + 10) )
      {
        v53 = (_BYTE *)(a1 + 209840);
        if ( v52 != 34 )
        {
          v54 = (_BYTE *)(v51 + 10);
          do
          {
            *v53 = v52;
            v52 = (unsigned __int8)*++v54;
            ++v53;
          }
          while ( *v54 && (_BYTE *)(v51 + 137) != v54 && v52 != 34 );
        }
      }
      strcpy(v74, "/tmp/auth_html_tmp/auth.tar.gz");
      create_dir2(v74);
      v55 = *(FILE **)(a1 + 209696);
      if ( v55 )
      {
        fclose(v55);
        *(_DWORD *)(a1 + 209696) = 0;
      }
      v56 = fopen(v74, "wb");
      v21 = a1 + 196608;
      *(_DWORD *)(a1 + 209696) = v56;
      if ( !v56 )
        goto LABEL_80;
      search_str((char *)(v51 + 10), *(_DWORD *)(a1 + 209704) - (v51 + 10 - *(_DWORD *)(a1 + 209700)), "\r\n\r\n", 4u);
      v58 = (_BYTE *)(v57 + 4);
      if ( v57 )
      {
        v59 = *(_BYTE **)(a1 + 209700);
        v60 = *(_DWORD *)(a1 + 209704) - (v58 - v59);
        *(_DWORD *)(a1 + 209704) = v60;
        memmove(v59, v58, v60);
        *(_BYTE *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)) = 0;
        *(_BYTE *)(a1 + 41) = 8;
        v26 = *(_DWORD *)(a1 + 209704);
        v9 = (const void *)(a1 + 209708);
        goto LABEL_23;
      }
    }
    if ( *(_DWORD *)(a1 + 209704) == 102400 )
    {
      v61 = *(_DWORD **)(a1 + 209700);
      v62 = v61 + 12800;
      v63 = v61 + 25600;
      do
      {
        v64 = v62[3];
        v65 = v62[1];
        v66 = v62[2];
        *v61 = *v62;
        v61[1] = v65;
        v61[2] = v66;
        v62 += 4;
        v61[3] = v64;
        v61 += 4;
      }
      while ( v62 != v63 );
      v67 = *(_DWORD *)(a1 + 209700) + 0x10000;
      *(_DWORD *)(a1 + 209704) = 51200;
      *(_BYTE *)(v67 - 14336) = 0;
    }
    goto LABEL_78;
  }
  if ( v3 != 8 )
  {
    v33 = *(unsigned __int8 *)(a1 + 210102);
    v32 = 13;
    goto LABEL_30;
  }
  if ( *(_DWORD *)(a1 + 209984) )
  {
    v46 = https_ssl_read(a1);
    if ( v46 == -2 )
    {
      v26 = *(_DWORD *)(a1 + 209704);
      v9 = (const void *)(a1 + 209708);
      goto LABEL_23;
    }
    if ( v46 >= 0 )
    {
      if ( v46 )
      {
LABEL_55:
        v26 = v46 + *(_DWORD *)(a1 + 209704);
        *(_DWORD *)(a1 + 209704) = v26;
        v9 = (const void *)(a1 + 209708);
        goto LABEL_23;
      }
LABEL_86:
      v33 = *(unsigned __int8 *)(a1 + 210102);
      v32 = 140;
      goto LABEL_30;
    }
  }
  else
  {
    v46 = recv(
            *(_DWORD *)(a1 + 205416),
            (void *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)),
            102400 - *(_DWORD *)(a1 + 209704),
            0);
    if ( v46 )
    {
      if ( v46 > 0 )
        goto LABEL_55;
      goto LABEL_86;
    }
  }
  result = 0;
  if ( !*(_BYTE *)(a1 + 210101) )
    goto LABEL_86;
  return result;
}
// 47EFEC: variable 'v5' is possibly undefined
// 47F088: variable 'v11' is possibly undefined
// 47F0FC: variable 'v14' is possibly undefined
// 47F254: variable 'v22' is possibly undefined
// 47F2B4: variable 'v27' is possibly undefined
// 47F328: variable 'v2' is possibly undefined
// 47F4AC: variable 'v42' is possibly undefined
// 47F6F4: variable 'v50' is possibly undefined
// 47F850: variable 'v57' is possibly undefined
// 47FA74: variable 'v72' is possibly undefined
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8584: using guessed type int __fastcall create_dir2(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (0047FB20) --------------------------------------------------------
int __fastcall sub_47FB20(int a1)
{
  int result; // $v0
  int v3; // $a2
  const char *v4; // $v0
  unsigned int v5; // $s1
  char v6[128]; // [sp+20h] [-80h] BYREF

  if ( check_usb_state() )
    return auth_html_upload_do_rcv(a1);
  memset(v6, 0, sizeof(v6));
  v4 = (const char *)_GET_LANG_TEXT(142, *(unsigned __int8 *)(a1 + 210102), v3);
  v5 = snprintf(v6, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v4);
  sync();
  if ( v5 >= 0x80 )
    result = httpd_cgi_ret(a1, v6, 127, 4);
  else
    result = httpd_cgi_ret(a1, v6, v5, 4);
  return result;
}
// 47FBB0: variable 'v3' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (0047FC50) --------------------------------------------------------
unsigned __int8 *__fastcall ShiBie_find(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4)
{
  int v4; // $t3
  unsigned __int8 *i; // $t4
  int v7; // $t0
  int v8; // $v1

  if ( !a1 || a2 < a4 )
    return 0;
  while ( 1 )
  {
    v4 = a4;
    if ( !a4 )
      break;
    for ( i = a1; ; ++i )
    {
      v7 = *a3;
      --v4;
      if ( (unsigned int)(v7 - 65) < 0x1A )
        v7 = (unsigned __int8)(v7 + 32);
      v8 = *i;
      ++a3;
      if ( (unsigned int)(v8 - 65) < 0x1A )
        v8 = (unsigned __int8)(v8 + 32);
      if ( v7 != v8 )
        break;
      if ( !v4 )
        return a1;
    }
    ++a1;
    --a2;
    if ( !a1 || a2 < a4 )
      return 0;
  }
  return a1;
}

//----- (0047FCE4) --------------------------------------------------------
int __fastcall user_name_pwd_get(int *a1, char *a2, char *a3)
{
  int v6; // $a1
  int v7; // $a0
  int v8; // $v0
  int v9; // $a2
  int v10; // $v1
  bool v11; // dc
  int result; // $v0
  int v13[513]; // [sp+18h] [-804h] BYREF

  memset(v13, 0, 0x800u);
  v6 = a1[2];
  v7 = a1[3];
  v8 = *a1;
  v9 = a1[1];
  v10 = a1[4];
  v13[0] = 16;
  v13[3] = 50;
  v13[6] = v6;
  v13[7] = v7;
  v13[1] = 2048;
  v13[4] = v8;
  v13[5] = v9;
  v13[8] = v10;
  v11 = jianhl_order_opt_fun(v13, 2048, v9) != 0;
  result = -1;
  if ( !v11 )
  {
    strcpy(a2, (char *)&v13[9]);
    strcpy(a3, (char *)&v13[25]);
    result = v13[2];
  }
  return result;
}
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0047FDEC) --------------------------------------------------------
int __fastcall sub_47FDEC(int a1)
{
  time_t v2; // $v0
  unsigned int v3; // $s3
  const char *v4; // $v0
  int v5; // $v0
  unsigned int v6; // $a0
  int v7; // $s3
  int v8; // $s0
  unsigned __int8 v9; // $s1
  const char *v10; // $s7
  const char *v11; // $fp
  const char *v12; // $v0
  unsigned int v13; // $v0
  int v14; // $s0
  unsigned int v15; // $v0
  const char *v17; // $v0
  char v18[10240]; // [sp+78h] [-2C38h] BYREF
  char v19[256]; // [sp+2878h] [-438h] BYREF
  char v20[256]; // [sp+2978h] [-338h] BYREF
  struct stat v21; // [sp+2A78h] [-238h] BYREF
  char v22[128]; // [sp+2B18h] [-198h] BYREF
  char v23[128]; // [sp+2B98h] [-118h] BYREF
  int v24[12]; // [sp+2C18h] [-98h] BYREF
  int v25[8]; // [sp+2C48h] [-68h] BYREF
  int v26[2]; // [sp+2C68h] [-48h] BYREF
  const char *v27; // [sp+2C70h] [-40h]
  const char *v28; // [sp+2C74h] [-3Ch]
  const char *v29; // [sp+2C78h] [-38h]
  const char *v30; // [sp+2C7Ch] [-34h]
  const char *v31; // [sp+2C80h] [-30h]
  const char *v32; // [sp+2C84h] [-2Ch]
  const char *v33; // [sp+2C88h] [-28h]
  const char *v34; // [sp+2C8Ch] [-24h]
  const char *v35; // [sp+2C90h] [-20h]
  const char *v36; // [sp+2C94h] [-1Ch]
  const char *v37; // [sp+2C98h] [-18h]
  const char *v38; // [sp+2C9Ch] [-14h]
  const char *v39; // [sp+2CA0h] [-10h]
  const char *v40; // [sp+2CA4h] [-Ch]
  const char *v41; // [sp+2CA8h] [-8h]
  const char *v42; // [sp+2CACh] [-4h]

  memset(v20, 0, sizeof(v20));
  memset(v18, 0, sizeof(v18));
  memset(v23, 0, sizeof(v23));
  memset(v22, 0, sizeof(v22));
  v2 = time(0);
  v26[0] = 0;
  v26[1] = 0;
  v25[0] = 0;
  v25[1] = 0;
  v25[2] = 0;
  v25[3] = 0;
  v25[4] = 0;
  v25[5] = 0;
  v25[6] = 0;
  v25[7] = 0;
  v24[0] = 0;
  v24[1] = 0;
  v24[2] = 0;
  v24[3] = 0;
  v24[4] = 0;
  v24[5] = 0;
  v24[6] = 0;
  v24[7] = 0;
  v24[8] = 0;
  v24[9] = 0;
  v24[10] = 0;
  v24[11] = 0;
  v3 = v2;
  user_name_pwd_get((int *)(a1 + 205460), v23, v22);
  MacToStr(v25, v26);
  IpaddrToStr(v24, a1 + 205460);
  if ( stat("/tmp/auth_pic", &v21) && check_usb_state() )
  {
    memset(v19, 0, sizeof(v19));
    v17 = (const char *)nvram_get("auth_pic_ext");
    if ( !v17 )
      v17 = ".jpg";
    snprintf(v19, 256, "/tmp/mnt/sda1/auth_pic/auth%s", v17);
    if ( !stat(v19, &v21) )
      system("cp -rf /tmp/mnt/sda1/auth_pic /tmp/auth_pic");
  }
  v4 = (const char *)nvram_get("auth_pic_ext");
  if ( !v4 )
    v4 = ".jpg";
  snprintf(v20, 256, "/tmp/auth_pic/auth%s", v4);
  v5 = stat(v20, &v21);
  v6 = v3;
  v7 = v5;
  srandom(v6);
  strcpy(v18, "{\"code\":0,\"error\":\"\",\"data\":{");
  v42 = (const char *)jhl_nv_get_def("user_sms_time");
  v8 = (unsigned __int8)random();
  v9 = random();
  v27 = (const char *)jhl_nv_get_def("user_sms_card_type");
  v28 = (const char *)jhl_nv_get_def("user_sms_card_atype");
  v10 = (const char *)jhl_nv_get_def("user_sms_card_dtype");
  v11 = (const char *)jhl_nv_get_def("user_sms_card_utype");
  v41 = (const char *)jhl_nv_get_def("user_sms_card_gotype");
  v40 = (const char *)jhl_nv_get_def("user_sms_card_gvtype");
  v39 = (const char *)jhl_nv_get_def("user_sms_card_lname");
  v29 = (const char *)jhl_nv_get_def("user_sms_card_dname");
  v38 = (const char *)jhl_nv_get_def("user_sms_card_uname");
  v37 = (const char *)jhl_nv_get_def("user_sms_card_gname");
  v36 = (const char *)jhl_nv_get_def("user_sms_card_acname");
  v35 = (const char *)jhl_nv_get_def("user_sms_card_dcname");
  v34 = (const char *)jhl_nv_get_def("user_sms_card_ucname");
  v33 = (const char *)jhl_nv_get_def("user_sms_card_gocname");
  v32 = (const char *)jhl_nv_get_def("user_sms_card_gvcname");
  v31 = (const char *)jhl_nv_get_def("user_sms_card_gctype");
  v30 = (const char *)jhl_nv_get_def("user_sms_card_goname");
  v12 = (const char *)jhl_nv_get_def("user_sms_card_gvname");
  v13 = snprintf(
          &v18[29],
          10211,
          "\"time\":\"%s\",\"pic_en\":\"%d\",\"card_pos\":\"%c%c\",\"card_type\":\"%s\",\"card_atype\":\"%s\",\"card_dtyp"
          "e\":\"%s\",\"card_utype\":\"%s\",\"card_gotype\":\"%s\",\"card_gvtype\":\"%s\",\"card_lname\":\"%s\",\"card_dn"
          "ame\":\"%s\",\"card_uname\":\"%s\",\"card_gname\":\"%s\",\"card_acname\":\"%s\",\"card_dcname\":\"%s\",\"card_"
          "ucname\":\"%s\",\"card_gocname\":\"%s\",\"card_gvcname\":\"%s\",\"card_gctype\":\"%s\",\"card_goname\":\"%s\","
          "\"card_gvname\":\"%s\",\"name\":\"%s\",\"pwd\":\"%s\"",
          v42,
          v7 == 0,
          v8 % 10 + 65,
          v9 % 9 + 49,
          v27,
          v28,
          v10,
          v11,
          v41,
          v40,
          v39,
          v29,
          v38,
          v37,
          v36,
          v35,
          v34,
          v33,
          v32,
          v31,
          v30,
          v12,
          v23,
          v22);
  v14 = v13 + 29;
  if ( v13 >= 0x27E3 )
    v14 = 10239;
  v15 = snprintf(&v18[v14], 10240 - v14, "}}");
  if ( v15 >= 10240 - v14 )
    v15 = 10239 - v14;
  return httpd_cgi_ret(a1, v18, v15 + v14, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (004804D0) --------------------------------------------------------
int __fastcall web_get_user_agent(unsigned __int8 *a1, int a2, _BYTE *a3, int a4)
{
  unsigned __int8 *v7; // $v0
  unsigned __int8 *v9; // $fp
  unsigned __int8 *v10; // $v0
  unsigned __int8 *v11; // $s7
  int v12; // $s0
  _BOOL4 v13; // $v0
  bool v14; // dc
  int result; // $v0
  int v16; // $s0
  unsigned __int8 *v17; // $v0
  unsigned __int8 *v18; // $a0
  _BYTE *v19; // $s4
  unsigned __int8 *v20; // $v0
  unsigned __int8 *v21; // $a0
  _BOOL4 i; // $v1
  _BYTE *v23; // [sp+1Ch] [-Ch]

  v7 = ShiBie_find(a1, a2, "(", 1);
  v9 = v7 + 1;
  if ( !v7 )
    return 0;
  v10 = ShiBie_find(v7 + 1, a2 - (v9 - a1), ")", 1);
  v11 = v10;
  if ( !v10 )
    return 0;
  v12 = v10 - v9;
  if ( ShiBie_find(v9, v10 - v9, "iPhone", 6) )
  {
    v13 = v9 < v11;
    goto LABEL_5;
  }
  v14 = ShiBie_find(v9, v12, "Android", 7) != 0;
  v13 = v9 < v11;
  if ( !v14 )
  {
    v14 = ShiBie_find(v9, v12, "iPad", 4) != 0;
    v13 = v9 < v11;
    if ( !v14 )
    {
      v14 = ShiBie_find(v9, v12, "iPod", 4) != 0;
      v13 = v9 < v11;
      if ( !v14 )
      {
        v14 = ShiBie_find(v9, v12, "Windows Phone", 13) != 0;
        v13 = v9 < v11;
        if ( !v14 )
        {
          v14 = ShiBie_find(v9, v12, "Symbian", 7) != 0;
          v13 = v9 < v11;
          if ( !v14 )
          {
            v14 = ShiBie_find(v9, v12, "BlackBerry", 10) != 0;
            v13 = v9 < v11;
            if ( !v14 )
            {
              if ( ShiBie_find(v9, v12, "Windows NT", 10) || ShiBie_find(v9, v12, "Macintosh", 9) )
              {
                *a3 = 80;
                a3[1] = 67;
                a3[2] = 0;
                return 0;
              }
              return 0;
            }
          }
        }
      }
    }
  }
LABEL_5:
  v14 = !v13;
  result = 0;
  if ( !v14 )
  {
    v16 = 0;
    if ( a4 > 0 )
    {
      v23 = a3;
      while ( 1 )
      {
        if ( !strnicmp(v9, "U;", 2) )
        {
          v9 += 3;
          goto LABEL_9;
        }
        if ( !strnicmp(v9, "zh-cn", 5) )
          break;
        v14 = strnicmp(v9, "en_us", 5) == 0;
        v17 = v9 + 5;
        if ( v14 )
          goto LABEL_14;
        v14 = strnicmp(v9, "en-us", 5) == 0;
        v17 = v9 + 5;
        if ( v14 )
          goto LABEL_14;
        v14 = strnicmp(v9, "zh_cn", 5) == 0;
        v17 = v9 + 5;
        if ( v14 )
          goto LABEL_14;
        v14 = strnicmp(v9, "Linux", 5) == 0;
        v17 = v9 + 5;
        if ( v14 )
          goto LABEL_14;
        if ( !strnicmp(v9, "like", 4) )
        {
          v20 = v9 + 4;
        }
        else
        {
          v14 = strnicmp(v9, "java", 4) == 0;
          v20 = v9 + 4;
          if ( !v14 )
          {
            ++v16;
            *v23++ = *v9++;
            goto LABEL_9;
          }
        }
        if ( v20 >= v11 )
          goto LABEL_19;
        v21 = v9 + 5;
        if ( v9[4] != 59 )
        {
          for ( i = v21 < v11; ; i = v21 < v11 )
          {
            ++v21;
            if ( !i )
              break;
            v9 = v21;
            if ( *(v21 - 1) == 59 )
              goto LABEL_9;
          }
          v19 = &a3[v16];
          if ( !v16 )
            return 0;
LABEL_21:
          *v19 = 0;
          return v16;
        }
        v9 += 5;
LABEL_9:
        if ( v9 >= v11 )
          goto LABEL_19;
        if ( v16 >= a4 )
          goto LABEL_20;
      }
      v17 = v9 + 5;
LABEL_14:
      if ( v17 >= v11 )
        goto LABEL_19;
      v18 = v9 + 6;
      if ( v9[5] != 59 )
      {
        while ( 1 )
        {
          v14 = v18++ < v11;
          if ( !v14 )
            break;
          v9 = v18;
          if ( *(v18 - 1) == 59 )
            goto LABEL_9;
        }
LABEL_19:
        if ( !v16 )
          return 0;
LABEL_20:
        v19 = &a3[v16];
        goto LABEL_21;
      }
      v9 += 6;
      goto LABEL_9;
    }
  }
  return result;
}
// 6A88B8: using guessed type int __fastcall strnicmp(_DWORD, _DWORD, _DWORD);

//----- (00480954) --------------------------------------------------------
int __fastcall webauth_data_send(int a1, int a2)
{
  int v4; // $a2
  char *v5; // $s3
  const char *v6; // $v0
  int v7; // $v0
  int v8; // $v0
  int v10; // $s4
  const char *v11; // $s0
  const char *v12; // $v0
  char v13[2048]; // [sp+20h] [-C00h] BYREF
  char v14[1024]; // [sp+820h] [-400h] BYREF

  v5 = httpd_get_parm(a1, "callback");
  if ( a2 != 1 )
  {
    if ( a2 < 2 )
    {
      if ( !a2 )
      {
        v6 = (const char *)_GET_LANG_TEXT(1778, *(unsigned __int8 *)(a1 + 210102), v4);
        goto LABEL_6;
      }
    }
    else
    {
      if ( a2 == 2 )
      {
        v6 = (const char *)_GET_LANG_TEXT(179, *(unsigned __int8 *)(a1 + 210102), v4);
        goto LABEL_6;
      }
      if ( a2 == 4 )
      {
        v6 = (const char *)_GET_LANG_TEXT(175, *(unsigned __int8 *)(a1 + 210102), v4);
LABEL_6:
        v7 = sprintf(v14, "{\"ret\":1,\"msg\":\"%s\"}", v6);
        goto LABEL_7;
      }
    }
    v6 = (const char *)_GET_LANG_TEXT(171, *(unsigned __int8 *)(a1 + 210102), a2);
    goto LABEL_6;
  }
  v10 = *(_DWORD *)(a1 + 205464);
  v11 = (const char *)nvram_get("rzgl_redirct_en");
  if ( !v11 )
    v11 = "0";
  v12 = (const char *)nvram_get("rzgl_redirct_url");
  if ( !v12 )
    v12 = "";
  v7 = sprintf(v14, "{\"ret\":0,\"i\":%u,\"e\":\"%s\",\"l\":\"%s\",\"isto_en\":\"%d\"}", v10, v11, v12, 0);
LABEL_7:
  if ( !v5 )
    return httpd_cgi_ret(a1, v14, v7, 4);
  memset(v13, 0, sizeof(v13));
  v8 = sprintf(v13, "try{%s(%s);}catch(e){}", v5, v14);
  return httpd_cgi_ret(a1, v13, v8, 4);
}
// 4809D4: variable 'v4' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00480BBC) --------------------------------------------------------
int __fastcall webauth_data_timeout(_DWORD *a1)
{
  int v2; // $a1
  int v3; // $a0
  int v4; // $a3
  int v5; // $a2
  int v6; // $v1
  _DWORD *v7; // $s1
  int v8; // $v0
  int v9; // $s3
  int v11[257]; // [sp+18h] [-404h] BYREF

  memset(v11, 0, 0x400u);
  v2 = a1[51367];
  v3 = a1[51368];
  v4 = a1[51365];
  v5 = a1[51366];
  v6 = a1[51369];
  v11[0] = 16;
  v11[3] = 41;
  v11[6] = v2;
  v11[7] = v3;
  v11[1] = 1024;
  v11[4] = v4;
  v11[5] = v5;
  v11[8] = v6;
  if ( jianhl_order_opt_fun(v11, 1024, v5) )
  {
    v7 = a1 + 49152;
    v8 = a1[51393];
    v11[9] = 0;
    if ( v8 >= 5 )
    {
      v9 = 0;
LABEL_4:
      a1[51388] = httpd_keep_alive_timeout;
      a1[51387] = jiffies_get() + 5000;
      add_timer(a1 + 51385);
      return webauth_data_send((int)a1, v9);
    }
  }
  else
  {
    v9 = v11[9];
    if ( v11[9] )
      goto LABEL_4;
    v7 = a1 + 49152;
    v8 = a1[51393];
    v9 = 0;
    if ( v8 >= 5 )
      goto LABEL_4;
  }
  v7[2241] = v8 + 1;
  v7[2235] = jiffies_get() + 1000;
  v7[2237] = a1;
  v7[2236] = &webauth_data_timeout;
  return add_timer(a1 + 51385);
}
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00480D88) --------------------------------------------------------
int __fastcall webauth_data(_DWORD *a1)
{
  a1[51393] = 0;
  webauth_data_timeout(a1);
  return 0;
}

//----- (00480DC4) --------------------------------------------------------
int __fastcall sub_480DC4(int a1)
{
  char *v2; // $s3
  char *v3; // $v0
  char *v4; // $s4
  int v5; // $t2
  int v6; // $t1
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  const char *v10; // $s6
  char *v11; // $fp
  int v12; // $v0
  struct tm *v13; // $s5
  unsigned int v14; // $v0
  int v15; // $s1
  unsigned int v16; // $s7
  int v17; // $a2
  int v18; // $v0
  int v19; // $v0
  unsigned int v20; // $v0
  const char *v22; // $v0
  int *v23; // $v1
  int v24; // $t0
  int v25; // $a3
  int v26; // $a2
  int v27; // $a1
  int v28; // $a2
  int v29; // $a1
  __int16 v30; // $a0
  char v31; // $v0
  const char *v32; // $v0
  int v33; // $a1
  int v34; // $a0
  char *v35; // $v0
  const char *v36; // $s4
  char *v37; // $v0
  char *v38; // $v0
  const char *v39; // $a2
  const char *v40; // $v0
  unsigned int v41; // $s1
  unsigned int v42; // $v0
  const char *v43; // $s2
  const char *v44; // $s3
  int v45; // $s4
  const char *v46; // $v0
  char v47[2048]; // [sp+38h] [-1980h] BYREF
  char v48[2048]; // [sp+838h] [-1180h] BYREF
  int v49[256]; // [sp+1038h] [-980h] BYREF
  int v50[6]; // [sp+1438h] [-580h] BYREF
  char v51[4]; // [sp+1450h] [-568h] BYREF
  char v52[256]; // [sp+1838h] [-180h] BYREF
  int v53[12]; // [sp+1938h] [-80h] BYREF
  int v54[8]; // [sp+1968h] [-50h] BYREF
  int v55; // [sp+1988h] [-30h] BYREF
  int v56; // [sp+198Ch] [-2Ch]
  int v57; // [sp+1990h] [-28h]
  int v58; // [sp+1994h] [-24h]
  int v59; // [sp+1998h] [-20h]
  int v60[2]; // [sp+199Ch] [-1Ch] BYREF
  time_t v61; // [sp+19A4h] [-14h] BYREF
  int *v62; // [sp+19A8h] [-10h]
  const char *v63; // [sp+19ACh] [-Ch]
  const char *v64; // [sp+19B0h] [-8h]

  memset(v48, 0, sizeof(v48));
  v60[0] = 0;
  v60[1] = 0;
  v53[0] = 0;
  v53[1] = 0;
  v53[2] = 0;
  v53[3] = 0;
  v53[4] = 0;
  v53[5] = 0;
  v53[6] = 0;
  v53[7] = 0;
  v53[8] = 0;
  v53[9] = 0;
  v53[10] = 0;
  v53[11] = 0;
  v54[0] = 0;
  v54[1] = 0;
  v54[2] = 0;
  v54[3] = 0;
  v54[4] = 0;
  v54[5] = 0;
  v54[6] = 0;
  v54[7] = 0;
  memset(v52, 0, sizeof(v52));
  v2 = httpd_get_parm(a1, "usr");
  v4 = httpd_get_parm(a1, (char *)&off_649194);
  v3 = httpd_get_parm(a1, "callback");
  v5 = *(_DWORD *)(a1 + 205460);
  v6 = *(_DWORD *)(a1 + 205464);
  v7 = *(_DWORD *)(a1 + 205468);
  v8 = *(_DWORD *)(a1 + 205472);
  v9 = *(_DWORD *)(a1 + 205476);
  v62 = v53;
  v55 = v5;
  v56 = v6;
  v57 = v7;
  v58 = v8;
  v59 = v9;
  v10 = v3;
  IpaddrToStr(v53, &v55);
  MacToStr(v54, v60);
  if ( (*(_DWORD *)(a1 + 32) & 0x10000) != 0 )
  {
    v11 = *(char **)(a1 + 205528);
    if ( v11 )
    {
      v12 = strlen(v11);
      web_get_user_agent((unsigned __int8 *)v11, v12, v52, 255);
    }
  }
  time(&v61);
  v13 = localtime(&v61);
  v14 = snprintf(
          v48,
          2048,
          a04d02d02d02d02_0,
          v13->tm_year + 1900,
          v13->tm_mon + 1,
          v13->tm_mday,
          v13->tm_hour,
          v13->tm_min,
          v13->tm_sec,
          v54,
          v62,
          v52);
  if ( v2 )
  {
    v15 = v14;
    if ( v4 )
    {
      if ( v14 >= 0x800 )
        v15 = 2047;
      v16 = snprintf(&v48[v15], 2048 - v15, aSS_14, v2, v4);
      if ( v16 >= 2048 - v15 )
        v16 = 2047 - v15;
      memset(v49, 0, sizeof(v49));
      v63 = (const char *)&v49[4];
      v49[0] = 16;
      v49[3] = 18;
      v49[1] = 1024;
      v49[36] = v55;
      v49[37] = v56;
      v49[38] = v57;
      v49[39] = v58;
      v49[40] = v59;
      strlcpy(&v49[4], v2, 64);
      strlcpy(&v49[20], v4, 64);
      v49[41] = 0;
      LOBYTE(v49[43]) = 0;
      check_client_is_or_not_mobile(a1);
      if ( v18 )
        v49[41] = 1;
      if ( jianhl_order_opt_fun(v49, v49[1], v17) || v49[2] )
      {
        v50[0] = 1701978747;
        v19 = 26;
        v50[1] = 825893492;
        v50[2] = 1936532012;
        v50[3] = 574235239;
        v50[4] = -1278364209;
        v50[5] = -204542540;
        strcpy(v51, "\"}");
      }
      else
      {
        switch ( v49[42] )
        {
          case 1:
          case 2:
            v32 = (const char *)_GET_LANG_TEXT(169, *(unsigned __int8 *)(a1 + 210102), v49[42]);
            goto LABEL_26;
          case 3:
            v32 = (const char *)_GET_LANG_TEXT(170, *(unsigned __int8 *)(a1 + 210102), v49[42]);
            goto LABEL_26;
          case 4:
          case 5:
          case 0xC:
          case 0xE:
            v33 = *(unsigned __int8 *)(a1 + 210102);
            v34 = 171;
            goto LABEL_30;
          case 7:
            v32 = (const char *)_GET_LANG_TEXT(172, *(unsigned __int8 *)(a1 + 210102), v49[42]);
            goto LABEL_26;
          case 8:
            v32 = (const char *)_GET_LANG_TEXT(173, *(unsigned __int8 *)(a1 + 210102), v49[42]);
            goto LABEL_26;
          case 9:
            v32 = (const char *)_GET_LANG_TEXT(174, *(unsigned __int8 *)(a1 + 210102), v49[42]);
            goto LABEL_26;
          case 0xA:
            v32 = (const char *)_GET_LANG_TEXT(175, *(unsigned __int8 *)(a1 + 210102), v49[42]);
            goto LABEL_26;
          case 0xB:
          case 0x11:
            v35 = strstr((const char *)&v49[45], ">>");
            if ( v35 )
            {
              v36 = v35 + 2;
              *v35 = 0;
              v37 = strstr(v35 + 2, ">>");
              if ( v37 )
              {
                v64 = v37 + 2;
                *v37 = 0;
                v38 = strstr(v37 + 2, ">>");
                v39 = v64;
                if ( v38 )
                {
                  *v38 = 0;
                  v40 = v38 + 2;
                }
                else
                {
                  v40 = "";
                }
              }
              else
              {
                v40 = "";
                v39 = "";
              }
            }
            else
            {
              v40 = "";
              v39 = "";
              v36 = "";
            }
            v41 = v16 + v15;
            v42 = snprintf(&v48[v41], 2048 - v41, "\t%s\t%s\t%s\t%s\n", v36, v39, v40, (const char *)&v49[45]);
            if ( v42 >= 2048 - v41 )
              v42 = 2047 - v41;
            auth_write_usblog(v13, v48, v42 + v41);
            v43 = (const char *)nvram_get("rzgl_redirct_en");
            if ( !v43 )
              v43 = "0";
            v44 = (const char *)nvram_get("rzgl_redirct_url");
            if ( !v44 )
              v44 = "";
            v45 = v49[37];
            v46 = (const char *)IpaddrToStr(v62, &v49[36]);
            v19 = sprintf(
                    (char *)v50,
                    "{\"ret\":0,\"u\":\"%s\",\"i\":%u,\"i6\":\"%s\",\"e\":\"%s\",\"l\":\"%s\",\"isto_en\":\"%d\"}",
                    v63,
                    v45,
                    v46,
                    v43,
                    v44,
                    0);
            break;
          case 0xF:
            return webauth_data((_DWORD *)a1);
          case 0x10:
            v32 = (const char *)_GET_LANG_TEXT(176, *(unsigned __int8 *)(a1 + 210102), v49[42]);
            goto LABEL_26;
          default:
            v33 = *(unsigned __int8 *)(a1 + 210102);
            v34 = 177;
LABEL_30:
            v32 = (const char *)_GET_LANG_TEXT(v34, v33, v49[42]);
LABEL_26:
            v19 = sprintf((char *)v50, "{\"ret\":1,\"msg\":\"%s\"}", v32);
            break;
        }
      }
      if ( v10 )
        goto LABEL_17;
      return httpd_cgi_ret(a1, (char *)v50, v19, 4);
    }
  }
  v22 = "{\"ret\":1,\"msg\":\"not user or password err\"}";
  v23 = v50;
  do
  {
    v24 = *(_DWORD *)v22;
    v25 = *((_DWORD *)v22 + 1);
    v26 = *((_DWORD *)v22 + 2);
    v27 = *((_DWORD *)v22 + 3);
    v22 += 16;
    *v23 = v24;
    v23[1] = v25;
    v23[2] = v26;
    v23[3] = v27;
    v23 += 4;
  }
  while ( v22 != "word err\"}" );
  v28 = *(_DWORD *)v22;
  v29 = *((_DWORD *)v22 + 1);
  v30 = *((_WORD *)v22 + 4);
  v31 = v22[10];
  *v23 = v28;
  *((_BYTE *)v23 + 10) = v31;
  v23[1] = v29;
  *((_WORD *)v23 + 4) = v30;
  v19 = 42;
  if ( !v10 )
    return httpd_cgi_ret(a1, (char *)v50, v19, 4);
LABEL_17:
  memset(v47, 0, sizeof(v47));
  v20 = snprintf(v47, 2048, "try{%s(%s);}catch(e){}", v10, (const char *)v50);
  if ( v20 >= 0x800 )
    v20 = 2047;
  return httpd_cgi_ret(a1, v47, v20, 4);
}
// 48115C: variable 'v18' is possibly undefined
// 481170: variable 'v17' is possibly undefined
// 649194: using guessed type char *off_649194;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A835C: using guessed type int __fastcall auth_write_usblog(_DWORD, _DWORD, _DWORD);
// 6A843C: using guessed type int __fastcall IpaddrToStr(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00481690) --------------------------------------------------------
int __fastcall fw_upgrade_timeout(int a1)
{
  int v2; // $s0
  int v3; // $v0
  bool v4; // dc
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  int v8; // $s2
  unsigned int v9; // $v0
  char *v10; // $v0
  int v11; // $a2
  int v12; // $s0
  int v13; // $a1
  int v14; // $a2
  int v15; // $a0
  char v16[1024]; // [sp+18h] [-414h] BYREF
  const char *v17; // [sp+418h] [-14h] BYREF
  void *v18; // [sp+41Ch] [-10h]
  int v19; // [sp+420h] [-Ch]
  int v20; // [sp+424h] [-8h]

  v2 = nvram_get_int("fw_upgrade_state");
  if ( v2 && v2 != 3 || (v3 = *(_DWORD *)(a1 + 205572), v4 = v3 >= 121, v5 = v3 + 1, v4) )
  {
    *(_DWORD *)(a1 + 205552) = httpd_keep_alive_timeout;
    *(_DWORD *)(a1 + 205548) = jiffies_get() + 5000;
    add_timer(a1 + 205540);
    strcpy(v16, "{\"code\":0,\"error\":\"\",\"data\":{");
    switch ( v2 )
    {
      case 0:
        v13 = *(unsigned __int8 *)(a1 + 210102);
        v14 = 0;
        v15 = 20;
        goto LABEL_15;
      case 1:
        v13 = *(unsigned __int8 *)(a1 + 210102);
        v14 = 1;
        v15 = 20;
        goto LABEL_15;
      case 2:
        v7 = (const char *)_GET_LANG_TEXT(22, *(unsigned __int8 *)(a1 + 210102), 572668450);
        goto LABEL_7;
      case 3:
        v7 = (const char *)_GET_LANG_TEXT(23, *(unsigned __int8 *)(a1 + 210102), 572668450);
        goto LABEL_7;
      case 4:
        v10 = httpd_get_parm(a1, "reboot_time");
        v12 = (int)v10;
        if ( v10 && strlen(v10) >= 3 )
        {
          v17 = "time_reboot_del.sh";
          v18 = &unk_649D2C;
          v19 = 0;
          eval(&v17, 0, 0, 0);
          v17 = "time_reboot_add.sh";
          v18 = &unk_649D2C;
          v19 = v12;
          v20 = 0;
          eval(&v17, 0, 0, 0);
        }
        v7 = (const char *)_GET_LANG_TEXT(24, *(unsigned __int8 *)(a1 + 210102), v11);
        goto LABEL_7;
      default:
        v13 = *(unsigned __int8 *)(a1 + 210102);
        v14 = v2;
        v15 = 25;
LABEL_15:
        v7 = (const char *)_GET_LANG_TEXT(v15, v13, v14);
LABEL_7:
        v8 = sprintf(&v16[29], "\"err\":\"%s\"", v7) + 29;
        v9 = snprintf(&v16[v8], 1024 - v8, "}}");
        if ( v9 >= 1024 - v8 )
          v9 = 1023 - v8;
        result = httpd_cgi_ret(a1, v16, v9 + v8, 4);
        break;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 205572) = v5;
    *(_DWORD *)(a1 + 205548) = jiffies_get() + 1000;
    *(_DWORD *)(a1 + 205556) = a1;
    *(_DWORD *)(a1 + 205552) = fw_upgrade_timeout;
    result = add_timer(a1 + 205540);
  }
  return result;
}
// 481904: variable 'v11' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (00481A0C) --------------------------------------------------------
int __fastcall sub_481A0C(int a1)
{
  char *v2; // $s3
  char *v3; // $v0
  char *v4; // $s2
  const char *v5; // $s0
  const char *v6; // $v0
  char *v7; // $v1
  int v8; // $t1
  int v9; // $t0
  int v10; // $a3
  int v11; // $a2
  const char *v13; // $v0
  int v14; // $s3
  const char *v15; // $v0
  int v16; // $a0
  char v17[516]; // [sp+18h] [-204h] BYREF

  v2 = httpd_get_parm(a1, "enable");
  v4 = httpd_get_parm(a1, "time");
  v3 = httpd_get_parm(a1, "opt");
  if ( !v3 )
  {
    if ( v2 )
    {
      v13 = (const char *)nvram_get(&unk_649DB8);
      if ( v13 && !strcmp(v13, v2) )
      {
        if ( !v4 )
          goto LABEL_5;
        v14 = 0;
      }
      else
      {
        nvram_set(&unk_649DB8, v2);
        v14 = 1;
        if ( !v4 )
        {
LABEL_16:
          start_module_upgrade_auto();
          jhl_parm_commit(v16);
          goto LABEL_5;
        }
      }
    }
    else
    {
      if ( !v4 )
        goto LABEL_5;
      v14 = 0;
    }
    v15 = (const char *)nvram_get("filter_auto_upgrade_time2");
    if ( v15 && !strcmp(v15, v4) )
    {
      if ( !v14 )
        goto LABEL_5;
    }
    else
    {
      nvram_set("filter_auto_upgrade_time2", v4);
    }
    goto LABEL_16;
  }
  v5 = v3;
  if ( !strcmp(v3, "insmod") )
  {
    load_module("wys_pg2.ko");
    wys_sj_module_add();
    exec_service("shibie_fbr_check-restart");
  }
  else if ( !strcmp(v5, "rmmod") )
  {
    wys_sj_module_del();
    system("rmmod wys_pg2.ko");
    exec_service("shibie_fbr_check-stop");
  }
LABEL_5:
  v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v7 = v17;
  do
  {
    v8 = *(_DWORD *)v6;
    v9 = *((_DWORD *)v6 + 1);
    v10 = *((_DWORD *)v6 + 2);
    v11 = *((_DWORD *)v6 + 3);
    v6 += 16;
    *(_DWORD *)v7 = v8;
    *((_DWORD *)v7 + 1) = v9;
    *((_DWORD *)v7 + 2) = v10;
    *((_DWORD *)v7 + 3) = v11;
    v7 += 16;
  }
  while ( v6 != "}" );
  *(_WORD *)v7 = *(_WORD *)v6;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 481CC0: variable 'v16' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8378: using guessed type int wys_sj_module_add(void);
// 6A8428: using guessed type int start_module_upgrade_auto(void);
// 6A8458: using guessed type int __fastcall load_module(_DWORD);
// 6A88FC: using guessed type int wys_sj_module_del(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00481D04) --------------------------------------------------------
int __fastcall sub_481D04(int a1)
{
  int v2; // $v0
  const char *v3; // $s7
  const char *v4; // $s1
  const char *v5; // $s2
  const char *v6; // $s4
  _BOOL4 v7; // $s5
  const char *v8; // $s6
  const char *v9; // $fp
  const char *v10; // $v0
  int v11; // $s2
  unsigned int v12; // $v0
  char v14[1024]; // [sp+38h] [-608h] BYREF
  char v15[512]; // [sp+438h] [-208h] BYREF
  const char *v16; // [sp+638h] [-8h]

  memset(v14, 0, sizeof(v14));
  v2 = nvram_get("tzk_time");
  if ( v2 )
    v3 = (const char *)v2;
  else
    v3 = "";
  v4 = (const char *)nvram_get("tzk_name");
  if ( !v4 )
    v4 = "22.10.17";
  v5 = (const char *)nvram_get(&unk_649DB8);
  if ( !v5 )
    v5 = "1";
  v6 = (const char *)jhl_nv_get_def("filter_auto_upgrade_time2");
  system("lsmod > /tmp/feature.txt");
  v7 = 0;
  if ( f_read("/tmp/feature.txt", v14, 1023) >= 7 )
    v7 = strstr(v14, "wys_pg2") != 0;
  strcpy(v15, "{\"code\":0,\"error\":\"\",\"data\":{");
  v8 = (const char *)nvram_get("tzk_state");
  if ( !v8 )
    v8 = "";
  v9 = (const char *)nvram_get(&unk_649E44);
  if ( !v9 )
    v9 = "";
  v16 = (const char *)wys_svn_info;
  v10 = (const char *)jhl_nv_get_def("vs_type");
  v11 = sprintf(
          &v15[29],
          "\"tzktime\":\"%s\",\"tzkname\":\"%s\",\"enable\":\"%s\",\"time\":\"%s\",\"status\":\"%s\",\"tzk_upgrade_info\""
          ":\"%s\",\"feature_ko\":%d,\"svn\":%s,\"platform\":\"%s\",\"vs_type\":%s",
          v3,
          v4,
          v5,
          v6,
          v8,
          v9,
          v7,
          v16,
          "RT-7621-44-DNS-MR",
          v10)
      + 29;
  v12 = snprintf(&v15[v11], 512 - v11, "}}");
  if ( v12 >= 512 - v11 )
    v12 = 511 - v11;
  return httpd_cgi_ret(a1, v15, v12 + v11, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);

//----- (00481FF4) --------------------------------------------------------
int __fastcall sub_481FF4(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  char *v4; // $s0
  const char *v5; // $v0
  int v6; // $s3
  const char *v7; // $v0
  int v8; // $a0
  const char *v9; // $v0
  char *v10; // $v1
  int v11; // $t1
  int v12; // $t0
  int v13; // $a3
  int v14; // $a2
  char v16[516]; // [sp+18h] [-204h] BYREF

  v3 = httpd_get_parm(a1, "en");
  v2 = httpd_get_parm(a1, "time");
  v4 = v2;
  if ( !v3 )
  {
    if ( !v2 )
      goto LABEL_9;
    v6 = 0;
    goto LABEL_5;
  }
  v5 = (const char *)nvram_get(v3);
  if ( v5 && !strcmp(v5, "auto_upgrade_en") )
  {
    if ( !v4 )
      goto LABEL_9;
    v6 = 0;
    goto LABEL_5;
  }
  nvram_set("auto_upgrade_en", v3);
  v6 = 1;
  if ( v4 )
  {
LABEL_5:
    v7 = (const char *)nvram_get(v4);
    if ( v7 && !strcmp(v7, "upgrade_auto_time") )
    {
      if ( !v6 )
        goto LABEL_9;
    }
    else
    {
      nvram_set("upgrade_auto_time", v4);
    }
  }
  start_version_upgrade_auto();
  jhl_parm_commit(v8);
LABEL_9:
  v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v10 = v16;
  do
  {
    v11 = *(_DWORD *)v9;
    v12 = *((_DWORD *)v9 + 1);
    v13 = *((_DWORD *)v9 + 2);
    v14 = *((_DWORD *)v9 + 3);
    v9 += 16;
    *(_DWORD *)v10 = v11;
    *((_DWORD *)v10 + 1) = v12;
    *((_DWORD *)v10 + 2) = v13;
    *((_DWORD *)v10 + 3) = v14;
    v10 += 16;
  }
  while ( v9 != "}" );
  *(_WORD *)v10 = *(_WORD *)v9;
  return httpd_cgi_ret(a1, v16, 33, 4);
}
// 48212C: variable 'v8' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8484: using guessed type int start_version_upgrade_auto(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004821E4) --------------------------------------------------------
int __fastcall sub_4821E4(int a1)
{
  int v2; // $v0
  const char *v3; // $s1
  const char *v4; // $s0
  const char *v5; // $v0
  int v6; // $s1
  unsigned int v7; // $v0
  char v9[2052]; // [sp+20h] [-804h] BYREF

  memset(v9, 0, 0x800u);
  strcpy(v9, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = nvram_get("auto_upgrade_en");
  if ( v2 )
    v3 = (const char *)v2;
  else
    v3 = "0";
  v4 = (const char *)nvram_get("upgrade_auto_time");
  if ( v4 )
  {
    v5 = (const char *)nvram_get("upgrade_auto_info");
    if ( v5 )
      goto LABEL_5;
  }
  else
  {
    v5 = (const char *)nvram_get("upgrade_auto_info");
    v4 = "";
    if ( v5 )
      goto LABEL_5;
  }
  v5 = "";
LABEL_5:
  v6 = sprintf(
         &v9[29],
         "\"upgrade_auto_en\":\"%s\",\"upgrade_auto_time\":\"%s\",\"upgrade_auto_info\":\"%s\"",
         v3,
         v4,
         v5)
     + 29;
  v7 = snprintf(&v9[v6], 2048 - v6, "}}");
  if ( v7 >= 2048 - v6 )
    v7 = 2047 - v6;
  return httpd_cgi_ret(a1, v9, v7 + v6, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (004823A4) --------------------------------------------------------
int __fastcall sub_4823A4(int a1)
{
  const char *v2; // $s6
  const char *v3; // $s7
  const char *v4; // $fp
  int v5; // $v0
  const char *v6; // $s0
  const char *v7; // $s1
  const char *v8; // $s4
  const char *v9; // $s5
  const char *v10; // $v0
  unsigned int v11; // $v0
  int v12; // $s0
  unsigned int v13; // $v0
  char v15[1024]; // [sp+40h] [-400h] BYREF

  memset(v15, 0, sizeof(v15));
  strcpy(v15, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)tomato_buildtime;
  v3 = (const char *)custom_tb_version();
  v4 = (const char *)wayos_version;
  v5 = nvram_get("time_upgrade_en");
  if ( v5 )
    v6 = (const char *)v5;
  else
    v6 = "";
  v7 = (const char *)nvram_get("time_upgrade_bb");
  if ( !v7 )
    v7 = "";
  v8 = (const char *)nvram_get("time_upgrade_path");
  if ( !v8 )
    v8 = "";
  v9 = (const char *)nvram_get("time_upgrade_time");
  if ( !v9 )
    v9 = "";
  v10 = (const char *)custom_device_name();
  v11 = snprintf(
          &v15[29],
          995,
          "\"vtm\":\"%s\",\"version\":\"%s%s  R(%s)\",\"time_upgrade_en\":\"%s\",\"time_upgrade_bb\":\"%s\",\"time_upgrad"
          "e_path\":\"%s\",\"time\":\"%s\",\"model\":\"%s\",\"svn\":\"%s\"",
          v2,
          v3,
          v4,
          wys_svn_info,
          v6,
          v7,
          v8,
          v9,
          v10,
          wys_svn_info);
  v12 = v11 + 29;
  if ( v11 >= 0x3E3 )
    v12 = 1023;
  v13 = snprintf(&v15[v12], 1024 - v12, "}}");
  if ( v13 >= 1024 - v12 )
    v13 = 1023 - v12;
  return httpd_cgi_ret(a1, v15, v13 + v12, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A86E4: using guessed type int custom_device_name(void);
// 6A8788: using guessed type int custom_tb_version(void);

//----- (00482618) --------------------------------------------------------
int __fastcall sub_482618(int a1)
{
  char *v2; // $s0
  char *v3; // $s1
  int v4; // $v0
  int v5; // $v0
  int v6; // $a2
  int v7; // $s0
  int v8; // $s1
  char *v9; // $v0
  unsigned int v10; // $v0
  unsigned int v11; // $s0
  unsigned int v12; // $v0
  const char *v14; // $v0
  unsigned int v15; // $v0
  const char *v16; // [sp+10h] [-22Ch]
  const char *v17; // [sp+10h] [-22Ch]
  char v18[512]; // [sp+20h] [-21Ch] BYREF
  const char *v19; // [sp+220h] [-1Ch] BYREF
  const char *v20; // [sp+224h] [-18h]
  char *v21; // [sp+228h] [-14h]
  char *v22; // [sp+22Ch] [-10h]
  int v23; // [sp+230h] [-Ch]

  v2 = httpd_get_parm(a1, "path");
  v3 = httpd_get_parm(a1, "type");
  strcpy(v18, "{\"code\":0,\"error\":\"\",\"data\":{");
  if ( v2 )
  {
    v4 = jiffies_get();
    mod_timer(a1 + 205540, v4 + 200000);
    if ( v3 && !strcmp(v3, "1") )
    {
      v19 = "wys";
      v20 = "version_upgrade";
      v21 = v2;
      v22 = "1";
      v23 = 0;
      eval(&v19, 0, 0, 0);
    }
    else
    {
      v19 = "wys";
      v20 = "version_upgrade";
      v21 = v2;
      v22 = "0";
      v23 = 0;
      eval(&v19, 0, 0, 0);
    }
    v5 = nvram_get("version_upgrade_state");
    v7 = J_atoi(v5);
    if ( v7 )
    {
      v8 = *(unsigned __int8 *)(a1 + 210102);
      v9 = (char *)nvram_get("version_upgrade_msg");
      if ( !v9 )
        v9 = "";
      v16 = (const char *)_GET_LANG_TEXT(19, v8, v9);
      v10 = snprintf(&v18[29], 483, "\"ret\":%d,\"msg\":\"%s\"", v7, v16);
    }
    else
    {
      v17 = (const char *)_GET_LANG_TEXT(18, *(unsigned __int8 *)(a1 + 210102), v6);
      v10 = snprintf(&v18[29], 483, "\"ret\":%d,\"msg\":\"%s\"", 0, v17);
    }
    if ( v10 < 0x1E3 )
      goto LABEL_10;
    goto LABEL_15;
  }
  v14 = (const char *)_GET_LANG_TEXT(17, *(unsigned __int8 *)(a1 + 210102), 1919906418);
  v15 = snprintf(&v18[29], 483, "\"ret\":1,\"msg\":\"%s\"", v14);
  v11 = v15 + 29;
  if ( v15 >= 0x1E3 )
  {
LABEL_15:
    v10 = 482;
LABEL_10:
    v11 = v10 + 29;
  }
  v12 = snprintf(&v18[v11], 512 - v11, "}}");
  if ( v12 >= 512 - v11 )
    v12 = 511 - v11;
  return httpd_cgi_ret(a1, v18, v12 + v11, 4);
}
// 4828EC: variable 'v6' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0048295C) --------------------------------------------------------
int __fastcall sub_48295C(int a1)
{
  char *v2; // $s1
  char *v3; // $s7
  char *v4; // $s5
  char *v5; // $s6
  const char *v6; // $v0
  int v7; // $s4
  const char *v8; // $v0
  const char *v9; // $v0
  const char *v10; // $v0
  int v11; // $a0
  const char **v12; // $v1
  const char *v13; // $v0
  const char *v14; // $t0
  const char *v15; // $a3
  const char *v16; // $a2
  const char *v17; // $a1
  const char *v19; // [sp+18h] [-204h] BYREF
  char *v20; // [sp+1Ch] [-200h]
  char *v21; // [sp+20h] [-1FCh]
  int v22; // [sp+24h] [-1F8h]

  v2 = httpd_get_parm(a1, "time_upgrade_en");
  v3 = httpd_get_parm(a1, "time_upgrade_bb");
  v4 = httpd_get_parm(a1, "time_upgrade_path");
  v5 = httpd_get_parm(a1, "time");
  if ( !v2 || (v6 = (const char *)nvram_get("time_upgrade_en")) != 0 && !strcmp(v6, v2) )
  {
    v7 = 0;
  }
  else
  {
    nvram_set("time_upgrade_en", v2);
    v7 = 1;
  }
  if ( v3 )
  {
    v8 = (const char *)nvram_get("time_upgrade_bb");
    if ( !v8 || strcmp(v8, v3) )
    {
      nvram_set("time_upgrade_bb", v3);
      v7 = 1;
    }
  }
  if ( !v4 || (v9 = (const char *)nvram_get("time_upgrade_path")) != 0 && !strcmp(v9, v4) )
  {
    if ( !v5 )
      goto LABEL_26;
  }
  else
  {
    nvram_set("time_upgrade_path", v4);
    if ( !v5 )
      goto LABEL_17;
    v7 = 1;
  }
  v10 = (const char *)nvram_get("time_upgrade_time");
  if ( v10 && !strcmp(v10, v5) )
  {
LABEL_26:
    if ( !v7 )
      goto LABEL_21;
    goto LABEL_17;
  }
  nvram_set("time_upgrade_time", v5);
LABEL_17:
  v19 = "time_version_upgrade_del.sh";
  v20 = 0;
  eval(&v19, 0, 0, 0);
  if ( v2 && J_atoi(v2) == 1 )
  {
    v19 = "time_version_upgrade_add.sh";
    v20 = v5;
    v21 = v4;
    v22 = 0;
    eval(&v19, 0, 0, 0);
  }
  jhl_parm_commit(v11);
LABEL_21:
  v12 = &v19;
  v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v14 = *(const char **)v13;
    v15 = (const char *)*((_DWORD *)v13 + 1);
    v16 = (const char *)*((_DWORD *)v13 + 2);
    v17 = (const char *)*((_DWORD *)v13 + 3);
    v13 += 16;
    *v12 = v14;
    v12[1] = v15;
    v12[2] = v16;
    v12[3] = v17;
    v12 += 4;
  }
  while ( v13 != "}" );
  *(_WORD *)v12 = *(_WORD *)v13;
  return httpd_cgi_ret(a1, (char *)&v19, 33, 4);
}
// 482BC4: variable 'v11' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00482CB4) --------------------------------------------------------
int __fastcall sub_482CB4(int a1)
{
  const char *v2; // $v0
  int v3; // $v0
  bool v4; // dc
  char *v5; // $v0
  int v6; // $fp
  const char *v7; // $s4
  const char *v8; // $s5
  const char *v9; // $s6
  const char *v10; // $s7
  const char *v11; // $s0
  const char *v12; // $a1
  const char *v13; // $v0
  int v14; // $s2
  unsigned int v15; // $v0
  char v17[2048]; // [sp+58h] [-848h] BYREF
  int v18[8]; // [sp+858h] [-48h] BYREF
  char v19[12]; // [sp+878h] [-28h] BYREF
  int v20; // [sp+884h] [-1Ch]
  const char *v21; // [sp+888h] [-18h]
  const char *v22; // [sp+88Ch] [-14h]
  const char *v23; // [sp+890h] [-10h]
  const char *v24; // [sp+894h] [-Ch]
  char *v25; // [sp+898h] [-8h]

  memset(v17, 0, sizeof(v17));
  v18[0] = 0;
  v18[1] = 0;
  v18[2] = 0;
  v18[3] = 0;
  v18[4] = 0;
  v18[5] = 0;
  v18[6] = 0;
  v18[7] = 0;
  get_memory(v19);
  v2 = (const char *)custom_tb_version();
  v3 = sprintf((char *)v18, "%s", v2);
  v4 = v3 <= 0;
  v5 = &v17[v3];
  if ( !v4 )
    v5[2047] = 0;
  strcpy(v17, "{\"code\":0,\"error\":\"\",\"data\":{");
  v6 = v20;
  v7 = (const char *)wys_svn_info;
  v8 = (const char *)jhl_nv_get_def("vs_type");
  v9 = (const char *)tomato_buildtime;
  v10 = (const char *)wayos_version;
  v11 = (const char *)nvram_get("upgrade_version_name");
  if ( !v11 )
    v11 = "";
  v12 = (const char *)nvram_get("backup_firmware_status");
  if ( !v12 )
    v12 = "0";
  v25 = "0";
  v24 = v12;
  v23 = (const char *)jhl_nv_get_def("auto_upgrade_en");
  v22 = (const char *)jhl_nv_get_def("upgrade_auto_time");
  v21 = (const char *)jhl_nv_get_def("upgrade_auto_info");
  v13 = (const char *)custom_device_name();
  v14 = sprintf(
          &v17[29],
          "\"jffs2_on\":\"0\",\"totalfreeram\":%lu ,\"svn\":%s,\"vs_type\":%s,\"vtm\":\"%s\" ,\"tbv\":\"%s\",\"pre_ver\":"
          "\"%s\",\"version\":\"%s\",\"tmp_version\":\"%s\",\"back_show\":\"%s\",\"back_state\":\"%s\",\"upgrade_auto_en\""
          ":\"%s\",\"upgrade_auto_time\":\"%s\",\"upgrade_auto_info\":\"%s\",\"ramfs\":\"%d\",\"model\":\"%s\",\"tb_versi"
          "on_def\":\"%s\",\"device_name_def\":\"%s\"",
          v6,
          v7,
          v8,
          v9,
          (const char *)v18,
          "V2.0",
          v10,
          v11,
          v25,
          v24,
          v23,
          v22,
          v21,
          1,
          v13,
          "FBM-1008V-",
          "FBM-1008V")
      + 29;
  v15 = snprintf(&v17[v14], 2048 - v14, "}}");
  if ( v15 >= 2048 - v14 )
    v15 = 2047 - v14;
  return httpd_cgi_ret(a1, v17, v15 + v14, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85CC: using guessed type int __fastcall get_memory(_DWORD);
// 6A86E4: using guessed type int custom_device_name(void);
// 6A8788: using guessed type int custom_tb_version(void);

//----- (00482FD4) --------------------------------------------------------
int __fastcall sub_482FD4(int a1)
{
  char *v2; // $v0
  int v3; // $a2
  size_t v4; // $v0
  char *v5; // $s3
  int v6; // $a1
  int v7; // $a0
  const char *v8; // $v0
  int v9; // $s3
  unsigned int v10; // $v0
  const char *v12; // $v0
  char v13[1024]; // [sp+18h] [-610h] BYREF
  char v14[512]; // [sp+418h] [-210h] BYREF
  int v15[4]; // [sp+618h] [-10h] BYREF

  memset(v13, 0, sizeof(v13));
  v2 = httpd_get_parm(a1, "url");
  v3 = 572668450;
  strcpy(v14, "{\"code\":0,\"error\":\"\",\"data\":{");
  if ( v2 && (v5 = v2, v4 = strlen(v2), base64_decode(v5, v13, v4), !strncmp(v13, "http://", 7u)) )
  {
    v12 = (const char *)nvram_get("fw_upgrade_state");
    if ( !v12 || strcmp(v12, "4") )
    {
      system("killall fw_upgrade");
      nvram_set("fw_upgrade_state", "0");
      v15[1] = (int)v13;
      v15[0] = (int)"fw_upgrade";
      v15[2] = 0;
      eval_nowait(v15, 0, 0, 0);
      *(_DWORD *)(a1 + 205572) = 0;
      fw_upgrade_timeout(a1);
      return 0;
    }
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v7 = 21;
  }
  else
  {
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v7 = 26;
  }
  v8 = (const char *)_GET_LANG_TEXT(v7, v6, v3);
  v9 = sprintf(&v14[29], "\"err\":\"%s\"", v8) + 29;
  v10 = snprintf(&v14[v9], 512 - v9, "}}");
  if ( v10 >= 512 - v9 )
    v10 = 511 - v9;
  return httpd_cgi_ret(a1, v14, v10 + v9, 4);
}
// 4830F4: variable 'v3' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0048328C) --------------------------------------------------------
int __fastcall sub_48328C(int a1)
{
  char *v1; // $v0
  const char *v3; // $s0
  char *v4; // $s1
  char *v5; // $s0
  const char *v6; // $v0
  unsigned int v7; // $v0
  int v8; // $s0
  unsigned int v9; // $v0
  int v11; // $a0
  char v12[516]; // [sp+20h] [-204h] BYREF

  v1 = httpd_get_parm(a1, "opt");
  if ( !v1 )
    goto LABEL_4;
  v3 = v1;
  if ( !strcmp(v1, "get") )
  {
    v5 = (char *)nvram_get("tzk_time");
    if ( !v5 )
      v5 = "";
    v4 = (char *)nvram_get("tzk_name");
    if ( !v4 )
      v4 = "";
  }
  else
  {
    if ( strcmp(v3, "set") )
    {
LABEL_4:
      v4 = 0;
      v5 = 0;
      goto LABEL_5;
    }
    v5 = httpd_get_parm(a1, "time");
    v4 = httpd_get_parm(a1, "name");
    if ( v5 )
    {
      nvram_set("tzk_time", v5);
    }
    else
    {
      v5 = (char *)nvram_get("tzk_time");
      if ( !v5 )
        v5 = "";
    }
    if ( v4 )
    {
      nvram_set("tzk_name", v4);
    }
    else
    {
      v4 = (char *)nvram_get("tzk_name");
      if ( !v4 )
        v4 = "";
    }
    jhl_parm_commit(v11);
  }
LABEL_5:
  strcpy(v12, "{\"code\":0,\"error\":\"\",\"data\":{");
  v6 = (const char *)custom_device_name();
  v7 = snprintf(&v12[29], 483, "\"tzktime\":\"%s\",\"tzkname\":\"%s\",\"JHL_ROUTER_MODEL\":\"%s\"", v5, v4, v6);
  v8 = v7 + 29;
  if ( v7 >= 0x1E3 )
    v8 = 511;
  v9 = snprintf(&v12[v8], 512 - v8, "}}");
  if ( v9 >= 512 - v8 )
    v9 = 511 - v8;
  return httpd_cgi_ret(a1, v12, v9 + v8, 4);
}
// 4834EC: variable 'v11' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A86E4: using guessed type int custom_device_name(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00483564) --------------------------------------------------------
int __fastcall sub_483564(int a1)
{
  char *v2; // $s5
  char *v3; // $s4
  int v4; // $v0
  int v5; // $v0
  int v6; // $a0
  int v7; // $a2
  int v9; // $a1
  const char *v10; // $v0
  int v11; // $s3
  unsigned int v12; // $v0
  _DWORD v13[129]; // [sp+18h] [-204h] BYREF

  v2 = httpd_get_parm(a1, "path");
  v3 = httpd_get_parm(a1, "time");
  nvram_set(&unk_649E44, "");
  nvram_set("tzk_state", "0");
  v4 = jiffies_get();
  mod_timer(a1 + 205540, v4 + 100000);
  v13[0] = "wys";
  v13[1] = "wget";
  v13[2] = "download";
  v13[3] = v2;
  v13[4] = 0;
  eval(v13, 0, 0, 0);
  v5 = nvram_get("tzk_state");
  if ( J_atoi(v5) )
  {
    v9 = *(unsigned __int8 *)(a1 + 210102);
    strcpy((char *)v13, "{\"code\":0,\"error\":\"\",\"data\":{");
    v10 = (const char *)_GET_LANG_TEXT(27, v9, 572668450);
    v11 = sprintf((char *)&v13[7] + 1, "\"ret\":1,\"msg\":\"%s\"", v10) + 29;
    v12 = snprintf((char *)v13 + v11, 512 - v11, "}}");
    if ( v12 >= 512 - v11 )
      v12 = 511 - v11;
    v7 = v12 + v11;
  }
  else
  {
    if ( v3 )
      nvram_set("tzk_time", v3);
    jhl_parm_commit(v6);
    strcpy((char *)v13, "{\"code\":0,\"error\":\"\",\"data\":{\"ret\":0,\"msg\":\"ok\"}}");
    v7 = 49;
  }
  return httpd_cgi_ret(a1, (char *)v13, v7, 4);
}
// 4836EC: variable 'v6' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0048389C) --------------------------------------------------------
int __fastcall sub_48389C(int a1)
{
  char *v2; // $v0
  int v3; // $s2
  int v4; // $s5
  char *v5; // $v0
  char *v6; // $s4
  char *v7; // $v0
  int v8; // $a2
  char *v9; // $s1
  signed int v10; // $s2
  const char *v11; // $v0
  unsigned int v12; // $a2
  FILE *v14; // $v0
  FILE *v15; // $s5
  int v16; // $v0
  int v17; // $a0
  char *v18; // $v1
  const char *v19; // $v0
  int v20; // $t0
  int v21; // $a3
  int v22; // $a2
  int v23; // $a1
  int v24; // $a0
  char v25[1028]; // [sp+20h] [-404h] BYREF

  v3 = a1 + 196608;
  v2 = httpd_get_parm(a1, "time");
  v4 = *(_DWORD *)(v3 + 8756);
  v6 = v2;
  find_file_head(a1, *(const char **)(v3 + 8956));
  if ( v5 )
  {
    v9 = v5;
    v7 = find_file_end(a1, v5, *(_DWORD *)(v3 + 8956) + v4 - (_DWORD)v5);
    v10 = v7 - v9;
    if ( v7 )
    {
      if ( v10 >= 1024 )
      {
        v14 = fopen("/tmp/upgrade/upgrade_file", "w");
        v15 = v14;
        if ( v14 )
        {
          fwrite(v9, 1u, v10, v14);
          fclose(v15);
          v16 = jiffies_get();
          mod_timer(a1 + 205540, v16 + 100000);
          if ( !wayos_file_upgrade("/tmp/upgrade", "upgrade_file") )
          {
            if ( v6 )
              nvram_set("tzk_time", v6);
            nvram_set("tzk_state", "0");
            jhl_parm_commit(v17);
            nvram_set(&unk_649E44, "");
            v18 = v25;
            v19 = "{\"code\":0,\"error\":\"\",\"data\":null}";
            do
            {
              v20 = *(_DWORD *)v19;
              v21 = *((_DWORD *)v19 + 1);
              v22 = *((_DWORD *)v19 + 2);
              v23 = *((_DWORD *)v19 + 3);
              v19 += 16;
              *(_DWORD *)v18 = v20;
              *((_DWORD *)v18 + 1) = v21;
              *((_DWORD *)v18 + 2) = v22;
              *((_DWORD *)v18 + 3) = v23;
              v18 += 16;
            }
            while ( v19 != "}" );
            v12 = 33;
            *(_WORD *)v18 = *(_WORD *)v19;
            return httpd_cgi_ret(a1, v25, v12, 4);
          }
          nvram_set("tzk_state", "1");
          jhl_parm_commit(v24);
        }
      }
    }
    else
    {
      v8 = 572;
      if ( debug_level > 0 )
        printf("%s:%d find_file_end err \n", "upgrade_filter_cgi", 572);
    }
  }
  else
  {
    v8 = 565;
    if ( debug_level > 0 )
      printf("%s:%d find_file_head err  \n", "upgrade_filter_cgi", 565);
  }
  v11 = (const char *)_GET_LANG_TEXT(29, *(unsigned __int8 *)(a1 + 210102), v8);
  v12 = snprintf(v25, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
  if ( v12 >= 0x400 )
    v12 = 1023;
  return httpd_cgi_ret(a1, v25, v12, 4);
}
// 48390C: variable 'v5' is possibly undefined
// 483958: variable 'v8' is possibly undefined
// 483B1C: variable 'v17' is possibly undefined
// 483BFC: variable 'v24' is possibly undefined
// 67D0BC: using guessed type int debug_level;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8598: using guessed type int __fastcall wayos_file_upgrade(_DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00483C10) --------------------------------------------------------
int __fastcall flash_Kernel_read(void *a1, int a2, int a3, int a4, size_t a5)
{
  int v7; // $v0
  int v8; // $s0
  int v9; // $v0
  __off_t v10; // $a1
  int v11; // $s1
  ssize_t v12; // $s0
  int result; // $v0
  char v14[8]; // [sp+20h] [-24h] BYREF
  unsigned int v15; // [sp+28h] [-1Ch]
  int v16; // [sp+2Ch] [-18h]

  v7 = mtd_open("Kernel", 0);
  if ( v7 < 0 )
  {
    fwrite("Could not open mtd device\n", 1u, 0x1Au, stderr);
    return -1;
  }
  v8 = v7;
  if ( ioctl(v7, 0x40204D01u, v14) )
  {
    fwrite("Could not get mtd device info\n", 1, 30, stderr);
    goto LABEL_9;
  }
  if ( v15 < a5 )
  {
    fprintf(stderr, "Too many bytes - %zu > %d bytes\n", a5, v16);
LABEL_9:
    close(v8);
    return -1;
  }
  close(v8);
  v9 = mtd_open("Kernel", 0);
  v11 = v9;
  if ( v9 < 0 )
  {
    fwrite("Could not open mtd block device\n", 1u, 0x20u, stderr);
    result = -1;
  }
  else
  {
    lseek(v9, v10, a3);
    v12 = read(v11, a1, a5);
    if ( v12 == -1 )
    {
      fwrite("Reading from mtd failed\n", 1u, 0x18u, stderr);
      close(v11);
      result = -1;
    }
    else
    {
      close(v11);
      result = v12;
    }
  }
  return result;
}
// 483CEC: variable 'v10' is possibly undefined
// 6A8684: using guessed type int __fastcall mtd_open(_DWORD, _DWORD);

//----- (00483E40) --------------------------------------------------------
ssize_t __fastcall flash_Kernel_write(char *a1, int a2, int a3, int a4, unsigned int a5)
{
  unsigned int v6; // $s1
  int v7; // $v0
  int v9; // $v0
  int v10; // $s3
  size_t v11; // $a2
  ssize_t v12; // $s0
  __off_t v13; // $a1
  char *v14; // $v0
  char *v15; // $s2
  int v16; // $s0
  size_t v17; // $a0
  int v18; // $s7
  __off_t v19; // $a1
  ssize_t result; // $v0
  int v21; // $v0
  FILE *v22; // $a3
  const char *v23; // $a0
  char v24[8]; // [sp+20h] [-30h] BYREF
  unsigned int v25; // [sp+28h] [-28h]
  size_t nbytes; // [sp+2Ch] [-24h]
  int v27; // [sp+40h] [-10h] BYREF
  size_t v28; // [sp+44h] [-Ch]
  unsigned int request; // [sp+48h] [-8h]
  char *v30; // [sp+4Ch] [-4h]

  v6 = a5;
  v7 = mtd_open("Kernel", 16402);
  if ( v7 < 0 )
  {
    fwrite("Could not open mtd device\n", 1u, 0x1Au, stderr);
    result = -1;
  }
  else
  {
    v10 = v7;
    v9 = ioctl(v7, 0x40204D01u, v24);
    v11 = 30;
    if ( v9 )
    {
      v22 = stderr;
      v23 = "Could not get mtd device info\n";
LABEL_21:
      fwrite(v23, 1u, v11, v22);
      close(v10);
      return -1;
    }
    if ( v25 >= a5 )
    {
      v12 = 0;
      if ( !a5 )
      {
LABEL_15:
        close(v10);
        return v12;
      }
      request = -2146939646;
      while ( 1 )
      {
        while ( ((nbytes - 1) & v6) != 0 || v6 < nbytes )
        {
          _mem_malloc(nbytes, "flash_Kernel_write", 1080);
          v15 = v14;
          v30 = "1\"";
          if ( !v14 )
          {
            v22 = stderr;
            v11 = 18;
            v23 = "Not enough memory\n";
            goto LABEL_21;
          }
          v16 = -nbytes & a3;
          lseek(v10, v13, v16);
          if ( read(v10, v15, nbytes) == -1 )
          {
            fwrite("Reading from mtd failed\n", 1u, 0x18u, stderr);
            close(v10);
            _mem_free(v15);
            return -1;
          }
          v17 = (nbytes - 1) & a3;
          v18 = nbytes - v17;
          if ( v6 < nbytes - v17 )
            v18 = v6;
          memcpy(&v15[v17], a1, v18);
          v27 = v16;
          v28 = nbytes;
          if ( ioctl(v10, request, &v27) < 0 )
          {
            fwrite("Erasing mtd failed\n", 1u, 0x13u, stderr);
            close(v10);
LABEL_24:
            _mem_free(v15);
            return -1;
          }
          lseek(v10, v19, v16);
          v12 = write(v10, v15, nbytes);
          if ( v12 == -1 )
          {
            fwrite("Writing to mtd failed\n", 1u, 0x16u, stderr);
            close(v10);
            goto LABEL_24;
          }
          v6 -= v18;
          _mem_free(v15);
          a1 += v18;
          a3 += v18;
          if ( !v6 )
            goto LABEL_15;
        }
        v27 = a3;
        v28 = nbytes;
        v21 = ioctl(v10, request, &v27);
        v11 = 19;
        if ( v21 < 0 )
          break;
        v12 = write(v10, a1, nbytes);
        v11 = 22;
        if ( v12 == -1 )
        {
          v22 = stderr;
          v23 = "Writing to mtd failed\n";
          goto LABEL_21;
        }
        v6 -= nbytes;
        a1 += nbytes;
        a3 += nbytes;
        if ( !v6 )
          goto LABEL_15;
      }
      v22 = stderr;
      v23 = "Erasing mtd failed\n";
      goto LABEL_21;
    }
    fprintf(stderr, "Too many bytes: %zu > %d bytes\n", a5, v25);
    close(v10);
    result = -2;
  }
  return result;
}
// 483F38: variable 'v14' is possibly undefined
// 483F64: variable 'v13' is possibly undefined
// 484008: variable 'v19' is possibly undefined
// 6A8684: using guessed type int __fastcall mtd_open(_DWORD, _DWORD);

//----- (00484304) --------------------------------------------------------
int __fastcall flash_Uboot_read(void *a1, int a2, int a3, int a4, size_t a5)
{
  int v7; // $v0
  int v8; // $s0
  int v9; // $v0
  __off_t v10; // $a1
  int v11; // $s1
  ssize_t v12; // $s0
  int result; // $v0
  char v14[8]; // [sp+20h] [-24h] BYREF
  unsigned int v15; // [sp+28h] [-1Ch]
  int v16; // [sp+2Ch] [-18h]

  v7 = mtd_open("Bootloader", 0);
  if ( v7 < 0 )
  {
    fwrite("Could not open mtd device\n", 1u, 0x1Au, stderr);
    return -1;
  }
  v8 = v7;
  if ( ioctl(v7, 0x40204D01u, v14) )
  {
    fwrite("Could not get mtd device info\n", 1, 30, stderr);
    goto LABEL_9;
  }
  if ( v15 < a5 )
  {
    fprintf(stderr, "Too many bytes - %zu > %d bytes\n", a5, v16);
LABEL_9:
    close(v8);
    return -1;
  }
  close(v8);
  v9 = mtd_open("Bootloader", 0);
  v11 = v9;
  if ( v9 < 0 )
  {
    fwrite("Could not open mtd block device\n", 1u, 0x20u, stderr);
    result = -1;
  }
  else
  {
    lseek(v9, v10, a3);
    v12 = read(v11, a1, a5);
    if ( v12 == -1 )
    {
      fwrite("Reading from mtd failed\n", 1u, 0x18u, stderr);
      close(v11);
      result = -1;
    }
    else
    {
      close(v11);
      result = v12;
    }
  }
  return result;
}
// 4843E0: variable 'v10' is possibly undefined
// 6A8684: using guessed type int __fastcall mtd_open(_DWORD, _DWORD);

//----- (00484534) --------------------------------------------------------
ssize_t __fastcall flash_Uboot_write(char *a1, int a2, int a3, int a4, unsigned int a5, char *s)
{
  unsigned int v7; // $s1
  int v8; // $v0
  int v10; // $s3
  ssize_t v11; // $s0
  __off_t v12; // $a1
  char *v13; // $v0
  char *v14; // $s2
  int v15; // $s0
  size_t v16; // $a0
  int v17; // $fp
  __off_t v18; // $a1
  ssize_t result; // $v0
  char v20[8]; // [sp+20h] [-30h] BYREF
  unsigned int v21; // [sp+28h] [-28h]
  size_t nbytes; // [sp+2Ch] [-24h]
  int v23; // [sp+40h] [-10h] BYREF
  size_t v24; // [sp+44h] [-Ch]
  unsigned int request; // [sp+48h] [-8h]
  char *v26; // [sp+4Ch] [-4h]

  v7 = a5;
  v8 = mtd_open("Bootloader", 16402);
  if ( v8 < 0 )
  {
    fwrite("Could not open mtd device\n", 1u, 0x1Au, stderr);
    strcpy(s, "Could not open mtd device\n");
    qmemcpy(s, "Could not open m", 16);
    *((_DWORD *)s + 5) = *(_DWORD *)"evice\n";
    result = -1;
  }
  else
  {
    v10 = v8;
    if ( ioctl(v8, 0x40204D01u, v20) )
    {
      fwrite("Could not get mtd device info\n", 1u, 0x1Eu, stderr);
      strcpy(s, "Could not get mtd device info\n");
      qmemcpy(s, "Could not get mt", 16);
      close(v10);
      result = -1;
    }
    else if ( v21 < a5 )
    {
      fprintf(stderr, "Too many bytes: %zu > %d bytes\n", a5, v21);
      sprintf(s, "Too many bytes: %zu > %d bytes\n", a5, v21);
      close(v10);
      result = -1;
    }
    else
    {
      v11 = 0;
      if ( a5 )
      {
        request = -2146939646;
        while ( 1 )
        {
          while ( ((nbytes - 1) & v7) != 0 || v7 < nbytes )
          {
            _mem_malloc(nbytes, "flash_Uboot_write", 1238);
            v14 = v13;
            v26 = "1\"";
            if ( !v13 )
            {
              fwrite("Not enough memory\n", 1u, 0x12u, stderr);
              strcpy(s, "Not enough memory\n");
              qmemcpy(s, "Not enough memor", 16);
              close(v10);
              return -1;
            }
            v15 = -nbytes & a3;
            lseek(v10, v12, v15);
            if ( read(v10, v14, nbytes) == -1 )
            {
              fwrite("Reading from mtd failed\n", 1u, 0x18u, stderr);
              strcpy(s, "Reading from mtd failed\n");
              qmemcpy(s, "Reading from mtd failed\n", 24);
              close(v10);
              _mem_free(v14);
              return -1;
            }
            v16 = (nbytes - 1) & a3;
            v17 = nbytes - v16;
            if ( v7 < nbytes - v16 )
              v17 = v7;
            memcpy(&v14[v16], a1, v17);
            v23 = v15;
            v24 = nbytes;
            if ( ioctl(v10, request, &v23) < 0 )
            {
              fwrite("Erasing mtd failed\n", 1u, 0x13u, stderr);
              strcpy(s, "Erasing mtd failed\n");
              strcpy(s, "Erasing mtd failed\n");
              close(v10);
LABEL_23:
              _mem_free(v14);
              return -1;
            }
            lseek(v10, v18, v15);
            v11 = write(v10, v14, nbytes);
            if ( v11 == -1 )
            {
              fwrite("Writing to mtd failed\n", 1u, 0x16u, stderr);
              close(v10);
              goto LABEL_23;
            }
            v7 -= v17;
            _mem_free(v14);
            a1 += v17;
            a3 += v17;
            if ( !v7 )
              goto LABEL_15;
          }
          v23 = a3;
          v24 = nbytes;
          if ( ioctl(v10, request, &v23) < 0 )
            break;
          v11 = write(v10, a1, nbytes);
          if ( v11 == -1 )
          {
            fwrite("Writing to mtd failed\n", 1u, 0x16u, stderr);
            strcpy(s, "Writing to mtd failed\n");
            qmemcpy(s, "Writing to mtd faile", 20);
            close(v10);
            return -1;
          }
          v7 -= nbytes;
          a1 += nbytes;
          a3 += nbytes;
          if ( !v7 )
            goto LABEL_15;
        }
        fwrite("Erasing mtd failed\n", 1u, 0x13u, stderr);
        strcpy(s, "Erasing mtd failed\n");
        strcpy(s, "Erasing mtd failed\n");
        close(v10);
        result = -1;
      }
      else
      {
LABEL_15:
        close(v10);
        result = v11;
      }
    }
  }
  return result;
}
// 48462C: variable 'v13' is possibly undefined
// 484658: variable 'v12' is possibly undefined
// 4846FC: variable 'v18' is possibly undefined
// 6A8684: using guessed type int __fastcall mtd_open(_DWORD, _DWORD);

//----- (00484CE0) --------------------------------------------------------
int __fastcall flash_art_read(void *a1, int a2, int a3, int a4, size_t a5)
{
  int v7; // $v0
  int v8; // $s0
  int v9; // $v0
  __off_t v10; // $a1
  int v11; // $s1
  ssize_t v12; // $s0
  int result; // $v0
  char v14[8]; // [sp+20h] [-24h] BYREF
  unsigned int v15; // [sp+28h] [-1Ch]
  int v16; // [sp+2Ch] [-18h]

  v7 = mtd_open("Factory", 0);
  if ( v7 < 0 )
  {
    fwrite("Could not open mtd device\n", 1u, 0x1Au, stderr);
    return -1;
  }
  v8 = v7;
  if ( ioctl(v7, 0x40204D01u, v14) )
  {
    fwrite("Could not get mtd device info\n", 1, 30, stderr);
    goto LABEL_9;
  }
  if ( v15 < a5 )
  {
    fprintf(stderr, "Too many bytes - %d > %d bytes\n", a5, v16);
LABEL_9:
    close(v8);
    return -1;
  }
  close(v8);
  v9 = mtd_open("Factory", 0);
  v11 = v9;
  if ( v9 < 0 )
  {
    fwrite("Could not open mtd block device\n", 1u, 0x20u, stderr);
    result = -1;
  }
  else
  {
    lseek(v9, v10, a3);
    v12 = read(v11, a1, a5);
    if ( v12 == -1 )
    {
      fwrite("Reading from mtd failed\n", 1u, 0x18u, stderr);
      close(v11);
      result = -1;
    }
    else
    {
      close(v11);
      result = v12;
    }
  }
  return result;
}
// 484DBC: variable 'v10' is possibly undefined
// 6A8684: using guessed type int __fastcall mtd_open(_DWORD, _DWORD);

//----- (00484F10) --------------------------------------------------------
ssize_t __fastcall flash_art_write(char *a1, int a2, int a3, int a4, unsigned int a5, char *s)
{
  unsigned int v7; // $s1
  int v8; // $v0
  int v10; // $s3
  ssize_t v11; // $s0
  __off_t v12; // $a1
  char *v13; // $v0
  char *v14; // $s2
  int v15; // $s0
  size_t v16; // $a0
  int v17; // $fp
  __off_t v18; // $a1
  ssize_t result; // $v0
  char v20[8]; // [sp+20h] [-30h] BYREF
  unsigned int v21; // [sp+28h] [-28h]
  size_t nbytes; // [sp+2Ch] [-24h]
  int v23; // [sp+40h] [-10h] BYREF
  size_t v24; // [sp+44h] [-Ch]
  unsigned int request; // [sp+48h] [-8h]
  char *v26; // [sp+4Ch] [-4h]

  v7 = a5;
  v8 = mtd_open("Factory", 16402);
  if ( v8 < 0 )
  {
    fwrite("Could not open mtd device\n", 1u, 0x1Au, stderr);
    strcpy(s, "Could not open mtd device\n");
    qmemcpy(s, "Could not open m", 16);
    *((_DWORD *)s + 5) = *(_DWORD *)"evice\n";
    result = -1;
  }
  else
  {
    v10 = v8;
    if ( ioctl(v8, 0x40204D01u, v20) )
    {
      fwrite("Could not get mtd device info\n", 1u, 0x1Eu, stderr);
      strcpy(s, "Could not get mtd device info\n");
      qmemcpy(s, "Could not get mt", 16);
      close(v10);
      result = -1;
    }
    else if ( v21 < a5 )
    {
      fprintf(stderr, "Too many bytes: %d > %d bytes\n", a5, v21);
      sprintf(s, "Too many bytes: %d > %d bytes\n", a5, v21);
      close(v10);
      result = -1;
    }
    else
    {
      v11 = 0;
      if ( a5 )
      {
        request = -2146939646;
        while ( 1 )
        {
          while ( ((nbytes - 1) & v7) != 0 || v7 < nbytes )
          {
            _mem_malloc(nbytes, "flash_art_write", 1406);
            v14 = v13;
            v26 = "1\"";
            if ( !v13 )
            {
              fwrite("Not enough memory\n", 1u, 0x12u, stderr);
              strcpy(s, "Not enough memory\n");
              qmemcpy(s, "Not enough memor", 16);
              close(v10);
              return -1;
            }
            v15 = -nbytes & a3;
            lseek(v10, v12, v15);
            if ( read(v10, v14, nbytes) == -1 )
            {
              fwrite("Reading from mtd failed\n", 1u, 0x18u, stderr);
              strcpy(s, "Reading from mtd failed\n");
              qmemcpy(s, "Reading from mtd failed\n", 24);
              close(v10);
              _mem_free(v14);
              return -1;
            }
            v16 = (nbytes - 1) & a3;
            v17 = nbytes - v16;
            if ( v7 < nbytes - v16 )
              v17 = v7;
            memcpy(&v14[v16], a1, v17);
            v23 = v15;
            v24 = nbytes;
            if ( ioctl(v10, request, &v23) < 0 )
            {
              fwrite("Erasing mtd failed\n", 1u, 0x13u, stderr);
              strcpy(s, "Erasing mtd failed\n");
              strcpy(s, "Erasing mtd failed\n");
              close(v10);
LABEL_23:
              _mem_free(v14);
              return -1;
            }
            lseek(v10, v18, v15);
            v11 = write(v10, v14, nbytes);
            if ( v11 == -1 )
            {
              fwrite("Writing to mtd failed\n", 1u, 0x16u, stderr);
              close(v10);
              goto LABEL_23;
            }
            v7 -= v17;
            _mem_free(v14);
            a1 += v17;
            a3 += v17;
            if ( !v7 )
              goto LABEL_15;
          }
          v23 = a3;
          v24 = nbytes;
          if ( ioctl(v10, request, &v23) < 0 )
            break;
          v11 = write(v10, a1, nbytes);
          if ( v11 == -1 )
          {
            fwrite("Writing to mtd failed\n", 1u, 0x16u, stderr);
            strcpy(s, "Writing to mtd failed\n");
            qmemcpy(s, "Writing to mtd faile", 20);
            close(v10);
            return -1;
          }
          v7 -= nbytes;
          a1 += nbytes;
          a3 += nbytes;
          if ( !v7 )
            goto LABEL_15;
        }
        fwrite("Erasing mtd failed\n", 1u, 0x13u, stderr);
        strcpy(s, "Erasing mtd failed\n");
        strcpy(s, "Erasing mtd failed\n");
        close(v10);
        result = -1;
      }
      else
      {
LABEL_15:
        close(v10);
        result = v11;
      }
    }
  }
  return result;
}
// 485008: variable 'v13' is possibly undefined
// 485034: variable 'v12' is possibly undefined
// 4850D8: variable 'v18' is possibly undefined
// 6A8684: using guessed type int __fastcall mtd_open(_DWORD, _DWORD);

//----- (004856BC) --------------------------------------------------------
int __fastcall sub_4856BC(int a1)
{
  char *v2; // $s3
  char *v3; // $v0
  char *v4; // $s2
  int v5; // $s4
  char *v6; // $v0
  const char *v7; // $s5
  char *v8; // $v0
  char *v9; // $fp
  int v10; // $s1
  int v11; // $a2
  int v12; // $a1
  int v13; // $a0
  int v14; // $v0
  void *v15; // $fp
  unsigned int v16; // $s4
  void *v17; // $a0
  uint32_t v19; // $a0
  signed int v20; // $s5
  unsigned __int8 *v21; // $s4
  char *v22; // $s6
  int v23; // $s7
  int v24; // $v0
  int v25; // $a0
  const char *v26; // $v0
  uint32_t v27; // $a0
  void *v28; // $v0
  uint32_t v29; // $a0
  uint32_t v30; // $v0
  int v31; // $a0
  int v32; // $s7
  const char *v33; // $v0
  int *v34; // $t1
  int i; // $t0
  unsigned int v36; // $a0
  int v37; // $a1
  char *v38; // $a1
  unsigned int v39; // $a0
  int v40; // $v0
  const char *v41; // $v0
  int v42; // $a2
  const char *v43; // $v0
  int v44; // $a1
  void *v45; // $v0
  signed int v46; // $s1
  int v47; // $a1
  int v48; // $t0
  int v49; // $v0
  int v50; // $v0
  int v51; // $t0
  int v52; // $v0
  ssize_t (__fastcall *v53)(char *, int, int, int, unsigned int, char *); // $t9
  int v54; // $v0
  int v55; // $t0
  int v56; // $v0
  int v57; // $a2
  int v58; // $v0
  unsigned int v59; // $s2
  void *v60; // $a0
  int v61; // $a0
  int v62; // $a2
  int v63; // $v0
  ssize_t v64; // $v0
  char v65[2048]; // [sp+28h] [-10B8h] BYREF
  int v66[257]; // [sp+828h] [-8B8h] BYREF
  char v67[1024]; // [sp+C2Ch] [-4B4h] BYREF
  char v68[128]; // [sp+102Ch] [-B4h] BYREF
  int v69[3]; // [sp+10ACh] [-34h] BYREF
  void *v70; // [sp+10B8h] [-28h]
  int v71; // [sp+10BCh] [-24h]
  int v72; // [sp+10C0h] [-20h]
  char *v73; // [sp+10C4h] [-1Ch]
  char *v74; // [sp+10C8h] [-18h]
  char *v75; // [sp+10CCh] [-14h]
  char *v76; // [sp+10D0h] [-10h]
  int v77; // [sp+10D4h] [-Ch]
  int v78; // [sp+10D8h] [-8h]

  strcpy(v68, "Error reading file");
  memset(&v68[19], 0, 0x6Du);
  v69[0] = 0;
  v69[1] = 0;
  v2 = httpd_get_parm(a1, "filename");
  v4 = httpd_get_parm(a1, "type");
  v3 = httpd_get_parm(a1, "md5");
  v5 = *(_DWORD *)(a1 + 205364);
  v7 = v3;
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( !v6 )
  {
    if ( debug_level > 0 )
    {
      printf("%s:%d %s:%d find_file_head err \n", "upfile_cgi", 1673);
LABEL_27:
      v15 = 0;
      v16 = 0;
      goto LABEL_10;
    }
LABEL_44:
    v15 = 0;
    v16 = 0;
    goto LABEL_10;
  }
  v9 = v6;
  v8 = find_file_end(a1, v6, *(_DWORD *)(a1 + 205564) + v5 - (_DWORD)v6);
  if ( !v8 )
  {
    if ( debug_level > 0 )
    {
      printf("%s:%d %s:%d find_file_end err \n", "upfile_cgi", 1680);
      goto LABEL_27;
    }
    goto LABEL_44;
  }
  v10 = v8 - v9;
  if ( v7 )
  {
    memset(v65, 0, 0x40u);
    getMD5Str(v9, v10, v65);
    if ( strcasecmp(v65, v7) )
    {
      if ( debug_level > 0 )
        printf("%s:%d %s:%d md5 error %s/%s \n", "upfile_cgi", 1691, "upfile_cgi", 1691, v7, v65);
      v12 = *(unsigned __int8 *)(a1 + 210102);
      v13 = 128;
      goto LABEL_8;
    }
  }
  if ( *v9 == 86 && v9[1] == 69 && v9[2] == 82 && v9[3] == 50 )
  {
    v27 = *((_DWORD *)v9 + 12);
    v72 = *((_DWORD *)v9 + 10);
    v20 = htonl(v27);
    v28 = (void *)htonl(*((_DWORD *)v9 + 14));
    v29 = *((_DWORD *)v9 + 15);
    v70 = v28;
    v30 = htonl(v29);
    v31 = (unsigned __int8)v9[75];
    v22 = v9 + 76;
    v21 = (unsigned __int8 *)(v9 + 36);
    v71 = v30;
    if ( v31 != 50 && !find_old_sq_exist(1) )
    {
      v14 = _GET_LANG_TEXT(50, *(unsigned __int8 *)(a1 + 210102), 1);
      goto LABEL_9;
    }
    v32 = (unsigned __int8)v9[73];
    v33 = (const char *)nvram_get("flash_enc_new");
    if ( v33 && !strcmp(v33, "1") && v32 != 1 )
    {
      v14 = _GET_LANG_TEXT(50, *(unsigned __int8 *)(a1 + 210102), 2);
      goto LABEL_9;
    }
    v23 = 76;
  }
  else
  {
    v70 = (void *)*((_DWORD *)v9 + 5);
    v19 = *((_DWORD *)v9 + 6);
    v72 = *((_DWORD *)v9 + 1);
    v20 = *((_DWORD *)v9 + 3);
    v21 = (unsigned __int8 *)v9;
    v22 = v9 + 40;
    v71 = htonl(v19);
    v23 = 40;
  }
  v24 = *v21;
  if ( v24 == 117 )
  {
    if ( v21[1] == 98 && v21[2] == 111 && v21[3] == 116 )
    {
      v72 = 123;
      goto LABEL_49;
    }
  }
  else if ( v24 == 97 && v21[1] == 114 && v21[2] == 116 && v21[3] == 49 )
  {
    v72 = 124;
    goto LABEL_49;
  }
  get_upfile_version_flag(v69);
  if ( __PAIR64__(v21[1], *v21) != __PAIR64__(BYTE1(v69[0]), LOBYTE(v69[0]))
    || __PAIR64__(v21[3], v21[2]) != __PAIR64__(HIBYTE(v69[0]), BYTE2(v69[0])) )
  {
    v14 = _GET_LANG_TEXT(42, *(unsigned __int8 *)(a1 + 210102), "1");
    goto LABEL_9;
  }
  if ( v72 != jhl_hardversion_get() )
  {
    v14 = _GET_LANG_TEXT(42, *(unsigned __int8 *)(a1 + 210102), "2");
    goto LABEL_9;
  }
  if ( v10 < 0x100000 )
  {
    v14 = _GET_LANG_TEXT(42, *(unsigned __int8 *)(a1 + 210102), "3");
    goto LABEL_9;
  }
  v72 = 0;
LABEL_49:
  if ( (char *)v70 + v20 + v23 != (void *)v10 )
  {
    v14 = _GET_LANG_TEXT(42, *(unsigned __int8 *)(a1 + 210102), "4");
    goto LABEL_9;
  }
  memset(v66, 0, sizeof(v66));
  v34 = &v66[256];
  for ( i = 255; i != -1; --i )
  {
    v36 = i;
    v37 = 8;
    do
    {
      while ( (v36 & 1) != 0 )
      {
        --v37;
        v36 = (v36 >> 1) ^ 0xEDB88320;
        if ( !v37 )
          goto LABEL_62;
      }
      --v37;
      v36 >>= 1;
    }
    while ( v37 );
LABEL_62:
    *v34-- = v36;
  }
  if ( v20 <= 0 )
  {
    v39 = 0;
  }
  else
  {
    v38 = v22;
    v39 = 0;
    do
    {
      v40 = *(_DWORD *)&v65[4 * (unsigned __int8)(*v38++ ^ v39) + 2052];
      v39 = (v39 >> 8) ^ v40;
    }
    while ( &v22[v20] != v38 );
    v66[0] = v39;
  }
  if ( v71 != v39 )
  {
    v14 = _GET_LANG_TEXT(42, *(unsigned __int8 *)(a1 + 210102), &unk_4D15F8);
    goto LABEL_9;
  }
  v73 = "a";
  v41 = (const char *)nvram_get("fw_upgrade_state");
  if ( v41 )
  {
    v70 = "a";
    if ( !strcmp(v41, "4") )
    {
      v12 = *(unsigned __int8 *)(a1 + 210102);
      v13 = 21;
LABEL_8:
      v14 = _GET_LANG_TEXT(v13, v12, v11);
LABEL_9:
      strlcpy(v68, v14, 128);
      v15 = 0;
      v16 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    v70 = "a";
  }
  v76 = "a";
  unregister_signal();
  exec_service("jhttpd_check-stop");
  v43 = (const char *)_GET_LANG_TEXT(22, *(unsigned __int8 *)(a1 + 210102), v42);
  v16 = snprintf(v67, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v43);
  if ( v16 >= 0x400 )
    v16 = 1023;
  if ( !v72 )
  {
    v71 = (int)v65;
    memset(v65, 0, 0x40u);
    get_md5_str(v9, v10, v65);
    nvram_set("self_trx_md5", v71);
    nvram_set("ai_upgrade_flag", "1");
    nvram_commit();
  }
  nvram_set(v73 + 20068, (char *)v70 + 16640);
  if ( !v4 || J_atoi(v4) )
    prepare_upgrade();
  v74 = "1\"";
  _mem_malloc(0x10000, "upfile_cgi", 1914);
  v15 = v45;
  if ( v72 == 123 )
  {
    v64 = flash_Uboot_write(v22, v44, 0, 0, v20, v68);
  }
  else
  {
    if ( v72 != 124 )
    {
      if ( flash_Kernel_write(v22, v44, 0, 0, v20) != -2 )
      {
        v46 = v20;
        sync();
        sleep(1u);
        if ( v20 >= 65537 )
          v46 = 0x10000;
        if ( !v15 )
        {
LABEL_103:
          if ( !v72 )
            flash_erase_mtd("modules", 0, 0);
          goto LABEL_105;
        }
LABEL_85:
        if ( v46 > 0 )
        {
          v77 = 65537;
          v48 = 0;
          v71 = 0;
          v70 = v22;
          v75 = v68;
          while ( 1 )
          {
            v49 = v72;
            if ( v72 != 123 )
              goto LABEL_88;
            while ( 2 )
            {
              v78 = v48;
              flash_Uboot_read(v15, v47, v48, v71, v46);
              v52 = memcmp(v15, v70, v46);
              v51 = v78;
              if ( v52 )
              {
                v53 = flash_Uboot_write;
                goto LABEL_94;
              }
LABEL_90:
              v48 = v51 + v46;
              v46 = v20 - v48;
              if ( v20 - v48 < v77 )
              {
                if ( v46 <= 0 )
                  goto LABEL_103;
                v71 = v48 >> 31;
                v70 = &v22[v48];
              }
              else
              {
                v71 = v48 >> 31;
                v70 = &v22[v48];
                v49 = v72;
                v46 = 0x10000;
                if ( v72 == 123 )
                  continue;
LABEL_88:
                if ( v49 != 124 )
                {
                  v78 = v48;
                  flash_Kernel_read(v15, v47, v48, v71, v46);
                  v50 = memcmp(v15, v70, v46);
                  v51 = v78;
                  if ( v50 )
                  {
                    flash_Kernel_write((char *)v70, v47, v78, v71, v46);
                    v55 = v78;
                    goto LABEL_95;
                  }
                  goto LABEL_90;
                }
                v78 = v48;
                flash_art_read(v15, v47, v48, v71, v46);
                v56 = memcmp(v15, v70, v46);
                v51 = v78;
                if ( !v56 )
                  goto LABEL_90;
                v53 = flash_art_write;
LABEL_94:
                v78 = v51;
                v54 = v53((char *)v70, v47, v51, v71, v46, v75);
                v55 = v78;
                if ( v54 == -1 )
                  goto LABEL_121;
LABEL_95:
                v78 = v55;
                sync();
                v48 = v78;
              }
              break;
            }
          }
        }
        goto LABEL_103;
      }
      nvram_set(v73 + 20068, "0");
      v63 = _GET_LANG_TEXT(41, *(unsigned __int8 *)(a1 + 210102), v62);
      strlcpy(v68, v63, 128);
LABEL_10:
      v17 = *(void **)(a1 + 205564);
      if ( v17 )
      {
        _mem_free(v17);
        *(_DWORD *)(a1 + 205564) = 0;
      }
      if ( v68[0] )
      {
        register_signal();
        exec_service("jhttpd_check-start");
        upgrade_after(v25);
        if ( !v15 )
        {
LABEL_15:
          if ( v68[0] )
          {
            v26 = (const char *)_GET_LANG_TEXT(19, *(unsigned __int8 *)(a1 + 210102), v68);
            v16 = snprintf(v67, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v26);
            if ( v16 >= 0x400 )
              v16 = 1023;
          }
          return httpd_cgi_ret(a1, v67, v16, 4);
        }
      }
      else if ( !v15 )
      {
        return httpd_cgi_ret(a1, v67, v16, 4);
      }
      _mem_free(v15);
      goto LABEL_15;
    }
    v64 = flash_art_write(v22, v44, 0, 0, v20, v68);
  }
  if ( v64 == -1 )
  {
LABEL_121:
    nvram_set(v73 + 20068, "0");
    goto LABEL_10;
  }
  v46 = v20;
  sync();
  sleep(1u);
  if ( v20 >= 65537 )
    v46 = 0x10000;
  if ( v15 )
    goto LABEL_85;
LABEL_105:
  nvram_set(v73 + 20068, "0");
  v68[0] = 0;
  if ( !v4 || J_atoi(v4) )
  {
    jhl_gl_reboot_timer(2000);
    goto LABEL_10;
  }
  v58 = _GET_LANG_TEXT(18, *(unsigned __int8 *)(a1 + 210102), v57);
  v59 = snprintf(v65, 2048, v76 + 20316, v58);
  if ( v59 >= 0x800 )
    v59 = 2047;
  if ( v2 )
    nvram_set("upgrade_version_name", v2);
  v60 = *(void **)(a1 + 205564);
  if ( v60 )
  {
    _mem_free(v60);
    *(_DWORD *)(a1 + 205564) = 0;
  }
  if ( v15 )
    _mem_free(v15);
  register_signal();
  exec_service("jhttpd_check-start");
  upgrade_after(v61);
  return httpd_cgi_ret(a1, v65, v59, 4);
}
// 4857CC: variable 'v6' is possibly undefined
// 4858B4: variable 'v11' is possibly undefined
// 485AFC: variable 'v25' is possibly undefined
// 485F70: variable 'v42' is possibly undefined
// 486030: variable 'v45' is possibly undefined
// 486064: variable 'v44' is possibly undefined
// 486118: variable 'v47' is possibly undefined
// 48633C: variable 'v57' is possibly undefined
// 486434: variable 'v61' is possibly undefined
// 486504: variable 'v62' is possibly undefined
// 67D0BC: using guessed type int debug_level;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81C0: using guessed type int prepare_upgrade(void);
// 6A82C8: using guessed type int __fastcall get_upfile_version_flag(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A837C: using guessed type int __fastcall upgrade_after(_DWORD);
// 6A8394: using guessed type int jhl_hardversion_get(void);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8520: using guessed type int __fastcall get_md5_str(_DWORD, _DWORD, _DWORD);
// 6A8660: using guessed type int __fastcall getMD5Str(_DWORD, _DWORD, _DWORD);
// 6A87B4: using guessed type int __fastcall find_old_sq_exist(_DWORD);
// 6A87C4: using guessed type int nvram_commit(void);
// 6A883C: using guessed type int __fastcall flash_erase_mtd(_DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00486680) --------------------------------------------------------
void __fastcall format_url_group_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 3 )
    snprintf(a3, a4, "{\"g\":%s,\"n\":\"%s\",\"t\":%s},", *a1, a1[1], a1[2]);
}

//----- (00486708) --------------------------------------------------------
int __fastcall get_url_group_data(char *a1, int a2)
{
  int v4; // $s2
  int v5; // $s0
  const char **v6; // $s4
  void *v7; // $v0
  _DWORD *v8; // $s7
  void *v9; // $fp
  int v10; // $s6
  _DWORD *v11; // $s3
  int i; // $s2
  int v13; // $v0
  int v14; // $v0
  char *v15; // $a0
  int v16; // $s1
  int v17; // $v0

  v4 = nvram_get(&unk_64A61C);
  v5 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v5 >= a2 )
    v5 = a2 - 1;
  if ( v4 )
  {
    v6 = (const char **)malloc(0x14u);
    v8 = malloc(0x4008u);
    v7 = malloc(0x200000u);
    v9 = v7;
    if ( v7 )
    {
      if ( v6 )
      {
        if ( v8 )
        {
          strlcpy(v7, v4, 0x200000);
          v10 = split_string(v9, 60, v8, 4096);
          if ( v10 > 0 )
          {
            v11 = v8;
            for ( i = 0; i != v10; ++i )
            {
              v13 = split_string(*v11, 124, v6, 3);
              format_url_group_data(v6, v13, &a1[v5], a2 - v5);
              v5 += v14;
              ++v11;
            }
          }
        }
      }
      free(v9);
    }
    if ( v6 )
      free(v6);
    if ( v8 )
      free(v8);
  }
  v15 = &a1[v5];
  if ( v5 > 0 && *(v15 - 1) == 44 )
    v15 = &a1[--v5];
  v16 = a2 - v5;
  *v15 = 0;
  v17 = snprintf(v15, v16, &byte_6445A0);
  if ( v17 >= v16 )
    v17 = v16 - 1;
  return v5 + v17;
}
// 486874: variable 'v14' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00486950) --------------------------------------------------------
int __fastcall get_url_update_data(char *a1)
{
  const char *v2; // $s1
  const char *v3; // $s2
  const char *v4; // $v0

  v2 = (const char *)jhl_nv_get_def("url_update_en");
  v3 = (const char *)jhl_nv_get_def("url_update_path");
  v4 = (const char *)jhl_nv_get_def("url_update_time");
  return sprintf(a1, "\"enable\":\"%s\",\"srv_path\":\"%s\",\"mod_time\":\"%s\"", v2, v3, v4);
}
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004869FC) --------------------------------------------------------
int __fastcall sub_4869FC(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  int v5; // $s1
  int v6; // $v0
  int v7; // $a2
  int result; // $v0
  const char *v9; // $v0
  unsigned int v10; // $v0
  char v11[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(10240, "url_group_data", 58);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{\"all\":");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    *(_BYTE *)(v2 + 32) = 108;
    v4 = get_url_group_data((char *)(v2 + 35), 10205);
    v3[v4 + 35] = 44;
    v5 = v4 + 36 + get_url_update_data(&v3[v4 + 36]);
    v6 = snprintf(&v3[v5], 10240 - v5, "}}");
    if ( v6 >= 10240 - v5 )
      v7 = 10239 - v5;
    else
      v7 = v6;
    result = httpd_cgi_ret(a1, v3, v7 + v5, 8);
  }
  else
  {
    v9 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v10 = snprintf(v11, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 >= 0x100 )
      v10 = 255;
    result = httpd_cgi_ret(a1, v11, v10, 4);
  }
  return result;
}
// 486A48: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6459A8: using guessed type int dword_6459A8;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00486C1C) --------------------------------------------------------
int __fastcall sub_486C1C(int a1)
{
  char *v2; // $s3
  char *v3; // $v0
  char *v4; // $s4
  const char *v5; // $s1
  const char *v6; // $v0
  int v7; // $v0
  unsigned int v9; // $v0
  int v10; // $a1
  char *v11; // $a2
  unsigned __int8 v12; // $v0
  unsigned int v13; // $v0
  int v14; // $a0
  char *v15; // $v1
  const char *v16; // $v0
  int v17; // $t0
  int v18; // $a3
  int v19; // $a2
  int v20; // $a1
  const char *v21; // $a2
  char s[10240]; // [sp+20h] [-2800h] BYREF

  v2 = httpd_get_parm(a1, "name");
  v4 = httpd_get_parm(a1, "id");
  v3 = httpd_get_parm(a1, "opt");
  if ( !v3 )
    goto LABEL_4;
  v5 = v3;
  if ( !strcmp(v3, (const char *)&off_646D8C) )
  {
    if ( strcmp(v5, "del") )
      goto LABEL_10;
  }
  else if ( strcmp(v5, "del") )
  {
LABEL_4:
    v6 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    goto LABEL_5;
  }
  if ( !v4 )
  {
    v6 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not id");
    goto LABEL_5;
  }
  v12 = J_atoi(v4);
  v13 = url_group_del(v12);
  if ( v13 == -1 )
  {
    v6 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
    goto LABEL_5;
  }
  if ( v13 )
  {
    if ( v13 >= 0x33 || (v21 = (const char *)jhlret_err_str[v13]) == 0 )
      v21 = "not find err!";
    v6 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), v21);
    goto LABEL_5;
  }
  if ( !strcmp(v5, (const char *)&off_646D8C) )
  {
LABEL_10:
    if ( v2 )
    {
      v7 = check_rule_num_limit(a1, 15, (int)&unk_64A61C, 60, s, 0x2800u);
      if ( v7 > 0 )
        return httpd_cgi_ret(a1, s, v7, 4);
      v9 = url_group_add(v2, 0, 0);
      if ( v9 == -1 )
      {
        v10 = *(unsigned __int8 *)(a1 + 210102);
        v11 = "";
      }
      else
      {
        if ( !v9 )
          goto LABEL_21;
        v10 = *(unsigned __int8 *)(a1 + 210102);
        if ( v9 >= 0x33 || (v11 = (char *)jhlret_err_str[v9]) == 0 )
          v11 = "not find err!";
      }
      v6 = (const char *)_GET_LANG_TEXT(3, v10, v11);
    }
    else
    {
      v6 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_6442E4);
    }
LABEL_5:
    v7 = snprintf(s, 10240, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v6);
    if ( (unsigned int)v7 >= 0x2800 )
      v7 = 10239;
    return httpd_cgi_ret(a1, s, v7, 4);
  }
LABEL_21:
  if ( url_group_get(s, 10240) )
    jhl_parm_set(&unk_64A61C, s);
  else
    jhl_parm_set(&unk_64A61C, "");
  jhl_parm_commit(v14);
  v15 = s;
  v16 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v17 = *(_DWORD *)v16;
    v18 = *((_DWORD *)v16 + 1);
    v19 = *((_DWORD *)v16 + 2);
    v20 = *((_DWORD *)v16 + 3);
    v16 += 16;
    *(_DWORD *)v15 = v17;
    *((_DWORD *)v15 + 1) = v18;
    *((_DWORD *)v15 + 2) = v19;
    *((_DWORD *)v15 + 3) = v20;
    v15 += 16;
  }
  while ( v16 != "}" );
  *(_WORD *)v15 = *(_WORD *)v16;
  return httpd_cgi_ret(a1, s, 33, 4);
}
// 486EE4: variable 'v14' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A819C: using guessed type int __fastcall url_group_del(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8648: using guessed type int __fastcall url_group_get(_DWORD, _DWORD);
// 6A8674: using guessed type int __fastcall url_group_add(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00487070) --------------------------------------------------------
void __fastcall format_url_member_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 3 )
    snprintf(a3, a4, "{\"n\":\"%s\",\"u\":\"%s\",\"g\":%s},", *a1, a1[1], a1[2]);
}

//----- (004870F8) --------------------------------------------------------
int __fastcall sub_4870F8(int a1)
{
  int v1; // $v0
  char *v2; // $s0
  _BYTE *v3; // $s4
  int v4; // $s1
  const char **v5; // $s3
  void *v6; // $v0
  _DWORD *v7; // $s7
  int v8; // $a1
  void *v9; // $s1
  int v10; // $s6
  _DWORD *v11; // $fp
  int v12; // $s1
  int i; // $s2
  int v14; // $v0
  int v15; // $v0
  int v16; // $s5
  char *v17; // $a0
  int v18; // $v0
  int v19; // $s1
  char *v20; // $v0
  int v21; // $s1
  int v22; // $a2
  const char *v24; // $v0
  unsigned int v25; // $v0
  char v26[256]; // [sp+20h] [-108h] BYREF
  void *ptr; // [sp+120h] [-8h]

  _mem_malloc(0x200000, "url_member_data", 207);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{\"all\":");
    qmemcpy((void *)v1, "{\"code\":0,\"e", 12);
    *(_DWORD *)(v1 + 24) = 975331700;
    *(_BYTE *)(v1 + 32) = 108;
    v3 = (_BYTE *)(v1 + 35);
    v4 = nvram_get("url_member");
    v2[35] = 91;
    v2[36] = 0;
    if ( v4 )
    {
      v5 = (const char **)malloc(0x14u);
      v7 = malloc(0x4008u);
      v6 = malloc(0x200000u);
      ptr = v6;
      if ( v6 )
      {
        if ( v5 && (v8 = v4, v7) && (v9 = v6, strlcpy(v6, v8, 0x200000), v10 = split_string(v9, 60, v7, 4096), v10 > 0) )
        {
          v11 = v7;
          v12 = 1;
          for ( i = 0; i != v10; ++i )
          {
            v14 = split_string(*v11, 124, v5, 3);
            format_url_member_data(v5, v14, &v3[v12], 2097117 - v12);
            v12 += v15;
            ++v11;
          }
          v16 = v12;
        }
        else
        {
          v16 = 1;
          v12 = 1;
        }
        free(ptr);
      }
      else
      {
        v16 = 1;
        v12 = 1;
      }
      if ( v5 )
        free(v5);
      if ( v7 )
        free(v7);
      if ( v12 <= 0 )
      {
        v17 = &v3[v16];
        goto LABEL_17;
      }
      v17 = &v3[v16];
      if ( v3[v16 - 1] != 44 )
      {
LABEL_17:
        *v17 = 0;
        v18 = snprintf(v17, 2097117 - v12, &byte_6445A0);
        if ( v18 >= 2097117 - v12 )
          v18 = 2097116 - v12;
        v19 = v12 + v18;
        v20 = &v2[v19 + 35];
        strcpy(v20, ",\"gid\":");
        strcpy(v20, ",\"gid\":");
        v21 = v19 + 42 + get_url_group_data(&v2[v19 + 42], 0x200000 - (v19 + 42));
        v22 = snprintf(&v2[v21], 0x200000 - v21, "}}");
        if ( v22 >= 0x200000 - v21 )
          v22 = 0x1FFFFF - v21;
        return jhl_data_giz(a1, v2, v22 + v21, 0x200000);
      }
    }
    else
    {
      v17 = v2 + 36;
      v12 = 1;
      if ( *v3 != 44 )
        goto LABEL_17;
    }
    v17 = &v3[--v12];
    goto LABEL_17;
  }
  v24 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v25 = snprintf(v26, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
  if ( v25 >= 0x100 )
    v25 = 255;
  return httpd_cgi_ret(a1, v26, v25, 4);
}
// 487158: variable 'v1' is possibly undefined
// 487308: variable 'v15' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6459A8: using guessed type int dword_6459A8;
// 64A6B0: using guessed type int dword_64A6B0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00487544) --------------------------------------------------------
int __fastcall sub_487544(int a1)
{
  char *v2; // $s4
  char *v3; // $s5
  char *v4; // $s7
  char *v5; // $v0
  char *v6; // $s6
  const char *v7; // $s1
  int v8; // $s2
  int v9; // $fp
  unsigned int v10; // $v0
  bool v11; // dc
  unsigned int v12; // $v0
  const char *v13; // $a2
  const char *v14; // $v0
  int v15; // $s1
  void *v16; // $s3
  unsigned __int8 v18; // $v0
  unsigned int v19; // $v0
  int v20; // $a2
  int v21; // $a1
  char *v22; // $a2
  void *v23; // $v0
  int v24; // $a0
  char *v25; // $v1
  const char *v26; // $v0
  int v27; // $t0
  int v28; // $a3
  int v29; // $a2
  int v30; // $a1
  void *v31; // $v0
  const char *v32; // $v0
  char s[128]; // [sp+20h] [-80h] BYREF

  v2 = httpd_get_parm(a1, "name");
  v3 = httpd_get_parm(a1, "u");
  v4 = httpd_get_parm(a1, "old_u");
  v6 = httpd_get_parm(a1, (char *)&off_64918C);
  v5 = httpd_get_parm(a1, "opt");
  if ( !v5 )
  {
LABEL_48:
    v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    goto LABEL_11;
  }
  v7 = v5;
  v8 = strcmp(v5, (const char *)&off_646D8C);
  v9 = v8;
  if ( !v8 || !strcmp(v7, (const char *)&off_648DDC) )
  {
    if ( !strcmp(v7, "delall") )
      goto LABEL_6;
    if ( strcmp(v7, "del") && strcmp(v7, (const char *)&off_648DDC) )
    {
      if ( v8 )
        goto LABEL_36;
      goto LABEL_23;
    }
LABEL_18:
    if ( !v4 )
    {
      v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not old_url");
      goto LABEL_11;
    }
    v10 = url_member_del(v4);
    if ( v10 == -1 )
      goto LABEL_52;
    if ( v10 )
    {
LABEL_8:
      v11 = v10 < 0x33;
      v12 = v10;
      if ( !v11 || (v13 = (const char *)jhlret_err_str[v12]) == 0 )
        v13 = "not find err!";
      v14 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), v13);
      goto LABEL_11;
    }
    v9 = strcmp(v7, (const char *)&off_646D8C);
    if ( v9 && strcmp(v7, (const char *)&off_648DDC) )
      goto LABEL_36;
LABEL_23:
    if ( !v2 )
    {
      v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_6442E4);
      goto LABEL_11;
    }
    if ( !v3 )
    {
      v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not url");
      goto LABEL_11;
    }
    if ( !v6 )
    {
      v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_649188);
      goto LABEL_11;
    }
    if ( !v9 )
    {
      v15 = check_rule_num_limit(a1, 16, (int)"url_member", 60, s, 0x80u);
      if ( v15 > 0 )
      {
        v16 = 0;
        goto LABEL_14;
      }
    }
    v18 = J_atoi(v6);
    v19 = url_member_add(v18, v2, v3, 0);
    if ( v19 == -2 )
    {
      v14 = (const char *)_GET_LANG_TEXT(180, *(unsigned __int8 *)(a1 + 210102), v20);
      goto LABEL_11;
    }
    if ( v19 == -1 )
    {
      v21 = *(unsigned __int8 *)(a1 + 210102);
      v22 = "";
LABEL_32:
      v14 = (const char *)_GET_LANG_TEXT(3, v21, v22);
LABEL_11:
      v15 = snprintf(s, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
      if ( (unsigned int)v15 >= 0x80 )
        v15 = 127;
      v16 = 0;
      goto LABEL_14;
    }
    if ( v19 )
    {
      v21 = *(unsigned __int8 *)(a1 + 210102);
      if ( v19 >= 0x33 || (v22 = (char *)jhlret_err_str[v19]) == 0 )
        v22 = "not find err!";
      goto LABEL_32;
    }
LABEL_36:
    _mem_malloc(0x200000, "url_member_asp", 364);
    v16 = v23;
    if ( v23 )
    {
      if ( url_member_get(v23, 0x200000) )
        jhl_parm_set("url_member", v16);
      else
        jhl_parm_set("url_member", "");
      jhl_parm_commit(v24);
      v25 = s;
      v26 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v27 = *(_DWORD *)v26;
        v28 = *((_DWORD *)v26 + 1);
        v29 = *((_DWORD *)v26 + 2);
        v30 = *((_DWORD *)v26 + 3);
        v26 += 16;
        *(_DWORD *)v25 = v27;
        *((_DWORD *)v25 + 1) = v28;
        *((_DWORD *)v25 + 2) = v29;
        *((_DWORD *)v25 + 3) = v30;
        v25 += 16;
      }
      while ( v26 != "}" );
      v15 = 33;
      *(_WORD *)v25 = *(_WORD *)v26;
      goto LABEL_14;
    }
    v32 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    goto LABEL_57;
  }
  if ( strcmp(v7, "del") )
  {
    if ( !strcmp(v7, "delall") )
      goto LABEL_6;
    goto LABEL_48;
  }
  if ( strcmp(v7, "delall") )
    goto LABEL_18;
LABEL_6:
  v10 = url_member_delall();
  if ( v10 == -1 )
  {
LABEL_52:
    v14 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
    goto LABEL_11;
  }
  if ( v10 )
    goto LABEL_8;
  _mem_malloc(0x200000, "url_member_asp", 273);
  v16 = v31;
  if ( v31 )
  {
    if ( url_group_get(v31, 0x200000) )
      jhl_parm_set(&unk_64A61C, v16);
    else
      jhl_parm_set(&unk_64A61C, "");
    _mem_free(v16);
    goto LABEL_36;
  }
  v32 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
LABEL_57:
  v15 = snprintf(s, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v32);
  if ( (unsigned int)v15 >= 0x80 )
    v15 = 127;
LABEL_14:
  _mem_free(v16);
  return httpd_cgi_ret(a1, s, v15, 4);
}
// 487970: variable 'v23' is possibly undefined
// 4879B4: variable 'v24' is possibly undefined
// 487A48: variable 'v31' is possibly undefined
// 487C20: variable 'v20' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 64918C: using guessed type void *off_64918C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8390: using guessed type int __fastcall url_member_get(_DWORD, _DWORD);
// 6A83B4: using guessed type int url_member_delall(void);
// 6A8648: using guessed type int __fastcall url_group_get(_DWORD, _DWORD);
// 6A86C4: using guessed type int __fastcall url_member_del(_DWORD);
// 6A8770: using guessed type int __fastcall url_member_add(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00487CEC) --------------------------------------------------------
int __fastcall url_member_get_file(char *a1, size_t a2)
{
  unsigned __int8 *v4; // $v0
  int v5; // $a2
  unsigned __int8 *v6; // $s6
  signed int v7; // $s1
  const char *v9; // $v0
  int v10; // $v0
  char *v11; // $v1
  _DWORD *v12; // $a0
  int v13; // $a1
  int v14; // $a2
  int v15; // $a1
  char v16; // $a2
  char v17; // $a1
  char v18; // $a0
  char *v19; // $a0
  const char *v20; // $s0
  signed int v21; // $s3
  int v22; // $s7

  _mem_malloc(0x200000, "url_member_get_file", 403);
  v6 = v4;
  if ( !v4 )
    return 0;
  *(_DWORD *)v4 = 24;
  *((_DWORD *)v4 + 3) = 5;
  *((_DWORD *)v4 + 1) = 0x200000;
  v7 = 0;
  if ( !jianhl_order_opt_fun(v4, 0x200000, v5) )
  {
    memset(a1, 0, a2);
    v9 = (const char *)jhl_nv_get_def(&unk_64A61C);
    v10 = sprintf(a1, "gids:%s\r\n", v9);
    v11 = &a1[v10];
    v12 = &unk_64A6D8;
    do
    {
      v13 = v12[1];
      *(_DWORD *)v11 = *v12;
      *((_DWORD *)v11 + 1) = v13;
      v14 = v12[2];
      *((_DWORD *)v11 + 1) = v13;
      *((_DWORD *)v11 + 2) = v14;
      v15 = v12[3];
      *((_DWORD *)v11 + 2) = v14;
      *((_DWORD *)v11 + 3) = v15;
      v12 += 4;
      *((_DWORD *)v11 + 3) = v15;
      v11 += 16;
    }
    while ( v12 != (_DWORD *)&unk_64A708 );
    v16 = *(_BYTE *)v12;
    v17 = *((_BYTE *)v12 + 1);
    v18 = *((_BYTE *)v12 + 2);
    *v11 = v16;
    v11[2] = v18;
    v11[1] = v17;
    v7 = v10 + 50;
    v19 = &a1[v10 + 50];
    v20 = (const char *)(v6 + 24);
    if ( *((int *)v6 + 5) > 0 )
    {
      v21 = a2 - 49;
      v22 = 0;
      do
      {
        v7 += sprintf(
                v19,
                "{n:%s,u:%s,g:%u}\r\n",
                &v20[*((unsigned __int8 *)v20 + 2) + 9],
                v20 + 8,
                *(unsigned __int8 *)v20);
        ++v22;
        v19 = &a1[v7];
        if ( v7 >= v21 )
          break;
        v20 += *((unsigned __int8 *)v20 + 3) + 8;
      }
      while ( v22 < *((_DWORD *)v6 + 5) );
    }
  }
  _mem_free(v6);
  return v7;
}
// 487D4C: variable 'v4' is possibly undefined
// 487D70: variable 'v5' is possibly undefined
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00487F0C) --------------------------------------------------------
int __fastcall sub_487F0C(int a1)
{
  char *v2; // $v0
  int v3; // $v0
  char *v4; // $s1
  int result; // $v0
  const char *v6; // $v0
  unsigned int v7; // $v0
  char v8[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "url_member_txt", 474);
  if ( v2 )
  {
    v4 = v2;
    v3 = url_member_get_file(v2, 0x200000u);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v3);
  }
  else
  {
    v6 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v7 = snprintf(v8, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v6);
    if ( v7 >= 0x100 )
      v7 = 255;
    result = httpd_cgi_ret(a1, v8, v7, 4);
  }
  return result;
}
// 487F4C: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0048802C) --------------------------------------------------------
int __fastcall sub_48802C(int a1)
{
  int v1; // $s0
  int v2; // $s3
  char *v3; // $v0
  char *v5; // $v0
  char *v6; // $s2
  void *v7; // $v0
  int v8; // $a2
  void *v9; // $s0
  int v10; // $a0
  const char *v11; // $v0
  unsigned int v12; // $v0
  const char *v14; // $v0
  char v15[516]; // [sp+20h] [-204h] BYREF

  v1 = a1 + 196608;
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( !v3 || (v6 = v3, (v5 = find_file_end(a1, v3, *(_DWORD *)(v1 + 8956) + v2 - (_DWORD)v3)) == 0) )
  {
    v14 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
    v12 = snprintf(v15, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v12 < 0x200 )
      return httpd_cgi_ret(a1, v15, v12, 4);
LABEL_10:
    v12 = 511;
    return httpd_cgi_ret(a1, v15, v12, 4);
  }
  *v5 = 0;
  url_memberfile_buf(v6, 0);
  _mem_malloc(0x200000, "url_memberfile_cgi", 526);
  v9 = v7;
  if ( v7 )
  {
    if ( url_member_get(v7, 0x200000) )
      jhl_parm_set("url_member", v9);
    else
      jhl_parm_set("url_member", "");
    jhl_parm_commit(v10);
    _mem_free(v9);
  }
  v11 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v8);
  v12 = snprintf(v15, 512, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v11);
  if ( v12 >= 0x200 )
    goto LABEL_10;
  return httpd_cgi_ret(a1, v15, v12, 4);
}
// 488078: variable 'v3' is possibly undefined
// 4880DC: variable 'v7' is possibly undefined
// 488128: variable 'v10' is possibly undefined
// 48815C: variable 'v8' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8390: using guessed type int __fastcall url_member_get(_DWORD, _DWORD);
// 6A8470: using guessed type int __fastcall url_memberfile_buf(_DWORD, _DWORD);

//----- (00488244) --------------------------------------------------------
void __fastcall format_url_rule_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 9 )
    snprintf(
      a3,
      a4,
      "{\"n\":\"%s\",\"en\":%s,\"ips\":\"%s\",\"u\":\"%s\",\"time\":\"%s\",\"log\":%s,\"rpri\":%s,\"act\":%s,\"flag\":%s},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7],
      a1[8]);
}

//----- (004882FC) --------------------------------------------------------
int __fastcall sub_4882FC(int a1)
{
  int v1; // $v0
  char *v2; // $fp
  const char *v3; // $s1
  const char *v4; // $s2
  const char *v5; // $s3
  const char *v6; // $v0
  int v7; // $v0
  int v8; // $s1
  int v9; // $s0
  int v10; // $v0
  int v11; // $s1
  int v12; // $v0
  int v13; // $s3
  int v14; // $s1
  char *v15; // $s4
  int v16; // $s5
  int v17; // $s0
  const char **v18; // $s2
  void *v19; // $v0
  _DWORD *v20; // $s6
  int v21; // $a1
  void *v22; // $s5
  int v23; // $s5
  int i; // $s7
  int v25; // $v0
  int v26; // $v0
  char *v27; // $a0
  int v28; // $s1
  int v29; // $v0
  int v30; // $s3
  int v31; // $v0
  int v32; // $a2
  int result; // $v0
  const char *v34; // $v0
  unsigned int v35; // $v0
  char v36[256]; // [sp+28h] [-108h] BYREF
  _DWORD *v37; // [sp+128h] [-8h]
  void *ptr; // [sp+12Ch] [-4h]

  _mem_malloc(0x200000, "url_rule_data", 602);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    v3 = (const char *)jhl_nv_get_def("urlAct");
    v4 = (const char *)jhl_nv_get_def(&unk_64A784);
    v5 = (const char *)jhl_nv_get_def("urlto");
    v6 = (const char *)jhl_nv_get_def("urltoz");
    v7 = snprintf(v2 + 29, 2097123, "\"def\":%s,\"block\":%s,\"tiao\":%s,\"tiaozhuan\":\"%s\"", v3, v4, v5, v6);
    if ( v7 >= 2097123 )
      v7 = 2097122;
    v8 = v7 + 29;
    v9 = 0x200000 - (v7 + 29);
    v10 = snprintf(&v2[v7 + 29], v9, (char *)&dword_64A6B0);
    if ( v10 >= v9 )
      v10 = 0x1FFFFF - v8;
    v11 = v10 + v8 + get_url_group_data(&v2[v10 + v8], 0x200000 - (v10 + v8));
    v12 = snprintf(&v2[v11], 0x200000 - v11, ",\"all\":");
    if ( v12 >= 0x200000 - v11 )
      v12 = 0x1FFFFF - v11;
    v13 = v12 + v11;
    v14 = 0x200000 - (v12 + v11);
    v15 = &v2[v13];
    v16 = nvram_get("url_rules");
    v17 = snprintf(&v2[v13], 0x200000 - v13, (char *)&word_642A04);
    if ( v17 >= 0x200000 - v13 )
      v17 = 0x1FFFFF - v13;
    if ( v16 )
    {
      v18 = (const char **)malloc(0x2Cu);
      v37 = malloc(0x4008u);
      v20 = v37;
      v19 = malloc(0x200000u);
      ptr = v19;
      if ( v19 )
      {
        if ( v18 )
        {
          v21 = v16;
          if ( v37 )
          {
            v22 = v19;
            strlcpy(v19, v21, 0x200000);
            v23 = split_string(v22, 60, v37, 4096);
            if ( v23 > 0 )
            {
              for ( i = 0; i != v23; ++i )
              {
                v25 = split_string(*v20, 124, v18, 9);
                format_url_rule_data(v18, v25, &v15[v17], v14 - v17);
                v17 += v26;
                ++v20;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v18 )
        free(v18);
      if ( v37 )
        free(v37);
    }
    v27 = &v15[v17];
    if ( v17 > 0 && *(v27 - 1) == 44 )
      v27 = &v15[--v17];
    v28 = v14 - v17;
    *v27 = 0;
    v29 = snprintf(v27, v28, &byte_6445A0);
    if ( v29 >= v28 )
      v29 = v28 - 1;
    v30 = v17 + v29 + v13;
    v31 = snprintf(&v2[v30], 0x200000 - v30, "}}");
    if ( v31 >= 0x200000 - v30 )
      v32 = 0x1FFFFF - v30;
    else
      v32 = v31;
    result = httpd_cgi_ret(a1, v2, v32 + v30, 8);
  }
  else
  {
    v34 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v35 = snprintf(v36, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v34);
    if ( v35 >= 0x100 )
      v35 = 255;
    result = httpd_cgi_ret(a1, v36, v35, 4);
  }
  return result;
}
// 48835C: variable 'v1' is possibly undefined
// 48863C: variable 'v26' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 64A6B0: using guessed type int dword_64A6B0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00488810) --------------------------------------------------------
int __fastcall sub_488810(int a1)
{
  void *v2; // $v0
  int v3; // $v0
  void *v4; // $s1
  const char **v5; // $s0
  int v6; // $s3
  int v7; // $s2
  int v8; // $s1
  int v9; // $v0
  char *v10; // $s1
  const char *v12; // [sp+38h] [-4178h] BYREF
  int v13; // [sp+3Ch] [-4174h]
  char v14[256]; // [sp+4038h] [-178h] BYREF
  int v15[11]; // [sp+4138h] [-78h] BYREF
  int v16; // [sp+4164h] [-4Ch] BYREF
  int v17; // [sp+4168h] [-48h]
  int v18; // [sp+416Ch] [-44h]
  int v19; // [sp+4170h] [-40h]
  int v20; // [sp+4174h] [-3Ch]
  int v21; // [sp+4178h] [-38h]
  int v22; // [sp+417Ch] [-34h]
  int v23; // [sp+4180h] [-30h]
  int v24; // [sp+4184h] [-2Ch]
  int v25; // [sp+4190h] [-20h]
  char *v26; // [sp+4194h] [-1Ch]
  char *format; // [sp+4198h] [-18h]
  const char *v28; // [sp+419Ch] [-14h]
  void *v29; // [sp+41A0h] [-10h]
  char *v30; // [sp+41A4h] [-Ch]
  char *v31; // [sp+41A8h] [-8h]

  v31 = "1\"";
  memset(v14, 0, sizeof(v14));
  _mem_malloc(0x200000, "url_rule_change_def", 654);
  v29 = v2;
  v4 = v2;
  _mem_malloc(0x200000, "url_rule_change_def", 655);
  v26 = (char *)v3;
  if ( !v4 )
    return -1;
  v5 = &v12;
  if ( !v3 )
    return -1;
  v12 = "url_clean.sh";
  v13 = 0;
  eval(&v12, 0, 0, 0);
  v30 = "a";
  v12 = "urlfilter_clean.sh";
  v13 = 0;
  eval(&v12, 0, 0, 0);
  jhl_parm_get("url_rules", v4, 0x200000);
  v6 = split_string(v4, 60, &v12, 4096);
  if ( v6 > 0 )
  {
    format = "%s|%s|%s|%s|%s|%s|%s|%s|%s<";
    v7 = 0;
    v8 = 0;
    v28 = "url_add.sh";
    do
    {
      while ( split_string(*v5, 124, &v16, 9) < 9 )
      {
        ++v8;
        ++v5;
        if ( v6 == v8 )
          goto LABEL_12;
      }
      v25 = 0x200000 - v7;
      v23 = a1;
      v9 = snprintf(&v26[v7], 0x200000 - v7, format, v16, v17, v18, v19, v20, v21, v22, a1, v24);
      if ( v9 >= v25 )
        v9 = 0x1FFFFF - v7;
      v7 += v9;
      if ( get_time_group(v20, v14, 256) )
        strlcpy(v14, v20, 256);
      v15[0] = (int)v28;
      v15[1] = v16;
      v15[2] = v17;
      v15[3] = v18;
      v15[4] = v19;
      v15[5] = (int)v14;
      v15[7] = v21;
      v15[6] = (int)v14;
      v15[8] = v22;
      v15[10] = 0;
      v15[9] = v23;
      ++v8;
      eval(v15, 0, 0, 0);
      ++v5;
    }
    while ( v6 != v8 );
  }
LABEL_12:
  v10 = v26;
  jhl_parm_set(v30 + 27940, v26);
  _mem_free(v29);
  _mem_free(v10);
  return 0;
}
// 4888A0: variable 'v2' is possibly undefined
// 4888AC: variable 'v3' is possibly undefined
// 6A8298: using guessed type int __fastcall get_time_group(_DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00488B80) --------------------------------------------------------
int __fastcall sub_488B80(int a1)
{
  char *v2; // $s3
  char *v3; // $s5
  char *v4; // $s2
  char *v5; // $s6
  int v6; // $s4
  const char *v7; // $s7
  int v8; // $a0
  const char *v9; // $v1
  char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  int v15; // $a2
  _DWORD *v16; // $fp
  int v17; // $a1
  const char *v18; // $a2
  const char *v19; // $v0
  int v20; // $v0
  char *v22; // $s2
  char *v23; // $s6
  char *v24; // $s5
  char *v25; // $s3
  int v26; // $a0
  int v27; // $t0
  int v28; // $a3
  int v29; // $a2
  int v30; // $a1
  char *v31; // $s6
  int v32; // $v0
  int v33; // $s6
  char *v34; // $s6
  const char *v35; // [sp+38h] [-32458h] BYREF
  char *v36; // [sp+3Ch] [-32454h]
  const char *v37; // [sp+40h] [-32450h]
  char *v38; // [sp+44h] [-3244Ch]
  char *v39; // [sp+48h] [-32448h]
  int v40; // [sp+4Ch] [-32444h]
  char s[102400]; // [sp+19038h] [-19458h] BYREF
  _BYTE v42[1024]; // [sp+32038h] [-458h] BYREF
  const char *v43; // [sp+32438h] [-58h] BYREF
  char *v44; // [sp+3243Ch] [-54h]
  char *v45; // [sp+32440h] [-50h]
  char *v46; // [sp+32444h] [-4Ch]
  char *v47; // [sp+32448h] [-48h]
  _BYTE *v48; // [sp+3244Ch] [-44h]
  _BYTE *v49; // [sp+32450h] [-40h]
  char *v50; // [sp+32454h] [-3Ch]
  char *v51; // [sp+32458h] [-38h]
  char *v52; // [sp+3245Ch] [-34h]
  int v53; // [sp+32460h] [-30h]
  char *v54; // [sp+32468h] [-28h]
  char *v55; // [sp+3246Ch] [-24h]
  char *v56; // [sp+32470h] [-20h]
  char *v57; // [sp+32474h] [-1Ch]
  char *v58; // [sp+32478h] [-18h]
  char *v59; // [sp+3247Ch] [-14h]
  char *v60; // [sp+32480h] [-10h]
  const char *v61; // [sp+32484h] [-Ch]
  char *v62; // [sp+32488h] [-8h]

  memset(v42, 0, sizeof(v42));
  v2 = httpd_get_parm(a1, "name");
  v60 = httpd_get_parm(a1, "old_name");
  v55 = httpd_get_parm(a1, "en");
  v54 = httpd_get_parm(a1, "ips");
  v3 = httpd_get_parm(a1, "u");
  v59 = httpd_get_parm(a1, "time");
  v56 = httpd_get_parm(a1, "act");
  v57 = httpd_get_parm(a1, "rpri");
  v58 = httpd_get_parm(a1, (char *)&off_64E034);
  v4 = httpd_get_parm(a1, "opt");
  v5 = httpd_get_parm(a1, "flag");
  v6 = httpd_get_json_parm(a1, (int)"del_list");
  if ( v5 )
    v7 = v5;
  else
    v7 = "0";
  if ( J_atoi(v7) )
    v61 = "urlfilter_add.sh";
  else
    v61 = "url_add.sh";
  if ( !v4 )
  {
LABEL_75:
    v17 = *(unsigned __int8 *)(a1 + 210102);
    v18 = "not opt";
    goto LABEL_30;
  }
  if ( strcmp(v4, (const char *)&off_646D8C) && strcmp(v4, (const char *)&off_648DDC) && strcmp(v4, "del") )
  {
    if ( strcmp(v4, (const char *)&off_64712C) )
    {
      if ( !strcmp(v4, "delall") )
      {
LABEL_11:
        v35 = "url_clean.sh";
        v36 = 0;
        eval(&v35, 0, 0, 0);
        v35 = "urlfilter_clean.sh";
        v36 = 0;
        eval(&v35, 0, 0, 0);
        LOBYTE(v35) = 0;
LABEL_12:
        jhl_parm_set("url_rules", &v35);
        jhl_parm_commit(v8);
        goto LABEL_13;
      }
      goto LABEL_75;
    }
LABEL_34:
    v22 = httpd_get_parm(a1, (char *)&off_64712C);
    v23 = httpd_get_parm(a1, "tiao");
    v24 = httpd_get_parm(a1, "tiaozhuan");
    v25 = httpd_get_parm(a1, "block");
    if ( !v22 || strcmp(v22, "0") && strcmp(v22, "1") && strcmp(v22, "2") )
    {
      v17 = *(unsigned __int8 *)(a1 + 210102);
      v18 = (const char *)&unk_647128;
      goto LABEL_30;
    }
    if ( v25 )
    {
      if ( v23 )
        goto LABEL_41;
    }
    else
    {
      v25 = "1";
      if ( v23 )
      {
LABEL_41:
        if ( v24 )
          goto LABEL_42;
        goto LABEL_83;
      }
    }
    v23 = "0";
    if ( v24 )
    {
LABEL_42:
      v36 = "url";
      v35 = "wys";
      v37 = "setdef";
      v38 = v22;
      v39 = v25;
      v40 = 0;
      eval(&v35, 0, 0, 0);
      v36 = "urlfilter";
      v35 = "wys";
      v37 = "global";
      v38 = v22;
      v39 = v25;
      v40 = 0;
      eval(&v35, 0, 0, 0);
      jhl_parm_set("urlAct", v22);
      jhl_parm_set("urlto", v23);
      jhl_parm_set("urltoz", v24);
      jhl_parm_set(&unk_64A784, v25);
      jhl_parm_commit(v26);
      v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      v10 = s;
      do
      {
        v27 = *(_DWORD *)v9;
        v28 = *((_DWORD *)v9 + 1);
        v29 = *((_DWORD *)v9 + 2);
        v30 = *((_DWORD *)v9 + 3);
        v9 += 16;
        *(_DWORD *)v10 = v27;
        *((_DWORD *)v10 + 1) = v28;
        *((_DWORD *)v10 + 2) = v29;
        *((_DWORD *)v10 + 3) = v30;
        v10 += 16;
      }
      while ( v9 != "}" );
      goto LABEL_15;
    }
LABEL_83:
    v24 = "";
    goto LABEL_42;
  }
  if ( !strcmp(v4, (const char *)&off_64712C) )
    goto LABEL_34;
  if ( !strcmp(v4, "delall") )
    goto LABEL_11;
  if ( !strcmp(v4, "del") && v6 && cJSON_IsArray(v6) )
  {
    v16 = *(_DWORD **)(v6 + 8);
    if ( !v16 )
      goto LABEL_13;
    v60 = 0;
    v54 = "urlfilter_del.sh";
    v55 = "url_rules";
    do
    {
      v43 = "url_del.sh";
      v44 = (char *)v16[4];
      v45 = 0;
      eval(&v43, 0, 0, 0);
      v43 = v54;
      v44 = (char *)v16[4];
      v45 = 0;
      eval(&v43, 0, 0, 0);
      jhl_parm_get("url_rules", s, 102400);
      if ( nvparm_del_str(s, 60, 7, v16[4], 124, 0, &v35) )
      {
        jhl_parm_set(v55, &v35);
        v60 = (char *)1;
      }
      v16 = (_DWORD *)*v16;
    }
    while ( v16 );
    goto LABEL_80;
  }
  if ( !v2 || !*v2 )
  {
    v17 = *(unsigned __int8 *)(a1 + 210102);
    v18 = (const char *)&unk_6442E4;
    goto LABEL_30;
  }
  v62 = "1\"";
  if ( strcmp(v4, (const char *)&off_648DDC) )
  {
    v33 = strcmp(v4, (const char *)&off_646D8C);
    if ( v33 )
      goto LABEL_13;
    v60 = 0;
LABEL_49:
    if ( v3 && *v3 )
    {
      if ( v33 || (v20 = check_rule_num_limit(a1, 14, (int)"url_rules", 60, s, 0x19000u), v20 <= 0) )
      {
        if ( !v54 || !*v54 )
          v54 = "not";
        if ( !v58 || !*v58 )
          v58 = "0";
        if ( !v57 || !*v57 )
          v57 = "100";
        if ( !v56 || !*v56 )
          v56 = "1";
        if ( !v55 || !*v55 )
          v55 = "1";
        if ( !v59 || !*v59 )
          v59 = "OFF";
        v34 = v59;
        sprintf(s, "%s|%s|%s|%s|%s|%s|%s|%s|%s<", v2, v55, v54, v3, v59, v58, v57, v56, v7);
        if ( get_time_group(v34, v42, 1024) )
          strlcpy(v42, v59, 1024);
        v48 = v42;
        v49 = v42;
        v43 = v61;
        v50 = v58;
        v45 = v55;
        v51 = v57;
        v44 = v2;
        v46 = v54;
        v47 = v3;
        v52 = v56;
        v53 = 0;
        eval(&v43, 0, 0, 0);
        if ( !v60 )
          jhl_parm_get("url_rules", &v35, 102400);
        strcat((char *)&v35, s);
        goto LABEL_12;
      }
LABEL_32:
      v15 = v20;
      return httpd_cgi_ret(a1, s, v15, 4);
    }
    v17 = *(unsigned __int8 *)(a1 + 210102);
    v18 = "not u";
LABEL_30:
    v19 = (const char *)_GET_LANG_TEXT(12, v17, v18);
    v20 = snprintf(s, 102400, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
    if ( (unsigned int)v20 >= 0x19000 )
      v20 = 102399;
    goto LABEL_32;
  }
  v31 = v60;
  if ( v60 )
  {
    v36 = v60;
    v35 = "url_del.sh";
    v37 = 0;
    eval(&v35, 0, 0, 0);
    v35 = "urlfilter_del.sh";
    v36 = v31;
    v37 = 0;
    eval(&v35, 0, 0, 0);
    v60 = s;
    jhl_parm_get("url_rules", s, 102400);
    v32 = nvparm_del_str(v60, 60, 7, v31, 124, 0, &v35);
  }
  else
  {
    v36 = v2;
    v35 = "url_del.sh";
    v37 = 0;
    eval(&v35, 0, 0, 0);
    v35 = "urlfilter_del.sh";
    v36 = v2;
    v37 = 0;
    eval(&v35, 0, 0, 0);
    jhl_parm_get("url_rules", s, 102400);
    v32 = nvparm_del_str(s, 60, 7, v2, 124, 0, &v35);
  }
  v60 = (char *)(v32 != 0);
  v33 = strcmp(v4, (const char *)&off_646D8C);
  if ( !v33 || !strcmp(v4, v62 - 29220) )
    goto LABEL_49;
LABEL_80:
  if ( v60 )
    goto LABEL_12;
LABEL_13:
  v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v10 = s;
  do
  {
    v11 = *(_DWORD *)v9;
    v12 = *((_DWORD *)v9 + 1);
    v13 = *((_DWORD *)v9 + 2);
    v14 = *((_DWORD *)v9 + 3);
    v9 += 16;
    *(_DWORD *)v10 = v11;
    *((_DWORD *)v10 + 1) = v12;
    *((_DWORD *)v10 + 2) = v13;
    *((_DWORD *)v10 + 3) = v14;
    v10 += 16;
  }
  while ( v9 != "}" );
LABEL_15:
  *(_WORD *)v10 = *(_WORD *)v9;
  v15 = 33;
  return httpd_cgi_ret(a1, s, v15, 4);
}
// 488EF8: variable 'v8' is possibly undefined
// 489450: variable 'v26' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 64E034: using guessed type int (**off_64E034)();
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8298: using guessed type int __fastcall get_time_group(_DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00489B8C) --------------------------------------------------------
int __fastcall sub_489B8C(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "url_rule_txt", 929);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("url_rules");
    if ( !v3 )
      v3 = "";
    v5 = sprintf(v4, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 489BCC: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00489CDC) --------------------------------------------------------
int __fastcall sub_489CDC(int a1)
{
  int v1; // $v0
  int v2; // $s2
  const char *v3; // $a1
  char *v4; // $v0
  char *v5; // $s0
  char *v6; // $s1
  char *v7; // $v0
  int v8; // $a1
  int v9; // $v1
  _BOOL4 v10; // $a2
  char *v11; // $t0
  char *v12; // $s3
  int v13; // $s5
  char *v14; // $s4
  int v15; // $s0
  int v16; // $a0
  char *v17; // $s1
  char *v18; // $s6
  char *v19; // $s7
  int v20; // $t7
  int v21; // $t6
  int v22; // $t5
  int v23; // $t4
  int v24; // $t3
  int v25; // $t1
  int v26; // $t0
  int v27; // $v0
  char *v28; // $t2
  char *v29; // $a0
  char *v30; // $v1
  const char **v31; // $s6
  int v32; // $fp
  int v33; // $s7
  char *v34; // $s1
  int v35; // $s0
  char *v36; // $s1
  int v37; // $a0
  int v38; // $a2
  const char *v39; // $v0
  unsigned int v40; // $v0
  unsigned int v41; // $a2
  const char *v43; // $v0
  char v44[222208]; // [sp+20h] [-36A58h] BYREF
  _BYTE v45[1024]; // [sp+36420h] [-658h] BYREF
  char *v46; // [sp+36A50h] [-28h]
  char *v47; // [sp+36A54h] [-24h]
  char *v48; // [sp+36A58h] [-20h]
  int v49; // [sp+36A5Ch] [-1Ch]
  int v50; // [sp+36A60h] [-18h]
  int v51; // [sp+36A64h] [-14h]
  char *v52; // [sp+36A68h] [-10h]
  char *v53; // [sp+36A6Ch] [-Ch]
  char *v54; // [sp+36A70h] [-8h]

  v46 = v44;
  memset(v45, 0, sizeof(v45));
  v1 = get_rule_num_limit(14);
  v2 = *(_DWORD *)(a1 + 205364);
  v3 = *(const char **)(a1 + 205564);
  v51 = v1;
  find_file_head(a1, v3);
  if ( v4 && (v5 = v4, (v6 = find_file_end(a1, v4, *(_DWORD *)(a1 + 205564) + v2 - (_DWORD)v4)) != 0) )
  {
    v53 = "a";
    *v6 = 0;
    jhl_parm_get("url_rules", v44, 102400);
    if ( v6 - v5 <= 0 )
    {
      v8 = 0;
    }
    else
    {
      v7 = v5;
      v8 = 0;
      do
      {
        v9 = *v7++;
        v10 = v8 + 1 < 102399;
        if ( v9 != 13 && v9 != 10 )
        {
          v44[v8++ + 102400] = v9;
          if ( !v10 )
            break;
        }
      }
      while ( v6 != v7 );
    }
    v11 = v46;
    v12 = v46 + 220160;
    v46[v8 + 102400] = 0;
    v49 = split_string(v11 + 102400, 60, v12, 512);
    if ( v49 > 0 )
    {
      v52 = "1\"";
      v54 = "1\"";
      v50 = 0;
      v47 = v46 + 215040;
      v48 = v46 + 223232;
      v13 = 0;
      v14 = v46 + 196608;
      do
      {
        strlcpy(v47, *(_DWORD *)v12, 5120);
        v15 = split_string(*(_DWORD *)v12, 124, v48, 128);
        if ( v15 >= 8 && !nvparm_find_str(v46, 60, 11, *((_DWORD *)v14 + 6656), 124, 0) )
        {
          v16 = *((_DWORD *)v14 + 6664);
          if ( v16 && J_atoi(v16) == 1 )
            v17 = v54 - 22528;
          else
            v17 = v52 - 22540;
          v18 = v46 + 222208;
          if ( get_time_group(*((_DWORD *)v14 + 6660), v46 + 222208, 1024) )
            strlcpy(v18, *((_DWORD *)v14 + 6660), 1024);
          v19 = v46;
          v20 = *((_DWORD *)v14 + 6656);
          v21 = *((_DWORD *)v14 + 6657);
          v22 = *((_DWORD *)v14 + 6658);
          v23 = *((_DWORD *)v14 + 6659);
          v24 = *((_DWORD *)v14 + 6660);
          v25 = *((_DWORD *)v14 + 6661);
          v26 = *((_DWORD *)v14 + 6662);
          v27 = *((_DWORD *)v14 + 6663);
          v28 = v46 + 222208;
          v29 = v46 + 223744;
          *((_DWORD *)v14 + 6784) = v17;
          *((_DWORD *)v14 + 6785) = v20;
          *((_DWORD *)v14 + 6786) = v21;
          *((_DWORD *)v14 + 6787) = v22;
          *((_DWORD *)v14 + 6788) = v23;
          *((_DWORD *)v14 + 6789) = v24;
          *((_DWORD *)v14 + 6790) = v28;
          *((_DWORD *)v14 + 6791) = v25;
          *((_DWORD *)v14 + 6792) = v26;
          *((_DWORD *)v14 + 6793) = v27;
          *((_DWORD *)v14 + 6794) = 0;
          eval(v29, 0, 0, 0);
          v30 = v19;
          v31 = (const char **)(v19 + 223232);
          v32 = 0;
          v33 = 0;
          v34 = v30 + 204800;
          do
          {
            ++v32;
            v33 += sprintf(&v34[v33], "%s|", *v31++);
          }
          while ( v15 != v32 );
          *(_WORD *)&v34[v33 - 1] = 60;
          v35 = ++v50;
          strcat(v46, v34);
          if ( v35 >= v51 )
            break;
        }
        ++v13;
        v12 += 4;
      }
      while ( v49 != v13 );
    }
    v36 = v46;
    jhl_parm_set(v53 + 27940, v46);
    jhl_parm_commit(v37);
    v39 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v38);
    v40 = snprintf(v36 + 215040, 5120, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v39);
    if ( v40 < 0x1400 )
      goto LABEL_23;
  }
  else
  {
    v43 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
    v41 = snprintf(v46 + 215040, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v43);
    if ( v41 < 0x1400 )
      return httpd_cgi_ret(a1, v46 + 215040, v41, 4);
  }
  v40 = 5119;
LABEL_23:
  v41 = v40;
  return httpd_cgi_ret(a1, v46 + 215040, v41, 4);
}
// 489DD4: variable 'v4' is possibly undefined
// 48A254: variable 'v37' is possibly undefined
// 48A284: variable 'v38' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8298: using guessed type int __fastcall get_time_group(_DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0048A3F8) --------------------------------------------------------
int __fastcall sub_48A3F8(int a1)
{
  char *v1; // $v0
  int v3; // $s1
  int v4; // $v0
  char *v5; // $s0
  int v6; // $v0
  int v7; // $s1
  int v8; // $a2
  int v10; // $a1
  int v11; // $a2
  int v12; // $a0
  const char *v13; // $v0
  unsigned int v14; // $v0
  char v15[256]; // [sp+20h] [-100h] BYREF

  v1 = httpd_get_parm(a1, (char *)&off_64918C);
  if ( v1 && (v3 = J_atoi(v1), (unsigned int)(v3 - 1) < 0xFF) )
  {
    _mem_malloc(0x200000, "urlgidlist_data", 1096);
    v5 = (char *)v4;
    if ( v4 )
    {
      strcpy((char *)v4, "{\"code\":0,\"error\":\"\",\"data\":[");
      qmemcpy((void *)v4, "{\"code\":0,\"error", 16);
      *(_DWORD *)(v4 + 24) = 975331700;
      v6 = url_gid_member_get(v4 + 29, 2097123, v3);
      v7 = v6 + 29;
      if ( v6 > 0 )
        v7 = v6 - 1 + 29;
      v8 = snprintf(&v5[v7], 0x200000 - v7, "]}");
      if ( v8 >= 0x200000 - v7 )
        v8 = 0x1FFFFF - v7;
      return jhl_data_giz(a1, v5, v8 + v7, 0x200000);
    }
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = 0x200000;
    v12 = 4;
  }
  else
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = (int)&unk_649188;
    v12 = 12;
  }
  v13 = (const char *)_GET_LANG_TEXT(v12, v10, v11);
  v14 = snprintf(v15, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
  if ( v14 >= 0x100 )
    v14 = 255;
  return httpd_cgi_ret(a1, v15, v14, 4);
}
// 48A488: variable 'v4' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 64918C: using guessed type void *off_64918C;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8530: using guessed type int __fastcall url_gid_member_get(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0048A648) --------------------------------------------------------
int __fastcall sub_48A648(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  const char *v4; // $s0
  const char *v5; // $v0
  int v6; // $s3
  const char *v7; // $v0
  int v8; // $a0
  int v9; // $s1
  unsigned int v10; // $v0
  char v12[1028]; // [sp+18h] [-404h] BYREF

  v3 = httpd_get_parm(a1, "enable");
  v2 = httpd_get_parm(a1, "srv_path");
  v4 = v2;
  if ( v3 )
  {
    v5 = (const char *)nvram_get("url_update_en");
    if ( v5 && !strcmp(v5, v3) )
    {
      v6 = 0;
      if ( !v4 )
        goto LABEL_9;
    }
    else
    {
      nvram_set("url_update_en", v3);
      v6 = 1;
      if ( !v4 )
      {
LABEL_8:
        nvram_unset("url_modify_time");
        exec_service("url_update-restart");
        jhl_parm_commit(v8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v6 = 0;
    if ( !v2 )
      goto LABEL_9;
  }
  v7 = (const char *)nvram_get("url_update_path");
  if ( !v7 || strcmp(v7, v4) )
  {
    nvram_set("url_update_path", v4);
    goto LABEL_8;
  }
  if ( v6 )
    goto LABEL_8;
LABEL_9:
  strcpy(v12, "{\"code\":0,\"error\":\"\",\"data\":{");
  v9 = get_url_update_data(&v12[29]) + 29;
  v10 = snprintf(&v12[v9], 1024 - v9, "}}");
  if ( v10 >= 1024 - v9 )
    v10 = 1023 - v9;
  return httpd_cgi_ret(a1, v12, v10 + v9, 4);
}
// 48A798: variable 'v8' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0048A8B0) --------------------------------------------------------
void __fastcall read_file_buf(const char *a1, int *a2)
{
  int v4; // $s1
  int v5; // $v0
  int v6; // $s2
  struct stat v7; // [sp+8h] [-B8h] BYREF

  if ( a1 && stat(a1, &v7) >= 0 )
  {
    v4 = v7.st_atim.tv_sec + 1024;
    _mem_malloc(v7.st_atim.tv_sec + 1024, "read_file_buf", 53);
    v6 = v5;
    if ( v5 )
    {
      do_file(a1, v5, v4);
      *a2 = v6;
    }
  }
}
// 48A924: variable 'v5' is possibly undefined

//----- (0048A974) --------------------------------------------------------
int __fastcall sub_48A974(int a1)
{
  char *v1; // $v0
  int v3; // $v0
  int v4; // $a2
  void *v5; // $a2
  int v7; // $a0
  int v8; // $a1
  int v9; // $a2
  const char *v10; // $v0
  unsigned int v11; // $a2
  char v12[200]; // [sp+20h] [-D4h] BYREF
  void *v13; // [sp+E8h] [-Ch] BYREF

  v1 = httpd_get_parm(a1, "fn");
  read_file_buf(v1, (int *)&v13);
  if ( v3 >= 0 )
  {
    v5 = v13;
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    return httpd_send_mime_file(a1, "application/binary-file", v5, v3);
  }
  if ( v3 == -3 )
  {
    v8 = *(unsigned __int8 *)(a1 + 210102);
    v9 = -1;
    v7 = 4;
  }
  else
  {
    v7 = 12;
    if ( v3 == -2 )
    {
      v10 = (const char *)_GET_LANG_TEXT(38, *(unsigned __int8 *)(a1 + 210102), v4);
      goto LABEL_7;
    }
    v8 = *(unsigned __int8 *)(a1 + 210102);
    v9 = (int)"not fn";
  }
  v10 = (const char *)_GET_LANG_TEXT(v7, v8, v9);
LABEL_7:
  v11 = snprintf(v12, 200, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
  if ( v11 >= 0xC8 )
    v11 = 199;
  return httpd_cgi_ret(a1, v12, v11, 4);
}
// 48A9C4: variable 'v3' is possibly undefined
// 48AAB8: variable 'v4' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0048AAE8) --------------------------------------------------------
int __fastcall read_file_asp(int a1, int a2, const char *a3)
{
  const char *v4; // $s1
  int v5; // $v0
  int v6; // $a2
  void *v7; // $a2
  int v9; // $a0
  int v10; // $a1
  int v11; // $a2
  const char *v12; // $v0
  unsigned int v13; // $a2
  char v14[200]; // [sp+20h] [-D4h] BYREF
  void *v15; // [sp+E8h] [-Ch] BYREF

  if ( a3 )
    v4 = a3;
  else
    v4 = "application/binary-file";
  read_file_buf((const char *)a2, (int *)&v15);
  if ( v5 >= 0 )
  {
    v7 = v15;
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    return httpd_send_mime_file(a1, v4, v7, v5);
  }
  if ( v5 == -3 )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = -1;
    v9 = 4;
  }
  else
  {
    v9 = 12;
    if ( v5 == -2 )
    {
      v12 = (const char *)_GET_LANG_TEXT(38, *(unsigned __int8 *)(a1 + 210102), v6);
      goto LABEL_9;
    }
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = (int)"not fn";
  }
  v12 = (const char *)_GET_LANG_TEXT(v9, v10, v11);
LABEL_9:
  v13 = snprintf(v14, 200, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v12);
  if ( v13 >= 0xC8 )
    v13 = 199;
  return httpd_cgi_ret(a1, v14, v13, 4);
}
// 48AB2C: variable 'v5' is possibly undefined
// 48AC2C: variable 'v6' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0048AC5C) --------------------------------------------------------
int __fastcall sub_48AC5C(int a1, int a2, int a3)
{
  int v3; // $s0
  int v4; // $s3
  char *v7; // $v0
  char *v9; // $v0
  char *v10; // $s2
  int v11; // $a2
  const char *v12; // $a2
  const char *v13; // $v0
  unsigned int v14; // $v0
  const char *v16; // $v0
  unsigned int v17; // $a2
  char v18[1028]; // [sp+20h] [-404h] BYREF

  v3 = a1 + 196608;
  v4 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( !v7 || (v10 = v7, (v9 = find_file_end(a1, v7, *(_DWORD *)(v3 + 8956) + v4 - (_DWORD)v7)) == 0) )
  {
    v12 = "Error reading file";
    goto LABEL_6;
  }
  if ( v9 - v10 != f_write(a2, v10, v9 - v10, 0, a3) )
  {
    v12 = "Error writing temporary file";
LABEL_6:
    v13 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v12);
    v14 = snprintf(v18, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
    if ( v14 >= 0x400 )
      v14 = 1023;
    httpd_cgi_ret(a1, v18, v14, 4);
    return -1;
  }
  v16 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(v3 + 13494), v11);
  v17 = snprintf(v18, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v16);
  if ( v17 >= 0x400 )
    v17 = 1023;
  httpd_cgi_ret(a1, v18, v17, 4);
  return 0;
}
// 48ACB8: variable 'v7' is possibly undefined
// 48ADC8: variable 'v11' is possibly undefined
// 6A8204: using guessed type int __fastcall f_write(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0048AE28) --------------------------------------------------------
int __fastcall sub_48AE28(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $s1
  int v5; // $s1
  int v6; // $v0
  int v7; // $a2
  int result; // $v0
  const char *v9; // $v0
  unsigned int v10; // $v0
  char v11[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(102400, "vpn_data", 218);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v4 = get_nvarms((const char **)pptp_parms, v2 + 29, 102371) + 29;
    v5 = v4 + get_nvarms((const char **)l2tp_parms, (int)&v3[v4], 102400 - v4) - 1;
    v6 = snprintf(&v3[v5], 102400 - v5, "}}");
    if ( v6 >= 102400 - v5 )
      v7 = 102399 - v5;
    else
      v7 = v6;
    result = httpd_cgi_ret(a1, v3, v7 + v5, 8);
  }
  else
  {
    v9 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v10 = snprintf(v11, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 >= 0x100 )
      v10 = 255;
    result = httpd_cgi_ret(a1, v11, v10, 4);
  }
  return result;
}
// 48AE7C: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 672EF4: using guessed type char *l2tp_parms[6];
// 672F14: using guessed type char *pptp_parms[8];
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0048B02C) --------------------------------------------------------
int __fastcall sub_48B02C(int a1)
{
  char *v2; // $a1
  int v3; // $a0
  char *v4; // $v1
  const char *v5; // $v0
  int v6; // $t1
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  char v11[256]; // [sp+18h] [-100h] BYREF

  v2 = httpd_get_parm(a1, "debug");
  if ( !v2 )
  {
    if ( jhl_web_save_parms(a1, pptp_parms, 1) )
    {
      jhl_stop_pptpd_srv();
      jhl_start_pptpd_srv();
      if ( !jhl_web_save_parms(a1, l2tp_parms, 1) )
        goto LABEL_9;
    }
    else if ( !jhl_web_save_parms(a1, l2tp_parms, 1) )
    {
      goto LABEL_3;
    }
    jhl_stop_l2tpd_srv();
    jhl_start_l2tpd_srv();
LABEL_9:
    jhl_setwanxx();
    goto LABEL_3;
  }
  nvram_set("debug_pppd", v2);
LABEL_3:
  jhl_parm_commit(v3);
  v4 = v11;
  v5 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v6 = *(_DWORD *)v5;
    v7 = *((_DWORD *)v5 + 1);
    v8 = *((_DWORD *)v5 + 2);
    v9 = *((_DWORD *)v5 + 3);
    v5 += 16;
    *(_DWORD *)v4 = v6;
    *((_DWORD *)v4 + 1) = v7;
    *((_DWORD *)v4 + 2) = v8;
    *((_DWORD *)v4 + 3) = v9;
    v4 += 16;
  }
  while ( v5 != "}" );
  *(_WORD *)v4 = *(_WORD *)v5;
  return httpd_cgi_ret(a1, v11, 33, 4);
}
// 48B08C: variable 'v3' is possibly undefined
// 672EF4: using guessed type char *l2tp_parms[6];
// 672F14: using guessed type char *pptp_parms[8];
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81A8: using guessed type int jhl_start_pptpd_srv(void);
// 6A81F0: using guessed type int jhl_stop_l2tpd_srv(void);
// 6A8210: using guessed type int jhl_start_l2tpd_srv(void);
// 6A82B8: using guessed type int jhl_setwanxx(void);
// 6A85E8: using guessed type int jhl_stop_pptpd_srv(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0048B1E0) --------------------------------------------------------
int __fastcall mask_addr_to_inet(const char *a1)
{
  uint32_t v1; // $v0
  int v2; // $a0
  int v3; // $v1
  uint32_t hostlong[3]; // [sp+18h] [-Ch] BYREF

  inet_aton(a1, (struct in_addr *)hostlong);
  v1 = htonl(hostlong[0]);
  v2 = 0;
  if ( (v1 & 1) != 0 )
    return 32;
  v3 = 1;
  do
  {
    v3 *= 2;
    ++v2;
  }
  while ( (v3 & v1) == 0 );
  return 32 - v2;
}

//----- (0048B25C) --------------------------------------------------------
int __fastcall ipsec_road_data(int a1)
{
  int v1; // $v0
  const char *v2; // $fp
  const char *v3; // $s0
  const char *v4; // $s1
  const char *v5; // $s2
  const char *v6; // $s3
  const char *v7; // $s4
  const char *v8; // $s5
  const char *v9; // $s6
  const char *v10; // $s7
  const char *v11; // $v1
  const char *v12; // $v0
  int v13; // $s1
  unsigned int v14; // $v0
  char v16[1024]; // [sp+58h] [-420h] BYREF
  char *v17; // [sp+458h] [-20h]
  char *v18; // [sp+45Ch] [-1Ch]
  const char *v19; // [sp+460h] [-18h]
  char *v20; // [sp+464h] [-14h]
  char *v21; // [sp+468h] [-10h]
  const char *v22; // [sp+46Ch] [-Ch]
  const char *v23; // [sp+470h] [-8h]

  strcpy(v16, "{\"code\":0,\"error\":\"\",\"data\":{");
  v1 = nvram_get("ipsec_road_enable");
  if ( v1 )
    v2 = (const char *)v1;
  else
    v2 = "0";
  v17 = (char *)nvram_get("ipsec_road_host_ip");
  if ( !v17 )
    v17 = "";
  v18 = (char *)nvram_get("ipsec_road_host_mask");
  if ( !v18 )
    v18 = "";
  v19 = (const char *)nvram_get("ipsec_road_ike_type");
  if ( !v19 )
    v19 = "psk";
  v20 = (char *)nvram_get("ipsec_road_psk_key");
  if ( !v20 )
    v20 = "";
  v21 = (char *)nvram_get("ipsec_road_ike_dh_group");
  if ( !v21 )
    v21 = "2";
  v22 = (const char *)nvram_get("ipsec_road_ike_encrypt");
  if ( !v22 )
    v22 = "3des";
  v3 = (const char *)nvram_get("ipsec_road_ike_auth");
  if ( !v3 )
    v3 = "md5";
  v4 = (const char *)nvram_get("ipsec_road_ike_lifetime");
  if ( !v4 )
    v4 = "3600";
  v5 = (const char *)nvram_get("ipsec_road_ike_pfs_group");
  if ( !v5 )
    v5 = "2";
  v6 = (const char *)nvram_get("ipsec_road_ipsec_encrypt");
  if ( !v6 )
    v6 = "3des";
  v7 = (const char *)nvram_get("ipsec_road_ipsec_auth");
  if ( !v7 )
    v7 = "md5";
  v8 = (const char *)nvram_get("ipsec_road_ipsec_lifetime");
  if ( !v8 )
    v8 = "3600";
  v9 = (const char *)nvram_get("ipsec_road_ip_compress");
  if ( !v9 )
    v9 = "1";
  v10 = (const char *)nvram_get("ipsec_road_ike_pfs");
  if ( !v10 )
    v10 = "1";
  v11 = (const char *)nvram_get("ipsec_road_dpd_time");
  if ( !v11 )
    v11 = "20";
  v23 = v11;
  v12 = (const char *)nvram_get("ipsec_road_dpd_latertime");
  if ( !v12 )
    v12 = "60";
  v13 = sprintf(
          &v16[29],
          "\"enable\":%s,\"host_ip\":\"%s\",\"host_mask\":\"%s\",\"ike_type\":\"%s\",\"psk_key\":\"%s\",\"ike_dh_group\":"
          "%s,\"ike_encrypt\":\"%s\",\"ike_auth\":\"%s\",\"ike_lifetime\":%s,\"ike_pfs_group\":%s,\"ipsec_encrypt\":\"%s\""
          ",\"ipsec_auth\":\"%s\",\"ipsec_lifetime\":\"%s\",\"ip_compress\":%s,\"ike_pfs\":%s,\"dpd_time\":%s,\"dpd_latertime\":%s",
          v2,
          v17,
          v18,
          v19,
          v20,
          v21,
          v22,
          v3,
          v4,
          v5,
          v6,
          v7,
          v8,
          v9,
          v10,
          v23,
          v12)
      + 29;
  v14 = snprintf(&v16[v13], 1024 - v13, "}}");
  if ( v14 >= 1024 - v13 )
    v14 = 1023 - v13;
  return httpd_cgi_ret(a1, v16, v14 + v13, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (0048B714) --------------------------------------------------------
int __fastcall sub_48B714(int a1)
{
  char *v2; // $s4
  char *v3; // $s3
  char *v4; // $s2
  char *v5; // $fp
  char *v6; // $s7
  char *v7; // $s6
  int v8; // $v0
  char *v9; // $s5
  int v10; // $a0
  const char *v12; // $v0
  int v13[8]; // [sp+18h] [-48h] BYREF
  char *v14; // [sp+38h] [-28h]
  char *v15; // [sp+3Ch] [-24h]
  char *v16; // [sp+40h] [-20h]
  char *v17; // [sp+44h] [-1Ch]
  char *v18; // [sp+48h] [-18h]
  char *v19; // [sp+4Ch] [-14h]
  char *v20; // [sp+50h] [-10h]
  char *v21; // [sp+54h] [-Ch]
  char *v22; // [sp+58h] [-8h]
  char *v23; // [sp+5Ch] [-4h]

  v13[0] = 0;
  v13[1] = 0;
  v13[2] = 0;
  v13[3] = 0;
  v13[4] = 0;
  v13[5] = 0;
  v13[6] = 0;
  v13[7] = 0;
  v2 = httpd_get_parm(a1, "host_ip");
  v3 = httpd_get_parm(a1, "host_mask");
  v23 = httpd_get_parm(a1, "ike_type");
  v22 = httpd_get_parm(a1, "psk_key");
  v4 = httpd_get_parm(a1, "enable");
  v21 = httpd_get_parm(a1, "ike_dh_group");
  v20 = httpd_get_parm(a1, "ike_encrypt");
  v19 = httpd_get_parm(a1, "ike_auth");
  v18 = httpd_get_parm(a1, "ike_lifetime");
  v17 = httpd_get_parm(a1, "ike_pfs_group");
  v16 = httpd_get_parm(a1, "ipsec_encrypt");
  v15 = httpd_get_parm(a1, "ipsec_auth");
  v14 = httpd_get_parm(a1, "ipsec_lifetime");
  v5 = httpd_get_parm(a1, "ip_compress");
  v6 = httpd_get_parm(a1, "ike_pfs");
  v7 = httpd_get_parm(a1, "dpd_time");
  v9 = httpd_get_parm(a1, "dpd_latertime");
  v8 = mask_addr_to_inet(v3);
  sprintf((char *)v13, "%s/%d", v2, v8);
  nvram_set("ipsec_road_enable", v4);
  nvram_set("ipsec_road_host_ip", v2);
  nvram_set("ipsec_road_host_mask", v3);
  nvram_set("ipsec_road_host_ip_mask", v13);
  nvram_set("ipsec_road_ike_type", v23);
  nvram_set("ipsec_road_psk_key", v22);
  nvram_set("ipsec_road_ike_dh_group", v21);
  nvram_set("ipsec_road_ike_encrypt", v20);
  nvram_set("ipsec_road_ike_auth", v19);
  nvram_set("ipsec_road_ike_lifetime", v18);
  nvram_set("ipsec_road_ike_pfs_group", v17);
  nvram_set("ipsec_road_ipsec_encrypt", v16);
  nvram_set("ipsec_road_ipsec_auth", v15);
  nvram_set("ipsec_road_ipsec_lifetime", v14);
  nvram_set("ipsec_road_ip_compress", v5);
  nvram_set("ipsec_road_ike_pfs", v6);
  nvram_set("ipsec_road_dpd_time", v7);
  nvram_set("ipsec_road_dpd_latertime", v9);
  if ( !strcmp(v4, "1") )
  {
    nvram_set("ipsec_mode", "road");
    nvram_set("ipsec_l2tp_enable", "0");
    nvram_set("ipsec_net_enable", "0");
    nvram_set("ipsec_l2tp_cli_enable", "0");
LABEL_3:
    jhl_parm_commit(v10);
    schedule_ipsec(1, 0);
    return ipsec_road_data(a1);
  }
  v12 = (const char *)nvram_get("ipsec_mode");
  if ( v12 && !strcmp(v12, "road") )
  {
    nvram_set("ipsec_mode", "none");
    goto LABEL_3;
  }
  return ipsec_road_data(a1);
}
// 48BC20: variable 'v10' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8724: using guessed type int __fastcall schedule_ipsec(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0048BCE8) --------------------------------------------------------
int __fastcall sub_48BCE8(int a1)
{
  int v2; // $v0
  const char *v3; // $s7
  const char *v4; // $s0
  const char *v5; // $s1
  const char *v6; // $s3
  const char *v7; // $s4
  const char *v8; // $s5
  const char *v9; // $s6
  const char *v10; // $v0
  int v11; // $s1
  unsigned int v12; // $v0
  char v14[1028]; // [sp+30h] [-404h] BYREF

  strcpy(v14, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = nvram_get("ipsec_l2tp_enable");
  if ( v2 )
    v3 = (const char *)v2;
  else
    v3 = "0";
  v4 = (const char *)nvram_get("ipsec_l2tp_max");
  if ( !v4 )
    v4 = " ";
  v5 = (const char *)nvram_get("ipsec_l2tp_psk_key");
  if ( !v5 )
    v5 = " ";
  v6 = (const char *)nvram_get("l2tpd_stip");
  if ( !v6 )
    v6 = " ";
  v7 = (const char *)nvram_get("l2tpd_endip");
  if ( !v7 )
    v7 = " ";
  v8 = (const char *)nvram_get("l2tpd_port");
  if ( !v8 )
    v8 = "1701";
  v9 = (const char *)nvram_get("l2tpd_dns1");
  if ( v9 )
  {
    v10 = (const char *)nvram_get("l2tpd_dns2");
    if ( v10 )
      goto LABEL_15;
  }
  else
  {
    v10 = (const char *)nvram_get("l2tpd_dns2");
    v9 = " ";
    if ( v10 )
      goto LABEL_15;
  }
  v10 = " ";
LABEL_15:
  v11 = sprintf(
          &v14[29],
          "\"enable\":%s,\"max\":%s,\"psk_key\":\"%s\",\"start_ip\":\"%s\",\"end_ip\":%s,\"port\":%s,\"dns1\":\"%s\",\"dns2\":\"%s\"",
          v3,
          v4,
          v5,
          v6,
          v7,
          v8,
          v9,
          v10)
      + 29;
  v12 = snprintf(&v14[v11], 1024 - v11, "}}");
  if ( v12 >= 1024 - v11 )
    v12 = 1023 - v11;
  return httpd_cgi_ret(a1, v14, v12 + v11, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (0048BF9C) --------------------------------------------------------
int __fastcall sub_48BF9C(int a1)
{
  char *v1; // $v0
  char *v3; // $s1
  char *v4; // $s2
  char *v5; // $fp
  char *v6; // $s7
  char *v7; // $s6
  char *v8; // $s5
  int v9; // $a0
  char *v10; // $v1
  const char *v11; // $v0
  int v12; // $t0
  int v13; // $a3
  int v14; // $a2
  int v15; // $a1
  unsigned int v16; // $a2
  const char *v17; // $v0
  const char *v19; // $v0
  char v20[1024]; // [sp+20h] [-408h] BYREF
  char *v21; // [sp+420h] [-8h]

  v1 = httpd_get_parm(a1, "opt");
  if ( v1 && !strcmp(v1, "enable") )
  {
    v3 = httpd_get_parm(a1, "enable");
    v4 = httpd_get_parm(a1, "psk_key");
    v21 = httpd_get_parm(a1, "start_ip");
    v5 = httpd_get_parm(a1, "end_ip");
    v6 = httpd_get_parm(a1, "port");
    v7 = httpd_get_parm(a1, "dns1");
    v8 = httpd_get_parm(a1, "dns2");
    nvram_set("ipsec_l2tp_enable", v3);
    nvram_set("ipsec_l2tp_psk_key", v4);
    nvram_set("ipsec_mode", "l2tp");
    nvram_set("ipsec_road_enable", "0");
    nvram_set("ipsec_net_enable", "0");
    nvram_set("ipsec_l2tp_cli_enable", "0");
    nvram_set("l2tpd_en", v3);
    nvram_set("l2tpd_stip", v21);
    nvram_set("l2tpd_endip", v5);
    nvram_set("l2tpd_port", v6);
    nvram_set("l2tpd_dns1", v7);
    nvram_set("l2tpd_dns2", v8);
    jhl_stop_l2tpd_srv();
    if ( !strcmp(v3, "1") )
    {
      jhl_vpnclient_stop(0);
      jhl_start_l2tpd_srv();
    }
    else
    {
      v19 = (const char *)nvram_get("ipsec_mode");
      if ( v19 && !strcmp(v19, "l2tp") )
        nvram_set("ipsec_mode", "none");
    }
    jhl_setwanxx();
    jhl_parm_commit(v9);
    schedule_ipsec(1, 0);
    v10 = v20;
    v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v12 = *(_DWORD *)v11;
      v13 = *((_DWORD *)v11 + 1);
      v14 = *((_DWORD *)v11 + 2);
      v15 = *((_DWORD *)v11 + 3);
      v11 += 16;
      *(_DWORD *)v10 = v12;
      *((_DWORD *)v10 + 1) = v13;
      *((_DWORD *)v10 + 2) = v14;
      *((_DWORD *)v10 + 3) = v15;
      v10 += 16;
    }
    while ( v11 != "}" );
    v16 = 33;
    *(_WORD *)v10 = *(_WORD *)v11;
  }
  else
  {
    v17 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    v16 = snprintf(v20, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
    if ( v16 >= 0x400 )
      v16 = 1023;
  }
  return httpd_cgi_ret(a1, v20, v16, 4);
}
// 48C2B4: variable 'v9' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81F0: using guessed type int jhl_stop_l2tpd_srv(void);
// 6A8210: using guessed type int jhl_start_l2tpd_srv(void);
// 6A82B8: using guessed type int jhl_setwanxx(void);
// 6A82F0: using guessed type int __fastcall jhl_vpnclient_stop(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8724: using guessed type int __fastcall schedule_ipsec(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0048C424) --------------------------------------------------------
void __fastcall format_ipsec_net_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 30 )
    snprintf(
      a3,
      a4,
      "{\"name\":\"%s\",\"auto\":\"%s\",\"wans\":\"%s\",\"host_ip\":\"%s\",\"host_mask\":\"%s\",\"ipsec_ip\":\"%s\",\"rem"
      "ot_ip\":\"%s\",\"remot_mask\":\"%s\",\"ike_type\":\"%s\",\"psk_key\":\"%s\",\"host_ip_mask\":\"%s\",\"remot_ip_mas"
      "k\":\"%s\",\"ike_dh_group\":\"%s\",\"ike_encrypt\":\"%s\",\"ike_auth\":\"%s\",\"ike_lifetime\":\"%s\",\"ike_pfs_gr"
      "oup\":\"%s\",\"ipsec_encrypt\":\"%s\",\"ipsec_auth\":\"%s\",\"ipsec_lifetime\":\"%s\",\"ip_compress\":\"%s\",\"ike"
      "_pfs\":\"%s\",\"dpd_time\":\"%s\",\"dpd_latertime\":\"%s\",\"exchange_mode\":\"%s\",\"ping_en\":\"%s\",\"local_ide"
      "nt\":\"%s\",\"local_ident_type\":\"%s\",\"remot_ident\":\"%s\",\"remot_ident_type\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7],
      a1[8],
      a1[9],
      a1[10],
      a1[11],
      a1[12],
      a1[13],
      a1[14],
      a1[15],
      a1[16],
      a1[17],
      a1[18],
      a1[19],
      a1[20],
      a1[21],
      a1[22],
      a1[23],
      a1[24],
      a1[25],
      a1[26],
      a1[27],
      a1[28],
      a1[29]);
}

//----- (0048C594) --------------------------------------------------------
int __fastcall sub_48C594(int a1)
{
  char *v1; // $v0
  int v2; // $s3
  char *v3; // $s0
  const char *v4; // $v0
  int v5; // $v0
  char *v6; // $v1
  int v7; // $fp
  char *v8; // $s6
  int v9; // $s2
  char *v10; // $s5
  int v11; // $s1
  const char **v12; // $s4
  void *v13; // $v0
  void *v14; // $s7
  char *v15; // $s6
  const char *i; // $s7
  int v17; // $v0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $s2
  int v21; // $v0
  int v22; // $s1
  int v23; // $s1
  int v24; // $s2
  int v25; // $v0
  char *v26; // $s4
  int v27; // $v0
  const char *v28; // $v0
  int v29; // $v0
  const char *v30; // $s7
  int v31; // $s1
  int v32; // $s1
  char *v33; // $v0
  char *v34; // $v0
  int v35; // $s1
  int v36; // $v0
  int v37; // $a2
  int result; // $v0
  const char *v39; // $v0
  const char *v40; // $v0
  unsigned int v41; // $a2
  char v42[256]; // [sp+20h] [-110h] BYREF
  const char *v43; // [sp+120h] [-10h]
  char *format; // [sp+124h] [-Ch]
  void *ptr; // [sp+128h] [-8h]
  char *v46; // [sp+12Ch] [-4h]

  v2 = sq_file_get_max_wan();
  _mem_malloc(77824, "ipsec_net_data", 561);
  v3 = v1;
  if ( v1 )
  {
    strcpy(v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v1, "{\"code\":0,\"error", 16);
    v4 = (const char *)nvram_get("ipsec_net_enable");
    if ( !v4 )
      v4 = "0";
    v5 = sprintf(v3 + 29, "\"enable\":%s", v4);
    v6 = &v3[v5 + 29];
    strcpy(v6, ",\"all\":");
    *(_DWORD *)v6 = *(_DWORD *)",\"all\":";
    v7 = v5 + 36;
    v8 = (char *)nvram_get("ipsec_net_users");
    if ( !v8 )
      v8 = " ";
    v9 = 77824 - v7;
    v10 = &v3[v7];
    v11 = snprintf(&v3[v7], 77824 - v7, (char *)&word_642A04);
    if ( v11 >= 77824 - v7 )
      v11 = 77823 - v7;
    v12 = (const char **)malloc(0x80u);
    format = (char *)malloc(0x4008u);
    v13 = malloc(0x200000u);
    ptr = v13;
    if ( v13 )
    {
      if ( v12 )
      {
        if ( format )
        {
          v14 = v13;
          strlcpy(v13, v8, 0x200000);
          v15 = format;
          v43 = (const char *)split_string(v14, 60, format, 4096);
          if ( (int)v43 > 0 )
          {
            for ( i = 0; i != v43; ++i )
            {
              v17 = split_string(*(_DWORD *)v15, 124, v12, 30);
              format_ipsec_net_data(v12, v17, &v10[v11], v9 - v11);
              v11 += v18;
              v15 += 4;
            }
          }
        }
      }
      free(ptr);
    }
    if ( v12 )
      free(v12);
    if ( format )
      free(format);
    v19 = &v10[v11];
    if ( v11 > 0 && *(v19 - 1) == 44 )
      v19 = &v10[--v11];
    v20 = v9 - v11;
    *v19 = 0;
    v21 = snprintf(v19, v20, &byte_6445A0);
    if ( v21 >= v20 )
      v21 = v20 - 1;
    v22 = v11 + v21 + v7;
    strcpy(&v3[v22], ",\"wans\":[ ");
    *(_DWORD *)&v3[v22] = 1635197484;
    v23 = v22 + 10;
    if ( v2 > 0 )
    {
      ptr = "1\"";
      v43 = "wan_proto";
      v24 = 0;
      format = "{\"iface\":%d,\"wan_ifname\":\"%s\"";
      do
      {
        while ( 1 )
        {
          v25 = jhl_nvget("wan_ifname", v24);
          v26 = (char *)nvram_get(v25);
          if ( !v26 )
            v26 = "";
          if ( !*v26 )
            goto LABEL_39;
          v27 = jhl_nvget("wan_down", v24);
          v28 = (const char *)nvram_get(v27);
          if ( (!v28 || strcmp(v28, "1")) && !jhl_iface_link_up_check(v26, v24) )
            break;
          ++v24;
LABEL_27:
          if ( v2 == v24 )
            goto LABEL_39;
        }
        v29 = jhl_nvget(v43, v24);
        v30 = (const char *)nvram_get(v29);
        if ( v30 )
        {
          v46 = "a";
          if ( !strcmp("3G", v30) )
          {
            v39 = (const char *)nvram_get("wan_3g_enable");
            if ( v39 )
            {
              if ( !strcmp(v39, "disable") )
              {
                ++v24;
                goto LABEL_27;
              }
            }
          }
          if ( !strncmp(v30, v46 + 12644, 2u) )
            v30 = "4G";
        }
        else
        {
          v30 = "";
        }
        v31 = sprintf(&v3[v23], format, v24, v26) + v23;
        v32 = v31 + sprintf(&v3[v31], (char *)ptr - 20260, v30);
        v33 = &v3[v32];
        ++v24;
        *v33 = 125;
        *(_WORD *)(v33 + 1) = 44;
        v23 = v32 + 2;
      }
      while ( v2 != v24 );
    }
LABEL_39:
    v34 = &v3[v23];
    if ( v23 > 0 && *(v34 - 1) == 44 )
      v34 = &v3[--v23];
    v35 = v23 + 1;
    *(_WORD *)v34 = 93;
    v36 = snprintf(&v3[v35], 77824 - v35, "}}");
    if ( v36 >= 77824 - v35 )
      v37 = 77823 - v35;
    else
      v37 = v36;
    result = httpd_cgi_ret(a1, v3, v37 + v35, 8);
  }
  else
  {
    v40 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 77824);
    v41 = snprintf(v42, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v40);
    if ( v41 >= 0x100 )
      v41 = 255;
    result = httpd_cgi_ret(a1, v42, v41, 4);
  }
  return result;
}
// 48C60C: variable 'v1' is possibly undefined
// 48C814: variable 'v18' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (0048CCBC) --------------------------------------------------------
int __fastcall sub_48CCBC(int a1)
{
  char *v2; // $s2
  char *v3; // $s4
  char *v4; // $s7
  char *v5; // $s5
  int v6; // $s3
  _BYTE *v7; // $v0
  _BYTE *v8; // $s1
  _DWORD *v9; // $s5
  int v10; // $v0
  int v11; // $a0
  char *v12; // $v1
  const char *v13; // $v0
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  int v18; // $s6
  int v20; // $a1
  const char *v21; // $a2
  const char *v22; // $v0
  bool v23; // dc
  char *v24; // $v0
  int v25; // $v0
  const char *v26; // $a2
  int v27; // $v0
  char *v28; // $v0
  const char *v29; // $v0
  const char *v30; // $v0
  const char *v31; // $v0
  unsigned int v32; // $v0
  char s[1024]; // [sp+28h] [-618h] BYREF
  int v34[64]; // [sp+428h] [-218h] BYREF
  int v35[25]; // [sp+528h] [-118h] BYREF
  char *v36; // [sp+58Ch] [-B4h]
  char *v37; // [sp+590h] [-B0h]
  char *v38; // [sp+594h] [-ACh]
  char *v39; // [sp+598h] [-A8h]
  char *v40; // [sp+59Ch] [-A4h]
  int v41[9]; // [sp+5A8h] [-98h] BYREF
  char *v42; // [sp+5CCh] [-74h]
  char *v43; // [sp+5D0h] [-70h]
  char *v44; // [sp+5D4h] [-6Ch]
  char *v45; // [sp+5D8h] [-68h]
  char *v46; // [sp+5DCh] [-64h]
  char *v47; // [sp+5E0h] [-60h]
  char *v48; // [sp+5E4h] [-5Ch]
  char *v49; // [sp+5E8h] [-58h]
  char *v50; // [sp+5ECh] [-54h]
  char *v51; // [sp+5F0h] [-50h]
  char *v52; // [sp+5F4h] [-4Ch]
  char *v53; // [sp+5F8h] [-48h]
  char *v54; // [sp+5FCh] [-44h]
  char *v55; // [sp+600h] [-40h]
  char *v56; // [sp+604h] [-3Ch]
  char *v57; // [sp+608h] [-38h]
  char *v58; // [sp+60Ch] [-34h]
  char *v59; // [sp+610h] [-30h]
  char *v60; // [sp+614h] [-2Ch]
  char *v61; // [sp+618h] [-28h]
  char *v62; // [sp+61Ch] [-24h]
  char *v63; // [sp+620h] [-20h]
  char *v64; // [sp+624h] [-1Ch]
  char *v65; // [sp+628h] [-18h]
  char *v66; // [sp+62Ch] [-14h]
  char *v67; // [sp+630h] [-10h]
  char *v68; // [sp+634h] [-Ch]
  char *v69; // [sp+638h] [-8h]
  const char *v70; // [sp+63Ch] [-4h]

  v2 = httpd_get_parm(a1, "opt");
  v3 = httpd_get_parm(a1, "name");
  v47 = httpd_get_parm(a1, "old_name");
  v53 = httpd_get_parm(a1, "auto");
  v54 = httpd_get_parm(a1, "wans");
  v42 = httpd_get_parm(a1, "host_ip");
  v43 = httpd_get_parm(a1, "host_mask");
  v4 = httpd_get_parm(a1, "ipsec_ip");
  v44 = httpd_get_parm(a1, "remot_ip");
  v45 = httpd_get_parm(a1, "remot_mask");
  v55 = httpd_get_parm(a1, "ike_type");
  v56 = httpd_get_parm(a1, "psk_key");
  v5 = httpd_get_parm(a1, "enable");
  v57 = httpd_get_parm(a1, "ike_dh_group");
  v58 = httpd_get_parm(a1, "ike_encrypt");
  v59 = httpd_get_parm(a1, "ike_auth");
  v60 = httpd_get_parm(a1, "ike_lifetime");
  v61 = httpd_get_parm(a1, "ike_pfs_group");
  v62 = httpd_get_parm(a1, "ipsec_encrypt");
  v63 = httpd_get_parm(a1, "ipsec_auth");
  v64 = httpd_get_parm(a1, "ipsec_lifetime");
  v65 = httpd_get_parm(a1, "ip_compress");
  v66 = httpd_get_parm(a1, "ike_pfs");
  v67 = httpd_get_parm(a1, "dpd_time");
  v68 = httpd_get_parm(a1, "dpd_latertime");
  v69 = httpd_get_parm(a1, "exchange_mode");
  v6 = httpd_get_json_parm(a1, (int)"del_list");
  v48 = httpd_get_parm(a1, "remot_ident");
  v49 = httpd_get_parm(a1, "remot_ident_type");
  v50 = httpd_get_parm(a1, "local_ident");
  v51 = httpd_get_parm(a1, "local_ident_type");
  if ( !v48 || !v50 )
  {
    v51 = "";
    v49 = "";
    v50 = "0";
    v48 = "0";
  }
  v41[8] = (int)"1\"";
  v52 = httpd_get_parm(a1, "ping_en");
  _mem_malloc(76800, "ipsec_net_asp", 689);
  v8 = v7;
  if ( v7 )
  {
    if ( v2 )
    {
      v46 = "a";
      if ( !strcmp(v2, (const char *)&off_646D8C) || !strcmp(v2, (const char *)&off_648DDC) || !strcmp(v2, "del") )
      {
        if ( !v4 || *v4 )
        {
          if ( strcmp(v2, "enable") )
          {
LABEL_13:
            if ( !strcmp(v2, "del") )
            {
              if ( v6 )
              {
                v9 = *(_DWORD **)(v6 + 8);
                if ( v9 )
                {
                  if ( v9[4] )
                  {
                    v70 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
                    do
                    {
                      *(_WORD *)v8 = 32;
                      v10 = nvram_get("ipsec_net_users");
                      if ( !v10 )
                        v10 = (int)(v70 - 1556);
                      if ( strdb_del(v10) == 1 )
                        nvram_set("ipsec_net_users", v8);
                      v3 = (char *)v9[4];
                      v9 = (_DWORD *)*v9;
                    }
                    while ( v9 && v9[4] );
                  }
                }
              }
            }
            if ( strcmp(v2, (const char *)&off_648DDC) && strcmp(v2, v46 + 28044) )
              goto LABEL_30;
            *v8 = 32;
            v23 = v47 == 0;
            v8[1] = 0;
            if ( !v23 )
            {
              v24 = (char *)nvram_get("ipsec_net_users");
              if ( !v24 )
                v24 = "";
              goto LABEL_42;
            }
            if ( v3 )
            {
              v24 = (char *)nvram_get("ipsec_net_users");
              if ( !v24 )
                v24 = "";
LABEL_42:
              if ( strdb_del(v24) == 1 )
                nvram_set("ipsec_net_users", v8);
              if ( !strcmp(v2, v46 + 28044) )
              {
                v18 = check_rule_num_limit(a1, 20, (int)"ipsec_net_users", 60, s, 0x400u);
                if ( v18 > 0 )
                {
LABEL_35:
                  _mem_free(v8);
                  return httpd_cgi_ret(a1, s, v18, 4);
                }
              }
              else if ( strcmp(v2, (const char *)&off_648DDC) )
              {
LABEL_30:
                jhl_parm_commit(v11);
                if ( !strcmp(v2, "enable") )
                {
                  schedule_ipsec(1, 0);
                }
                else
                {
                  v29 = (const char *)nvram_get("ipsec_mode");
                  if ( v29 && !strcmp(v29, "net") )
                  {
                    snprintf((char *)v34, 256, "%s|%s<", v2, v3);
                    schedule_ipsec(0, v34);
                  }
                }
                goto LABEL_32;
              }
              v35[0] = (int)v3;
              v35[1] = (int)v53;
              v35[5] = (int)v4;
              v35[2] = (int)v54;
              v35[3] = (int)v42;
              v35[4] = (int)v43;
              v35[6] = (int)v44;
              v35[7] = (int)v45;
              v35[8] = (int)v55;
              v35[9] = (int)v56;
              v35[12] = (int)v57;
              v35[13] = (int)v58;
              v35[14] = (int)v59;
              v35[15] = (int)v60;
              v35[16] = (int)v61;
              v35[17] = (int)v62;
              v35[18] = (int)v63;
              v35[19] = (int)v64;
              v35[20] = (int)v65;
              v35[21] = (int)v66;
              v35[22] = (int)v67;
              v35[23] = (int)v68;
              v35[24] = (int)v69;
              v39 = v48;
              v40 = v49;
              v37 = v50;
              v38 = v51;
              if ( v52 )
                v36 = v52;
              else
                v36 = "0";
              v25 = mask_addr_to_inet(v43);
              v26 = v42;
              v42 = (char *)v41;
              v41[0] = 0;
              v41[1] = 0;
              v41[2] = 0;
              v41[3] = 0;
              v41[4] = 0;
              v41[5] = 0;
              v41[6] = 0;
              v41[7] = 0;
              v34[0] = 0;
              v34[1] = 0;
              v34[2] = 0;
              v34[3] = 0;
              v34[4] = 0;
              v34[5] = 0;
              v34[6] = 0;
              v34[7] = 0;
              sprintf((char *)v41, "%s/%d", v26, v25);
              v27 = mask_addr_to_inet(v45);
              sprintf((char *)v34, "%s/%d", v44, v27);
              v35[10] = (int)v42;
              v35[11] = (int)v34;
              v28 = (char *)nvram_get("ipsec_net_users");
              if ( !v28 )
                v28 = "";
              if ( strdb_add(v28, v8, v35, 30, 60, 124) > 0 )
                nvram_set("ipsec_net_users", v8);
              goto LABEL_30;
            }
            v20 = *(unsigned __int8 *)(a1 + 210102);
            v21 = (const char *)&unk_6442E4;
LABEL_37:
            v22 = (const char *)_GET_LANG_TEXT(12, v20, v21);
            v18 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v22);
            if ( (unsigned int)v18 >= 0x400 )
              v18 = 1023;
            goto LABEL_35;
          }
LABEL_11:
          nvram_set("ipsec_net_enable", v5);
          if ( !strcmp(v5, "1") )
          {
            nvram_set("ipsec_mode", "net");
            nvram_set("ipsec_road_enable", "0");
            nvram_set("ipsec_l2tp_enable", "0");
            nvram_set("ipsec_l2tp_cli_enable", "0");
          }
          else
          {
            v30 = (const char *)nvram_get("ipsec_mode");
            if ( !v30 || strcmp(v30, "net") )
            {
LABEL_32:
              v12 = s;
              v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
              do
              {
                v14 = *(_DWORD *)v13;
                v15 = *((_DWORD *)v13 + 1);
                v16 = *((_DWORD *)v13 + 2);
                v17 = *((_DWORD *)v13 + 3);
                v13 += 16;
                *(_DWORD *)v12 = v14;
                *((_DWORD *)v12 + 1) = v15;
                *((_DWORD *)v12 + 2) = v16;
                *((_DWORD *)v12 + 3) = v17;
                v12 += 16;
              }
              while ( v13 != "}" );
              v18 = 33;
              *(_WORD *)v12 = *(_WORD *)v13;
              goto LABEL_35;
            }
            nvram_set("ipsec_mode", "none");
          }
          goto LABEL_13;
        }
LABEL_36:
        v20 = *(unsigned __int8 *)(a1 + 210102);
        v21 = (const char *)&unk_64B158;
        goto LABEL_37;
      }
      if ( !strcmp(v2, "enable") )
      {
        if ( !v4 || *v4 )
          goto LABEL_11;
        goto LABEL_36;
      }
    }
    v20 = *(unsigned __int8 *)(a1 + 210102);
    v21 = "not opt";
    goto LABEL_37;
  }
  v31 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 76800);
  v32 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
  if ( v32 >= 0x400 )
    v32 = 1023;
  return httpd_cgi_ret(a1, s, v32, 4);
}
// 48D0BC: variable 'v7' is possibly undefined
// 48D384: variable 'v11' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81D0: using guessed type int __fastcall strdb_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8404: using guessed type int __fastcall strdb_del(_DWORD);
// 6A8724: using guessed type int __fastcall schedule_ipsec(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0048DAB8) --------------------------------------------------------
int __fastcall GetIpsecSaStatus(const char *a1, char *a2, const char *a3, void *a4, size_t n)
{
  int v9; // $s5
  FILE *v10; // $s4
  unsigned int v11; // $a2
  int v12; // $s3
  char *v13; // $v0
  bool v14; // dc
  struct hostent *v16; // $v0
  char *v17; // $a1
  int v18; // $a0
  char v19[128]; // [sp+18h] [-98h] BYREF
  char v20[4]; // [sp+98h] [-18h] BYREF
  char *v21; // [sp+9Ch] [-14h]
  char *v22; // [sp+A0h] [-10h]

  memset(v19, 0, sizeof(v19));
  if ( !a1 || !a2 || !*a2 )
    return 0;
  v9 = strcmp(a2, "dynamic");
  if ( v9 )
  {
    v12 = 0;
    if ( !is_domain(a2) )
      goto LABEL_14;
    v16 = gethostbyname(a2);
    v9 = 0;
    if ( !v16 )
      return v9;
    v17 = *v16->h_addr_list;
    if ( !v17 )
      return v9;
    v18 = v16->h_addrtype;
    if ( (v18 & 0xFFFFFFF7) != 2 )
      return v9;
    a2 = v19;
    if ( inet_ntop(v18, v17, v19, 0x80u) )
    {
      v12 = 0;
      goto LABEL_14;
    }
    return 0;
  }
  if ( a3 )
  {
    v10 = fopen("/tmp/spdump", "r");
    if ( v10 )
    {
      do
      {
        if ( !fgets(v19, 128, v10) )
        {
          fclose(v10);
          return v9;
        }
      }
      while ( split_string(v19, 124, v20, 4) < 4 || strcmp(a3, v21) );
      a2 = v22;
      fclose(v10);
      if ( !a2 )
        return v9;
      memset(a4, 0, n);
      v11 = strlen(a2);
      if ( n >= v11 )
        memcpy(a4, a2, v11);
      v12 = 0;
LABEL_14:
      while ( 1 )
      {
        v13 = strstr(a1, a2);
        if ( !v13 )
          break;
        a1 = &v13[strlen(a2)];
        if ( *a1 == 124 )
        {
          v14 = v12 == 1;
          v12 = 1;
          if ( v14 )
            return 1;
        }
      }
      return 0;
    }
  }
  return v9;
}
// 6A8224: using guessed type int __fastcall is_domain(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0048DD94) --------------------------------------------------------
int show_ipsec_status()
{
  int v0; // $v0
  const char *v1; // $s0
  int v2; // $s3
  char *v4; // $v1
  const char *v5; // $v0
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  int v9; // $a1
  int v10; // $a2
  int v11; // $a1
  int v12; // $v0
  int v13; // $s2
  ssize_t v14; // $s1
  char *v15; // $a0
  void *v16; // $v0
  char *v17; // $s0
  int v18; // $s4
  int v19; // $s1
  int v20; // $s2
  int v21; // $s5
  char *v22; // $s6
  char v23; // $v0
  const char *v24; // $s6
  int v25; // $s6
  int v26; // $s2
  int v27; // $s1
  int v28; // $s7
  ssize_t v29; // $fp
  char *v30; // $v0
  int v31; // $v0
  int v32; // $s7
  int v33; // $a2
  char *v34; // $fp
  char *v35; // $v0
  char *v36; // $v1
  int v37; // $a0
  int v38; // $v1
  void *v39; // $v0
  void *v40; // $s1
  int v41; // $v0
  int v42; // $s0
  char v43[1032]; // [sp+20h] [-560h] BYREF
  struct stat v44; // [sp+428h] [-158h] BYREF
  const char *v45; // [sp+4C8h] [-B8h] BYREF
  char *v46; // [sp+4DCh] [-A4h]
  const char *v47; // [sp+4F4h] [-8Ch]
  char v48[24]; // [sp+540h] [-40h] BYREF
  int v49; // [sp+558h] [-28h]
  char *v50; // [sp+55Ch] [-24h]
  char *v51; // [sp+560h] [-20h]
  int v52; // [sp+564h] [-1Ch]
  void *v53; // [sp+568h] [-18h]
  char *format; // [sp+56Ch] [-14h]
  char *v55; // [sp+570h] [-10h]
  char *v56; // [sp+574h] [-Ch]
  char *v57; // [sp+578h] [-8h]

  v0 = nvram_get("ipsec_mode");
  if ( !v0 )
  {
    memset(ipsec_info, 0, sizeof(ipsec_info));
    return 1;
  }
  v1 = (const char *)v0;
  memset(ipsec_info, 0, sizeof(ipsec_info));
  if ( !strcmp(v1, "net") )
  {
    v55 = "1\"";
    _mem_malloc(76800, "show_ipsec_status", 998);
    v53 = v16;
    if ( !v16 )
      return 1;
    jhl_parm_get("ipsec_net_users", v53, 76799);
    jhl_system("setkey -Ds >/tmp/sadump");
    jhl_system("setkey -DPs >/tmp/spdump");
    if ( stat("/tmp/sadump", &v44)
      || *(_QWORD *)&v44.st_atim < 11
      || (_mem_malloc(v44.st_atim.tv_sec + 4, v55 - 18508, 1008), v40 = v39, (v51 = (char *)v39) == 0) )
    {
      v17 = v43;
      v18 = split_string(v53, 60, v43, 256);
      if ( v18 <= 0 )
      {
        _mem_free(v53);
        return 1;
      }
      v50 = 0;
      v51 = 0;
    }
    else
    {
      v41 = open("/tmp/sadump", 0);
      v42 = v41;
      if ( v41 < 0 )
      {
        v50 = 0;
      }
      else
      {
        v50 = (char *)read(v41, v40, v44.st_atim.tv_sec);
        close(v42);
      }
      v17 = v43;
      v18 = split_string(v53, 60, v43, 256);
      if ( v18 <= 0 )
      {
        _mem_free(v53);
        v2 = 1;
        goto LABEL_27;
      }
    }
    v49 = (int)ipsec_info;
    format = "%s";
    v19 = 0;
    v56 = "dynamic";
    v2 = 1;
    v20 = 0;
    v57 = "%s(%s)";
    do
    {
      if ( split_string(*(_DWORD *)v17, 124, &v45, 30) >= 25 )
      {
        v21 = 65 * v20;
        v22 = (char *)(v49 + 65 * v20);
        snprintf(v22, 32, "%s", v45);
        v52 = (int)ipsec_info;
        if ( v50 )
        {
          v52 = (int)v48;
          v23 = GetIpsecSaStatus(v51, v46, v47, v48, 0x16u);
          v22[64] = v23;
          v24 = v46;
          if ( v23 && !strcmp(v46, v56) )
          {
            snprintf(&ipsec_info[v21 + 32], 32, v57, v24, v52);
            ++v20;
          }
          else
          {
            snprintf((char *)(v49 + 65 * v20++ + 32), 32, "%s", v24);
          }
        }
        else
        {
          snprintf(&ipsec_info[v21 + 32], 32, format, v46);
          ++v20;
        }
        v2 = 0;
        if ( v20 == 256 )
          break;
      }
      ++v19;
      v17 += 4;
    }
    while ( v19 < v18 );
    _mem_free(v53);
    if ( !v51 )
      return v2;
LABEL_27:
    _mem_free(v51);
    return v2;
  }
  v2 = strcmp(v1, "road");
  if ( v2 )
    return 1;
  memset(v43, 0, 0x200u);
  v4 = v43;
  v5 = "racoonctl -s /var/run/racoon.sock show-sa isakmp |wc -l >/etc/racoon/tmp123";
  do
  {
    v6 = *(_DWORD *)v5;
    v7 = *((_DWORD *)v5 + 1);
    v8 = *((_DWORD *)v5 + 2);
    v9 = *((_DWORD *)v5 + 3);
    v5 += 16;
    *(_DWORD *)v4 = v6;
    *((_DWORD *)v4 + 1) = v7;
    *((_DWORD *)v4 + 2) = v8;
    *((_DWORD *)v4 + 3) = v9;
    v4 += 16;
  }
  while ( v5 != "coon/tmp123" );
  v10 = *(_DWORD *)v5;
  v11 = *((_DWORD *)v5 + 1);
  v12 = *((_DWORD *)v5 + 2);
  *((_DWORD *)v4 + 1) = v11;
  *(_DWORD *)v4 = v10;
  *((_DWORD *)v4 + 2) = v12;
  jhl_system(v43);
  v13 = open("/etc/racoon/tmp123", 0);
  if ( v13 < 0 )
    return 1;
  memset(v43, 0, 0x200u);
  v14 = read(v13, v43, 0x20u);
  close(v13);
  if ( v14 <= 0 )
    return 1;
  v15 = v43;
  while ( (unsigned int)(*v15 - 48) >= 0xA )
  {
    if ( &v43[v14] == ++v15 )
      return 1;
  }
  v25 = J_atoi(v15);
  if ( v25 < 2 )
    return 1;
  v51 = "1\"";
  v49 = 1;
  v26 = 0;
  v27 = 2;
  v50 = ipsec_info;
  v52 = 1684107090;
  do
  {
    memset(v43, 0, 0x200u);
    sprintf(
      v43,
      "racoonctl -s /var/run/racoon.sock show-sa isakmp |sed -n '%dp' |sed 's/\\(.*\\)\\.\\(.*\\)\\.\\(.*\\)\\.\\(.*\\)\\"
      ".\\(.*\\) .*/\\1.\\2.\\3.\\4/' >/etc/racoon/tmp123",
      v27);
    jhl_system(v43);
    v28 = open("/etc/racoon/tmp123", 0);
    if ( v28 >= 0 )
    {
      memset(v43, 0, 0x200u);
      v29 = read(v28, v43, 0x20u);
      close(v28);
      if ( v29 >= 2 )
      {
        v30 = strchr(v43, 13);
        if ( v30 || (v30 = strchr(v43, 10)) != 0 )
        {
          v29 = v30 - v43;
          v31 = v26 << 6;
        }
        else
        {
          v31 = v26 << 6;
        }
        v32 = v31 + v26;
        v33 = v29;
        v34 = v50;
        memcpy(&v50[v31 + 32 + v26], v43, v33);
        v35 = &v34[v32];
        v36 = v51 - 19816;
        v37 = *((_DWORD *)v51 - 4953);
        *(_DWORD *)v35 = v52;
        *((_DWORD *)v35 + 1) = v37;
        v38 = *((_DWORD *)v36 + 2);
        *((_DWORD *)v35 + 1) = v37;
        *((_DWORD *)v35 + 2) = v38;
        ++v26;
        v35[64] = 1;
        if ( v26 == 256 )
          return v2;
        v49 = 0;
      }
    }
    ++v27;
  }
  while ( v25 >= v27 );
  return v49;
}
// 48DFC4: variable 'v16' is possibly undefined
// 48E4A4: variable 'v39' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8594: using guessed type int __fastcall jhl_system(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0048E578) --------------------------------------------------------
int __fastcall sub_48E578(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  int v4; // $s2
  char *v5; // $s0
  const char *v6; // $v0
  int v7; // $v0
  char *v8; // $a0
  int v9; // $a1
  int v10; // $s0
  int v11; // $a2
  int result; // $v0
  const char *v13; // $v0
  unsigned int v14; // $v0
  char v15[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(20580, "ipsec_state_data", 1141);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy(v2, "{\"code\":0,\"error", 16);
    v4 = 29;
    if ( show_ipsec_status() )
    {
      v8 = v3 + 29;
      v9 = 20551;
      v10 = 20551;
    }
    else
    {
      v5 = ipsec_info;
      do
      {
        if ( !*v5 )
          break;
        v6 = v5[64] ? "conn" : "disconn";
        v7 = sprintf(&v3[v4], "{\"n\":\"%s\",\"ip\":\"%s\",\"s\":\"%s\"},", v5, v5 + 32, v6);
        v5 += 65;
        v4 += v7;
      }
      while ( v5 != (char *)&switch_reboot_timer );
      v8 = &v3[v4];
      if ( v4 > 0 && *(v8 - 1) == 44 )
        v8 = &v3[--v4];
      v10 = 20580 - v4;
      *v8 = 0;
      v9 = 20580 - v4;
    }
    v11 = snprintf(v8, v9, "]}");
    if ( v11 >= v10 )
      v11 = 20579 - v4;
    result = httpd_cgi_ret(a1, v3, v4 + v11, 8);
  }
  else
  {
    v13 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 20580);
    v14 = snprintf(v15, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
    if ( v14 >= 0x100 )
      v14 = 255;
    result = httpd_cgi_ret(a1, v15, v14, 4);
  }
  return result;
}
// 48E5D4: variable 'v2' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0048E7F0) --------------------------------------------------------
int __fastcall sub_48E7F0(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $s2
  int v5; // $a1
  const char *v6; // $a2
  const char *v7; // $v0
  const char **v8; // $v1
  const char *v9; // $v0
  const char *v10; // $t0
  const char *v11; // $a3
  const char *v12; // $a2
  const char *v13; // $a1
  unsigned int v14; // $a2
  const char *v16; // $v0
  const char *v17; // [sp+20h] [-404h] BYREF
  const char *v18; // [sp+24h] [-400h]
  const char *v19; // [sp+28h] [-3FCh]
  const char *v20; // [sp+2Ch] [-3F8h]
  int v21; // [sp+30h] [-3F4h]
  int v22; // [sp+34h] [-3F0h]

  v3 = httpd_get_parm(a1, "opt");
  v2 = httpd_get_parm(a1, "ip");
  if ( v3 )
  {
    v4 = (int)v2;
    if ( !strcmp(v3, "disconn") )
    {
      if ( v4 )
      {
        v17 = "racoonctl";
        v18 = "-s";
        v19 = "/var/run/racoon.sock";
        v7 = "vpn-disconnect";
LABEL_11:
        v20 = v7;
        v21 = v4;
        v22 = 0;
        eval_nowait(&v17, 0, 0, 0);
LABEL_12:
        v8 = &v17;
        v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v10 = *(const char **)v9;
          v11 = (const char *)*((_DWORD *)v9 + 1);
          v12 = (const char *)*((_DWORD *)v9 + 2);
          v13 = (const char *)*((_DWORD *)v9 + 3);
          v9 += 16;
          *v8 = v10;
          v8[1] = v11;
          v8[2] = v12;
          v8[3] = v13;
          v8 += 4;
        }
        while ( v9 != "}" );
        v14 = 33;
        *(_WORD *)v8 = *(_WORD *)v9;
        return httpd_cgi_ret(a1, (char *)&v17, v14, 4);
      }
LABEL_9:
      v5 = *(unsigned __int8 *)(a1 + 210102);
      v6 = "NOT IP";
      goto LABEL_20;
    }
    if ( !strcmp(v3, "conn") )
    {
      if ( v4 )
      {
        v17 = "racoonctl";
        v18 = "-s";
        v19 = "/var/run/racoon.sock";
LABEL_18:
        v7 = "vpn-connect";
        goto LABEL_11;
      }
      goto LABEL_9;
    }
    if ( !strcmp(v3, "reboot") )
    {
      if ( v4 )
      {
        if ( strcmp(v3, "reboot") )
          goto LABEL_12;
        v17 = "racoonctl";
        v18 = "-s";
        v19 = "/var/run/racoon.sock";
        v20 = "vpn-disconnect";
        v21 = v4;
        v22 = 0;
        eval_nowait(&v17, 0, 0, 0);
        v17 = "racoonctl";
        v18 = "-s";
        v19 = "/var/run/racoon.sock";
        goto LABEL_18;
      }
      goto LABEL_9;
    }
  }
  v5 = *(unsigned __int8 *)(a1 + 210102);
  v6 = "NOT OPT";
LABEL_20:
  v16 = (const char *)_GET_LANG_TEXT(12, v5, v6);
  v14 = snprintf((char *)&v17, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v16);
  if ( v14 >= 0x400 )
    v14 = 1023;
  return httpd_cgi_ret(a1, (char *)&v17, v14, 4);
}
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0048EB0C) --------------------------------------------------------
void __fastcall format_user_state_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 10 )
    snprintf(
      a3,
      a4,
      "{\"user\":\"%s\",\"tm\":%s,\"ifname\":\"%s\",\"fip\":\"%s\",\"bytes_in\":%s,\"bytes_out\":%s,\"pkts_in\":%s,\"pkts"
      "_out\":%s,\"peerip\":\"%s\"},",
      *a1,
      a1[1],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7],
      a1[8],
      a1[9]);
}

//----- (0048EBC4) --------------------------------------------------------
int __fastcall get_vpn_user_state_data(int a1, char *a2, int a3)
{
  int v5; // $s2
  int v6; // $s0
  const char **v7; // $s4
  void *v8; // $v0
  _DWORD *v9; // $s7
  void *v10; // $fp
  int v11; // $s6
  _DWORD *v12; // $s3
  int i; // $s2
  int v14; // $v0
  int v15; // $v0
  char *v16; // $a0
  int v17; // $s1
  int v18; // $v0

  v5 = nvram_get(a1);
  v6 = snprintf(a2, a3, (char *)&word_642A04);
  if ( v6 >= a3 )
    v6 = a3 - 1;
  if ( v5 )
  {
    v7 = (const char **)malloc(0x30u);
    v9 = malloc(0x4008u);
    v8 = malloc(0x200000u);
    v10 = v8;
    if ( v8 )
    {
      if ( v7 )
      {
        if ( v9 )
        {
          strlcpy(v8, v5, 0x200000);
          v11 = split_string(v10, 60, v9, 4096);
          if ( v11 > 0 )
          {
            v12 = v9;
            for ( i = 0; i != v11; ++i )
            {
              v14 = split_string(*v12, 124, v7, 10);
              format_user_state_data(v7, v14, &a2[v6], a3 - v6);
              v6 += v15;
              ++v12;
            }
          }
        }
      }
      free(v10);
    }
    if ( v7 )
      free(v7);
    if ( v9 )
      free(v9);
  }
  v16 = &a2[v6];
  if ( v6 > 0 && *(v16 - 1) == 44 )
    v16 = &a2[--v6];
  v17 = a3 - v6;
  *v16 = 0;
  v18 = snprintf(v16, v17, &byte_6445A0);
  if ( v18 >= v17 )
    v18 = v17 - 1;
  return v6 + v18;
}
// 48ED28: variable 'v15' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0048EE04) --------------------------------------------------------
void __fastcall format_vpn_user_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 8 )
    snprintf(
      a3,
      a4,
      "{\"en\":%s,\"user\":\"%s\",\"pwd\":\"%s\",\"utype\":%s,\"ip\":\"%s\",\"type\":\"%s\",\"route\":\"%s\",\"mem\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7]);
}

//----- (0048EEB4) --------------------------------------------------------
int __fastcall get_vpn_user_data(int a1, char *a2, int a3)
{
  int v5; // $s2
  int v6; // $s0
  const char **v7; // $s4
  void *v8; // $v0
  _DWORD *v9; // $s7
  void *v10; // $fp
  int v11; // $s6
  _DWORD *v12; // $s3
  int i; // $s2
  int v14; // $v0
  int v15; // $v0
  char *v16; // $a0
  int v17; // $s1
  int v18; // $v0

  v5 = nvram_get(a1);
  v6 = snprintf(a2, a3, (char *)&word_642A04);
  if ( v6 >= a3 )
    v6 = a3 - 1;
  if ( v5 )
  {
    v7 = (const char **)malloc(0x28u);
    v9 = malloc(0x4008u);
    v8 = malloc(0x200000u);
    v10 = v8;
    if ( v8 )
    {
      if ( v7 )
      {
        if ( v9 )
        {
          strlcpy(v8, v5, 0x200000);
          v11 = split_string(v10, 60, v9, 4096);
          if ( v11 > 0 )
          {
            v12 = v9;
            for ( i = 0; i != v11; ++i )
            {
              v14 = split_string(*v12, 124, v7, 8);
              format_vpn_user_data(v7, v14, &a2[v6], a3 - v6);
              v6 += v15;
              ++v12;
            }
          }
        }
      }
      free(v10);
    }
    if ( v7 )
      free(v7);
    if ( v9 )
      free(v9);
  }
  v16 = &a2[v6];
  if ( v6 > 0 && *(v16 - 1) == 44 )
    v16 = &a2[--v6];
  v17 = a3 - v6;
  *v16 = 0;
  v18 = snprintf(v16, v17, &byte_6445A0);
  if ( v18 >= v17 )
    v18 = v17 - 1;
  return v6 + v18;
}
// 48F018: variable 'v15' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0048F0F4) --------------------------------------------------------
int __fastcall sub_48F0F4(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  char *v4; // $s0
  const char *v5; // $s3
  const char *v6; // $s5
  int v7; // $s1
  int v8; // $s1
  char *v9; // $v0
  int v10; // $s1
  int v11; // $v0
  int v12; // $a2
  const char *v14; // $v0
  int v15; // $v0
  int v16; // $a3
  const char *v17; // $v0
  char v18[260]; // [sp+20h] [-104h] BYREF

  v3 = httpd_get_parm(a1, "id");
  _mem_malloc(1024000, "vpn_user_data", 1315);
  if ( !v2 )
  {
    v17 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v4 = v18;
    v15 = snprintf(v18, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
    if ( (unsigned int)v15 >= 0x100 )
      v15 = 255;
    v16 = 4;
    return httpd_cgi_ret(a1, v4, v15, v16);
  }
  v4 = v2;
  if ( !v3 )
    goto LABEL_13;
  if ( strcmp(v3, "pptp") )
  {
    if ( !strcmp(v3, "l2tp") )
    {
      v5 = "l2tp_vpn_users_st";
      v6 = "l2tp_vpn_users";
      goto LABEL_5;
    }
    if ( strcmp(v3, "pptp_l2tp") )
    {
LABEL_13:
      v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "error type");
      v15 = snprintf(v4, 1024000, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
      if ( v15 >= 1024000 )
        v15 = 1023999;
      v16 = 8;
      return httpd_cgi_ret(a1, v4, v15, v16);
    }
  }
  v5 = "pptp_vpn_users_st";
  v6 = "pptp_vpn_users";
LABEL_5:
  strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":{");
  qmemcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":", 28);
  v7 = sprintf(v4 + 29, "\"vpn_type\":\"%s\",\"all\":", "all") + 29;
  v8 = v7 + get_vpn_user_data((int)v6, &v4[v7], 1024000 - v7);
  v9 = &v4[v8];
  strcpy(&v4[v8], ",\"state\":");
  *(_DWORD *)v9 = 1953702444;
  *((_DWORD *)v9 + 1) = 577074273;
  v10 = v8 + 9 + get_vpn_user_state_data((int)v5, &v4[v8 + 9], 1024000 - (v8 + 9));
  v11 = snprintf(&v4[v10], 1024000 - v10, "}}");
  if ( v11 >= 1024000 - v10 )
    v12 = 1023999 - v10;
  else
    v12 = v11;
  return httpd_cgi_ret(a1, v4, v12 + v10, 8);
}
// 48F160: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0048F450) --------------------------------------------------------
int __fastcall sub_48F450(int a1)
{
  char *v2; // $s5
  char *v3; // $s6
  char *v4; // $s4
  char *v5; // $s7
  char *v6; // $s2
  int v7; // $v0
  char *v8; // $s1
  int v9; // $fp
  _DWORD *i; // $fp
  int v11; // $a0
  int v12; // $a0
  char *v13; // $v0
  char *v14; // $v1
  const char *v15; // $v0
  int v16; // $t0
  int v17; // $a3
  int v18; // $a2
  int v19; // $a1
  int v20; // $a2
  char *v22; // $a2
  int v23; // $a1
  const char *v24; // $a2
  const char *v25; // $v0
  char s[1024]; // [sp+30h] [-418h] BYREF
  char *v27; // [sp+430h] [-18h]
  char *v28; // [sp+434h] [-14h]
  char *v29; // [sp+438h] [-10h]
  char *v30; // [sp+43Ch] [-Ch]
  char *v31; // [sp+440h] [-8h]
  char *v32; // [sp+444h] [-4h]

  v2 = httpd_get_parm(a1, "user");
  v3 = httpd_get_parm(a1, "old_user");
  v28 = httpd_get_parm(a1, (char *)&off_649194);
  v29 = httpd_get_parm(a1, "ip");
  v30 = httpd_get_parm(a1, "type");
  v31 = httpd_get_parm(a1, "utype");
  v4 = httpd_get_parm(a1, "route");
  v27 = httpd_get_parm(a1, "mem");
  v5 = httpd_get_parm(a1, "en");
  v6 = httpd_get_parm(a1, "opt");
  v8 = httpd_get_parm(a1, "id");
  v7 = httpd_get_json_parm(a1, (int)"del_list");
  if ( !v6 )
    goto LABEL_41;
  v9 = v7;
  if ( !strcmp(v6, (const char *)&off_646D8C) )
  {
    if ( strcmp(v6, "del") )
      goto LABEL_14;
    v32 = "1\"";
    goto LABEL_5;
  }
  v32 = "1\"";
  if ( !strcmp(v6, (const char *)&off_648DDC) )
  {
    if ( strcmp(v6, "del") )
      goto LABEL_14;
    goto LABEL_5;
  }
  if ( strcmp(v6, "del") )
  {
    if ( !strcmp(v6, "delall") )
      goto LABEL_11;
LABEL_41:
    v23 = *(unsigned __int8 *)(a1 + 210102);
    v24 = "not opt";
    goto LABEL_42;
  }
LABEL_5:
  if ( v9 )
  {
    for ( i = *(_DWORD **)(v9 + 8); i; i = (_DWORD *)*i )
    {
      v11 = i[4];
      if ( !v11 )
        break;
      vpn_user_del(v11, v8);
    }
  }
  if ( strcmp(v6, v32 - 29220) )
  {
LABEL_11:
    if ( strcmp(v6, (const char *)&off_646D8C) )
    {
LABEL_26:
      jhl_parm_commit(v12);
      v14 = s;
      v15 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v16 = *(_DWORD *)v15;
        v17 = *((_DWORD *)v15 + 1);
        v18 = *((_DWORD *)v15 + 2);
        v19 = *((_DWORD *)v15 + 3);
        v15 += 16;
        *(_DWORD *)v14 = v16;
        *((_DWORD *)v14 + 1) = v17;
        *((_DWORD *)v14 + 2) = v18;
        *((_DWORD *)v14 + 3) = v19;
        v14 += 16;
      }
      while ( v15 != "}" );
      v20 = 33;
      *(_WORD *)v14 = *(_WORD *)v15;
      return httpd_cgi_ret(a1, s, v20, 4);
    }
  }
LABEL_14:
  if ( v2 )
  {
    if ( v3 )
      vpn_user_del(v3, v8);
    else
      vpn_user_del(v2, v8);
    if ( strcmp(v6, (const char *)&off_646D8C) )
    {
      if ( strcmp(v6, (const char *)&off_648DDC) )
        goto LABEL_26;
LABEL_19:
      if ( !v4 )
        v4 = "";
      if ( !v5 )
        v4 = "1";
      v13 = v27;
      if ( !v27 )
        v13 = "";
      vpn_user_add(v5, v2, v28, v31, v29, v30, v4, v13, v8);
      goto LABEL_26;
    }
    if ( v8 )
    {
      if ( !strcmp(v8, "pptp") )
      {
        v22 = "pptp_vpn_users";
        goto LABEL_35;
      }
      if ( !strcmp(v8, "l2tp") )
      {
        v22 = "l2tp_vpn_users";
        goto LABEL_35;
      }
    }
    v22 = "";
LABEL_35:
    v20 = check_rule_num_limit(a1, 21, (int)v22, 60, s, 0x400u);
    if ( v20 > 0 )
      return httpd_cgi_ret(a1, s, v20, 4);
    goto LABEL_19;
  }
  v23 = *(unsigned __int8 *)(a1 + 210102);
  v24 = "not user";
LABEL_42:
  v25 = (const char *)_GET_LANG_TEXT(12, v23, v24);
  v20 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v25);
  if ( (unsigned int)v20 >= 0x400 )
    v20 = 1023;
  return httpd_cgi_ret(a1, s, v20, 4);
}
// 48F7B8: variable 'v12' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 649194: using guessed type char *off_649194;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A820C: using guessed type int __fastcall vpn_user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82EC: using guessed type int __fastcall vpn_user_del(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0048F9F4) --------------------------------------------------------
char *__fastcall jhl_vpn_link_uptime(char *a1, int a2)
{
  int v4; // $v0
  char *result; // $v0
  struct sysinfo v6[4]; // [sp+18h] [-144h] BYREF
  int v7[3]; // [sp+150h] [-Ch] BYREF

  *a1 = 45;
  a1[1] = 0;
  sysinfo(v6);
  v4 = jhl_vpndtime(a2);
  result = (char *)f_read(v4, v7, 4);
  if ( result == (char *)4 )
    result = reltime(a1, v6[0].uptime - v7[0]);
  return result;
}
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);
// 6A87F4: using guessed type int __fastcall jhl_vpndtime(_DWORD);

//----- (0048FAB4) --------------------------------------------------------
int __fastcall get_vpn_nvarms(const char **a1, char *a2, int a3)
{
  int v5; // $s1
  int v6; // $s2
  int v7; // $v0
  const char *v8; // $fp
  int v9; // $s0
  const char **v10; // $s1
  int v11; // $v0
  void **v12; // $v0
  const char *v13; // $s7
  const char *v14; // $v0
  int v15; // $fp
  int v16; // $v0
  char *v17; // $a0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $s3
  int v21; // $v0
  int v23; // $v0
  int v24; // $v0
  int v25; // [sp+28h] [-18h]

  v25 = sq_file_get_max_wan();
  v5 = snprintf(a2, a3, "\"wans\":[ ");
  if ( v5 >= a3 )
    v5 = a3 - 1;
  if ( v25 > 0 )
  {
    v6 = 0;
    while ( 1 )
    {
      v7 = snprintf(&a2[v5], a3 - v5, "{\"iface\":%d,", v6);
      if ( v7 >= a3 - v5 )
        v7 = a3 - v5 - 1;
      v8 = *a1;
      v9 = v7 + v5;
      if ( *a1 )
      {
        if ( *v8 )
          break;
      }
LABEL_15:
      v17 = &a2[v9];
      if ( v9 > 0 && *(v17 - 1) == 44 )
        v17 = &a2[--v9];
      *v17 = 0;
      v18 = snprintf(v17, a3 - v9, &byte_65078C);
      if ( v18 >= a3 - v9 )
        v18 = a3 - v9 - 1;
      ++v6;
      v5 = v9 + v18;
      if ( v6 == 5 || v25 == v6 )
        goto LABEL_22;
    }
    v10 = a1;
    while ( 1 )
    {
      if ( !strcmp(v8, "vpn_proto") )
      {
        v11 = jhl_vpnget("vpn_new_proto", v6);
        v12 = (void **)nvram_get(v11);
        if ( !v12 )
        {
          v24 = jhl_vpnget("vpn_proto", v6);
          v12 = (void **)nvram_get(v24);
          if ( !v12 )
            v12 = &off_63F984;
        }
      }
      else
      {
        v23 = jhl_vpnget(v8, v6);
        v12 = (void **)jhl_nv_get_def(v23);
        v15 = a3 - v9;
        if ( !v12 )
        {
          v16 = snprintf(&a2[v9], a3 - v9, "\"%s\":\"\",", *v10);
          if ( v16 < v15 )
            goto LABEL_13;
          goto LABEL_30;
        }
      }
      v13 = *v10;
      v14 = (const char *)get_json_data(v12);
      v15 = a3 - v9;
      v16 = snprintf(&a2[v9], a3 - v9, "\"%s\":\"%s\",", v13, v14);
      if ( v16 < a3 - v9 )
        goto LABEL_13;
LABEL_30:
      v16 = v15 - 1;
LABEL_13:
      v8 = *++v10;
      v9 += v16;
      if ( !*v10 || !*v8 )
        goto LABEL_15;
    }
  }
LABEL_22:
  v19 = &a2[v5];
  if ( v5 > 0 && *(v19 - 1) == 44 )
    v19 = &a2[--v5];
  v20 = a3 - v5;
  *v19 = 0;
  v21 = snprintf(v19, v20, "],");
  if ( v21 >= v20 )
    v21 = v20 - 1;
  return v5 + v21;
}
// 63F984: using guessed type void *off_63F984;
// 65078C: using guessed type char byte_65078C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (0048FE44) --------------------------------------------------------
int __fastcall get_vpn_state(char *a1, int a2)
{
  int v4; // $s4
  int v5; // $s0
  int v6; // $s1
  int v7; // $v0
  int v8; // $fp
  const char *v9; // $s5
  int v10; // $v0
  int v11; // $s0
  char *v12; // $a0
  char *v13; // $v0
  int v14; // $v0
  char *v15; // $a0
  int v16; // $s2
  int v17; // $v0
  int v19; // $v0
  int v20; // $v1
  int v21; // $v0
  int v22; // $fp
  int v23; // $v0
  int v24; // $v0
  int v25; // $v0
  int v26; // $v0
  int v27; // $fp
  int v28; // $v0
  int v29; // $v0
  int v30; // $v0
  int v31; // $v0
  int v32; // $fp
  int v33; // $v0
  int v34; // $s0
  int v35; // $v0
  int v36; // $v0
  int v37; // $v0
  int v38; // $s0
  const char *v39; // $v0
  int v40; // $fp
  int v41; // $v0
  int v42; // $v0
  int v43; // $s0
  const char *v44; // $v0
  int v45; // $fp
  int v46; // $v0
  int v47; // $v0
  int v48; // $s0
  const char *v49; // $v0
  int v50; // $fp
  int v51; // $v0
  int v52; // $v0
  int v53; // $s0
  const char *v54; // $v0
  int v55; // $fp
  int v56; // $v0
  int v57; // $v0
  const char *v58; // $v0
  int v59; // $fp
  int v60; // $v0
  int v61; // $v1
  char v62[128]; // [sp+20h] [-A0h] BYREF
  char *v63; // [sp+A0h] [-20h]
  char *v64; // [sp+A4h] [-1Ch]
  char *v65; // [sp+A8h] [-18h]
  const char *v66; // [sp+ACh] [-14h]
  char *format; // [sp+B0h] [-10h]
  char *v68; // [sp+B4h] [-Ch]
  char *v69; // [sp+B8h] [-8h]
  char *v70; // [sp+BCh] [-4h]

  v4 = sq_file_get_max_wan();
  v5 = snprintf(a1, a2, "\"state\":[ ");
  if ( v5 >= a2 )
    v5 = a2 - 1;
  if ( v4 > 0 )
  {
    v65 = "a";
    v64 = "1\"";
    v6 = 0;
    v68 = "1\"";
    v70 = "a";
    v66 = "vpn_run";
    format = "\"vpn_run\":\"%s\",";
    v69 = "\"vpn_run_wan\":\"WAN%lu\",";
    while ( 1 )
    {
      v7 = jhl_vpnget("vpn_new_proto", v6);
      v8 = a2 - v5;
      v9 = (const char *)nvram_get(v7);
      if ( v9 )
        break;
      v60 = jhl_vpnget("vpn_proto", v6);
      v9 = (const char *)nvram_get(v60);
      if ( v9 )
        break;
      v61 = snprintf(&a1[v5], a2 - v5, "{\"iface\":%d,\"vpn_proto\":\"%s\",", v6, v65 - 1660);
      v19 = 0;
      if ( v61 >= v8 )
      {
        v20 = v8 - 1;
        goto LABEL_22;
      }
      v11 = v61 + v5;
LABEL_8:
      v12 = &a1[v11];
      if ( v11 > 0 && *(v12 - 1) == 44 )
        v12 = &a1[--v11];
      v13 = v64;
      *v12 = 0;
      v14 = snprintf(v12, a2 - v11, v13 + 1932);
      if ( v14 >= a2 - v11 )
        v14 = a2 - v11 - 1;
      ++v6;
      v5 = v11 + v14;
      if ( v6 == 5 || v4 == v6 )
        goto LABEL_15;
    }
    v63 = (char *)snprintf(&a1[v5], a2 - v5, "{\"iface\":%d,\"vpn_proto\":\"%s\",", v6, v9);
    if ( (int)v63 >= v8 )
    {
      v19 = strcmp(v9, v65 - 1660);
      v20 = v8 - 1;
LABEL_22:
      v11 = v20 + v5;
      if ( !v19 )
        goto LABEL_8;
    }
    else
    {
      v10 = strcmp(v9, v65 - 1660);
      v11 = (int)&v63[v5];
      if ( !v10 )
        goto LABEL_8;
    }
    v21 = jhl_vpnget(v66, v6);
    v22 = nvram_get(v21);
    if ( !v22 )
      v22 = (int)(v70 + 14076);
    v63 = (char *)(a2 - v11);
    v23 = snprintf(&a1[v11], a2 - v11, format, v22);
    if ( v23 >= (int)v63 )
    {
      v11 += (int)(v63 - 1);
      v24 = J_atoi(v22);
      if ( v24 != 2 )
        goto LABEL_27;
    }
    else
    {
      v11 += v23;
      v24 = J_atoi(v22);
      if ( v24 != 2 )
      {
LABEL_27:
        if ( v24 != 1 )
          goto LABEL_8;
        v25 = jhl_vpnget(v68 - 19164, v6);
        v27 = a2 - v11;
        v26 = nvram_get(v25);
        if ( !v26 )
          v26 = (int)(v70 + 14076);
        v63 = &a1[v11];
        v28 = J_atoi(v26);
        v29 = snprintf(v63, a2 - v11, v69, v28 + 1);
        if ( v29 >= v27 )
          v29 = v27 - 1;
        goto LABEL_32;
      }
    }
    v63 = v62;
    jhl_vpn_link_uptime(v62, v6);
    v30 = snprintf(&a1[v11], a2 - v11, "\"vpn_time\":\"%s\",", v63);
    if ( v30 >= a2 - v11 )
      v30 = a2 - v11 - 1;
    v32 = v30 + v11;
    v31 = jhl_vpnget(v68 - 19164, v6);
    v34 = a2 - v32;
    v33 = nvram_get(v31);
    if ( !v33 )
      v33 = (int)(v70 + 14076);
    v63 = &a1[v32];
    v35 = J_atoi(v33);
    v36 = snprintf(v63, a2 - v32, v69, v35 + 1);
    if ( v36 >= v34 )
      v36 = v34 - 1;
    v38 = v36 + v32;
    v37 = jhl_vpnget("vpn_localip", v6);
    v40 = a2 - v38;
    v39 = (const char *)nvram_get(v37);
    if ( !v39 )
      v39 = " ";
    v41 = snprintf(&a1[v38], a2 - v38, "\"vpn_localip\":\"%s\",", v39);
    if ( v41 >= v40 )
      v41 = v40 - 1;
    v43 = v41 + v38;
    v42 = jhl_vpnget("vpn_peerip", v6);
    v45 = a2 - v43;
    v44 = (const char *)nvram_get(v42);
    if ( !v44 )
      v44 = " ";
    v46 = snprintf(&a1[v43], a2 - v43, "\"vpn_peerip\":\"%s\",", v44);
    if ( v46 >= v45 )
      v46 = v45 - 1;
    v48 = v46 + v43;
    v47 = jhl_vpnget(&unk_645880, v6);
    v50 = a2 - v48;
    v49 = (const char *)nvram_get(v47);
    if ( !v49 )
      v49 = " ";
    v51 = snprintf(&a1[v48], a2 - v48, "\"vpn_link\":\"%s\",", v49);
    if ( v51 >= v50 )
      v51 = v50 - 1;
    v53 = v51 + v48;
    v52 = jhl_vpnget("vpn_run_mtu", v6);
    v55 = a2 - v53;
    v54 = (const char *)nvram_get(v52);
    if ( !v54 )
      v54 = " ";
    v56 = snprintf(&a1[v53], a2 - v53, "\"vpn_run_mtu\":\"%s\",", v54);
    if ( v56 >= v55 )
      v56 = v55 - 1;
    v11 = v56 + v53;
    v57 = jhl_vpnget("vpn_get_dns", v6);
    v59 = a2 - v11;
    v58 = (const char *)nvram_get(v57);
    if ( !v58 )
      v58 = " ";
    v29 = snprintf(&a1[v11], a2 - v11, "\"vpn_get_dns\":\"%s\",", v58);
    if ( v29 >= v59 )
      v29 = v59 - 1;
LABEL_32:
    v11 += v29;
    goto LABEL_8;
  }
LABEL_15:
  v15 = &a1[v5];
  if ( v5 > 0 && *(v15 - 1) == 44 )
    v15 = &a1[--v5];
  v16 = a2 - v5;
  *v15 = 0;
  v17 = snprintf(v15, v16, "],");
  if ( v17 >= v16 )
    v17 = v16 - 1;
  return v5 + v17;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004905B8) --------------------------------------------------------
int __fastcall sub_4905B8(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  char *v5; // $v1
  int v6; // $s1
  int v7; // $v0
  int v8; // $a2
  int result; // $v0
  const char *v10; // $v0
  unsigned int v11; // $v0
  char v12[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(0x200000, "vpn_client_data", 1631);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v4 = get_vpn_nvarms((const char **)vpn_parms, (char *)(v2 + 29), 2097123);
    v5 = &v3[v4 + 29];
    strcpy(v5, "\"wans_all\":");
    strcpy(v5, "\"wans_all\":");
    v6 = v4 + 40 + get_wans_data(&v3[v4 + 40], 0x200000 - (v4 + 40));
    v7 = snprintf(&v3[v6], 0x200000 - v6, "}}");
    if ( v7 >= 0x200000 - v6 )
      v8 = 0x1FFFFF - v6;
    else
      v8 = v7;
    result = httpd_cgi_ret(a1, v3, v8 + v6, 8);
  }
  else
  {
    v10 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v11 = snprintf(v12, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
    if ( v11 >= 0x100 )
      v11 = 255;
    result = httpd_cgi_ret(a1, v12, v11, 4);
  }
  return result;
}
// 490608: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 672EA0: using guessed type char *vpn_parms[3];
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004907EC) --------------------------------------------------------
int __fastcall sub_4907EC(int a1)
{
  int v1; // $a0
  int v2; // $v0
  int v3; // $s0
  int v4; // $v0
  _DWORD *v5; // $s0
  int v6; // $s4
  char *v7; // $s2
  int v8; // $s6
  int v9; // $s5
  const char *v10; // $s1
  char *v11; // $v1
  int v12; // $v0
  const char *v13; // $v0
  char *v15; // $v1
  const char *v16; // $v0
  int v17; // $t0
  int v18; // $a3
  int v19; // $a2
  int v20; // $a1
  int v22; // $v0
  const char *v23; // $v0
  int v24; // $v0
  int v25; // $v0
  int v26; // $v0
  int v27; // $v0
  const char *v28; // $v0
  int v29; // $v0
  int v30; // $v0
  int v31; // $v0
  int v32; // $v0
  int v33; // $v0
  const char *v34; // $v0
  int v35; // $v0
  char v36[1024]; // [sp+18h] [-460h] BYREF
  int v37[8]; // [sp+418h] [-60h] BYREF
  int v38[6]; // [sp+438h] [-40h] BYREF
  char *v39; // [sp+450h] [-28h]
  int v40; // [sp+454h] [-24h]
  int v41; // [sp+458h] [-20h]
  char *v42; // [sp+45Ch] [-1Ch]
  char *v43; // [sp+460h] [-18h]
  char *v44; // [sp+464h] [-14h]
  int v45; // [sp+468h] [-10h]
  int v46; // [sp+46Ch] [-Ch]
  char *v47; // [sp+470h] [-8h]
  char *v48; // [sp+474h] [-4h]

  v48 = v36;
  memset(v36, 0, sizeof(v36));
  v45 = httpd_get_json_parm(a1, (int)"wans");
  v46 = cJSON_GetArraySize(v45);
  if ( v46 <= 0 )
    goto LABEL_21;
  v42 = "1\"";
  v44 = "a";
  v40 = 0;
  v39 = "l2tp";
  do
  {
    v3 = cJSON_GetArrayItem(v45, v40);
    v2 = cJSON_GetObjectItem(v3, "iface");
    v4 = cJSON_GetIntvalue(v2);
    v5 = *(_DWORD **)(v3 + 8);
    v6 = v4;
    if ( !v5 )
      continue;
    v7 = (char *)v5[4];
    v8 = 0;
    if ( !v7 )
      continue;
    v41 = 0;
    v9 = 0;
    v43 = 0;
    do
    {
      v10 = (const char *)v5[8];
      if ( !strcmp(v10, "iface") )
        goto LABEL_15;
      if ( !strcmp(v10, "vpnqos_dk") )
      {
        v8 = (int)v7;
      }
      else
      {
        v22 = jhl_vpnget(v10, v6);
        v23 = (const char *)nvram_get(v22);
        if ( !v23 || strcmp(v23, v7) )
        {
          v24 = strcmp(v10, v44 + 10188);
          v11 = "a";
          if ( v24 )
          {
            v47 = "a";
            v32 = jhl_vpnget(v10, v6);
            nvram_set(v32, v7);
            v41 = 1;
            v11 = v47;
          }
          else
          {
            v43 = v7;
            v41 = 1;
          }
          goto LABEL_10;
        }
      }
      v11 = "a";
LABEL_10:
      v12 = jhl_vpnget(v11 + 10188, v6);
      v13 = (const char *)nvram_get(v12);
      if ( v13 && !strcmp(v13, v39) )
        v9 = 1;
      if ( !strcmp(v10, "ipsec_l2tp_cli_enable") || !strcmp(v10, v42 - 18968) )
        v9 = 1;
LABEL_15:
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        break;
      v7 = (char *)v5[4];
    }
    while ( v7 );
    if ( v8 )
      qos_parm_apply(v6 + 101, v8, 1);
    if ( v41 )
    {
      v37[0] = 0;
      v37[1] = 0;
      v37[2] = 0;
      v37[3] = 0;
      v37[4] = 0;
      v37[5] = 0;
      v37[6] = 0;
      v37[7] = 0;
      sprintf((char *)v37, "%d", v6);
      v25 = jhl_vpnget("vpn_new_proto", v6);
      nvram_unset(v25);
      v26 = jhl_vpnget("vpn_ipsec_l2tp", v6);
      if ( v9 )
        nvram_set(v26, "1");
      else
        nvram_unset(v26);
      if ( v43 )
      {
        if ( !strcmp(v43, v39) )
        {
          v33 = jhl_vpnget("vpn_port", v6);
          nvram_set(v33, "1701");
          v34 = (const char *)nvram_get("l2tpd_en");
          if ( v34 && !strcmp(v34, "1") )
          {
            nvram_set("l2tpd_en", "0");
            jhl_stop_l2tpd_srv();
          }
        }
        else if ( !strcmp(v43, "pptp") )
        {
          v35 = jhl_vpnget("vpn_port", v6);
          nvram_set(v35, "1723");
        }
        v27 = jhl_vpnget(v44 + 10188, v6);
        v28 = (const char *)nvram_get(v27);
        if ( !v28 || strcmp(v28, v43) )
        {
          v29 = jhl_vpnget("vpn_new_proto", v6);
          nvram_set(v29, v43);
        }
      }
      v30 = jhl_vpnget("vpn_conn_cnt", v6);
      nvram_set_int(v30, 0);
      v31 = jhl_vpnget("vpn_run_wan", v6);
      nvram_unset(v31);
      v38[0] = (int)"vpn_conn";
      v38[1] = (int)"restart";
      v38[2] = (int)v37;
      v38[3] = (int)"vpn_client_asp";
      v38[4] = 0;
      eval_nowait(v38, 0, 0, 0);
    }
  }
  while ( v46 != ++v40 );
LABEL_21:
  jhl_parm_commit(v1);
  v15 = v48;
  v16 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v17 = *(_DWORD *)v16;
    v18 = *((_DWORD *)v16 + 1);
    v19 = *((_DWORD *)v16 + 2);
    v20 = *((_DWORD *)v16 + 3);
    v16 += 16;
    *(_DWORD *)v15 = v17;
    *((_DWORD *)v15 + 1) = v18;
    *((_DWORD *)v15 + 2) = v19;
    *((_DWORD *)v15 + 3) = v20;
    v15 += 16;
  }
  while ( v16 != "}" );
  *(_WORD *)v15 = *(_WORD *)v16;
  return httpd_cgi_ret(a1, v48, 33, 4);
}
// 490A6C: variable 'v1' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81F0: using guessed type int jhl_stop_l2tpd_srv(void);
// 6A8518: using guessed type int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A86FC: using guessed type int __fastcall cJSON_GetArraySize(_DWORD);
// 6A8744: using guessed type int __fastcall cJSON_GetIntvalue(_DWORD);
// 6A878C: using guessed type int __fastcall nvram_set_int(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (00490F1C) --------------------------------------------------------
int __fastcall sub_490F1C(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  int v5; // $s1
  char *v6; // $a0
  int v7; // $v0
  int v8; // $a2
  int result; // $v0
  const char *v10; // $v0
  unsigned int v11; // $v0
  char v12[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(0x200000, "vpn_state_data", 1770);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v2, "{\"code\":0,\"error", 16);
    *(_DWORD *)(v2 + 24) = 975331700;
    v4 = get_vpn_state((char *)(v2 + 29), 2097123);
    v5 = v4 + 29;
    v6 = &v3[v4 + 29];
    if ( v4 + 29 > 0 && *(v6 - 1) == 44 )
    {
      v5 = v4 + 28;
      v6 = &v3[v4 + 28];
    }
    *v6 = 0;
    v7 = snprintf(v6, 0x200000 - v5, "}}");
    if ( v7 >= 0x200000 - v5 )
      v8 = 0x1FFFFF - v5;
    else
      v8 = v7;
    result = httpd_cgi_ret(a1, v3, v5 + v8, 8);
  }
  else
  {
    v10 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v11 = snprintf(v12, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
    if ( v11 >= 0x100 )
      v11 = 255;
    result = httpd_cgi_ret(a1, v12, v11, 4);
  }
  return result;
}
// 490F6C: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00491124) --------------------------------------------------------
int __fastcall sub_491124(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $s4
  char *v5; // $v1
  const char *v6; // $v0
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  int v10; // $a1
  const char *v12; // $s3
  char v13[512]; // [sp+18h] [-218h] BYREF
  int v14[6]; // [sp+218h] [-18h] BYREF

  memset(v13, 0, sizeof(v13));
  v3 = httpd_get_parm(a1, "act");
  v2 = httpd_get_parm(a1, "action_iface");
  if ( v3 )
  {
    v4 = (int)v2;
    if ( !strcmp(v3, "stop") )
    {
      v12 = "stop";
    }
    else
    {
      if ( strcmp(v3, "restart") )
        goto LABEL_4;
      v12 = "restart";
    }
    v14[0] = (int)"vpn_conn";
    v14[1] = (int)v12;
    v14[2] = v4;
    v14[3] = (int)"vpn_connect_asp";
    v14[4] = 0;
    eval_nowait(v14, 0, 0, 0);
  }
LABEL_4:
  v5 = v13;
  v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v7 = *(_DWORD *)v6;
    v8 = *((_DWORD *)v6 + 1);
    v9 = *((_DWORD *)v6 + 2);
    v10 = *((_DWORD *)v6 + 3);
    v6 += 16;
    *(_DWORD *)v5 = v7;
    *((_DWORD *)v5 + 1) = v8;
    *((_DWORD *)v5 + 2) = v9;
    *((_DWORD *)v5 + 3) = v10;
    v5 += 16;
  }
  while ( v6 != "}" );
  *(_WORD *)v5 = *(_WORD *)v6;
  return httpd_cgi_ret(a1, v13, 33, 4);
}
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004912C4) --------------------------------------------------------
int __fastcall get_vpns_iface(_BYTE *a1)
{
  int v2; // $s6
  int v3; // $s0
  int v4; // $s1
  int v5; // $v0
  const char *v6; // $v0
  int v7; // $v1
  int v8; // $v0
  _BYTE *v9; // $s2

  v2 = sq_file_get_max_wan();
  *a1 = 91;
  a1[1] = 0;
  if ( v2 <= 0 )
  {
    v8 = 0;
    v7 = 1;
    v4 = 1;
LABEL_10:
    if ( a1[v8] == 44 )
      v7 = --v4;
    goto LABEL_12;
  }
  v3 = 0;
  v4 = 1;
  do
  {
    v5 = jhl_vpnget("vpn_proto", v3);
    v6 = (const char *)nvram_get(v5);
    if ( !v6 || strcmp(v6, (const char *)&off_63F984) )
      v4 += sprintf(&a1[v4], "{\"iface\":%d},", v3);
    ++v3;
  }
  while ( v3 != 5 && v2 != v3 );
  v7 = v4;
  if ( v4 > 0 )
  {
    v8 = v4 - 1;
    goto LABEL_10;
  }
LABEL_12:
  v9 = &a1[v7];
  *v9 = 93;
  v9[1] = 0;
  return v4 + 1;
}
// 63F984: using guessed type void *off_63F984;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (00491440) --------------------------------------------------------
int __fastcall dns_more_rule_check_used_group(int a1, int a2)
{
  void *v3; // $v0
  int v4; // $s1
  void *v5; // $s0
  int v6; // $v0
  int v7; // $s1

  v4 = 4 - (a2 != 0);
  _mem_malloc(0x200000, "dns_more_rule_check_used_group", 56);
  if ( !v3 )
    return 0;
  v5 = v3;
  jhl_parm_get("dns_more_dnswan_rule", v3, 0x200000);
  v6 = nvparm_find_str(v5, 60, 4096, a1, 124, v4);
  v7 = 0;
  if ( v6 )
    v7 = 116;
  _mem_free(v5);
  return v7;
}
// 491494: variable 'v3' is possibly undefined
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (00491544) --------------------------------------------------------
int __fastcall dns_more_dnstype_is_used(int a1)
{
  return dns_more_rule_check_used_group(a1, 1);
}

//----- (00491560) --------------------------------------------------------
int __fastcall dns_more_dnswan_is_used(const char *a1)
{
  const char *v2; // $v0
  bool v3; // dc
  int result; // $v0

  v2 = (const char *)nvram_get("dns_more_def_out");
  if ( !v2 || !a1 || (v3 = strcmp(v2, a1) == 0, result = 117, !v3) )
    result = dns_more_rule_check_used_group((int)a1, 0);
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (004915EC) --------------------------------------------------------
void __fastcall format_dns_more_dnswan_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 4 )
    snprintf(a3, a4, "{\"n\":\"%s\",\"id\":\"%s\",\"dns\":\"%s\",\"wans\":\"%s\"},", *a1, a1[1], a1[2], a1[3]);
}

//----- (0049167C) --------------------------------------------------------
void __fastcall format_dns_more_dnswan_rule_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 6 )
    snprintf(
      a3,
      a4,
      "{\"n\":\"%s\",\"en\":%s,\"hi\":%s,\"dns\":%s,\"wan\":%s,\"pri\":%s},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5]);
}

//----- (0049171C) --------------------------------------------------------
int __fastcall get_dns_more_dnswan_data(char *a1, int a2)
{
  int v4; // $s2
  int v5; // $s0
  const char **v6; // $s4
  void *v7; // $v0
  _DWORD *v8; // $s7
  void *v9; // $fp
  int v10; // $s6
  _DWORD *v11; // $s3
  int i; // $s2
  int v13; // $v0
  int v14; // $v0
  char *v15; // $a0
  int v16; // $s1
  int v17; // $v0

  v4 = nvram_get("dns_more_dnswan");
  v5 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v5 >= a2 )
    v5 = a2 - 1;
  if ( v4 )
  {
    v6 = (const char **)malloc(0x18u);
    v8 = malloc(0x4008u);
    v7 = malloc(0x200000u);
    v9 = v7;
    if ( v7 )
    {
      if ( v6 )
      {
        if ( v8 )
        {
          strlcpy(v7, v4, 0x200000);
          v10 = split_string(v9, 60, v8, 4096);
          if ( v10 > 0 )
          {
            v11 = v8;
            for ( i = 0; i != v10; ++i )
            {
              v13 = split_string(*v11, 124, v6, 4);
              format_dns_more_dnswan_data(v6, v13, &a1[v5], a2 - v5);
              v5 += v14;
              ++v11;
            }
          }
        }
      }
      free(v9);
    }
    if ( v6 )
      free(v6);
    if ( v8 )
      free(v8);
  }
  v15 = &a1[v5];
  if ( v5 > 0 && *(v15 - 1) == 44 )
    v15 = &a1[--v5];
  v16 = a2 - v5;
  *v15 = 0;
  v17 = snprintf(v15, v16, &byte_6445A0);
  if ( v17 >= v16 )
    v17 = v16 - 1;
  return v5 + v17;
}
// 491888: variable 'v14' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00491964) --------------------------------------------------------
int __fastcall sub_491964(int a1)
{
  int v1; // $v0
  char *v2; // $fp
  const char *v3; // $v0
  int v4; // $v0
  const char *v5; // $v0
  int v6; // $s1
  int v7; // $v0
  int v8; // $s1
  int v9; // $v0
  int v10; // $s1
  int v11; // $v0
  int v12; // $s1
  int v13; // $v0
  int v14; // $s1
  int v15; // $v0
  int v16; // $s3
  int v17; // $s1
  char *v18; // $s4
  int v19; // $s5
  int v20; // $s0
  const char **v21; // $s2
  void *v22; // $v0
  _DWORD *v23; // $s6
  int v24; // $a1
  void *v25; // $s5
  int v26; // $s5
  int i; // $s7
  int v28; // $v0
  int v29; // $v0
  char *v30; // $a0
  int v31; // $s1
  int v32; // $v0
  int v33; // $s3
  int v34; // $v0
  int v35; // $a2
  int result; // $v0
  const char *v37; // $v0
  unsigned int v38; // $v0
  char v39[256]; // [sp+20h] [-108h] BYREF
  _DWORD *v40; // [sp+120h] [-8h]
  void *ptr; // [sp+124h] [-4h]

  _mem_malloc(1024000, "dns_more_dnswan_rule_data", 156);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    v3 = (const char *)jhl_nv_get_def("dns_more_def_out");
    v4 = snprintf(v2 + 29, 1023971, "\"def_out\":\"%s\"", v3);
    if ( v4 >= 1023971 )
      v4 = 1023970;
    v6 = v4 + 29;
    v5 = (const char *)jhl_nv_get_def("dns_more_def_pri");
    v7 = snprintf(&v2[v6], 1024000 - v6, ",\"pri\":\"%s\"", v5);
    if ( v7 >= 1024000 - v6 )
      v7 = 1023999 - v6;
    v8 = v7 + v6;
    v9 = snprintf(&v2[v8], 1024000 - v8, ",\"userzu\":");
    if ( v9 >= 1024000 - v8 )
      v9 = 1023999 - v8;
    v10 = v9 + v8 + get_ips_group_data(&v2[v9 + v8], 1024000 - (v9 + v8));
    v11 = snprintf(&v2[v10], 1024000 - v10, ",\"dnszu\":");
    if ( v11 >= 1024000 - v10 )
      v11 = 1023999 - v10;
    v12 = v11 + v10 + dns_more_dnstype_get_json(&v2[v11 + v10], 1024000 - (v11 + v10));
    v13 = snprintf(&v2[v12], 1024000 - v12, ",\"outzu\":");
    if ( v13 >= 1024000 - v12 )
      v13 = 1023999 - v12;
    v14 = v13 + v12 + get_dns_more_dnswan_data(&v2[v13 + v12], 1024000 - (v13 + v12));
    v15 = snprintf(&v2[v14], 1024000 - v14, ",\"all\":");
    if ( v15 >= 1024000 - v14 )
      v15 = 1023999 - v14;
    v16 = v15 + v14;
    v17 = 1024000 - (v15 + v14);
    v18 = &v2[v16];
    v19 = nvram_get("dns_more_dnswan_rule");
    v20 = snprintf(&v2[v16], 1024000 - v16, (char *)&word_642A04);
    if ( v20 >= 1024000 - v16 )
      v20 = 1023999 - v16;
    if ( v19 )
    {
      v21 = (const char **)malloc(0x20u);
      v40 = malloc(0x4008u);
      v23 = v40;
      v22 = malloc(0x200000u);
      ptr = v22;
      if ( v22 )
      {
        if ( v21 )
        {
          v24 = v19;
          if ( v40 )
          {
            v25 = v22;
            strlcpy(v22, v24, 0x200000);
            v26 = split_string(v25, 60, v40, 4096);
            if ( v26 > 0 )
            {
              for ( i = 0; i != v26; ++i )
              {
                v28 = split_string(*v23, 124, v21, 6);
                format_dns_more_dnswan_rule_data(v21, v28, &v18[v20], v17 - v20);
                v20 += v29;
                ++v23;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v21 )
        free(v21);
      if ( v40 )
        free(v40);
    }
    v30 = &v18[v20];
    if ( v20 > 0 && *(v30 - 1) == 44 )
      v30 = &v18[--v20];
    v31 = v17 - v20;
    *v30 = 0;
    v32 = snprintf(v30, v31, &byte_6445A0);
    if ( v32 >= v31 )
      v32 = v31 - 1;
    v33 = v20 + v32 + v16;
    v34 = snprintf(&v2[v33], 1024000 - v33, "}}");
    if ( v34 >= 1024000 - v33 )
      v35 = 1023999 - v33;
    else
      v35 = v34;
    result = httpd_cgi_ret(a1, v2, v35 + v33, 8);
  }
  else
  {
    v37 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v38 = snprintf(v39, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v37);
    if ( v38 >= 0x100 )
      v38 = 255;
    result = httpd_cgi_ret(a1, v39, v38, 4);
  }
  return result;
}
// 4919C8: variable 'v1' is possibly undefined
// 491D50: variable 'v29' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8934: using guessed type int __fastcall dns_more_dnstype_get_json(_DWORD, _DWORD);

//----- (00491F24) --------------------------------------------------------
int __fastcall sub_491F24(int a1)
{
  char *v2; // $s7
  char *v3; // $s6
  char *v4; // $s1
  int v5; // $s5
  char *v6; // $v0
  char *v7; // $v0
  char *v8; // $s2
  char *v9; // $s4
  int v10; // $v0
  char *v11; // $s6
  int v12; // $a0
  char *v13; // $s1
  const char **v14; // $v1
  const char *v15; // $v0
  const char *v16; // $t0
  const char *v17; // $a3
  const char *v18; // $a2
  const char *v19; // $a1
  int v20; // $fp
  char *v22; // $v0
  const char *v23; // $v0
  const char *v24; // $v0
  const char *v25; // $v0
  int v26; // $a0
  const char *v27; // $t0
  const char *v28; // $a3
  const char *v29; // $a2
  const char *v30; // $a1
  _DWORD *v31; // $s7
  const char *v32; // $v0
  int v33; // $v0
  int v34; // $a1
  const char *v35; // $a2
  int v36; // $a0
  const char *v37; // $v0
  const char *s; // [sp+28h] [-468h] BYREF
  const char *v39; // [sp+2Ch] [-464h]
  char *v40; // [sp+30h] [-460h]
  char *v41; // [sp+34h] [-45Ch]
  char *v42; // [sp+38h] [-458h]
  char *v43; // [sp+3Ch] [-454h]
  int v44; // [sp+40h] [-450h]
  int v45; // [sp+44h] [-44Ch]
  const char *v46; // [sp+428h] [-68h] BYREF
  const char *v47; // [sp+42Ch] [-64h]
  const char *v48; // [sp+430h] [-60h]
  char *v49; // [sp+434h] [-5Ch]
  char *v50; // [sp+438h] [-58h]
  const char *v51; // [sp+43Ch] [-54h]
  const char *v52; // [sp+440h] [-50h]
  const char *v53; // [sp+444h] [-4Ch]
  const char *v54; // [sp+448h] [-48h]
  int v55; // [sp+44Ch] [-44h]
  char *v56; // [sp+450h] [-40h] BYREF
  char *v57; // [sp+454h] [-3Ch]
  const char *v58; // [sp+458h] [-38h]
  const char *v59; // [sp+45Ch] [-34h]
  char *v60; // [sp+460h] [-30h]
  const char *v61; // [sp+464h] [-2Ch]
  int v62; // [sp+468h] [-28h]
  int v63; // [sp+46Ch] [-24h]
  int v64; // [sp+470h] [-20h]
  char *v65; // [sp+474h] [-1Ch]
  char *v66; // [sp+478h] [-18h]
  char *v67; // [sp+47Ch] [-14h]
  char *v68; // [sp+480h] [-10h]
  char *v69; // [sp+484h] [-Ch]
  char *v70; // [sp+488h] [-8h]

  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v2 = httpd_get_parm(a1, "name");
  v66 = httpd_get_parm(a1, "old_name");
  v64 = (int)httpd_get_parm(a1, "en");
  v67 = httpd_get_parm(a1, "rpri");
  v68 = httpd_get_parm(a1, "userzu");
  v69 = httpd_get_parm(a1, "dnszu");
  v3 = httpd_get_parm(a1, "outzu");
  v4 = httpd_get_parm(a1, "opt");
  v5 = httpd_get_json_parm(a1, (int)"del_list");
  _mem_malloc(102400, "dns_more_dnswan_rule_asp", 228);
  v8 = v7;
  _mem_malloc(102400, "dns_more_dnswan_rule_asp", 229);
  v9 = v6;
  if ( v8 && v6 )
  {
    v10 = a1 + 196608;
    if ( !v4 )
    {
LABEL_61:
      v34 = *(unsigned __int8 *)(v10 + 13494);
      v35 = "not opt";
LABEL_62:
      v36 = 12;
      goto LABEL_63;
    }
    v65 = "a";
    if ( !strcmp(v4, (const char *)&off_646D8C) || !strcmp(v4, (const char *)&off_648DDC) )
    {
      if ( !strcmp(v4, (const char *)&off_64712C) )
        goto LABEL_8;
      v70 = "1\"";
      if ( strcmp(v4, "del") )
        goto LABEL_18;
    }
    else
    {
      v70 = "1\"";
      if ( strcmp(v4, "del") )
      {
        if ( !strcmp(v4, (const char *)&off_64712C) )
        {
LABEL_8:
          v11 = httpd_get_parm(a1, "def_out");
          v13 = httpd_get_parm(a1, (char *)&off_645B94);
          if ( v11 )
          {
            nvram_set("dns_more_def_out", v11);
            s = "wys";
            v39 = "dns_more";
            v40 = "dnswan";
            v41 = "set_def";
            v42 = v11;
            v43 = 0;
            eval(&s, 0, 0, 0);
          }
          if ( v13 )
          {
            nvram_set("dns_more_def_pri", v13);
            s = "wys";
            v39 = "dns_more";
            v41 = "set";
            v40 = "opt";
            v42 = "on";
            v43 = v13;
            v44 = jhl_nv_get_def("dnsMaxtm");
            v45 = 0;
            eval(&s, 0, 0, 0);
          }
          jhl_parm_commit(v12);
          v14 = &s;
          v15 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          do
          {
            v16 = *(const char **)v15;
            v17 = (const char *)*((_DWORD *)v15 + 1);
            v18 = (const char *)*((_DWORD *)v15 + 2);
            v19 = (const char *)*((_DWORD *)v15 + 3);
            v15 += 16;
            *v14 = v16;
            v14[1] = v17;
            v14[2] = v18;
            v14[3] = v19;
            v14 += 4;
          }
          while ( v15 != "}" );
          goto LABEL_14;
        }
        v10 = a1 + 196608;
        goto LABEL_61;
      }
      if ( !strcmp(v4, (const char *)&off_64712C) )
        goto LABEL_8;
    }
    if ( v5 && cJSON_IsArray(v5) )
    {
      v31 = *(_DWORD **)(v5 + 8);
      if ( !v31 )
        goto LABEL_40;
      v32 = (const char *)v31[4];
      if ( !v32 )
        goto LABEL_40;
      v64 = 0;
      do
      {
        v56 = (char *)v32;
        if ( set_dns_more_dnswan_rule_to_kernel(v4, &v56) >= 0 )
        {
          jhl_parm_get("dns_more_dnswan_rule", v8, 102400);
          if ( nvparm_del_str(v8, 60, 6, v31[4], 124, 0, v9) )
          {
            jhl_parm_set("dns_more_dnswan_rule", v9);
            v64 = 1;
          }
        }
        v31 = (_DWORD *)*v31;
        if ( !v31 )
          break;
        v32 = (const char *)v31[4];
      }
      while ( v32 );
      if ( !v64 )
        goto LABEL_40;
      goto LABEL_39;
    }
LABEL_18:
    if ( !v2 )
    {
      v34 = *(unsigned __int8 *)(a1 + 210102);
      v35 = (const char *)&unk_6442E4;
      goto LABEL_62;
    }
    v56 = v2;
    if ( !strcmp(v4, v65 + 28044) )
    {
      jhl_parm_get("dns_more_dnswan_rule", v9, 102400);
      if ( nvparm_find_str(v9, 60, 8, v56, 124, 0) )
      {
        v34 = *(unsigned __int8 *)(a1 + 210102);
        v35 = "same name";
        goto LABEL_62;
      }
      v20 = check_rule_num_limit(a1, 3, (int)"dns_more_dnswan_rule", 60, (char *)&s, 0x400u);
      if ( v20 > 0 )
        goto LABEL_15;
    }
    else if ( strcmp(v4, (const char *)&off_648DDC) )
    {
      goto LABEL_40;
    }
    v22 = (char *)v64;
    if ( !v64 )
      v22 = "1";
    v57 = v22;
    v23 = v68;
    if ( !v68 )
      v23 = "0";
    v58 = v23;
    v24 = v69;
    if ( !v69 )
      v24 = "0";
    v59 = v24;
    if ( !v3 )
      v3 = "0";
    v25 = v67;
    v60 = v3;
    if ( !v67 )
      v25 = "3000";
    v61 = v25;
    if ( v66 )
    {
      v64 = (int)&v46;
      v50 = v66;
      v46 = "wys";
      v47 = "dns_more";
      v48 = "dnswan_rule";
      v49 = v70 - 15196;
      v51 = 0;
      eval(&v46, 0, 0, 0);
      if ( !strcmp(v57, "1") )
      {
        v49 = v65 + 28044;
        v50 = v56;
        v51 = v58;
        v52 = v59;
        v53 = v60;
        v46 = "wys";
        v47 = "dns_more";
        v48 = "dnswan_rule";
        v54 = v61;
        v55 = 0;
        eval(v64, 0, 0, 0);
      }
      if ( strcmp(v4, (const char *)&off_648DDC) )
        goto LABEL_36;
      jhl_parm_get("dns_more_dnswan_rule", v8, 102400);
      v33 = nvparm_del_str(v8, 60, 8, v66, 124, 0, v9);
      goto LABEL_58;
    }
    if ( set_dns_more_dnswan_rule_to_kernel(v4, &v56) >= 0 )
    {
      if ( strcmp(v4, (const char *)&off_648DDC) )
        goto LABEL_36;
      jhl_parm_get("dns_more_dnswan_rule", v8, 102400);
      v33 = nvparm_del_str(v8, 60, 8, v2, 124, 0, v9);
LABEL_58:
      if ( v33 )
      {
        sprintf(v8, "%s|%s|%s|%s|%s|%s<", v56, v57, v58, v59, v60, v61);
LABEL_38:
        strcat(v9, v8);
LABEL_39:
        jhl_parm_set("dns_more_dnswan_rule", v9);
        jhl_parm_commit(v26);
        goto LABEL_40;
      }
LABEL_36:
      sprintf(v8, "%s|%s|%s|%s|%s|%s<", v56, v57, v58, v59, v60, v61);
      jhl_parm_get("dns_more_dnswan_rule", v9, 102400);
      if ( !strcmp(v9, " ") )
        *v9 = 0;
      goto LABEL_38;
    }
LABEL_40:
    v14 = &s;
    v15 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v27 = *(const char **)v15;
      v28 = (const char *)*((_DWORD *)v15 + 1);
      v29 = (const char *)*((_DWORD *)v15 + 2);
      v30 = (const char *)*((_DWORD *)v15 + 3);
      v15 += 16;
      *v14 = v27;
      v14[1] = v28;
      v14[2] = v29;
      v14[3] = v30;
      v14 += 4;
    }
    while ( v15 != "}" );
LABEL_14:
    v20 = 33;
    *(_WORD *)v14 = *(_WORD *)v15;
    goto LABEL_15;
  }
  v34 = *(unsigned __int8 *)(a1 + 210102);
  v35 = (const char *)102400;
  v36 = 4;
LABEL_63:
  v37 = (const char *)_GET_LANG_TEXT(v36, v34, v35);
  v20 = snprintf((char *)&s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v37);
  if ( (unsigned int)v20 >= 0x400 )
    v20 = 1023;
LABEL_15:
  _mem_free(v8);
  _mem_free(v9);
  return httpd_cgi_ret(a1, (char *)&s, v20, 4);
}
// 4920B0: variable 'v7' is possibly undefined
// 4920BC: variable 'v6' is possibly undefined
// 4922A0: variable 'v12' is possibly undefined
// 492620: variable 'v26' is possibly undefined
// 645B94: using guessed type void *off_645B94;
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85F8: using guessed type int __fastcall set_dns_more_dnswan_rule_to_kernel(_DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00492A4C) --------------------------------------------------------
int __fastcall dns_more_check_data(int a1)
{
  const char *v2; // $s1
  const char *v3; // $s0
  const char *v4; // $v0
  int v5; // $s1
  unsigned int v6; // $v0
  char v8[1028]; // [sp+20h] [-404h] BYREF

  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("dns_more_check_en");
  v3 = (const char *)jhl_nv_get_def("dns_more_check_path2");
  v4 = (const char *)jhl_nv_get_def("dns_more_modify_time");
  v5 = sprintf(&v8[29], "\"enable\":%s,\"srv_path\":\"%s\",\"mod_time\":\"%s\"", v2, v3, v4) + 29;
  v6 = snprintf(&v8[v5], 1024 - v5, "}}");
  if ( v6 >= 1024 - v5 )
    v6 = 1023 - v5;
  return httpd_cgi_ret(a1, v8, v6 + v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (00492BA4) --------------------------------------------------------
int __fastcall sub_492BA4(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  const char *v4; // $s0
  const char *v5; // $v0
  int v6; // $s3
  const char *v7; // $v0
  int v8; // $a0

  v3 = httpd_get_parm(a1, "enable");
  v2 = httpd_get_parm(a1, "srv_path");
  v4 = v2;
  if ( v3 )
  {
    v5 = (const char *)nvram_get("dns_more_check_en");
    if ( !v5 || strcmp(v5, v3) )
    {
      nvram_set("dns_more_check_en", v3);
      v6 = 1;
      if ( !v4 )
      {
LABEL_8:
        exec_service("dns_more_check-restart");
        jhl_parm_commit(v8);
        return dns_more_check_data(a1);
      }
LABEL_5:
      v7 = (const char *)nvram_get("dns_more_check_path2");
      if ( v7 && !strcmp(v7, v4) )
      {
        if ( !v6 )
          return dns_more_check_data(a1);
      }
      else
      {
        nvram_set("dns_more_check_path2", v4);
      }
      goto LABEL_8;
    }
    if ( !v4 )
      return dns_more_check_data(a1);
LABEL_11:
    v6 = 0;
    goto LABEL_5;
  }
  if ( v2 )
    goto LABEL_11;
  return dns_more_check_data(a1);
}
// 492CD8: variable 'v8' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (00492D6C) --------------------------------------------------------
int __fastcall dns_more_dnstype_search(_WORD *a1, size_t a2, int a3)
{
  int v6; // $a1
  int v7; // $a2
  bool v8; // dc
  int result; // $v0
  int v10; // $v1
  int v11[256]; // [sp+20h] [-400h] BYREF

  memset(v11, 0, sizeof(v11));
  v11[0] = 58;
  v11[3] = 22;
  v11[1] = 1024;
  strlcpy(&v11[4], a3, 128);
  v6 = v11[1];
  *a1 = 91;
  v8 = jianhl_order_opt_fun(v11, v6, v7) == 0;
  result = 2;
  if ( v8 )
  {
    memset(a1, 0, a2);
    if ( BYTE2(v11[36]) )
    {
      v10 = sprintf(
              (char *)a1,
              "{\"dns\":\"%s\",\"name\":\"%s\",\"sys\":%d}",
              (const char *)&v11[4],
              (const char *)&v11[36] + 2,
              BYTE1(v11[36]));
      result = v10 + 1;
    }
    else
    {
      result = 1;
      v10 = 0;
    }
  }
  else
  {
    v10 = 1;
  }
  *(_WORD *)((char *)a1 + v10) = 93;
  return result;
}
// 492E08: variable 'v7' is possibly undefined
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00492EAC) --------------------------------------------------------
int __fastcall sub_492EAC(int a1)
{
  char *v2; // $v0
  char *v3; // $s2
  char *v4; // $s0
  const char *v5; // $v0
  int v6; // $s1
  int v7; // $s1
  int v8; // $v0
  int v9; // $a2
  int result; // $v0
  const char *v11; // $v0
  unsigned int v12; // $v0
  char v13[256]; // [sp+20h] [-100h] BYREF

  v3 = httpd_get_parm(a1, "name");
  _mem_malloc(102400, "dns_more_dnstype_data", 474);
  v4 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error", 16);
    v5 = (const char *)nvram_get("dns_more_check_en");
    if ( !v5 )
      v5 = "0";
    v6 = sprintf(v4 + 29, "\"enable\":%s,\"all\":", v5) + 29;
    if ( v3 && *v3 )
      v7 = v6 + dns_more_dnstype_search(&v4[v6], 102400 - v6, (int)v3);
    else
      v7 = v6 + dns_more_dnstype_get_json(&v4[v6], 102400 - v6);
    v8 = snprintf(&v4[v7], 102400 - v7, "}}");
    if ( v8 >= 102400 - v7 )
      v9 = 102399 - v7;
    else
      v9 = v8;
    result = httpd_cgi_ret(a1, v4, v7 + v9, 8);
  }
  else
  {
    v11 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v12 = snprintf(v13, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
    if ( v12 >= 0x100 )
      v12 = 255;
    result = httpd_cgi_ret(a1, v13, v12, 4);
  }
  return result;
}
// 492F18: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8934: using guessed type int __fastcall dns_more_dnstype_get_json(_DWORD, _DWORD);

//----- (0049312C) --------------------------------------------------------
int __fastcall dns_more_get_dnstype_item_list_id(int a1)
{
  int v2; // $a2
  int result; // $v0
  int v4[25600]; // [sp+18h] [-19000h] BYREF

  memset(v4, 0, sizeof(v4));
  v4[0] = 58;
  v4[3] = 21;
  v4[1] = 102400;
  BYTE2(v4[21]) = J_atoi(a1);
  if ( jianhl_order_opt_fun(v4, v4[1], v2) )
    result = 0;
  else
    result = v4[5];
  return result;
}
// 4931B4: variable 'v2' is possibly undefined
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0049320C) --------------------------------------------------------
int __fastcall sub_49320C(int a1)
{
  char *v2; // $s0
  char *v3; // $v0
  void *v4; // $v0
  void *v5; // $s7
  _DWORD *v6; // $s1
  char *v7; // $v0
  int v8; // $s2
  int v9; // $a0
  int v10; // $v0
  int v11; // $a2
  int v12; // $a2
  const char *v13; // $v0
  unsigned int v14; // $s1
  const char *v16; // $v1
  char *v17; // $v0
  int v18; // $t0
  int v19; // $a3
  int v20; // $a2
  int v21; // $a1
  int v22; // $s3
  char *v23; // $s1
  int i; // $s0
  int v25; // $s1
  char *v26; // $s3
  int v27; // $s4
  char *v28; // $a1
  int v29; // $a0
  int v30; // $t0
  int v31; // $a3
  int v32; // $a2
  int v33; // $a1
  int v34; // $a1
  int v35; // $a2
  int v36; // $a0
  const char *v37; // $v0
  int v38; // $a3
  char *v39; // $s0
  int v40; // $a0
  const char *v41; // $v0
  char v42[81920]; // [sp+28h] [-14628h] BYREF
  char s[1024]; // [sp+14028h] [-628h] BYREF
  _DWORD v44[128]; // [sp+14428h] [-228h] BYREF
  char *v45; // [sp+14628h] [-28h] BYREF
  char *v46; // [sp+1462Ch] [-24h]
  int v47; // [sp+14630h] [-20h]
  int v48; // [sp+14634h] [-1Ch]
  char *v49; // [sp+14638h] [-18h]
  char *v50; // [sp+1463Ch] [-14h]
  char *v51; // [sp+14640h] [-10h]
  char *v52; // [sp+14644h] [-Ch]
  int v53; // [sp+14648h] [-8h]

  v45 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  v50 = httpd_get_parm(a1, "name");
  v52 = httpd_get_parm(a1, "id");
  v2 = httpd_get_parm(a1, "opt");
  v51 = (char *)httpd_get_json_parm(a1, (int)"del_list");
  if ( !v2 || strcmp(v2, (const char *)&off_646D8C) && strcmp(v2, "del") && strcmp(v2, "delall") )
  {
    v13 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    v14 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
    if ( v14 >= 0x400 )
      v14 = 1023;
    return httpd_cgi_ret(a1, s, v14, 4);
  }
  _mem_malloc(1024000, "dns_more_dnstype_asp", 553);
  v5 = v4;
  _mem_malloc(1024000, "dns_more_dnstype_asp", 554);
  v49 = v3;
  if ( !v5 )
  {
    v41 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v14 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v41);
    if ( v14 >= 0x400 )
      v14 = 1023;
    goto LABEL_30;
  }
  if ( !v3 )
  {
    v34 = *(unsigned __int8 *)(a1 + 210102);
    v35 = 1024000;
    v36 = 4;
    goto LABEL_49;
  }
  if ( !strcmp(v2, "delall") )
  {
    v50 = "1\"";
    jhl_parm_get("dns_more_dnstype_item", v5, 1024000);
    v22 = split_string(v5, 60, v42, 20480);
    if ( v22 > 0 )
    {
      v23 = v42;
      for ( i = 0; i != v22; ++i )
      {
        if ( split_string(*(_DWORD *)v23, 124, v44, 128) >= 2 )
          set_dns_more_dnstype_item_to_kernel("del", v44);
        v23 += 4;
      }
    }
    v52 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
    jhl_parm_set(v50 - 17924, "");
    v51 = "1\"";
    memset(v5, 0, 0xFA000u);
    jhl_parm_get("dns_more_dnstype", v5, 1024000);
    v25 = split_string(v5, 60, v42, 512);
    if ( v25 > 0 )
    {
      v26 = v42;
      v27 = 0;
      v50 = "del";
      do
      {
        while ( 1 )
        {
          ++v27;
          if ( split_string(*(_DWORD *)v26, 124, v44, 128) >= 3 && !J_atoi(v44[2]) )
            break;
          v26 += 4;
          if ( v25 == v27 )
            goto LABEL_43;
        }
        set_dns_more_dnstype_to_kernel(v50, v44);
        v26 += 4;
      }
      while ( v25 != v27 );
    }
LABEL_43:
    memset(v5, 0, 0xFA000u);
    if ( dns_more_dnstype_get(v5, 1024000) )
      v28 = (char *)v5;
    else
      v28 = v52 - 1556;
    jhl_parm_set(v51 - 17900, v28);
    jhl_parm_commit(v29);
    v16 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v17 = s;
    do
    {
      v30 = *(_DWORD *)v16;
      v31 = *((_DWORD *)v16 + 1);
      v32 = *((_DWORD *)v16 + 2);
      v33 = *((_DWORD *)v16 + 3);
      v16 += 16;
      *(_DWORD *)v17 = v30;
      *((_DWORD *)v17 + 1) = v31;
      *((_DWORD *)v17 + 2) = v32;
      *((_DWORD *)v17 + 3) = v33;
      v17 += 16;
    }
    while ( v16 != "}" );
    goto LABEL_28;
  }
  if ( strcmp(v2, "del") || !v51 || !cJSON_IsArray(v51) )
  {
    if ( v50 )
    {
      v45 = v50;
      if ( strcmp(v2, (const char *)&off_646D8C) )
        goto LABEL_26;
      v51 = "1\"";
      v14 = check_rule_num_limit(a1, 4, (int)"dns_more_dnstype", 60, s, 0x400u);
      if ( (int)v14 > 0 )
        goto LABEL_29;
      if ( !v52 || !*v52 )
        v52 = "0";
      v46 = v52;
      v38 = set_dns_more_dnstype_to_kernel(v2, &v45);
      if ( v38 < 0 )
        goto LABEL_26;
      sprintf((char *)v5, "%s|%d|%d<", v45, v38, 0);
      v39 = v49;
      jhl_parm_get(v51 - 17900, v49, 1024000);
      if ( !strcmp(v39, " ") )
        *v39 = 0;
      strcat(v49, (char *)v5);
      goto LABEL_60;
    }
    v34 = *(unsigned __int8 *)(a1 + 210102);
    v35 = (int)&unk_6442E4;
    v36 = 12;
LABEL_49:
    v37 = (const char *)_GET_LANG_TEXT(v36, v34, v35);
LABEL_50:
    v14 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v37);
    if ( v14 >= 0x400 )
      v14 = 1023;
    goto LABEL_29;
  }
  v6 = (_DWORD *)*((_DWORD *)v51 + 2);
  if ( !v6 )
    goto LABEL_26;
  v53 = 0;
  v52 = (char *)&v45;
  v51 = "dns_more_dnstype";
  do
  {
    v8 = cJSON_GetObjectItem(v6, "name");
    v7 = (char *)cJSON_GetObjectItem(v6, "id");
    if ( v8 && v7 )
    {
      v9 = *((_DWORD *)v7 + 4);
      v50 = v7;
      v10 = dns_more_dnstype_is_used(v9);
      if ( v10 )
      {
        v37 = (const char *)_GET_LANG_TEXT(v10, *(unsigned __int8 *)(a1 + 210102), v11);
        goto LABEL_50;
      }
      if ( dns_more_get_dnstype_item_list_id(*((_DWORD *)v50 + 4)) )
      {
        v37 = (const char *)_GET_LANG_TEXT(39, *(unsigned __int8 *)(a1 + 210102), v12);
        goto LABEL_50;
      }
      v45 = *(char **)(v8 + 16);
      if ( set_dns_more_dnstype_to_kernel(v2, v52) >= 0 )
      {
        jhl_parm_get(v51, v5, 1024000);
        if ( nvparm_del_str(v5, 60, 2, *(_DWORD *)(v8 + 16), 124, 0, v49) )
        {
          jhl_parm_set(v51, v49);
          v53 = 1;
        }
      }
    }
    v6 = (_DWORD *)*v6;
  }
  while ( v6 );
  if ( !v53 )
    goto LABEL_26;
  v51 = "1\"";
LABEL_60:
  jhl_parm_set(v51 - 17900, v49);
  jhl_parm_commit(v40);
LABEL_26:
  v16 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v17 = s;
  do
  {
    v18 = *(_DWORD *)v16;
    v19 = *((_DWORD *)v16 + 1);
    v20 = *((_DWORD *)v16 + 2);
    v21 = *((_DWORD *)v16 + 3);
    v16 += 16;
    *(_DWORD *)v17 = v18;
    *((_DWORD *)v17 + 1) = v19;
    *((_DWORD *)v17 + 2) = v20;
    *((_DWORD *)v17 + 3) = v21;
    v17 += 16;
  }
  while ( v16 != "}" );
LABEL_28:
  v14 = 33;
  *(_WORD *)v17 = *(_WORD *)v16;
LABEL_29:
  _mem_free(v5);
LABEL_30:
  if ( v49 )
    _mem_free(v49);
  return httpd_cgi_ret(a1, s, v14, 4);
}
// 493378: variable 'v4' is possibly undefined
// 493390: variable 'v3' is possibly undefined
// 493A24: variable 'v29' is possibly undefined
// 493C9C: variable 'v40' is possibly undefined
// 493D8C: variable 'v11' is possibly undefined
// 493DB0: variable 'v12' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8278: using guessed type int __fastcall set_dns_more_dnstype_to_kernel(_DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83E8: using guessed type int __fastcall dns_more_dnstype_get(_DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A88D0: using guessed type int __fastcall set_dns_more_dnstype_item_to_kernel(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00493DC4) --------------------------------------------------------
int __fastcall dns_more_member_get_file(char *a1, size_t a2)
{
  char *v4; // $v0
  char *v5; // $s6
  const char *v6; // $v0
  int v7; // $v0
  char *v8; // $v1
  _DWORD *v9; // $a0
  int v10; // $a1
  int v11; // $a2
  int v12; // $a1
  signed int v13; // $s2
  const char *v14; // $s0
  signed int v15; // $s5
  char *v16; // $v0
  const char *v17; // $s1
  const char *v19; // [sp+18h] [-10h] BYREF
  const char *v20; // [sp+1Ch] [-Ch]
  int v21; // [sp+20h] [-8h]
  int v22; // [sp+24h] [-4h]

  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  _mem_malloc(0x200000, "dns_more_member_get_file", 719);
  if ( !v4 )
    return 0;
  v5 = v4;
  memset(a1, 0, a2);
  v6 = (const char *)nvram_get("dns_more_dnstype");
  if ( !v6 )
    v6 = "";
  v7 = sprintf(a1, "gids:%s\r\n", v6);
  v8 = &a1[v7];
  v9 = &unk_64BA34;
  do
  {
    v10 = v9[1];
    *(_DWORD *)v8 = *v9;
    *((_DWORD *)v8 + 1) = v10;
    v11 = v9[2];
    *((_DWORD *)v8 + 1) = v10;
    *((_DWORD *)v8 + 2) = v11;
    v12 = v9[3];
    *((_DWORD *)v8 + 2) = v11;
    *((_DWORD *)v8 + 3) = v12;
    v9 += 4;
    *((_DWORD *)v8 + 3) = v12;
    v8 += 16;
  }
  while ( v9 != (_DWORD *)&unk_64BA54 );
  *v8 = *(_BYTE *)v9;
  v13 = v7 + 32;
  jhl_parm_get("dns_more_dnstype_item", v5, 0x200000);
  v14 = v5;
  v15 = a2 - 49;
  while ( *v14 )
  {
    v16 = strchr(v14, 60);
    v17 = v16 + 1;
    if ( !v16 )
    {
      if ( split_string(v14, 124, &v19, 2) >= 2 )
        v13 += sprintf(&a1[v13], "{n:%s;g:%s}\r\n", v19, v20);
      break;
    }
    *v16 = 0;
    if ( split_string(v14, 124, &v19, 2) < 2 || (v13 += sprintf(&a1[v13], "{n:%s;g:%s}\r\n", v19, v20), v13 < v15) )
    {
      v14 = v17;
      if ( v17 )
        continue;
    }
    break;
  }
  _mem_free(v5);
  return v13;
}
// 493E34: variable 'v4' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00494050) --------------------------------------------------------
int __fastcall sub_494050(int a1)
{
  char *v2; // $v0
  int v3; // $v0
  char *v4; // $s1
  int result; // $v0
  const char *v6; // $v0
  unsigned int v7; // $v0
  char v8[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "dns_more_member_txt", 771);
  if ( v2 )
  {
    v4 = v2;
    v3 = dns_more_member_get_file(v2, 0x200000u);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v3);
  }
  else
  {
    v6 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v7 = snprintf(v8, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v6);
    if ( v7 >= 0x100 )
      v7 = 255;
    result = httpd_cgi_ret(a1, v8, v7, 4);
  }
  return result;
}
// 494090: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00494170) --------------------------------------------------------
int __fastcall sub_494170(int a1)
{
  int v1; // $s0
  int v2; // $s3
  char *v3; // $v0
  char *v5; // $v0
  char *v6; // $s2
  void *v7; // $v0
  int v8; // $a2
  void *v9; // $s0
  int v10; // $a0
  const char *v11; // $v0
  unsigned int v12; // $v0
  int result; // $v0
  const char *v14; // $v0
  unsigned int v15; // $v0
  char v16[516]; // [sp+20h] [-204h] BYREF

  v1 = a1 + 196608;
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( v3 && (v6 = v3, (v5 = find_file_end(a1, v3, *(_DWORD *)(v1 + 8956) + v2 - (_DWORD)v3)) != 0) )
  {
    *v5 = 0;
    dns_more_dnstype_buf(v6, 0);
    _mem_malloc(0x200000, "dns_more_memberfile_cgi", 820);
    v9 = v7;
    if ( v7 )
    {
      if ( dns_more_dnstype_get(v7, 0x200000) )
        jhl_parm_set("dns_more_dnstype", v9);
      else
        jhl_parm_set("dns_more_dnstype", "");
      jhl_parm_commit(v10);
      _mem_free(v9);
    }
    v11 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v8);
    v12 = snprintf(v16, 512, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v11);
    if ( v12 >= 0x200 )
      v12 = 511;
    httpd_cgi_ret(a1, v16, v12, 4);
    result = 0;
  }
  else
  {
    v14 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
    v15 = snprintf(v16, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v15 >= 0x200 )
      v15 = 511;
    httpd_cgi_ret(a1, v16, v15, 4);
    result = -1;
  }
  return result;
}
// 4941BC: variable 'v3' is possibly undefined
// 494220: variable 'v7' is possibly undefined
// 49426C: variable 'v10' is possibly undefined
// 4942A0: variable 'v8' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E8: using guessed type int __fastcall dns_more_dnstype_get(_DWORD, _DWORD);
// 6A85B8: using guessed type int __fastcall dns_more_dnstype_buf(_DWORD, _DWORD);

//----- (004943C8) --------------------------------------------------------
int __fastcall dns_more_dnstype_item_get_file(_DWORD *a1, size_t a2, const char *a3)
{
  char *v6; // $v0
  char *v7; // $s6
  const char *v8; // $s0
  int v9; // $s2
  signed int v10; // $s4
  char *v11; // $v0
  const char *v12; // $a0
  const char *v13; // $fp
  const char *v15; // [sp+18h] [-18h] BYREF
  const char *v16; // [sp+1Ch] [-14h]
  int v17; // [sp+20h] [-10h]
  int v18; // [sp+24h] [-Ch]
  char *v19; // [sp+28h] [-8h]

  v19 = "1\"";
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  _mem_malloc(0x200000, "dns_more_dnstype_item_get_file", 869);
  if ( v6 )
  {
    v7 = v6;
    memset(a1, 0, a2);
    *a1 = 1313094254;
    *a1 = 1313094254;
    a1[1] = 979840083;
    a1[1] = 979840083;
    a1[2] = -188024373;
    a1[2] = -188024373;
    a1[3] = 1145694679;
    a1[3] = 1145694679;
    *((_BYTE *)a1 + 17) = 10;
    *((_BYTE *)a1 + 16) = 13;
    *((_BYTE *)a1 + 18) = 0;
    jhl_parm_get("dns_more_dnstype_item", v7, 0x200000);
    v8 = v7;
    v9 = 18;
    v10 = a2 - 49;
    while ( 1 )
    {
      if ( !*v8 )
      {
LABEL_11:
        _mem_free(v7);
        return v9;
      }
      v11 = strchr(v8, 60);
      v12 = v8;
      if ( !v11 )
        break;
      *v11 = 0;
      v8 = v11 + 1;
      if ( split_string(v12, 124, &v15, 2) >= 2 )
      {
        if ( a3 )
          goto LABEL_7;
LABEL_14:
        v9 += sprintf((char *)a1 + v9, "{n:%s;g:%s}\r\n", v15, v16);
        goto LABEL_9;
      }
LABEL_10:
      if ( !v8 )
        goto LABEL_11;
    }
    if ( split_string(v8, 124, &v15, 2) < 2 )
      goto LABEL_11;
    v8 = 0;
    if ( !a3 )
      goto LABEL_14;
LABEL_7:
    v13 = v16;
    if ( !strcmp(v16, a3) )
      v9 += sprintf((char *)a1 + v9, "{n:%s;g:%s}\r\n", v15, v13);
LABEL_9:
    if ( v9 >= v10 )
      goto LABEL_11;
    goto LABEL_10;
  }
  return 0;
}
// 494440: variable 'v6' is possibly undefined
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00494640) --------------------------------------------------------
int __fastcall sub_494640(int a1)
{
  _DWORD *v2; // $v0
  char *v3; // $s2
  int v4; // $v0
  void *v5; // $s1
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[256]; // [sp+20h] [-100h] BYREF

  v3 = httpd_get_parm(a1, (char *)&off_64918C);
  _mem_malloc(0x200000, "dns_more_dnstype_item_txt", 931);
  if ( v2 )
  {
    v5 = v2;
    v4 = dns_more_dnstype_item_get_file(v2, 0x200000u, v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v5, v4);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 49469C: variable 'v2' is possibly undefined
// 64918C: using guessed type void *off_64918C;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00494788) --------------------------------------------------------
int __fastcall sub_494788(int a1)
{
  char *v1; // $v0
  int v3; // $s4
  char *v4; // $v0
  char *v5; // $s3
  char *v6; // $s2
  char *v7; // $v0
  int v8; // $a2
  const char *v9; // $v0
  unsigned int v10; // $v0
  const char *v12; // $a2
  const char *v13; // $v0
  unsigned int v14; // $v0
  char v15[512]; // [sp+20h] [-200h] BYREF

  v1 = httpd_get_parm(a1, (char *)&off_64918C);
  if ( v1
    && (v3 = *(_DWORD *)(a1 + 205364), v5 = v1, find_file_head(a1, *(const char **)(a1 + 205564)), (v6 = v4) != 0)
    && (v7 = find_file_end(a1, v4, *(_DWORD *)(a1 + 205564) + v3 - (_DWORD)v4)) != 0 )
  {
    *v7 = 0;
    if ( dns_more_dnstype_item_buf(v6, 0, v5) >= 0 )
    {
      v9 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v8);
      v10 = snprintf(v15, 512, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v9);
      if ( v10 >= 0x200 )
        httpd_cgi_ret(a1, v15, 511, 4);
      else
        httpd_cgi_ret(a1, v15, v10, 4);
      return 0;
    }
    v12 = "Error DNS member";
  }
  else
  {
    v12 = "Error reading file";
  }
  v13 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v12);
  v14 = snprintf(v15, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
  if ( v14 >= 0x200 )
    v14 = 511;
  httpd_cgi_ret(a1, v15, v14, 4);
  return -1;
}
// 4947FC: variable 'v4' is possibly undefined
// 494850: variable 'v8' is possibly undefined
// 64918C: using guessed type void *off_64918C;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A87F0: using guessed type int __fastcall dns_more_dnstype_item_buf(_DWORD, _DWORD, _DWORD);

//----- (00494990) --------------------------------------------------------
int __fastcall sub_494990(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $s1
  int v5; // $v0
  int v6; // $s1
  int v7; // $v0
  int v8; // $s1
  int v9; // $v0
  int v10; // $a2
  int result; // $v0
  const char *v12; // $v0
  unsigned int v13; // $v0
  char v14[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(102400, "dns_more_dnswan_data", 1016);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{\"all\":");
    qmemcpy((void *)v2, "{\"code\":0,\"error", 16);
    *(_DWORD *)(v2 + 24) = 975331700;
    *(_BYTE *)(v2 + 32) = 108;
    v4 = get_dns_more_dnswan_data((char *)(v2 + 35), 102365) + 35;
    v5 = snprintf(&v3[v4], 102400 - v4, (char *)&dword_6448E0);
    if ( v5 >= 102400 - v4 )
      v5 = 102399 - v4;
    v6 = v5 + v4 + get_wans_data(&v3[v5 + v4], 102400 - (v5 + v4));
    v7 = snprintf(&v3[v6], 102400 - v6, (char *)&dword_64331C);
    if ( v7 >= 102400 - v6 )
      v7 = 102399 - v6;
    v8 = v7 + v6 + get_vpns_iface(&v3[v7 + v6]);
    v9 = snprintf(&v3[v8], 102400 - v8, "}}");
    if ( v9 >= 102400 - v8 )
      v10 = 102399 - v8;
    else
      v10 = v9;
    result = httpd_cgi_ret(a1, v3, v10 + v8, 8);
  }
  else
  {
    v12 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v13 = snprintf(v14, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v12);
    if ( v13 >= 0x100 )
      v13 = 255;
    result = httpd_cgi_ret(a1, v14, v13, 4);
  }
  return result;
}
// 4949E4: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 64331C: using guessed type int dword_64331C;
// 6448E0: using guessed type int dword_6448E0;
// 6459A8: using guessed type int dword_6459A8;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (00494C4C) --------------------------------------------------------
int __fastcall sub_494C4C(int a1)
{
  char *v2; // $s7
  char *v3; // $s6
  char *v4; // $s5
  char *v5; // $s1
  char *v6; // $v0
  char *v7; // $v0
  char *v8; // $s2
  char *v9; // $s4
  int v10; // $v0
  _DWORD *v11; // $s5
  char *v12; // $fp
  int v13; // $v0
  int v14; // $s6
  const char *v15; // $a0
  int v16; // $v0
  int v17; // $s7
  int v18; // $a0
  int *v19; // $v1
  const char *v20; // $v0
  int v21; // $t0
  int v22; // $a3
  int v23; // $a2
  int v24; // $a1
  int v25; // $s6
  int v27; // $v0
  int v28; // $a1
  int v29; // $a2
  int v30; // $a0
  const char *v31; // $v0
  int s[64]; // [sp+28h] [-148h] BYREF
  int v33[6]; // [sp+128h] [-48h] BYREF
  char *v34; // [sp+140h] [-30h] BYREF
  char *v35; // [sp+144h] [-2Ch]
  char *v36; // [sp+148h] [-28h]
  char *v37; // [sp+14Ch] [-24h]
  int v38; // [sp+150h] [-20h]
  int v39; // [sp+154h] [-1Ch]
  char *v40; // [sp+158h] [-18h]
  const char *v41; // [sp+15Ch] [-14h]
  int v42; // [sp+160h] [-10h]
  char *v43; // [sp+164h] [-Ch]
  char *v44; // [sp+168h] [-8h]
  char *v45; // [sp+16Ch] [-4h]

  v44 = "a";
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v45 = "1\"";
  v40 = httpd_get_parm(a1, "name");
  v42 = (int)httpd_get_parm(a1, "old_name");
  v2 = httpd_get_parm(a1, "id");
  v3 = httpd_get_parm(a1, "dns");
  v4 = httpd_get_parm(a1, "wans");
  v5 = httpd_get_parm(a1, "opt");
  v41 = (const char *)httpd_get_json_parm(a1, (int)"del_list");
  _mem_malloc(10240, "dns_more_dnswan_asp", 1072);
  v8 = v7;
  _mem_malloc(10240, "dns_more_dnswan_asp", 1073);
  v9 = v6;
  if ( v8 && v6 )
  {
    v10 = a1 + 196608;
    if ( v5 )
    {
      if ( !strcmp(v5, (const char *)&off_646D8C) || !strcmp(v5, (const char *)&off_648DDC) )
      {
        v43 = "1\"";
        if ( strcmp(v5, "del") )
        {
LABEL_19:
          if ( v40 )
          {
            v34 = v40;
            if ( strcmp(v5, (const char *)&off_646D8C) && strcmp(v5, (const char *)&off_648DDC) )
              goto LABEL_35;
            if ( !v2 || !*v2 )
              v2 = "0";
            v35 = v2;
            if ( !v3 || !*v3 )
              v3 = "";
            v36 = v3;
            if ( !v4 || !*v4 )
              v4 = "";
            v37 = v4;
            if ( v42 )
            {
              s[0] = (int)"wys";
              s[1] = (int)"dns_more";
              s[2] = (int)"dnswan";
              s[4] = v42;
              s[3] = (int)(v43 - 15196);
              s[5] = 0;
              eval(s, 0, 0, 0);
              v17 = dns_more_dnswan_add(v34, v35, v36, v37);
            }
            else
            {
              v25 = check_rule_num_limit(a1, 6, (int)"dns_more_dnswan", 60, (char *)s, 0x100u);
              if ( v25 > 0 )
                goto LABEL_38;
              v17 = set_dns_more_dnswan_to_kernel(v5, &v34);
            }
            if ( v17 < 0 )
              goto LABEL_35;
            if ( !strcmp(v5, (const char *)&off_648DDC)
              && ((jhl_parm_get("dns_more_dnswan", v8, 10240), !v42) ? (v27 = nvparm_del_str(v8, 60, 6, v40, 124, 0, v9)) : (v27 = nvparm_del_str(v8, 60, 6, v42, 124, 0, v9)),
                  v27) )
            {
              sprintf(v8, "%s|%d|%s|%s<", v34, v17, v36, v37);
            }
            else
            {
              sprintf(v8, "%s|%d|%s|%s<", v34, v17, v36, v37);
              jhl_parm_get("dns_more_dnswan", v9, 10240);
              if ( !strcmp(v9, " ") )
                *v9 = 0;
            }
            strcat(v9, v8);
            goto LABEL_34;
          }
          v28 = *(unsigned __int8 *)(a1 + 210102);
          v29 = (int)&unk_6442E4;
          goto LABEL_50;
        }
LABEL_7:
        if ( v41 && cJSON_IsArray(v41) )
        {
          v11 = (_DWORD *)*((_DWORD *)v41 + 2);
          if ( !v11 )
          {
LABEL_35:
            v19 = s;
            v20 = "{\"code\":0,\"error\":\"\",\"data\":null}";
            do
            {
              v21 = *(_DWORD *)v20;
              v22 = *((_DWORD *)v20 + 1);
              v23 = *((_DWORD *)v20 + 2);
              v24 = *((_DWORD *)v20 + 3);
              v20 += 16;
              *v19 = v21;
              v19[1] = v22;
              v19[2] = v23;
              v19[3] = v24;
              v19 += 4;
            }
            while ( v20 != "}" );
            v25 = 33;
            *(_WORD *)v19 = *(_WORD *)v20;
            goto LABEL_38;
          }
          v42 = 0;
          v40 = v44 + 17128;
          v12 = v45 - 3336;
          v41 = "dns_more_dnswan";
          do
          {
            v14 = cJSON_GetObjectItem(v11, v40);
            v13 = cJSON_GetObjectItem(v11, v12);
            if ( v14 && v13 )
            {
              v15 = *(const char **)(v13 + 16);
              v34 = *(char **)(v14 + 16);
              v16 = dns_more_dnswan_is_used(v15);
              if ( v16 )
              {
                v29 = *(_DWORD *)(v14 + 16);
                v28 = *(unsigned __int8 *)(a1 + 210102);
                v30 = v16;
                goto LABEL_51;
              }
              if ( set_dns_more_dnswan_to_kernel(v5, &v34) >= 0 )
              {
                jhl_parm_get(v41, v8, 10240);
                if ( nvparm_del_str(v8, 60, 6, *(_DWORD *)(v14 + 16), 124, 0, v9) )
                {
                  jhl_parm_set(v41, v9);
                  v42 = 1;
                }
              }
            }
            v11 = (_DWORD *)*v11;
          }
          while ( v11 );
          if ( !v42 )
            goto LABEL_35;
LABEL_34:
          v33[0] = (int)"wys";
          v33[1] = (int)"dns_more";
          v33[2] = (int)"dnswan";
          v33[3] = (int)"set_def";
          v33[4] = jhl_nv_get_def("dns_more_def_out");
          v33[5] = 0;
          eval(v33, 0, 0, 0);
          jhl_parm_set("dns_more_dnswan", v9);
          jhl_parm_commit(v18);
          goto LABEL_35;
        }
        goto LABEL_19;
      }
      v43 = "1\"";
      if ( !strcmp(v5, "del") )
        goto LABEL_7;
      v10 = a1 + 196608;
    }
    v28 = *(unsigned __int8 *)(v10 + 13494);
    v29 = (int)"not opt";
LABEL_50:
    v30 = 12;
    goto LABEL_51;
  }
  v28 = *(unsigned __int8 *)(a1 + 210102);
  v29 = 10240;
  v30 = 4;
LABEL_51:
  v31 = (const char *)_GET_LANG_TEXT(v30, v28, v29);
  v25 = snprintf((char *)s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
  if ( (unsigned int)v25 >= 0x100 )
    v25 = 255;
LABEL_38:
  _mem_free(v8);
  _mem_free(v9);
  return httpd_cgi_ret(a1, (char *)s, v25, 4);
}
// 494DA0: variable 'v7' is possibly undefined
// 494DAC: variable 'v6' is possibly undefined
// 4951FC: variable 'v18' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A84FC: using guessed type int __fastcall dns_more_dnswan_add(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A875C: using guessed type int __fastcall set_dns_more_dnswan_to_kernel(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (004954DC) --------------------------------------------------------
int __fastcall sub_4954DC(int a1)
{
  char *v1; // $v0
  int v3; // $s1
  int v4; // $v0
  char *v5; // $s0
  int v6; // $v0
  int v7; // $s1
  char *v8; // $a0
  int v9; // $a2
  int v11; // $a1
  int v12; // $a2
  int v13; // $a0
  const char *v14; // $v0
  unsigned int v15; // $v0
  char v16[256]; // [sp+20h] [-100h] BYREF

  v1 = httpd_get_parm(a1, (char *)&off_64918C);
  if ( v1 )
  {
    v3 = J_atoi(v1);
    if ( (unsigned int)(v3 - 1) >= 0xFF )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = (int)"not i_gid";
      v13 = 12;
    }
    else
    {
      _mem_malloc(0x200000, "dns_more_dnstype_item_data", 1264);
      v5 = (char *)v4;
      if ( v4 )
      {
        strcpy((char *)v4, "{\"code\":0,\"error\":\"\",\"data\":[");
        qmemcpy((void *)v4, "{\"code\":0,\"error", 16);
        *(_DWORD *)(v4 + 24) = 975331700;
        v6 = dns_more_dns_gid_member_get(v4 + 29, 2097123, v3);
        v7 = v6 + 29;
        v8 = &v5[v6 + 29];
        if ( v6 + 29 > 0 && *(v8 - 1) == 44 )
        {
          v7 = v6 + 28;
          v8 = &v5[v6 + 28];
        }
        *v8 = 0;
        v9 = snprintf(v8, 0x200000 - v7, "]}");
        if ( v9 >= 0x200000 - v7 )
          v9 = 0x1FFFFF - v7;
        return jhl_data_giz(a1, v5, v7 + v9, 0x200000);
      }
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = 0x200000;
      v13 = 4;
    }
  }
  else
  {
    v11 = *(unsigned __int8 *)(a1 + 210102);
    v12 = (int)&unk_649188;
    v13 = 12;
  }
  v14 = (const char *)_GET_LANG_TEXT(v13, v11, v12);
  v15 = snprintf(v16, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
  if ( v15 >= 0x100 )
    v15 = 255;
  return httpd_cgi_ret(a1, v16, v15, 4);
}
// 49556C: variable 'v4' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 64918C: using guessed type void *off_64918C;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A860C: using guessed type int __fastcall dns_more_dns_gid_member_get(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00495764) --------------------------------------------------------
int __fastcall sub_495764(int a1)
{
  char *v2; // $s7
  char *v3; // $v0
  char *v4; // $s6
  const char *v5; // $s1
  char *v6; // $v0
  char *v7; // $v0
  char *v8; // $s5
  char *v9; // $s3
  _BOOL4 v10; // $s6
  unsigned int v11; // $s4
  int v12; // $s4
  int v13; // $a1
  const char *v14; // $a2
  const char *v15; // $v0
  int v16; // $a1
  char *v17; // $a2
  int v18; // $a0
  const char *v19; // $v0
  unsigned int v21; // $v0
  bool v22; // dc
  unsigned int v23; // $v0
  unsigned int v24; // $v0
  const char *v25; // $a2
  const char *v26; // $v0
  char *v27; // $v1
  const char *v28; // $v0
  int v29; // $t0
  int v30; // $a3
  int v31; // $a2
  int v32; // $a1
  int v33; // $a0
  char s[1024]; // [sp+28h] [-410h] BYREF
  char *v35; // [sp+428h] [-10h]
  int v36; // [sp+42Ch] [-Ch]
  char *v37; // [sp+430h] [-8h]

  v35 = httpd_get_parm(a1, "dns");
  v2 = httpd_get_parm(a1, "old_dns");
  v4 = httpd_get_parm(a1, (char *)&off_64918C);
  v3 = httpd_get_parm(a1, "opt");
  if ( !v3
    || (v5 = v3, strcmp(v3, (const char *)&off_646D8C))
    && strcmp(v5, (const char *)&off_648DDC)
    && strcmp(v5, "del")
    && strcmp(v5, "delall") )
  {
    v13 = *(unsigned __int8 *)(a1 + 210102);
    v14 = "not opt";
    goto LABEL_19;
  }
  if ( !v4 )
  {
    v13 = *(unsigned __int8 *)(a1 + 210102);
    v14 = (const char *)&unk_649188;
LABEL_19:
    v15 = (const char *)_GET_LANG_TEXT(12, v13, v14);
    v11 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v15);
    if ( v11 >= 0x400 )
      v11 = 1023;
    return httpd_cgi_ret(a1, s, v11, 4);
  }
  _mem_malloc(1024000, "dns_more_dnstype_item_asp", 1320);
  v8 = v7;
  _mem_malloc(1024000, "dns_more_dnstype_item_asp", 1321);
  v9 = v6;
  if ( !v8 )
  {
    v26 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v11 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v26);
    if ( v11 >= 0x400 )
      v11 = 1023;
    goto LABEL_26;
  }
  if ( !v6 )
  {
    v16 = *(unsigned __int8 *)(a1 + 210102);
    v17 = (char *)1024000;
    v18 = 4;
LABEL_22:
    v19 = (const char *)_GET_LANG_TEXT(v18, v16, v17);
    goto LABEL_23;
  }
  v36 = J_atoi(v4);
  if ( !strcmp(v5, "delall") )
  {
    v21 = dns_more_dnstype_item_delall((unsigned __int8)v36);
    if ( v21 == -1 )
    {
LABEL_51:
      v16 = *(unsigned __int8 *)(a1 + 210102);
      v17 = "";
      v18 = 3;
      goto LABEL_22;
    }
    if ( v21 )
    {
LABEL_32:
      v16 = *(unsigned __int8 *)(a1 + 210102);
      v22 = v21 < 0x33;
      v23 = v21;
      if ( !v22 || (v17 = (char *)jhlret_err_str[v23]) == 0 )
        v17 = "not find err!";
      v18 = 3;
      goto LABEL_22;
    }
    jhl_parm_get("dns_more_dnstype_item", v8, 1024000);
    v10 = nvparm_del_str(v8, 60, 2, v4, 124, 1, v9) != 0;
  }
  else
  {
    v10 = 0;
  }
  if ( strcmp(v5, "del") && strcmp(v5, (const char *)&off_648DDC) )
  {
    if ( !strcmp(v5, (const char *)&off_646D8C) )
    {
      if ( v35 )
      {
        v37 = "1\"";
        goto LABEL_13;
      }
      goto LABEL_53;
    }
LABEL_56:
    if ( !v10 )
      goto LABEL_57;
    v37 = "1\"";
LABEL_65:
    jhl_parm_set(v37 - 17924, v9);
    jhl_parm_commit(v33);
LABEL_57:
    v27 = s;
    v28 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v29 = *(_DWORD *)v28;
      v30 = *((_DWORD *)v28 + 1);
      v31 = *((_DWORD *)v28 + 2);
      v32 = *((_DWORD *)v28 + 3);
      v28 += 16;
      *(_DWORD *)v27 = v29;
      *((_DWORD *)v27 + 1) = v30;
      *((_DWORD *)v27 + 2) = v31;
      *((_DWORD *)v27 + 3) = v32;
      v27 += 16;
    }
    while ( v28 != "}" );
    v11 = 33;
    *(_WORD *)v27 = *(_WORD *)v28;
    goto LABEL_25;
  }
  if ( !v2 )
  {
LABEL_53:
    v16 = *(unsigned __int8 *)(a1 + 210102);
    v17 = "not dns";
    v18 = 12;
    goto LABEL_22;
  }
  v12 = (unsigned __int8)v36;
  v21 = dns_more_dnstype_item_del(v2, (unsigned __int8)v36);
  if ( v21 == -1 )
    goto LABEL_51;
  if ( v21 )
    goto LABEL_32;
  v37 = "1\"";
  jhl_parm_get("dns_more_dnstype_item", v8, 1024000);
  if ( nvparm_del_str(v8, 60, 2, v2, 124, 0, v9) )
    v10 = 1;
  if ( strcmp(v5, (const char *)&off_646D8C) )
  {
    if ( strcmp(v5, (const char *)&off_648DDC) )
      goto LABEL_56;
    if ( v35 )
      goto LABEL_42;
    goto LABEL_53;
  }
  if ( !v35 )
    goto LABEL_53;
LABEL_13:
  v11 = check_rule_num_limit(a1, 5, (int)(v37 - 17924), 60, s, 0x400u);
  if ( (int)v11 <= 0 )
  {
    v12 = (unsigned __int8)v36;
LABEL_42:
    v24 = dns_more_dnstype_item_add(v12, v35);
    if ( v24 != -1 )
    {
      if ( v24 )
      {
        if ( v24 >= 0x33 || (v25 = (const char *)jhlret_err_str[v24]) == 0 )
          v25 = "not find err!";
        v19 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), v25);
        goto LABEL_23;
      }
      sprintf(v8, "%s|%d<", v35, v12);
      if ( !v10 )
      {
        jhl_parm_get(v37 - 17924, v9, 1024000);
        if ( !strcmp(v9, " ") )
          *v9 = 0;
      }
      strcat(v9, v8);
      goto LABEL_65;
    }
    v19 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
LABEL_23:
    v11 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
    if ( v11 >= 0x400 )
      v11 = 1023;
  }
LABEL_25:
  _mem_free(v8);
LABEL_26:
  if ( v9 )
    _mem_free(v9);
  return httpd_cgi_ret(a1, s, v11, 4);
}
// 49586C: variable 'v7' is possibly undefined
// 495878: variable 'v6' is possibly undefined
// 495F08: variable 'v33' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 64918C: using guessed type void *off_64918C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8290: using guessed type int __fastcall dns_more_dnstype_item_delall(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8590: using guessed type int __fastcall dns_more_dnstype_item_add(_DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86BC: using guessed type int __fastcall dns_more_dnstype_item_del(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00495F60) --------------------------------------------------------
int __fastcall asp_activeroutes(char *a1, int a2)
{
  int v4; // $s4
  FILE *v5; // $s1
  char *v6; // $v0
  char *v7; // $v0
  char *v8; // $v0
  char *v9; // $a3
  int v10; // $v0
  int v11; // $s3
  int v12; // $v0
  char *v14; // [sp+1Ch] [-28Ch]
  char v15[512]; // [sp+30h] [-278h] BYREF
  char v16[20]; // [sp+230h] [-78h] BYREF
  char v17; // [sp+244h] [-64h] BYREF
  __int16 v18[8]; // [sp+254h] [-54h] BYREF
  int v19[4]; // [sp+264h] [-44h] BYREF
  int v20; // [sp+274h] [-34h] BYREF
  struct in_addr v21; // [sp+278h] [-30h] BYREF
  int v22; // [sp+27Ch] [-2Ch] BYREF
  struct in_addr v23; // [sp+280h] [-28h] BYREF
  struct in_addr in; // [sp+284h] [-24h] BYREF
  int v25; // [sp+288h] [-20h]
  char *format; // [sp+28Ch] [-1Ch]
  char *v27; // [sp+290h] [-18h]
  int v28; // [sp+294h] [-14h]
  char *dest; // [sp+298h] [-10h]
  __int16 *v30; // [sp+29Ch] [-Ch]
  int *v31; // [sp+2A0h] [-8h]

  v4 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v4 >= a2 )
    v4 = a2 - 1;
  v5 = fopen("/proc/net/route", "r");
  if ( v5 )
  {
    format = "%s{\"dev\":\"%s\",\"dst\":\"%s\",\"gw\":\"%s\",\"mask\":\"%s\",\"met\":%u}";
    v27 = "a";
    v25 = 0;
    v28 = 1634100580;
    while ( fgets(v15, 512, v5) )
    {
      while ( sscanf(v15, "%16s%x%x%x%*s%*s%u%x", v16, &in, &v23, &v22, &v20, &v21) == 6
           && (v22 & 1) != 0
           && !strstr(v16, "wssocks") )
      {
        if ( in.s_addr )
        {
          v6 = inet_ntoa(in);
          v31 = v19;
          strcpy((char *)v19, v6);
        }
        else
        {
          v31 = v19;
          v19[0] = v28;
          v19[1] = 7629941;
        }
        if ( v23.s_addr )
        {
          v7 = inet_ntoa(v23);
          v30 = v18;
          strcpy((char *)v18, v7);
        }
        else
        {
          v30 = v18;
          v18[0] = 42;
        }
        dest = &v17;
        v8 = inet_ntoa(v21);
        strcpy(dest, v8);
        if ( v25 )
          v9 = v27 + 15692;
        else
          v9 = "";
        v14 = dest;
        dest = (char *)(a2 - v4);
        v10 = snprintf(&a1[v4], a2 - v4, format, v9, v16, v31, v30, v14, v20);
        if ( v10 >= (int)dest )
          v10 = (int)(dest - 1);
        v4 += v10;
        ++v25;
        if ( !fgets(v15, 512, v5) )
          goto LABEL_18;
      }
    }
LABEL_18:
    fclose(v5);
  }
  v11 = a2 - v4;
  v12 = snprintf(&a1[v4], v11, &byte_6445A0);
  if ( v12 >= v11 )
    v12 = v11 - 1;
  return v4 + v12;
}
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;

//----- (004962BC) --------------------------------------------------------
void __fastcall format_routers_static(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 6 )
    snprintf(
      a3,
      a4,
      "{\"dest\":\"%s\",\"gateway\":\"%s\",\"mask\":\"%s\",\"metric\":%s,\"ifname\":\"%s\",\"name\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5]);
}

//----- (0049635C) --------------------------------------------------------
int __fastcall sub_49635C(int a1)
{
  char *v1; // $v0
  char *v2; // $s0
  const char *v3; // $v0
  int v4; // $v0
  const char *v5; // $v0
  int v6; // $s1
  int v7; // $v0
  int v8; // $s3
  int v9; // $s2
  char *v10; // $s5
  int v11; // $s6
  int v12; // $s1
  const char **v13; // $s4
  void *v14; // $v0
  char *v15; // $s7
  int v16; // $a1
  void *v17; // $s6
  int v18; // $s6
  int i; // $fp
  int v20; // $v0
  int v21; // $v0
  char *v22; // $a0
  int v23; // $s2
  int v24; // $v0
  int v25; // $s1
  int v26; // $s1
  char *v27; // $v0
  int v28; // $s1
  char *v29; // $v0
  int v30; // $s1
  char *v31; // $v0
  const char *v32; // $v0
  int v33; // $s1
  const char *v34; // $s2
  const char *v35; // $s3
  const char *v36; // $v0
  char *v37; // $s3
  int v38; // $s1
  int v39; // $a2
  int result; // $v0
  int v41; // $v0
  const char *v42; // $a0
  int v43; // $s2
  char *v44; // $v0
  const char *v45; // $s7
  int v46; // $v0
  char *v47; // $s7
  int v48; // $v0
  int v49; // $v0
  const char *v50; // $v1
  int v51; // $v0
  const char *v52; // $v0
  void *v53; // $a0
  const char *v54; // $v0
  unsigned int v55; // $v0
  char *v56[64]; // [sp+28h] [-120h] BYREF
  char *v57; // [sp+128h] [-20h]
  char *v58; // [sp+12Ch] [-1Ch]
  char *v59; // [sp+130h] [-18h]
  char *v60; // [sp+134h] [-14h]
  void *ptr; // [sp+138h] [-10h]
  char *v62; // [sp+13Ch] [-Ch]
  void *v63; // [sp+140h] [-8h]

  _mem_malloc(0x200000, "router_data", 120);
  v2 = v1;
  if ( v1 )
  {
    strcpy(v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    v57 = "a";
    qmemcpy(v1, "{\"code\":0,\"error\":\"\"", 20);
    v58 = "a";
    v3 = (const char *)jhl_nv_get_def("dual_lan_mode");
    v4 = strcmp(v3, "1");
    v59 = "a";
    v6 = sprintf(v2 + 29, "\"dual_lan\":\"%d\"", v4 == 0) + 29;
    v5 = (const char *)nvram_get("lan_ifname");
    if ( !v5 )
      v5 = "";
    v7 = v6 + sprintf(&v2[v6], ",\"lan_ifname\":\"%s\"", v5);
    strcpy(&v2[v7], ",\"routes_static\":");
    qmemcpy(&v2[v7], ",\"routes_static\"", 16);
    v8 = v7 + 17;
    v9 = 0x200000 - (v7 + 17);
    v10 = &v2[v7 + 17];
    v11 = nvram_get("routes_static");
    v12 = snprintf(&v2[v8], 0x200000 - v8, (char *)&word_642A04);
    if ( v12 >= 0x200000 - v8 )
      v12 = 0x1FFFFF - v8;
    if ( v11 )
    {
      v13 = (const char **)malloc(0x20u);
      v60 = (char *)malloc(0x4008u);
      v15 = v60;
      v14 = malloc(0x200000u);
      ptr = v14;
      if ( v14 )
      {
        if ( v13 )
        {
          v16 = v11;
          if ( v60 )
          {
            v17 = v14;
            strlcpy(v14, v16, 0x200000);
            v18 = split_string(v17, 62, v60, 4096);
            if ( v18 > 0 )
            {
              for ( i = 0; i != v18; ++i )
              {
                v20 = split_string(*(_DWORD *)v15, 60, v13, 6);
                format_routers_static(v13, v20, &v10[v12], v9 - v12);
                v12 += v21;
                v15 += 4;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v13 )
        free(v13);
      if ( v60 )
        free(v60);
    }
    v22 = &v10[v12];
    if ( v12 > 0 && *(v22 - 1) == 44 )
      v22 = &v10[--v12];
    v23 = v9 - v12;
    *v22 = 0;
    v24 = snprintf(v22, v23, &byte_6445A0);
    if ( v24 >= v23 )
      v24 = v23 - 1;
    v25 = v12 + v24 + v8;
    strcpy(&v2[v25], ",\"activeroutes\":");
    qmemcpy(&v2[v25], ",\"activeroutes\":", 16);
    v26 = v25 + 16 + asp_activeroutes(&v2[v25 + 16], 0x200000 - (v25 + 16));
    v27 = &v2[v26];
    strcpy(&v2[v26], ",\"wans\":");
    *(_DWORD *)v27 = 1635197484;
    *((_DWORD *)v27 + 1) = 975336302;
    v28 = v26 + 8 + get_wans_data(&v2[v26 + 8], 0x200000 - (v26 + 8));
    v29 = &v2[v28];
    strcpy(&v2[v28], ",\"vpns\":");
    *(_DWORD *)v29 = 1886790188;
    *((_DWORD *)v29 + 1) = 975336302;
    v30 = v28 + 8 + get_vpns_iface(&v2[v28 + 8]);
    v31 = &v2[v30];
    strcpy(&v2[v30], ",\"lans\":[");
    *(_DWORD *)v31 = 1634476588;
    *((_DWORD *)v31 + 1) = 975336302;
    v32 = (const char *)jhl_nv_get_def(v57 + 13964);
    v33 = v30 + 9;
    if ( !strcmp(v32, v58 + 9340) )
    {
      v41 = nvram_get("lan_ifnames");
      if ( v41 )
        v42 = (const char *)v41;
      else
        v42 = "";
      v63 = strdup(v42);
      v43 = 1;
      if ( v63 )
      {
        v56[0] = (char *)v63;
        v60 = "a";
        ptr = "lan_ipaddr";
        v62 = "a";
        while ( 1 )
        {
          v44 = strsep(v56, " ");
          v45 = v44;
          if ( !v44 )
            break;
          v46 = *v44;
          if ( v46 == 32 )
          {
            v47 = (char *)(v45 + 1);
            do
              v46 = *v47++;
            while ( v46 == 32 );
            v45 = v47 - 1;
          }
          if ( !v46 )
            break;
          if ( !strncmp(v45, "bind_", 5u) || !strncmp(v45, "bond_", 5u) )
          {
            ++v43;
          }
          else
          {
            v48 = jhl_langet(v60 + 14348, v43 - 1);
            v57 = (char *)nvram_get(v48);
            if ( !v57 )
              break;
            v49 = jhl_langet(ptr, v43 - 1);
            v50 = (const char *)nvram_get(v49);
            if ( !v50 )
              v50 = "";
            v59 = &v2[v33];
            v58 = (char *)v50;
            v51 = jhl_langet(v62 + 15044, v43 - 1);
            v52 = (const char *)nvram_get(v51);
            if ( !v52 )
              v52 = "";
            v33 += sprintf(
                     v59,
                     "{\"iface\":%d,\"ifname\":\"%s\",\"show_ifname\":\"%s\",\"ipaddr\":\"%s\",\"netmask\":\"%s\"},",
                     v43++ - 1,
                     v45,
                     v57,
                     v58,
                     v52);
          }
        }
        v37 = &v2[v33];
        if ( v33 > 0 && *(v37 - 1) == 44 )
          v37 = &v2[--v33];
        v53 = v63;
        *v37 = 0;
        free(v53);
      }
      else
      {
        v37 = &v2[v33];
      }
    }
    else
    {
      v34 = (const char *)nvram_get(v59 + 13980);
      if ( !v34 )
        v34 = "";
      v35 = (const char *)nvram_get("lan_ipaddr");
      if ( !v35 )
        v35 = "";
      v36 = (const char *)nvram_get("lan_netmask");
      if ( !v36 )
        v36 = "";
      v33 += sprintf(
               &v2[v33],
               "{\"iface\":0,\"ifname\":\"%s\",\"show_ifname\":\"LAN\",\"ipaddr\":\"%s\",\"netmask\":\"%s\"}",
               v34,
               v35,
               v36);
      v37 = &v2[v33];
    }
    v38 = v33 + 1;
    *(_WORD *)v37 = 93;
    v39 = snprintf(&v2[v38], 0x200000 - v38, "}}");
    if ( v39 >= 0x200000 - v38 )
      v39 = 0x1FFFFF - v38;
    result = httpd_cgi_ret(a1, v2, v39 + v38, 8);
  }
  else
  {
    v54 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v55 = snprintf((char *)v56, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v54);
    if ( v55 >= 0x100 )
      v55 = 255;
    result = httpd_cgi_ret(a1, (char *)v56, v55, 4);
  }
  return result;
}
// 4963BC: variable 'v1' is possibly undefined
// 496654: variable 'v21' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 64331C: using guessed type int dword_64331C;
// 6445A0: using guessed type char byte_6445A0;
// 6448E0: using guessed type int dword_6448E0;
// 64BD3C: using guessed type int dword_64BD3C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8994: using guessed type int __fastcall jhl_langet(_DWORD, _DWORD);

//----- (00496CB8) --------------------------------------------------------
int __fastcall sub_496CB8(int a1)
{
  char *v2; // $fp
  char *v3; // $s6
  int v4; // $s7
  char *v5; // $s2
  char *v6; // $v0
  char *v7; // $v0
  char *v8; // $s4
  char *v9; // $s1
  int v10; // $v0
  int v11; // $a0
  char *v12; // $v1
  const char *v13; // $v0
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  int v18; // $s5
  int v20; // $a1
  const char *v21; // $a2
  int v22; // $a0
  _DWORD *v23; // $s6
  const char *v24; // $v0
  const char *v25; // $v0
  int v26; // $v0
  char s[256]; // [sp+28h] [-118h] BYREF
  char *v28; // [sp+128h] [-18h]
  char *v29; // [sp+12Ch] [-14h]
  char *v30; // [sp+130h] [-10h]
  char *v31; // [sp+134h] [-Ch]
  char *v32; // [sp+138h] [-8h]
  char *v33; // [sp+13Ch] [-4h]

  v2 = httpd_get_parm(a1, "dest");
  v28 = httpd_get_parm(a1, "gateway");
  v29 = httpd_get_parm(a1, "mask");
  v30 = httpd_get_parm(a1, "metric");
  v31 = httpd_get_parm(a1, "ifname");
  v3 = httpd_get_parm(a1, "name");
  v32 = httpd_get_parm(a1, "old_name");
  v4 = httpd_get_json_parm(a1, (int)"del_list");
  v5 = httpd_get_parm(a1, "opt");
  _mem_malloc(102400, "router_asp", 228);
  v8 = v7;
  _mem_malloc(102400, "router_asp", 229);
  v9 = v6;
  if ( v8 )
  {
    if ( !v6 )
    {
      v20 = *(unsigned __int8 *)(a1 + 210102);
      v21 = (const char *)102400;
      v22 = 4;
      goto LABEL_41;
    }
    v10 = a1 + 196608;
    if ( !v5 )
    {
LABEL_40:
      v20 = *(unsigned __int8 *)(v10 + 13494);
      v21 = "not opt";
      v22 = 12;
      goto LABEL_41;
    }
    if ( !strcmp(v5, (const char *)&off_646D8C) || !strcmp(v5, (const char *)&off_648DDC) )
    {
      if ( !strcmp(v5, "delall") )
        goto LABEL_8;
      if ( strcmp(v5, "del") )
        goto LABEL_18;
    }
    else
    {
      if ( strcmp(v5, "del") )
      {
        if ( !strcmp(v5, "delall") )
        {
LABEL_8:
          jhl_parm_set("routes_static", v9);
          jhl_parm_commit(v11);
          goto LABEL_9;
        }
        v10 = a1 + 196608;
        goto LABEL_40;
      }
      if ( !strcmp(v5, "delall") )
        goto LABEL_8;
    }
    if ( v4 && cJSON_IsArray(v4) )
    {
      v23 = *(_DWORD **)(v4 + 8);
      if ( !v23 || !v23[4] )
        goto LABEL_9;
      v32 = 0;
      v28 = "routes_static";
      do
      {
        jhl_parm_get("routes_static", v8, 102400);
        if ( nvparm_del_str(v8, 62, 8, v23[4], 60, 5, v9) )
        {
          jhl_parm_set(v28, v9);
          v32 = (char *)1;
        }
        v23 = (_DWORD *)*v23;
      }
      while ( v23 && v23[4] );
LABEL_46:
      if ( v32 )
        goto LABEL_8;
LABEL_9:
      jhl_gl_restart_jhttpd("routing-restart", 500);
      v12 = s;
      v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v14 = *(_DWORD *)v13;
        v15 = *((_DWORD *)v13 + 1);
        v16 = *((_DWORD *)v13 + 2);
        v17 = *((_DWORD *)v13 + 3);
        v13 += 16;
        *(_DWORD *)v12 = v14;
        *((_DWORD *)v12 + 1) = v15;
        *((_DWORD *)v12 + 2) = v16;
        *((_DWORD *)v12 + 3) = v17;
        v12 += 16;
      }
      while ( v13 != "}" );
      v18 = 33;
      *(_WORD *)v12 = *(_WORD *)v13;
      goto LABEL_12;
    }
LABEL_18:
    if ( v3 )
    {
      if ( v2 )
      {
        if ( v28 )
        {
          if ( v29 )
          {
            if ( v30 )
            {
              if ( v31 )
              {
                v33 = "1\"";
                if ( !strcmp(v5, (const char *)&off_648DDC) )
                {
                  jhl_parm_get("routes_static", v8, 102400);
                  if ( v32 )
                    v26 = nvparm_del_str(v8, 62, 8, v32, 60, 5, v9);
                  else
                    v26 = nvparm_del_str(v8, 62, 8, v3, 60, 5, v9);
                  v32 = (char *)(v26 != 0);
                  if ( strcmp(v5, (const char *)&off_646D8C) )
                  {
                    if ( strcmp(v5, v33 - 29220) )
                      goto LABEL_46;
LABEL_52:
                    sprintf(v8, "%s<%s<%s<%s<%s<%s>", v2, v28, v29, v30, v31, v3);
                    if ( !v32 )
                    {
                      jhl_parm_get("routes_static", v9, 102400);
                      if ( !strcmp(v9, " ") )
                        *v9 = 0;
                    }
                    strcat(v9, v8);
                    goto LABEL_8;
                  }
                }
                else
                {
                  if ( strcmp(v5, (const char *)&off_646D8C) )
                    goto LABEL_9;
                  v32 = 0;
                }
                jhl_parm_get("routes_static", v9, 102400);
                if ( nvparm_find_str(v9, 62, 8, v3, 60, 5) )
                {
                  v20 = *(unsigned __int8 *)(a1 + 210102);
                  v21 = "same name";
                  v22 = 12;
                  goto LABEL_41;
                }
                v18 = check_rule_num_limit(a1, 23, (int)"routes_static", 62, s, 0x100u);
                if ( v18 > 0 )
                {
LABEL_12:
                  _mem_free(v8);
                  goto LABEL_13;
                }
                goto LABEL_52;
              }
              v20 = *(unsigned __int8 *)(a1 + 210102);
              v21 = (const char *)&unk_64BE28;
              v22 = 12;
            }
            else
            {
              v20 = *(unsigned __int8 *)(a1 + 210102);
              v21 = (const char *)&unk_64BE1C;
              v22 = 12;
            }
          }
          else
          {
            v20 = *(unsigned __int8 *)(a1 + 210102);
            v21 = (const char *)&unk_64BE10;
            v22 = 12;
          }
        }
        else
        {
          v20 = *(unsigned __int8 *)(a1 + 210102);
          v21 = (const char *)&unk_64BE04;
          v22 = 12;
        }
      }
      else
      {
        v20 = *(unsigned __int8 *)(a1 + 210102);
        v21 = (const char *)&unk_64BDF8;
        v22 = 12;
      }
    }
    else
    {
      v20 = *(unsigned __int8 *)(a1 + 210102);
      v21 = (const char *)&unk_6442E4;
      v22 = 12;
    }
LABEL_41:
    v24 = (const char *)_GET_LANG_TEXT(v22, v20, v21);
    v18 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
    if ( (unsigned int)v18 >= 0x100 )
      v18 = 255;
    goto LABEL_12;
  }
  v25 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v18 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v25);
  if ( (unsigned int)v18 >= 0x100 )
    v18 = 255;
LABEL_13:
  if ( v9 )
    _mem_free(v9);
  return httpd_cgi_ret(a1, s, v18, 4);
}
// 496E24: variable 'v7' is possibly undefined
// 496E30: variable 'v6' is possibly undefined
// 496EEC: variable 'v11' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (00497560) --------------------------------------------------------
int __fastcall sub_497560(int a1)
{
  char *v2; // $v0
  const char *v3; // $s3
  char *v4; // $s0
  int v5; // $s4
  char *v6; // $v0
  int v7; // $s1
  int v8; // $s1
  char *v9; // $v1
  int v10; // $v0
  const char *v11; // $v0
  int v12; // $s1
  int v13; // $s1
  int v14; // $a2
  const char *v16; // $s4
  const char *v17; // $v0
  const char *v18; // $v0
  unsigned int v19; // $v0
  char v20[5120]; // [sp+50h] [-1C48h] BYREF
  char v21[2048]; // [sp+1450h] [-848h] BYREF
  int v22[18]; // [sp+1C50h] [-48h] BYREF

  memset(v20, 0, sizeof(v20));
  memset(v22, 0, sizeof(v22));
  v3 = (const char *)jhl_nv_get_def("dual_lan_mode");
  _mem_malloc(5120, "pppoe_base_data", 43);
  if ( v2 )
  {
    v4 = v2;
    jhl_parm_get("pppoeBase", v20, 5120);
    split_string(v20, 60, v22, 16);
    if ( v22[0] )
    {
      if ( v22[1] )
        goto LABEL_4;
    }
    else
    {
      v22[0] = (int)&off_63F984;
      if ( v22[1] )
      {
LABEL_4:
        if ( v22[2] )
          goto LABEL_5;
        goto LABEL_28;
      }
    }
    v22[1] = (int)"Router_PPPoE";
    if ( v22[2] )
    {
LABEL_5:
      if ( v22[3] )
        goto LABEL_6;
      goto LABEL_29;
    }
LABEL_28:
    v22[2] = (int)"10.0.0.1";
    if ( v22[3] )
    {
LABEL_6:
      if ( v22[4] )
        goto LABEL_7;
      goto LABEL_30;
    }
LABEL_29:
    v22[3] = (int)"255.255.255.0";
    if ( v22[4] )
    {
LABEL_7:
      if ( v22[5] )
        goto LABEL_8;
      goto LABEL_31;
    }
LABEL_30:
    v22[4] = (int)"6";
    if ( v22[5] )
    {
LABEL_8:
      if ( v22[6] )
        goto LABEL_9;
      goto LABEL_32;
    }
LABEL_31:
    v22[5] = (int)"3";
    if ( v22[6] )
    {
LABEL_9:
      if ( v22[7] )
        goto LABEL_10;
      goto LABEL_33;
    }
LABEL_32:
    v22[6] = (int)&off_63F984;
    if ( v22[7] )
    {
LABEL_10:
      if ( v22[8] )
        goto LABEL_11;
      goto LABEL_34;
    }
LABEL_33:
    v22[7] = (int)"1";
    if ( v22[8] )
    {
LABEL_11:
      if ( v22[9] )
        goto LABEL_12;
      goto LABEL_35;
    }
LABEL_34:
    v22[8] = (int)"0";
    if ( v22[9] )
    {
LABEL_12:
      if ( v22[10] )
        goto LABEL_13;
      goto LABEL_36;
    }
LABEL_35:
    v22[9] = (int)"0";
    if ( v22[10] )
    {
LABEL_13:
      if ( v22[11] )
        goto LABEL_14;
      goto LABEL_37;
    }
LABEL_36:
    v22[10] = (int)"0";
    if ( v22[11] )
    {
LABEL_14:
      if ( v22[12] )
        goto LABEL_15;
      goto LABEL_38;
    }
LABEL_37:
    v22[11] = (int)"1";
    if ( v22[12] )
    {
LABEL_15:
      if ( v22[13] )
        goto LABEL_16;
      goto LABEL_39;
    }
LABEL_38:
    v22[12] = (int)"0.0.0.0";
    if ( v22[13] )
    {
LABEL_16:
      if ( v22[14] )
        goto LABEL_17;
      goto LABEL_40;
    }
LABEL_39:
    v22[13] = (int)"0.0.0.0";
    if ( v22[14] )
    {
LABEL_17:
      if ( v22[15] )
      {
LABEL_18:
        strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":{");
        qmemcpy(v4, "{\"code\":0,\"error\":\"\"", 20);
        v5 = sprintf(
               v4 + 29,
               "\"en\":\"%s\",\"acn\":\"%s\",\"stip\":\"%s\",\"endip\":\"%s\",\"chktm\":%s,\"chkmax\":%s,\"only_pppoe\":\""
               "%s\",\"pap_en\":\"%s\",\"chap_en\":\"%s\",\"mschap_en\":\"%s\",\"mschap2_en\":\"%s\",\"any_acname\":\"%s\""
               ",\"dns0\":\"%s\",\"dns1\":\"%s\",\"any_user\":\"%s\",\"any_user_dq\":\"%s\"",
               (const char *)v22[0],
               (const char *)v22[1],
               (const char *)v22[2],
               (const char *)v22[3],
               (const char *)v22[4],
               (const char *)v22[5],
               (const char *)v22[6],
               (const char *)v22[7],
               (const char *)v22[8],
               (const char *)v22[9],
               (const char *)v22[10],
               (const char *)v22[11],
               (const char *)v22[12],
               (const char *)v22[13],
               (const char *)v22[14],
               (const char *)v22[15]);
        v6 = &v4[v5 + 29];
        strcpy(v6, ",\"pppoe_group_flag\":\"1\"");
        strcpy(v6, ",\"pppoe_group_flag\":\"1\"");
        v7 = v5 + 52;
        if ( !strcmp(v3, "1") )
        {
          memset(v21, 0, sizeof(v21));
          dual_lan_get_lan_showname(v21, 2048);
          v16 = (const char *)jhl_nv_get_def("pppoesrv_iface_en");
          v17 = (const char *)jhl_nv_get_def("pppoesrv_iface_list");
          v8 = v7
             + sprintf(
                 &v4[v7],
                 ",\"iface_show\":\"1\",\"lan_list\":\"%s\",\"iface_en\":\"%s\",\"iface_list\":\"%s\"",
                 v21,
                 v16,
                 v17);
        }
        else
        {
          strcpy(&v4[v7], ",\"iface_show\":\"0\"");
          qmemcpy(&v4[v7], ",\"iface_show", 12);
          v8 = v5 + 69;
        }
        strcpy(&v4[v8], ",\"chap2_show\":\"1\"");
        qmemcpy(&v4[v8], ",\"chap2_show\":\"1", 16);
        v9 = &v4[v8 + 17];
        strcpy(v9, ",\"ipv6_show\":\"1\"");
        *((_DWORD *)v9 + 3) = *(_DWORD *)":\"1\"";
        v10 = lan_name_get2("ipv6.lan", 0, "pppsrv", 0);
        v12 = v8 + 33;
        v11 = (const char *)nvram_get(v10);
        if ( !v11 )
          v11 = "";
        v13 = v12 + sprintf(&v4[v12], ",\"stipv6\":\"%s\"", v11);
        v14 = snprintf(&v4[v13], 5120 - v13, "}}");
        if ( v14 >= 5120 - v13 )
          v14 = 5119 - v13;
        return httpd_cgi_ret(a1, v4, v14 + v13, 8);
      }
LABEL_41:
      v22[15] = (int)"0";
      goto LABEL_18;
    }
LABEL_40:
    v22[14] = (int)&off_63F984;
    if ( v22[15] )
      goto LABEL_18;
    goto LABEL_41;
  }
  v18 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 5120);
  v19 = snprintf(v21, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v18);
  if ( v19 >= 0x100 )
    v19 = 255;
  return httpd_cgi_ret(a1, v21, v19, 4);
}
// 497604: variable 'v2' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8434: using guessed type int __fastcall dual_lan_get_lan_showname(_DWORD, _DWORD);
// 6A84C4: using guessed type int __fastcall lan_name_get2(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00497D98) --------------------------------------------------------
int __fastcall sub_497D98(int a1)
{
  char *v2; // $s1
  char *v3; // $s2
  char *v4; // $s3
  char *v5; // $s5
  char *v6; // $s4
  char *v7; // $fp
  int v8; // $v0
  const char *v9; // $v0
  int v10; // $v0
  char *v11; // $v0
  uint32_t v12; // $v0
  uint32_t v13; // $v0
  char *v14; // $v1
  const char *v15; // $v0
  int v16; // $t0
  int v17; // $a3
  int v18; // $a2
  int v19; // $a1
  int v21; // $s2
  char *v22; // $s3
  char *v23; // $s1
  const char *v24; // $v0
  const char *v25; // $v0
  char v26[5120]; // [sp+50h] [-28A0h] BYREF
  char v27[5120]; // [sp+1450h] [-14A0h] BYREF
  char *v28[18]; // [sp+2850h] [-A0h] BYREF
  char v29[24]; // [sp+2898h] [-58h] BYREF
  char *v30; // [sp+28B0h] [-40h]
  char *v31; // [sp+28B4h] [-3Ch]
  char *v32; // [sp+28B8h] [-38h]
  char *v33; // [sp+28BCh] [-34h]
  char *v34; // [sp+28C0h] [-30h]
  char *v35; // [sp+28C4h] [-2Ch]
  char *v36; // [sp+28C8h] [-28h]
  char *v37; // [sp+28CCh] [-24h]
  char *v38; // [sp+28D0h] [-20h]
  char *v39; // [sp+28D4h] [-1Ch]
  char *v40; // [sp+28D8h] [-18h]
  char *v41; // [sp+28DCh] [-14h]
  char **v42; // [sp+28E0h] [-10h]
  char *v43; // [sp+28E4h] [-Ch]
  char *v44; // [sp+28E8h] [-8h]

  memset(v27, 0, sizeof(v27));
  v42 = v28;
  memset(v28, 0, sizeof(v28));
  memset(v26, 0, sizeof(v26));
  v2 = httpd_get_parm(a1, "en");
  v31 = httpd_get_parm(a1, "acn");
  v3 = httpd_get_parm(a1, "stip");
  v4 = httpd_get_parm(a1, "endip");
  v32 = httpd_get_parm(a1, "chktm");
  v33 = httpd_get_parm(a1, "chkmax");
  v5 = httpd_get_parm(a1, "only_pppoe");
  v37 = httpd_get_parm(a1, "pap_en");
  v38 = httpd_get_parm(a1, "chap_en");
  v39 = httpd_get_parm(a1, "mschap_en");
  v36 = httpd_get_parm(a1, "mschap2_en");
  v40 = httpd_get_parm(a1, "any_acname");
  v6 = httpd_get_parm(a1, "any_user");
  v30 = httpd_get_parm(a1, "any_user_dq");
  v34 = httpd_get_parm(a1, "dns0");
  v35 = httpd_get_parm(a1, "dns1");
  v41 = (char *)jhl_nv_get_def("dual_lan_mode");
  v7 = httpd_get_parm(a1, "stipv6");
  if ( v7 )
  {
    v44 = "1\"";
    v43 = "1\"";
    v8 = lan_name_get2("ipv6.lan", 0, "pppsrv", 0);
    v9 = (const char *)nvram_get(v8);
    if ( !v9 || strcmp(v9, v7) )
    {
      v10 = lan_name_get2(v44 - 16320, 0, v43 - 16328, 0);
      nvram_set(v10, v7);
    }
  }
  v11 = (char *)nvram_get("pppoeBase");
  if ( !v11 )
    v11 = "";
  strlcpy(v26, v11, 5120);
  split_string(v26, 60, v42, 16);
  if ( !v28[0] )
    v28[0] = "";
  if ( !v28[2] )
    v28[2] = "";
  jhl_parm_get("lan_ifname", v29, 20);
  if ( !v2 || strcmp(v2, "on") )
    v2 = (char *)&off_63F984;
  if ( !v5 || strcmp(v5, "on") )
    v5 = (char *)&off_63F984;
  if ( v31 )
  {
    if ( v3 )
      goto LABEL_18;
  }
  else
  {
    v31 = "Router_PPPoE";
    if ( v3 )
      goto LABEL_18;
  }
  v3 = "10.198.0.1";
LABEL_18:
  if ( StrToIp(v3) )
  {
    if ( v4 )
      goto LABEL_20;
  }
  else
  {
    v3 = "10.198.0.1";
    StrToIp("10.198.0.1");
    if ( v4 )
    {
LABEL_20:
      v12 = StrToIp(v4);
      if ( v12 )
        goto LABEL_21;
      goto LABEL_56;
    }
  }
  v4 = "255.255.255.0";
  v12 = StrToIp("255.255.255.0");
  if ( v12 )
  {
LABEL_21:
    if ( v34 )
      goto LABEL_22;
    goto LABEL_57;
  }
LABEL_56:
  v12 = StrToIp("255.255.255.0");
  v4 = "255.255.255.0";
  if ( v34 )
  {
LABEL_22:
    if ( v35 )
      goto LABEL_23;
    goto LABEL_58;
  }
LABEL_57:
  v34 = "0.0.0.0";
  if ( v35 )
  {
LABEL_23:
    if ( v32 )
      goto LABEL_24;
LABEL_59:
    v32 = "3";
    if ( v33 )
      goto LABEL_25;
    goto LABEL_60;
  }
LABEL_58:
  v35 = "0.0.0.0";
  if ( !v32 )
    goto LABEL_59;
LABEL_24:
  if ( v33 )
    goto LABEL_25;
LABEL_60:
  v33 = "3";
LABEL_25:
  v13 = htonl(v12);
  if ( get_netmask_wei(v13) < 16 )
    StrToIp("255.255.255.0");
  if ( v6 && !strcmp(v6, "on") )
  {
    if ( !v30 )
      v30 = "0";
    v36 = "0";
  }
  else
  {
    if ( !v30 )
      v30 = "0";
    v6 = (char *)&off_63F984;
  }
  sprintf(
    v27,
    "%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s<%s",
    v2,
    v31,
    v3,
    v4,
    v32,
    v33,
    v5,
    v37,
    v38,
    v39,
    v36,
    v40,
    v34,
    v35,
    v6,
    v30);
  if ( strcmp(v2, v28[0]) || strcmp(v3, v28[2]) )
  {
    jhl_parm_set("pppoeBase", v27);
    if ( strcmp(v41, "1") )
      goto LABEL_41;
    v21 = 1;
LABEL_47:
    v22 = httpd_get_parm(a1, "iface_en");
    v23 = httpd_get_parm(a1, "iface_list");
    if ( !v22 || (v24 = (const char *)nvram_get("pppoesrv_iface_en")) != 0 && !strcmp(v24, v22) )
    {
      if ( !v23 )
        goto LABEL_62;
      goto LABEL_51;
    }
    nvram_set("pppoesrv_iface_en", v22);
    ++v21;
    if ( v23 )
    {
LABEL_51:
      v25 = (const char *)nvram_get("pppoesrv_iface_list");
      if ( !v25 || strcmp(v25, v23) )
      {
        nvram_set("pppoesrv_iface_list", v23);
        goto LABEL_41;
      }
LABEL_62:
      pppoe_srv_start("0");
      if ( !v21 )
        goto LABEL_36;
      goto LABEL_42;
    }
LABEL_41:
    pppoe_srv_start("0");
LABEL_42:
    start_rzgl(0);
    goto LABEL_36;
  }
  jhl_parm_set("pppoeBase", v27);
  if ( !strcmp(v41, "1") )
  {
    v21 = 0;
    goto LABEL_47;
  }
  pppoe_srv_start("0");
LABEL_36:
  v14 = v27;
  v15 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v16 = *(_DWORD *)v15;
    v17 = *((_DWORD *)v15 + 1);
    v18 = *((_DWORD *)v15 + 2);
    v19 = *((_DWORD *)v15 + 3);
    v15 += 16;
    *(_DWORD *)v14 = v16;
    *((_DWORD *)v14 + 1) = v17;
    *((_DWORD *)v14 + 2) = v18;
    *((_DWORD *)v14 + 3) = v19;
    v14 += 16;
  }
  while ( v15 != "}" );
  *(_WORD *)v14 = *(_WORD *)v15;
  jhl_parm_commit("}");
  return httpd_cgi_ret(a1, v27, 33, 4);
}
// 63F984: using guessed type void *off_63F984;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81AC: using guessed type int __fastcall get_netmask_wei(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C4: using guessed type int __fastcall lan_name_get2(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A862C: using guessed type int __fastcall StrToIp(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A88E4: using guessed type int __fastcall pppoe_srv_start(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);

//----- (00498798) --------------------------------------------------------
int __fastcall pppoe_list_data(int a1)
{
  _DWORD *v1; // $v0
  char *v2; // $v0
  char *v3; // $fp
  _DWORD *v4; // $s1
  int v5; // $a2
  _DWORD *v6; // $s3
  int v7; // $s0
  int v8; // $s7
  uint32_t v9; // $a0
  uint32_t v10; // $v0
  int v11; // $a1
  int v12; // $v0
  int v13; // $s2
  int v14; // $v0
  int v15; // $s4
  char *v16; // $t7
  int v17; // $a2
  const char *v18; // $v0
  int v19; // $s0
  int v20; // $a2
  int result; // $v0
  int v22; // $a0
  int v23; // $v0
  char *v24; // $a0
  int v25; // $v0
  int v26; // $s0
  const char *v27; // $v0
  unsigned int v28; // $v0
  __int16 v29[64]; // [sp+48h] [-100h] BYREF
  char v30[64]; // [sp+C8h] [-80h] BYREF
  char v31[32]; // [sp+108h] [-40h] BYREF
  int v32; // [sp+128h] [-20h]
  uint32_t v33; // [sp+12Ch] [-1Ch]
  char *v34; // [sp+130h] [-18h]
  char *s; // [sp+134h] [-14h]
  char *v36; // [sp+138h] [-10h]
  char *format; // [sp+13Ch] [-Ch]
  char *v38; // [sp+140h] [-8h]
  char *v39; // [sp+144h] [-4h]

  v38 = "1\"";
  _mem_malloc(0x200000, "pppoe_list_data", 395);
  v3 = v2;
  _mem_malloc(0x200000, "pppoe_list_data", 396);
  v4 = v1;
  if ( v3 && v1 )
  {
    memset(v1, 0, 0x200000u);
    *v4 = 9;
    v4[3] = 3;
    v4[1] = 0x200000;
    if ( !jianhl_order_opt_fun(v4, 0x200000, v5) )
    {
      strcpy(v3, "{\"code\":0,\"error\":\"\",\"data\":[");
      qmemcpy(v3, "{\"code\":0,\"error", 16);
      v6 = v4 + 9;
      if ( (int)v4[2] <= 0 )
      {
        v23 = 28;
        v22 = 29;
        v8 = 29;
      }
      else
      {
        v36 = "1\"";
        s = (char *)v29;
        v7 = 0;
        format = "%d";
        v8 = 29;
        v39 = "%d.%d";
        do
        {
          v16 = &v3[v8];
          if ( *((_WORD *)v6 + 6) )
          {
            v17 = *((unsigned __int16 *)v6 + 6);
            if ( *((_WORD *)v6 + 7) )
              sprintf(s, v39, v17);
            else
              sprintf(s, format, v17);
            v16 = &v3[v8];
          }
          else
          {
            v29[0] = 32;
          }
          v9 = *(v6 - 4);
          v34 = v16;
          v10 = ntohl(v9);
          v11 = *(v6 - 4);
          v33 = v10;
          v32 = IpToStr(v30, v11);
          v12 = MacToStr(v31, v6);
          v13 = *(v6 - 5);
          v15 = v12;
          v14 = get_json_data(v6 + 6);
          v8 += sprintf(
                  v34,
                  v36 - 16092,
                  v33,
                  v32,
                  v15,
                  v13,
                  v14,
                  *((unsigned __int16 *)v6 + 3),
                  *(v6 - 3),
                  *(v6 - 1),
                  *(v6 - 2),
                  v6[2],
                  s,
                  v6[4],
                  v6[5]);
          if ( ++v7 >= v4[2] )
            break;
          v6 += 30;
        }
        while ( 0x200000 - v8 >= 100 );
        v22 = v8;
        if ( v8 <= 0 )
          goto LABEL_21;
        v23 = v8 - 1;
      }
      if ( v3[v23] == 44 )
        v22 = --v8;
LABEL_21:
      v24 = &v3[v22];
      *v24 = 0;
      v25 = snprintf(v24, 0x200000 - v8, "]}");
      if ( v25 >= 0x200000 - v8 )
        v25 = 0x1FFFFF - v8;
      v26 = v8 + v25;
      _mem_free(v4);
      return jhl_data_giz(a1, v3, v26, 0x200000);
    }
    v18 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
    v19 = snprintf(v3, 0x200000, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v18);
    _mem_free(v4);
    v20 = v19;
    if ( v19 >= 0x200000 )
      v20 = 0x1FFFFF;
    result = httpd_cgi_ret(a1, v3, v20, 8);
  }
  else
  {
    _mem_free(v3);
    _mem_free(v4);
    v27 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    s = (char *)v29;
    v28 = snprintf((char *)v29, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
    if ( v28 >= 0x80 )
      v28 = 127;
    result = httpd_cgi_ret(a1, s, v28, 4);
  }
  return result;
}
// 498810: variable 'v2' is possibly undefined
// 49881C: variable 'v1' is possibly undefined
// 49885C: variable 'v5' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00498CB4) --------------------------------------------------------
int __fastcall pppoe_opt(__int16 a1, __int16 a2)
{
  int v4; // $a2
  bool v5; // dc
  int result; // $v0
  int v7[256]; // [sp+18h] [-400h] BYREF

  memset(v7, 0, sizeof(v7));
  v7[0] = 9;
  v7[3] = 7;
  v7[1] = 1024;
  LOWORD(v7[4]) = a1;
  HIWORD(v7[4]) = a2;
  v5 = jianhl_order_opt_fun(v7, 1024, v4) != 0;
  result = -1;
  if ( !v5 )
    result = v7[2];
  return result;
}
// 498D24: variable 'v4' is possibly undefined
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (00498D50) --------------------------------------------------------
int __fastcall sub_498D50(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  __int16 v4; // $v0
  unsigned int v5; // $v0
  int v6; // $a1
  bool v7; // dc
  unsigned int v8; // $v0
  char *v9; // $a2
  int v10; // $a0
  const char *v11; // $v0
  unsigned int v12; // $a2
  char v14[10244]; // [sp+20h] [-2804h] BYREF

  v3 = httpd_get_parm(a1, "s");
  v2 = httpd_get_parm(a1, "opt");
  if ( v2 && !strcmp(v2, "del") )
  {
    if ( v3 )
    {
      v4 = J_atoi(v3);
      v5 = pppoe_opt(0, v4);
      if ( v5 == -1 )
      {
        v6 = *(unsigned __int8 *)(a1 + 210102);
        v9 = "";
        v10 = 3;
      }
      else
      {
        if ( !v5 )
          return pppoe_list_data(a1);
        v6 = *(unsigned __int8 *)(a1 + 210102);
        v7 = v5 >= 0x33;
        v8 = v5;
        if ( v7 || (v9 = (char *)jhlret_err_str[v8]) == 0 )
          v9 = "not find err!";
        v10 = 3;
      }
    }
    else
    {
      v6 = *(unsigned __int8 *)(a1 + 210102);
      v9 = "not sid";
      v10 = 12;
    }
  }
  else
  {
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v9 = "not opt";
    v10 = 12;
  }
  v11 = (const char *)_GET_LANG_TEXT(v10, v6, v9);
  v12 = snprintf(v14, 10240, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
  if ( v12 >= 0x2800 )
    v12 = 10239;
  return httpd_cgi_ret(a1, v14, v12, 4);
}
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (00498F4C) --------------------------------------------------------
int __fastcall sub_498F4C(int a1)
{
  void *v1; // $v0
  int v2; // $v0
  int v3; // $s5
  int v4; // $s0
  int v5; // $v0
  int v6; // $s3
  char *v7; // $s2
  int v8; // $s1
  int v9; // $s7
  _DWORD *v10; // $s4
  int v11; // $s6
  int i; // $s3
  int v13; // $v0
  int v14; // $v0
  int v15; // $a0
  char *v16; // $a0
  char *v17; // $a2
  int v18; // $v0
  int v19; // $v0
  int v20; // $v1
  int v21; // $v0
  int v22; // $s1
  int v23; // $a3
  int v24; // $a2
  char *v25; // $a1
  const char *v27; // $v0
  unsigned int v28; // $v0
  char v29[8]; // [sp+28h] [-8060h] BYREF
  char v30[16384]; // [sp+4028h] [-4060h] BYREF
  _DWORD v31[13]; // [sp+8028h] [-60h] BYREF
  char *v32; // [sp+805Ch] [-2Ch]
  char *v33; // [sp+8060h] [-28h]
  char *v34; // [sp+8064h] [-24h]
  int v35; // [sp+8068h] [-20h]
  int v36; // [sp+806Ch] [-1Ch]
  _DWORD *v37; // [sp+8070h] [-18h]
  char *v38; // [sp+8074h] [-14h]
  char *v39; // [sp+8078h] [-10h]
  const char *v40; // [sp+807Ch] [-Ch]
  void *v41; // [sp+8080h] [-8h]
  char *v42; // [sp+8084h] [-4h]

  v42 = "1\"";
  _mem_malloc(102400, "pppoe_group_data", 587);
  v3 = v2;
  _mem_malloc(102400, "pppoe_group_data", 588);
  v41 = v1;
  if ( v3 && v1 )
  {
    strcpy((char *)v3, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy((void *)v3, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v3 + 24) = 975331700;
    jhl_parm_get("pppoe_group_list", v41, 102400);
    v36 = split_string(v41, 60, v30, 4096);
    if ( v36 <= 0 )
    {
      v20 = 28;
      v19 = 29;
      v4 = 29;
    }
    else
    {
      v38 = v29;
      v32 = "1\"";
      v33 = "a";
      v34 = v30;
      v35 = 0;
      v37 = v31;
      v39 = "{\"name\":\"%s\",\"ip\":\"%s\",\"mask\":\"%s\",\"dns\":\"%s\",\"speed\":[";
      v4 = 29;
      v40 = "]},";
      do
      {
        if ( split_string(*(_DWORD *)v34, 124, v37, 5) >= 5 )
        {
          v5 = snprintf(
                 (char *)(v3 + v4),
                 102400 - v4,
                 v39,
                 *((_DWORD *)v38 + 0x2000),
                 *((_DWORD *)v38 + 8193),
                 *((_DWORD *)v38 + 8194),
                 *((_DWORD *)v38 + 8196));
          if ( v5 >= 102400 - v4 )
            v5 = 102399 - v4;
          v6 = (int)v38;
          v7 = v38 + 0x10000;
          v8 = v5 + v4;
          v9 = split_string(*((_DWORD *)v38 + 8195), 62, v38, 4096);
          if ( v9 > 0 )
          {
            v10 = (_DWORD *)v6;
            v11 = v6 + 32796;
            for ( i = 0; i != v9; ++i )
            {
              split_string(*v10, 42, v11, 3);
              v14 = J_atoi(*((_DWORD *)v7 - 8185));
              v15 = *((_DWORD *)v7 - 8184);
              v31[12] = v14;
              J_atoi(v15);
              v13 = snprintf((char *)(v3 + v8), 102400 - v8, v32 - 15900);
              if ( v13 >= 102400 - v8 )
                v13 = 102399 - v8;
              v8 += v13;
              ++v10;
            }
          }
          v16 = (char *)(v3 + v8);
          if ( v8 > 0 && *(v16 - 1) == 44 )
          {
            --v8;
            v16 = (char *)(v3 + v8);
          }
          v17 = (char *)v40;
          *v16 = 0;
          v18 = snprintf(v16, 102400 - v8, v17);
          if ( v18 >= 102400 - v8 )
            v18 = 102399 - v8;
          v4 = v8 + v18;
        }
        ++v35;
        v34 += 4;
      }
      while ( v36 != v35 );
      v19 = v4;
      if ( v4 <= 0 )
        goto LABEL_25;
      v20 = v4 - 1;
    }
    if ( *(_BYTE *)(v3 + v20) == 44 )
      v19 = --v4;
LABEL_25:
    *(_BYTE *)(v3 + v19) = 0;
    v21 = snprintf((char *)(v3 + v19), 102400 - v4, "]}");
    if ( v21 < 102400 - v4 )
      v22 = v21;
    else
      v22 = 102399 - v4;
    _mem_free(v41);
    v23 = 8;
    v24 = v4 + v22;
    v25 = (char *)v3;
    return httpd_cgi_ret(a1, v25, v24, v23);
  }
  _mem_free((void *)v3);
  _mem_free(v41);
  v27 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v38 = v29;
  v28 = snprintf(v29, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
  if ( v28 >= 0x100 )
    v28 = 255;
  v24 = v28;
  v25 = v38;
  v23 = 4;
  return httpd_cgi_ret(a1, v25, v24, v23);
}
// 498FE0: variable 'v2' is possibly undefined
// 498FF4: variable 'v1' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004995AC) --------------------------------------------------------
int __fastcall sub_4995AC(int a1)
{
  char *v2; // $s5
  char *v3; // $s6
  char *v4; // $s7
  char *v5; // $fp
  char *v6; // $s2
  char *v7; // $v0
  char *v8; // $v0
  char *v9; // $s1
  char *v10; // $s4
  const char *v11; // $v0
  int v12; // $s6
  int v13; // $v0
  int v14; // $a0
  bool v15; // dc
  char *v16; // $v0
  int *v17; // $v1
  const char *v18; // $v0
  int v19; // $t0
  int v20; // $a3
  int v21; // $a2
  int v22; // $a1
  _DWORD *v24; // $s6
  const char *v25; // $fp
  int v26; // $v0
  const char *v27; // $a2
  int v28; // $v0
  const char *v29; // $v1
  int v30; // $a0
  int v31; // $a1
  int v32; // $a0
  const char *v33; // $v0
  unsigned int v34; // $v0
  int v35; // $a2
  int v36; // $v0
  int v37; // $a1
  int v38; // $a0
  int v39; // $v0
  char v40[256]; // [sp+28h] [-270h] BYREF
  char *s; // [sp+128h] [-170h] BYREF
  const char *v42; // [sp+12Ch] [-16Ch]
  char *v43; // [sp+130h] [-168h]
  char *v44; // [sp+134h] [-164h]
  char *v45; // [sp+138h] [-160h]
  int v46; // [sp+13Ch] [-15Ch]
  int v47; // [sp+140h] [-158h]
  char v48[4]; // [sp+228h] [-70h] BYREF
  int v49; // [sp+22Ch] [-6Ch]
  int v50; // [sp+230h] [-68h]
  const char *v51; // [sp+244h] [-54h] BYREF
  char *v52; // [sp+248h] [-50h]
  char *v53; // [sp+24Ch] [-4Ch]
  char *v54; // [sp+250h] [-48h]
  char *v55; // [sp+254h] [-44h]
  int v56[4]; // [sp+260h] [-38h] BYREF
  char *v57; // [sp+270h] [-28h]
  char *v58; // [sp+274h] [-24h]
  char *v59; // [sp+278h] [-20h]
  int v60; // [sp+27Ch] [-1Ch]
  char *v61; // [sp+280h] [-18h]
  char *v62; // [sp+284h] [-14h]
  const char *v63; // [sp+288h] [-10h]
  char *v64; // [sp+28Ch] [-Ch]
  char *v65; // [sp+290h] [-8h]

  v61 = "1\"";
  v57 = httpd_get_parm(a1, "name");
  v58 = httpd_get_parm(a1, "old_name");
  v2 = httpd_get_parm(a1, "ip");
  v3 = httpd_get_parm(a1, "mask");
  v4 = httpd_get_parm(a1, "speed");
  v5 = httpd_get_parm(a1, "dns");
  v6 = httpd_get_parm(a1, "opt");
  v59 = (char *)httpd_get_json_parm(a1, (int)"del_list");
  _mem_malloc(102400, "pppoe_group_asp", 661);
  v9 = v8;
  _mem_malloc(102400, "pppoe_group_asp", 662);
  v10 = v7;
  if ( v9 && v7 )
  {
    if ( !v6 )
    {
LABEL_8:
      v11 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
      goto LABEL_9;
    }
    v60 = (int)"a";
    if ( !strcmp(v6, (const char *)&off_646D8C) || !strcmp(v6, (const char *)&off_648DDC) )
    {
      if ( !strcmp(v6, "delall") )
        goto LABEL_37;
      v62 = "1\"";
      if ( strcmp(v6, "del") )
      {
LABEL_13:
        if ( v57 )
        {
          v51 = v57;
          if ( !strcmp(v6, (const char *)(v60 + 28044)) )
          {
            v59 = "1\"";
          }
          else
          {
            v59 = "1\"";
            if ( strcmp(v6, (const char *)&off_648DDC) )
            {
LABEL_38:
              v17 = (int *)&s;
              v18 = "{\"code\":0,\"error\":\"\",\"data\":null}";
              do
              {
                v19 = *(_DWORD *)v18;
                v20 = *((_DWORD *)v18 + 1);
                v21 = *((_DWORD *)v18 + 2);
                v22 = *((_DWORD *)v18 + 3);
                v18 += 16;
                *v17 = v19;
                v17[1] = v20;
                v17[2] = v21;
                v17[3] = v22;
                v17 += 4;
              }
              while ( v18 != "}" );
              v12 = 33;
              *(_WORD *)v17 = *(_WORD *)v18;
              goto LABEL_41;
            }
          }
          if ( !v2 || !*v2 )
            v2 = "";
          v52 = v2;
          if ( !v3 || !*v3 )
            v3 = "255.255.255.0";
          v53 = v3;
          if ( !v4 || !*v4 )
            v4 = "";
          v54 = v4;
          if ( !v5 || !*v5 )
            v5 = "";
          v55 = v5;
          if ( strcmp(v6, v59 - 29220) )
          {
            if ( !strcmp(v6, (const char *)(v60 + 28044)) )
            {
              v12 = check_rule_num_limit(a1, 24, (int)"pppoe_group_list", 60, (char *)&s, 0x100u);
              if ( v12 > 0 )
                goto LABEL_41;
            }
            if ( v58 )
              goto LABEL_27;
LABEL_83:
            v13 = set_pppoe_group_to_kernel(v6, &v51, "0");
            goto LABEL_29;
          }
          jhl_parm_get("pppoe_group_list", v9, 102400);
          if ( !v58 )
          {
            if ( nvparm_get_str(v9, 60, 7, v57, 124, 0, v48) )
            {
              ip_get_tbm(v49, v50, v40);
              s = v61 + 444;
              v42 = "route";
              v43 = v62 - 15196;
              v44 = v40;
              v45 = "dev";
              v46 = jhl_nv_get_def("pppoesrv");
              v47 = 0;
              eval(&s, 0, 0, 0);
            }
            goto LABEL_83;
          }
          if ( !strcmp(v58, "Default") )
          {
            v37 = *(unsigned __int8 *)(a1 + 210102);
            v38 = 45;
          }
          else
          {
            v36 = pppoe_group_get_username(v58);
            v35 = 7;
            if ( v36 < 3 )
            {
              if ( nvparm_get_str(v9, 60, 7, v58, 124, 0, v48) )
              {
                ip_get_tbm(v49, v50, v40);
                s = v61 + 444;
                v42 = "route";
                v43 = v62 - 15196;
                v44 = v40;
                v45 = "dev";
                v46 = jhl_nv_get_def("pppoesrv");
                v47 = 0;
                eval(&s, 0, 0, 0);
              }
LABEL_27:
              if ( pppoe_group_del_kernel(v58) )
                goto LABEL_38;
              v56[0] = (int)"pppoe_group_del.sh";
              v56[1] = (int)v58;
              v56[2] = 0;
              eval(v56, 0, 0, 0);
              v13 = set_pppoe_group_to_kernel(v60 + 28044, &v51, "0");
LABEL_29:
              if ( v13 < 0 )
                goto LABEL_38;
              if ( !strcmp(v6, v59 - 29220) )
              {
                v59 = "1\"";
                jhl_parm_get("pppoe_group_list", v9, 102400);
                if ( v58 )
                  v39 = nvparm_del_str(v9, 60, 7, v58, 124, 0, v10);
                else
                  v39 = nvparm_del_str(v9, 60, 7, v57, 124, 0, v10);
                if ( v39 )
                {
                  sprintf(v9, "%s|%s|%s|%s|%s<", v51, v52, v53, v54, v55);
LABEL_34:
                  strcat(v10, v9);
                  goto LABEL_35;
                }
              }
              else
              {
                v59 = "1\"";
              }
              sprintf(v9, "%s|%s|%s|%s|%s<", v51, v52, v53, v54, v55);
              jhl_parm_get(v59 - 15976, v10, 102400);
              if ( !strcmp(v10, " ") )
                *v10 = 0;
              goto LABEL_34;
            }
            v37 = *(unsigned __int8 *)(a1 + 210102);
            v38 = 46;
          }
          v11 = (const char *)_GET_LANG_TEXT(v38, v37, v35);
        }
        else
        {
          v11 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_6442E4);
        }
LABEL_9:
        v12 = snprintf((char *)&s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
        if ( (unsigned int)v12 >= 0x100 )
          v12 = 255;
LABEL_41:
        _mem_free(v9);
        _mem_free(v10);
        return httpd_cgi_ret(a1, (char *)&s, v12, 4);
      }
    }
    else
    {
      v62 = "1\"";
      if ( strcmp(v6, "del") )
      {
        if ( strcmp(v6, "delall") )
          goto LABEL_8;
        goto LABEL_37;
      }
      if ( !strcmp(v6, "delall") )
      {
LABEL_37:
        v15 = set_pppoe_group_to_kernel(v6, &v51, "0") == 0;
        v16 = v10;
        if ( !v15 )
          goto LABEL_38;
        v29 = "Default|172.16.1.1|255.255.255.0||<";
        do
        {
          v30 = *((_DWORD *)v29 + 1);
          *(_DWORD *)v16 = *(_DWORD *)v29;
          *((_DWORD *)v16 + 1) = v30;
          v31 = *((_DWORD *)v29 + 2);
          *((_DWORD *)v16 + 1) = v30;
          *((_DWORD *)v16 + 2) = v31;
          v32 = *((_DWORD *)v29 + 3);
          *((_DWORD *)v16 + 2) = v31;
          *((_DWORD *)v16 + 3) = v32;
          v29 += 16;
          *((_DWORD *)v16 + 3) = v32;
          v16 += 16;
        }
        while ( v29 != "||<" );
        *(_DWORD *)v16 = *(_DWORD *)v29;
        v52 = "172.16.1.1";
        v51 = "Default";
        v53 = "255.255.255.0";
        v54 = "";
        v55 = "";
        set_pppoe_group_to_kernel(v60 + 28044, &v51, "0");
        v59 = "1\"";
LABEL_35:
        jhl_parm_set(v59 - 15976, v10);
        jhl_parm_commit(v14);
        goto LABEL_38;
      }
    }
    if ( v59 && cJSON_IsArray(v59) )
    {
      v24 = (_DWORD *)*((_DWORD *)v59 + 2);
      if ( !v24 )
        goto LABEL_38;
      v25 = (const char *)v24[4];
      if ( !v25 )
        goto LABEL_38;
      v57 = "1\"";
      v60 = 0;
      v58 = "a";
      v65 = "1\"";
      v63 = "route";
      v64 = "dev";
      do
      {
        v26 = strcmp(v25, v57 - 15812);
        v27 = v58 + 14076;
        if ( !v26 )
        {
          v11 = (const char *)_GET_LANG_TEXT(43, *(unsigned __int8 *)(a1 + 210102), v27);
          goto LABEL_9;
        }
        v51 = v25;
        if ( set_pppoe_group_to_kernel(v6, &v51, v27) < 0 )
        {
          v11 = (const char *)_GET_LANG_TEXT(44, *(unsigned __int8 *)(a1 + 210102), 102400);
          goto LABEL_9;
        }
        jhl_parm_get("pppoe_group_list", v9, 102400);
        v28 = nvparm_get_str(v9, 60, 7, v24[4], 124, 0, v48);
        v59 = "1\"";
        if ( v28 )
        {
          ip_get_tbm(v49, v50, v40);
          v43 = v62 - 15196;
          s = v61 + 444;
          v42 = v63;
          v44 = v40;
          v45 = v64;
          v46 = jhl_nv_get_def(v65 - 15804);
          v47 = 0;
          eval(&s, 0, 0, 0);
        }
        jhl_parm_get("pppoe_group_list", v9, 102400);
        if ( nvparm_del_str(v9, 60, 7, v24[4], 124, 0, v10) )
        {
          jhl_parm_set("pppoe_group_list", v10);
          v60 = 1;
        }
        v24 = (_DWORD *)*v24;
        if ( !v24 )
          break;
        v25 = (const char *)v24[4];
      }
      while ( v25 );
      if ( !v60 )
        goto LABEL_38;
      goto LABEL_35;
    }
    goto LABEL_13;
  }
  _mem_free(v9);
  _mem_free(v10);
  v33 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v34 = snprintf((char *)&s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v33);
  if ( v34 >= 0x100 )
    v34 = 255;
  return httpd_cgi_ret(a1, (char *)&s, v34, 4);
}
// 499704: variable 'v8' is possibly undefined
// 499710: variable 'v7' is possibly undefined
// 499A98: variable 'v14' is possibly undefined
// 49A07C: variable 'v35' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8250: using guessed type int __fastcall set_pppoe_group_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A84D0: using guessed type int __fastcall pppoe_group_del_kernel(_DWORD);
// 6A85D4: using guessed type int __fastcall pppoe_group_get_username(_DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86B0: using guessed type int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A898C: using guessed type int __fastcall ip_get_tbm(_DWORD, _DWORD, _DWORD);

//----- (0049A39C) --------------------------------------------------------
int __fastcall get_wans_pppoebr_data(char *a1, int a2)
{
  int v4; // $s3
  int v5; // $s1
  int v6; // $s0
  int v7; // $v0
  const char *v8; // $fp
  int v9; // $v0
  const char *v10; // $v0
  int v11; // $v0
  _BYTE *v12; // $v0
  int v13; // $v0
  _BYTE *v14; // $v0
  int v15; // $v0
  char *v16; // $v0
  int v18; // [sp+14h] [-84h]
  char v19[64]; // [sp+28h] [-70h] BYREF
  int v20; // [sp+68h] [-30h] BYREF
  int v21; // [sp+6Ch] [-2Ch]
  const char *v22; // [sp+78h] [-20h]
  const char *v23; // [sp+7Ch] [-1Ch]
  const char *v24; // [sp+80h] [-18h]
  char *v25; // [sp+84h] [-14h]
  int v26; // [sp+88h] [-10h]
  int *v27; // [sp+8Ch] [-Ch]
  int v28; // [sp+90h] [-8h]

  v4 = sq_file_get_max_wan();
  v5 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v5 >= a2 )
    v5 = a2 - 1;
  if ( v4 > 0 && v5 < a2 - 99 )
  {
    v22 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
    v6 = 0;
    v23 = "wan_pppoebr";
    v24 = "wan_increase";
    v25 = "1\"";
    do
    {
      v7 = jhl_nvget("wan_ifname", v6);
      v8 = (const char *)nvram_get(v7);
      if ( !v8 )
        v8 = v22 - 1556;
      if ( !*v8 )
        break;
      v9 = jhl_nvget("wan_down", v6);
      v10 = (const char *)nvram_get(v9);
      if ( v10 && !strcmp(v10, "1")
        || jhl_iface_link_up_check(v8, v6)
        || (v11 = jhl_nvget(v23, v6), (v12 = (_BYTE *)nvram_get(v11)) == 0)
        || !*v12
        || (strlcpy(v19, v12, 64), v27 = &v20, split_string(v19, 124, &v20, 2) < 2) )
      {
        if ( v4 == ++v6 )
          break;
      }
      else
      {
        v26 = J_atoi(v20);
        v28 = J_atoi(v21);
        v13 = jhl_nvget(v24, v26);
        v14 = (_BYTE *)nvram_get(v13);
        if ( v14 && *v14 && (strlcpy(v19, v14, 64), split_string(v19, 124, v27, 2) >= 2) )
          v18 = J_atoi(v21);
        else
          v18 = 0;
        v15 = snprintf(&a1[v5], a2 - v5, v25 - 15772, v6, v26, v18, v28);
        if ( v15 >= a2 - v5 )
          v15 = a2 - v5 - 1;
        ++v6;
        v5 += v15;
        if ( v4 == v6 )
          break;
      }
    }
    while ( v5 < a2 - 99 );
  }
  v16 = &a1[v5];
  if ( v5 > 0 && *(v16 - 1) == 44 )
    v16 = &a1[--v5];
  *(_WORD *)v16 = 93;
  return v5 + 1;
}
// 642A04: using guessed type __int16 word_642A04;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0049A75C) --------------------------------------------------------
void __fastcall format_pppoe_br_more_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 3 )
    snprintf(a3, a4, "{\"wan_name\":\"%s\",\"wan_iface\":%s,\"wan_num\":%s},", *a1, a1[1], a1[2]);
}

//----- (0049A7E4) --------------------------------------------------------
int __fastcall sub_49A7E4(int a1)
{
  int v1; // $v0
  char *v2; // $fp
  const char *v3; // $v0
  int v4; // $v0
  int v5; // $s3
  int v6; // $s1
  char *v7; // $s4
  int v8; // $s5
  int v9; // $s0
  const char **v10; // $s2
  void *v11; // $v0
  _DWORD *v12; // $s6
  int v13; // $a1
  void *v14; // $s5
  int v15; // $s5
  int i; // $s7
  int v17; // $v0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $s1
  int v21; // $v0
  int v22; // $s0
  int v23; // $v0
  int v24; // $s0
  int v25; // $v0
  int v26; // $s0
  int v27; // $v0
  int v28; // $a2
  int result; // $v0
  const char *v30; // $v0
  unsigned int v31; // $v0
  char v32[256]; // [sp+20h] [-108h] BYREF
  _DWORD *v33; // [sp+120h] [-8h]
  void *ptr; // [sp+124h] [-4h]

  _mem_malloc(0x200000, "pppoe_br_more_data", 946);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    v3 = (const char *)jhl_nv_get_def("pppoe_br_more_enable");
    v4 = snprintf(v2 + 29, 2097123, "\"enable\":\"%s\",\"all\":", v3);
    if ( v4 >= 2097123 )
      v4 = 2097122;
    v5 = v4 + 29;
    v6 = 0x200000 - (v4 + 29);
    v7 = &v2[v4 + 29];
    v8 = nvram_get("pppoe_br_all");
    v9 = snprintf(&v2[v5], 0x200000 - v5, (char *)&word_642A04);
    if ( v9 >= 0x200000 - v5 )
      v9 = 0x1FFFFF - v5;
    if ( v8 )
    {
      v10 = (const char **)malloc(0x14u);
      v33 = malloc(0x4008u);
      v12 = v33;
      v11 = malloc(0x200000u);
      ptr = v11;
      if ( v11 )
      {
        if ( v10 )
        {
          v13 = v8;
          if ( v33 )
          {
            v14 = v11;
            strlcpy(v11, v13, 0x200000);
            v15 = split_string(v14, 60, v33, 4096);
            if ( v15 > 0 )
            {
              for ( i = 0; i != v15; ++i )
              {
                v17 = split_string(*v12, 124, v10, 3);
                format_pppoe_br_more_data(v10, v17, &v7[v9], v6 - v9);
                v9 += v18;
                ++v12;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v10 )
        free(v10);
      if ( v33 )
        free(v33);
    }
    v19 = &v7[v9];
    if ( v9 > 0 && *(v19 - 1) == 44 )
      v19 = &v7[--v9];
    v20 = v6 - v9;
    *v19 = 0;
    v21 = snprintf(v19, v20, &byte_6445A0);
    if ( v21 >= v20 )
      v21 = v20 - 1;
    v22 = v9 + v21 + v5;
    v23 = snprintf(&v2[v22], 0x200000 - v22, (char *)&dword_6448E0);
    if ( v23 >= 0x200000 - v22 )
      v23 = 0x1FFFFF - v22;
    v24 = v23 + v22 + get_wans_pppoebr_data(&v2[v23 + v22], 0x200000 - (v23 + v22));
    v25 = snprintf(&v2[v24], 0x200000 - v24, ",\"real_wans\":");
    if ( v25 >= 0x200000 - v24 )
      v25 = 0x1FFFFF - v24;
    v26 = v25 + v24 + get_realwans_data(1, &v2[v25 + v24], 0x200000 - (v25 + v24));
    v27 = snprintf(&v2[v26], 0x200000 - v26, "}}");
    if ( v27 >= 0x200000 - v26 )
      v28 = 0x1FFFFF - v26;
    else
      v28 = v27;
    result = httpd_cgi_ret(a1, v2, v28 + v26, 8);
  }
  else
  {
    v30 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v31 = snprintf(v32, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v30);
    if ( v31 >= 0x100 )
      v31 = 255;
    result = httpd_cgi_ret(a1, v32, v31, 4);
  }
  return result;
}
// 49A844: variable 'v1' is possibly undefined
// 49AA34: variable 'v18' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6448E0: using guessed type int dword_6448E0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85B4: using guessed type int __fastcall get_realwans_data(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0049ACB4) --------------------------------------------------------
int __fastcall sub_49ACB4(int a1)
{
  int v2; // $s0
  void *v3; // $v0
  char *v4; // $v0
  void *v5; // $s1
  char *v6; // $s2
  const char *v7; // $v0
  int v8; // $a0
  char *v9; // $v1
  const char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  unsigned int v15; // $s0
  const char *v17; // $v0
  _DWORD *v18; // $s0
  int v19; // $v0
  int v20; // $s1
  int v21; // $s3
  int v22; // $fp
  int v23; // $s1
  char *v24; // $a1
  char *v25; // $v0
  char *v26; // $s3
  char *v27; // $v0
  int v28; // $v0
  char *v29; // $fp
  unsigned int v30; // $v0
  int v31; // $v0
  int v32; // $a1
  int v33; // $a2
  int v34; // $a0
  const char *v35; // $v0
  char v36[256]; // [sp+28h] [-180h] BYREF
  char v37[32]; // [sp+128h] [-80h] BYREF
  char v38[32]; // [sp+148h] [-60h] BYREF
  int v39[2]; // [sp+168h] [-40h] BYREF
  char *s; // [sp+170h] [-38h]
  char *v41; // [sp+174h] [-34h]
  char *v42; // [sp+178h] [-30h]
  char *v43; // [sp+17Ch] [-2Ch]
  void *v44; // [sp+180h] [-28h]
  char *v45; // [sp+184h] [-24h]
  char *v46; // [sp+188h] [-20h]
  unsigned int v47; // [sp+18Ch] [-1Ch]
  char *v48; // [sp+190h] [-18h]
  char *v49; // [sp+194h] [-14h]
  int v50; // [sp+198h] [-10h]
  char *format; // [sp+19Ch] [-Ch]
  const char *v52; // [sp+1A0h] [-8h]

  v2 = httpd_get_json_parm(a1, (int)"list");
  v45 = httpd_get_parm(a1, "enable");
  v47 = sq_file_get_max_wan();
  _mem_malloc(0x200000, "pppoe_br_more_asp", 987);
  v44 = v3;
  v5 = v3;
  _mem_malloc(0x200000, "pppoe_br_more_asp", 988);
  v6 = v4;
  if ( !v5 || !v4 )
  {
    v17 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    s = v36;
    v15 = snprintf(v36, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
    if ( v15 >= 0x100 )
      v15 = 255;
    goto LABEL_13;
  }
  jhl_parm_get("pppoe_br_all", v44, 0x200000);
  if ( !v2
    || !cJSON_IsArray(v2)
    || (v52 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n",
        jhl_parm_set("pppoe_br_all", ""),
        (v18 = *(_DWORD **)(v2 + 8)) == 0) )
  {
    s = v36;
LABEL_6:
    if ( v45 )
    {
      v7 = (const char *)nvram_get("pppoe_br_more_enable");
      if ( !v7 || strcmp(v7, v45) )
        nvram_set("pppoe_br_more_enable", v45);
    }
    v39[0] = (int)"pppoe_br_more_clean.sh";
    v39[1] = 0;
    eval(v39, 0, 0, 0);
    jhl_parm_commit(v8);
    jhl_gl_net_restart_timer(1000);
    v9 = s;
    v10 = "{\"code\":4,\"error\":\"\",\"data\":null}";
    do
    {
      v11 = *(_DWORD *)v10;
      v12 = *((_DWORD *)v10 + 1);
      v13 = *((_DWORD *)v10 + 2);
      v14 = *((_DWORD *)v10 + 3);
      v10 += 16;
      *(_DWORD *)v9 = v11;
      *((_DWORD *)v9 + 1) = v12;
      *((_DWORD *)v9 + 2) = v13;
      *((_DWORD *)v9 + 3) = v14;
      v9 += 16;
    }
    while ( v10 != "}" );
    v15 = 33;
    *(_WORD *)v9 = *(_WORD *)v10;
    goto LABEL_13;
  }
  v41 = "a";
  v42 = "a";
  v43 = "a";
  v48 = "a";
  s = v36;
  v50 = (int)"pppoe_br_all";
  format = "%s%s|%s|%s<";
  v49 = "1";
  while ( 1 )
  {
    v20 = cJSON_GetObjectItem(v18, v41 + 12200);
    v21 = cJSON_GetObjectItem(v18, v42 + 12212);
    v22 = cJSON_GetObjectItem(v18, v43 + 12224);
    if ( !v20 )
      goto LABEL_20;
    v23 = *(_DWORD *)(v20 + 16);
    if ( !v23 || !v21 || !*(_DWORD *)(v21 + 16) || !v22 || !*(_DWORD *)(v22 + 16) )
      goto LABEL_20;
    jhl_parm_get("pppoe_br_all", v6, 0x200000);
    if ( nvparm_find_str(v6, 60, 5, v23, 124, 0) )
    {
      v32 = *(unsigned __int8 *)(a1 + 210102);
      v33 = (int)"same name";
      v34 = 12;
      goto LABEL_40;
    }
    if ( check_rule_num_limit(a1, 34, v50, 60, s, 0x100u) > 0 )
    {
      v15 = 0;
      goto LABEL_42;
    }
    v24 = *(char **)(v21 + 16);
    if ( !v24 || !*v24 )
    {
      v25 = v49;
      *(_DWORD *)(v21 + 16) = v49;
      v24 = v25;
    }
    v26 = *(char **)(v22 + 16);
    if ( !v26 || !*v26 )
    {
      v27 = v49;
      *(_DWORD *)(v22 + 16) = v49;
      v26 = v27;
    }
    v46 = v24;
    if ( (unsigned int)J_ato10(v24) >= 0xFA )
      break;
    v28 = J_ato10(v46);
    v29 = v48;
    sprintf(v37, v48 + 24872, v28);
    v30 = J_ato10(v26);
    if ( v47 < v30 )
    {
      sprintf(v38, v29 + 24872, v47);
      v19 = nvram_get("pppoe_br_all");
      if ( !v19 )
        goto LABEL_38;
    }
    else
    {
      v31 = J_ato10(v26);
      sprintf(v38, v48 + 24872, v31);
      v19 = nvram_get("pppoe_br_all");
      if ( !v19 )
      {
LABEL_38:
        v19 = (int)(v52 - 1556);
        goto LABEL_19;
      }
    }
LABEL_19:
    snprintf(v6, 0x200000, format, v19, v23, v37, v38);
    jhl_parm_set("pppoe_br_all", v6);
LABEL_20:
    v18 = (_DWORD *)*v18;
    if ( !v18 )
      goto LABEL_6;
  }
  v32 = *(unsigned __int8 *)(a1 + 210102);
  v33 = 249;
  v34 = 167;
LABEL_40:
  v35 = (const char *)_GET_LANG_TEXT(v34, v32, v33);
  v15 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v35);
  if ( v15 >= 0x100 )
    v15 = 255;
LABEL_42:
  jhl_parm_set("pppoe_br_all", v44);
LABEL_13:
  _mem_free(v44);
  _mem_free(v6);
  return httpd_cgi_ret(a1, s, v15, 4);
}
// 49AD68: variable 'v3' is possibly undefined
// 49AD7C: variable 'v4' is possibly undefined
// 49AE68: variable 'v8' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A853C: using guessed type int __fastcall J_ato10(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (0049B3AC) --------------------------------------------------------
int __fastcall sub_49B3AC(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "pppoe_br_more_txt", 1089);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("pppoe_br_all");
    if ( !v3 )
      v3 = "";
    v5 = snprintf(v4, 0x200000, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    if ( v5 >= 0x200000 )
      v5 = 0x1FFFFF;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 49B3EC: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0049B514) --------------------------------------------------------
int __fastcall sub_49B514(int a1)
{
  char *v2; // $v0
  _BYTE *v3; // $v0
  _BYTE *v4; // $s4
  char *v5; // $s2
  int v6; // $s3
  char *v7; // $v0
  char *v8; // $s0
  char *v9; // $s1
  char *v10; // $v0
  int v11; // $a0
  int v12; // $v1
  _BOOL4 v13; // $a2
  char *v14; // $s0
  int v15; // $s1
  int v16; // $s7
  int v17; // $a0
  char *v18; // $v1
  const char *v19; // $v0
  int v20; // $t0
  int v21; // $a3
  int v22; // $a2
  int v23; // $a1
  unsigned int v24; // $s0
  const char *v25; // $v0
  unsigned int v26; // $a2
  const char *v28; // $v0
  char v29[16384]; // [sp+20h] [-4420h] BYREF
  char v30[1024]; // [sp+4020h] [-420h] BYREF
  int v31[6]; // [sp+4420h] [-20h] BYREF
  char *format; // [sp+4438h] [-8h]
  char *v33; // [sp+443Ch] [-4h]

  _mem_malloc(0x200000, "pppoe_br_more_cgi", 1120);
  v4 = v3;
  _mem_malloc(0x200000, "pppoe_br_more_cgi", 1121);
  v5 = v2;
  if ( v4 && v2 )
  {
    v6 = *(_DWORD *)(a1 + 205364);
    find_file_head(a1, *(const char **)(a1 + 205564));
    v8 = v7;
    if ( v7 )
    {
      v9 = find_file_end(a1, v7, *(_DWORD *)(a1 + 205564) + v6 - (_DWORD)v7);
      if ( v9 )
      {
        v33 = "1\"";
        *v9 = 0;
        jhl_parm_get("pppoe_br_all", v5, 0x200000);
        if ( v9 - v8 <= 0 )
        {
          v11 = 0;
        }
        else
        {
          v10 = v8;
          v11 = 0;
          do
          {
            v12 = *v10++;
            v13 = v11 + 1 < 0x1FFFFF;
            if ( v12 != 13 && v12 != 10 )
            {
              v4[v11++] = v12;
              if ( !v13 )
                break;
            }
          }
          while ( v9 != v10 );
        }
        v14 = v29;
        v4[v11] = 0;
        v15 = split_string(v4, 60, v29, 512);
        if ( v15 > 0 )
        {
          v16 = 0;
          format = "%s|%s|%s<";
          do
          {
            while ( 1 )
            {
              ++v16;
              if ( split_string(*(_DWORD *)v14, 124, v31, 5) >= 3 && !nvparm_find_str(v5, 60, 5, v31[0], 124, 0) )
                break;
              v14 += 4;
              if ( v15 == v16 )
                goto LABEL_17;
            }
            snprintf(v30, 1024, format, v31[0], v31[1], v31[2]);
            strcat(v5, v30);
            v14 += 4;
          }
          while ( v15 != v16 );
        }
LABEL_17:
        jhl_parm_set(v33 - 15648, v5);
        jhl_parm_commit(v17);
        jhl_gl_net_restart_timer(1000);
        v18 = v30;
        v19 = "{\"code\":4,\"error\":\"\",\"data\":null}";
        do
        {
          v20 = *(_DWORD *)v19;
          v21 = *((_DWORD *)v19 + 1);
          v22 = *((_DWORD *)v19 + 2);
          v23 = *((_DWORD *)v19 + 3);
          v19 += 16;
          *(_DWORD *)v18 = v20;
          *((_DWORD *)v18 + 1) = v21;
          *((_DWORD *)v18 + 2) = v22;
          *((_DWORD *)v18 + 3) = v23;
          v18 += 16;
        }
        while ( v19 != "}" );
        v24 = 33;
        *(_WORD *)v18 = *(_WORD *)v19;
        goto LABEL_28;
      }
      if ( debug_level > 0 )
        printf("%s:%d find_file_end err \n", "pppoe_br_more_cgi", 1141);
    }
    else if ( debug_level > 0 )
    {
      printf("%s:%d find_file_head err  \n", "pppoe_br_more_cgi", 1134);
    }
    v28 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
    v24 = snprintf(v30, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v28);
    if ( v24 >= 0x400 )
      v24 = 1023;
LABEL_28:
    _mem_free(v4);
    _mem_free(v5);
    return httpd_cgi_ret(a1, v30, v24, 4);
  }
  _mem_free(v4);
  _mem_free(v5);
  v25 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v26 = snprintf(v30, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v25);
  if ( v26 >= 0x400 )
    v26 = 1023;
  return httpd_cgi_ret(a1, v30, v26, 4);
}
// 49B584: variable 'v3' is possibly undefined
// 49B590: variable 'v2' is possibly undefined
// 49B5C0: variable 'v7' is possibly undefined
// 49B77C: variable 'v17' is possibly undefined
// 67D0BC: using guessed type int debug_level;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0049B9EC) --------------------------------------------------------
int __fastcall pppoe_br_get_state(char *a1, size_t a2)
{
  char *v4; // $v0
  int v5; // $a2
  char *v6; // $fp
  int v7; // $v0
  int v8; // $s7
  char *v10; // $s5
  int v11; // $s3
  int v12; // $v0
  int v13; // $v0
  char v14[32]; // [sp+28h] [-38h] BYREF
  int v15; // [sp+48h] [-18h]
  char *v16; // [sp+4Ch] [-14h]
  char *format; // [sp+50h] [-10h]
  char *v18; // [sp+54h] [-Ch]
  char *v19; // [sp+58h] [-8h]
  char *v20; // [sp+5Ch] [-4h]

  _mem_malloc(a2, "pppoe_br_get_state", 1202);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = 41;
    *((_DWORD *)v4 + 3) = 2;
    *((_DWORD *)v4 + 1) = a2;
    if ( !jianhl_order_opt_fun(v4, a2, v5) )
    {
      memset(a1, 0, a2);
      v10 = v6 + 2116;
      v16 = "1\"";
      v15 = a2 - 49;
      format = "%u-%u";
      v8 = 0;
      v19 = "%u";
      v11 = 1;
      v18 = ".%u-%u";
      v20 = ".%u";
      do
      {
        if ( *((unsigned __int16 *)v10 + 8) == *((unsigned __int16 *)v10 + 9) )
          v12 = sprintf(v14, v19);
        else
          v12 = sprintf(v14, format);
        if ( *((_WORD *)v10 + 10) )
        {
          if ( *((unsigned __int16 *)v10 + 10) == *((unsigned __int16 *)v10 + 11) )
            sprintf(&v14[v12], v20);
          else
            sprintf(&v14[v12], v18);
        }
        v13 = snprintf(&a1[v8], a2 - v8, v16 - 15576, v11, v10, *((_DWORD *)v10 + 6), *((_DWORD *)v10 + 7), v14);
        if ( v13 >= (int)(a2 - v8) )
          v13 = a2 - v8 - 1;
        v8 += v13;
        if ( v8 >= v15 )
          break;
        ++v11;
        v10 += 32;
      }
      while ( v11 != 3 );
      if ( v8 > 0 )
      {
        v7 = v8;
        if ( a1[v8 - 1] != 44 )
          goto LABEL_4;
        --v8;
      }
      v7 = v8;
      goto LABEL_4;
    }
  }
  v7 = 0;
  v8 = 0;
LABEL_4:
  a1[v7] = 0;
  _mem_free(v6);
  return v8;
}
// 49BA50: variable 'v4' is possibly undefined
// 49BA70: variable 'v5' is possibly undefined
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0049BC60) --------------------------------------------------------
int __fastcall sub_49BC60(int a1)
{
  int v1; // $v0
  int v2; // $s7
  int v3; // $s6
  int v4; // $s5
  const char *v5; // $v0
  int v6; // $s6
  int v7; // $s5
  const char *v8; // $v0
  int v9; // $s6
  char *v10; // $s1
  int v11; // $s5
  int v12; // $v0
  const char *v13; // $s1
  const char *v14; // $v0
  int v15; // $v0
  int v16; // $s0
  int v17; // $s1
  int v18; // $v0
  int v19; // $s0
  int v20; // $v0
  int v21; // $s0
  int v22; // $v0
  int v23; // $a2
  int result; // $v0
  const char *v25; // $v0
  unsigned int v26; // $v0
  const char *v27; // $v0
  int v28; // $v0
  const char *v29; // $v0
  char v30[10240]; // [sp+30h] [-7890h] BYREF
  char v31[10240]; // [sp+2830h] [-5090h] BYREF
  char v32[10240]; // [sp+5030h] [-2890h] BYREF
  int v33; // [sp+7830h] [-90h] BYREF
  char v34[12]; // [sp+7834h] [-8Ch] BYREF
  char *format; // [sp+78B0h] [-10h]
  int v36; // [sp+78B4h] [-Ch]
  int v37; // [sp+78B8h] [-8h]

  memset(v32, 0, sizeof(v32));
  memset(v31, 0, sizeof(v31));
  memset(v30, 0, sizeof(v30));
  _mem_malloc(0x200000, "pppoe_br_data", 1275);
  v2 = v1;
  if ( v1 )
  {
    v36 = (int)"a";
    v3 = 2;
    format = "pppoe_br_wan%d";
    v4 = 0;
    v37 = 1869639792;
    while ( v3 == 2 )
    {
      v33 = v37;
      strcpy(v34, "e_br_wan");
      v27 = (const char *)jhl_nv_get_def(&v33);
      v4 += sprintf(&v32[v4], "%s|", v27);
      v3 = 3;
    }
    sprintf((char *)&v33, format, 2);
    v5 = (const char *)jhl_nv_get_def(&v33);
    sprintf(&v32[v4], "%s|", v5);
    format = "pppoe_br_vlan%d";
    v6 = 2;
    v7 = 0;
    v37 = 1869639792;
    while ( v6 == 2 )
    {
      v33 = v37;
      strcpy(v34, "e_br_vlan");
      v29 = (const char *)jhl_nv_get_def(&v33);
      v7 += sprintf(&v31[v7], "%s|", v29);
      v6 = 3;
    }
    sprintf((char *)&v33, format, 2);
    v8 = (const char *)jhl_nv_get_def(&v33);
    sprintf(&v31[v7], "%s|", v8);
    format = "pppoe_br_info%d";
    v9 = 2;
    v10 = (char *)(v36 + 11516);
    v11 = 0;
    v36 = 1869639792;
    while ( v9 == 2 )
    {
      v33 = v36;
      strcpy(v34, "e_br_info");
      v28 = jhl_nv_get_def(&v33);
      v11 += sprintf(&v30[v11], v10, v28);
      v9 = 3;
    }
    sprintf((char *)&v33, format, 2);
    v12 = jhl_nv_get_def(&v33);
    sprintf(&v30[v11], v10, v12);
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v13 = (const char *)jhl_nv_get_def("pppoe_br_enable");
    v14 = (const char *)jhl_nv_get_def("pppoe_br_time");
    v15 = snprintf(
            (char *)(v2 + 29),
            2097123,
            "\"enable\":%s,\"wan_br_iface\":\"%s\",\"wan_br_vlan\":\"%s\",\"wan_br_info\":\"%s\",\"wan_br_time\":\"%s\",\""
            "wan_max\":\"%d\"",
            v13,
            v32,
            v31,
            v30,
            v14,
            2);
    if ( v15 >= 2097123 )
      v15 = 2097122;
    v16 = v15 + 29;
    v17 = 0x200000 - (v15 + 29);
    v18 = snprintf((char *)(v2 + v15 + 29), v17, ",\"state\":[");
    if ( v18 >= v17 )
      v18 = 0x1FFFFF - v16;
    v19 = v18 + v16 + pppoe_br_get_state((char *)(v2 + v18 + v16), 0x200000 - (v18 + v16));
    v20 = snprintf((char *)(v2 + v19), 0x200000 - v19, &byte_6445A0);
    if ( v20 >= 0x200000 - v19 )
      v20 = 0x1FFFFF - v19;
    v21 = v20 + v19;
    v22 = snprintf((char *)(v2 + v21), 0x200000 - v21, "}}");
    if ( v22 >= 0x200000 - v21 )
      v23 = 0x1FFFFF - v21;
    else
      v23 = v22;
    result = httpd_cgi_ret(a1, (char *)v2, v23 + v21, 8);
  }
  else
  {
    v25 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v26 = snprintf((char *)&v33, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v25);
    if ( v26 >= 0x80 )
      v26 = 127;
    result = httpd_cgi_ret(a1, (char *)&v33, v26, 4);
  }
  return result;
}
// 49BDA4: conditional instruction was optimized away because of '$s6.4==3'
// 49BE24: conditional instruction was optimized away because of '$s6.4==3'
// 49BEAC: conditional instruction was optimized away because of '$s6.4==3'
// 49BDA8: ignored the value written to the shadow area of the succeeding call
// 49BE28: ignored the value written to the shadow area of the succeeding call
// 49BD14: variable 'v1' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0049C250) --------------------------------------------------------
int __fastcall sub_49C250(int a1)
{
  unsigned int v2; // $s3
  char *v3; // $s5
  char *v4; // $s6
  int v5; // $v0
  char *v6; // $s2
  int v7; // $s0
  int v8; // $a1
  const char *v9; // $a2
  const char *v10; // $v0
  unsigned int v11; // $a2
  _BOOL4 v12; // $s5
  int v13; // $a0
  const char *v14; // $v0
  char **v15; // $v1
  char *v16; // $t0
  char *v17; // $a3
  char *v18; // $a2
  char *v19; // $a1
  _DWORD *v21; // $fp
  char *v22; // $s0
  char *v23; // $s6
  char *v24; // $s2
  char *v25; // $s4
  int v26; // $a0
  char *v27; // $s5
  int v28; // $s6
  char *v29; // $a1
  char *v30; // $a1
  int v31; // $s4
  int v32; // $s4
  const char *v33; // $v1
  char **v34; // $v0
  char *v35; // $t0
  char *v36; // $a3
  char *v37; // $a2
  char *v38; // $a1
  int v39; // $t0
  _DWORD v40[25600]; // [sp+28h] [-32030h] BYREF
  char *v41; // [sp+19028h] [-19030h] BYREF
  char *v42; // [sp+1902Ch] [-1902Ch]
  int v43; // [sp+30028h] [-2030h] BYREF
  const char *v44; // [sp+32028h] [-30h] BYREF
  const char *v45; // [sp+3202Ch] [-2Ch]
  const char *v46; // [sp+32030h] [-28h]
  const char *v47; // [sp+32034h] [-24h]
  int v48; // [sp+32038h] [-20h]
  char *v49; // [sp+3203Ch] [-1Ch] BYREF
  char *v50; // [sp+32040h] [-18h]
  char *v51; // [sp+32048h] [-10h]
  const char *v52; // [sp+3204Ch] [-Ch]
  const char *v53; // [sp+32050h] [-8h]
  const char *v54; // [sp+32054h] [-4h]

  v2 = sq_file_get_max_wan();
  v3 = httpd_get_parm(a1, "wan_name");
  v4 = httpd_get_parm(a1, "wan_mac");
  v6 = httpd_get_parm(a1, "opt");
  v5 = httpd_get_json_parm(a1, (int)"del_list");
  if ( !v6 )
    goto LABEL_6;
  v7 = v5;
  if ( !strcmp(v6, (const char *)&off_646D8C) || !strcmp(v6, (const char *)&off_648DDC) )
  {
    if ( !strcmp(v6, (const char *)&off_64712C) )
      goto LABEL_34;
    if ( strcmp(v6, "del") )
      goto LABEL_12;
    goto LABEL_24;
  }
  if ( !strcmp(v6, "del") )
  {
    if ( !strcmp(v6, (const char *)&off_64712C) )
      goto LABEL_34;
LABEL_24:
    if ( v7 && cJSON_IsArray(v7) )
    {
      v21 = *(_DWORD **)(v7 + 8);
      if ( !v21 || !v21[4] )
        goto LABEL_19;
      v51 = "1\"";
      v52 = "wys";
      v53 = "pppoe_br";
      v12 = 0;
      v54 = "mac_del";
      do
      {
        jhl_parm_get("pppoe_br_mac", &v41, 102400);
        if ( nvparm_get_str(&v41, 60, 4, v21[4], 124, 0, &v49) )
        {
          v44 = v52;
          v45 = v53;
          v46 = v54;
          v47 = v50;
          v48 = 0;
          eval(&v44, 0, 0, 0);
          jhl_parm_get(v51 - 15228, &v41, 102400);
          if ( nvparm_del_str(&v41, 60, 4, v21[4], 124, 0, v40) )
          {
            jhl_parm_set(v51 - 15228, v40);
            v12 = 1;
          }
        }
        v21 = (_DWORD *)*v21;
      }
      while ( v21 && v21[4] );
LABEL_66:
      if ( !v12 )
      {
LABEL_19:
        v14 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        v15 = &v41;
        do
        {
          v16 = *(char **)v14;
          v17 = (char *)*((_DWORD *)v14 + 1);
          v18 = (char *)*((_DWORD *)v14 + 2);
          v19 = (char *)*((_DWORD *)v14 + 3);
          v14 += 16;
          *v15 = v16;
          v15[1] = v17;
          v15[2] = v18;
          v15[3] = v19;
          v15 += 4;
        }
        while ( v14 != "}" );
        v11 = 33;
        *(_WORD *)v15 = *(_WORD *)v14;
        return httpd_cgi_ret(a1, (char *)&v41, v11, 4);
      }
LABEL_18:
      jhl_parm_set("pppoe_br_mac", v40);
      jhl_parm_commit(v13);
      goto LABEL_19;
    }
LABEL_12:
    if ( !v3 )
    {
      v8 = *(unsigned __int8 *)(a1 + 210102);
      v9 = (const char *)&unk_6442E4;
      goto LABEL_7;
    }
    v51 = (char *)&v43;
    v49 = v3;
    if ( !strcmp(v6, (const char *)&off_648DDC) )
    {
      v53 = (const char *)102400;
      v52 = (const char *)&v41;
      jhl_parm_get("pppoe_br_mac", &v41, 102400);
      if ( nvparm_get_str(v52, 60, 4, v3, 124, 0, &v49) )
      {
        v39 = *((_DWORD *)v51 + 2054);
        v40[0] = "wys";
        v40[3] = v39;
        v40[1] = "pppoe_br";
        v40[2] = "mac_del";
        v40[4] = 0;
        eval(v40, 0, 0, 0);
        jhl_parm_get("pppoe_br_mac", v52, v53);
        v12 = nvparm_del_str(v52, 60, 4, v3, 124, 0, v40) != 0;
      }
      else
      {
        v12 = 0;
      }
      if ( strcmp(v6, (const char *)&off_646D8C) && strcmp(v6, (const char *)&off_648DDC) )
        goto LABEL_66;
    }
    else
    {
      v12 = 0;
      if ( strcmp(v6, (const char *)&off_646D8C) )
        goto LABEL_19;
    }
    if ( !v4 )
    {
      v10 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_646720);
LABEL_8:
      v11 = snprintf((char *)&v41, 102400, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
      if ( v11 >= 0x19000 )
        v11 = 102399;
      return httpd_cgi_ret(a1, (char *)&v41, v11, 4);
    }
    v44 = "wys";
    v45 = "pppoe_br";
    v50 = v4;
    v46 = "mac_add";
    v47 = v4;
    v48 = 0;
    eval(&v44, 0, 0, 0);
    sprintf((char *)&v41, "%s|%s<", v49, v50);
    if ( !v12 )
    {
      jhl_parm_get("pppoe_br_mac", v40, 102400);
      if ( !strcmp((const char *)v40, " ") )
        LOBYTE(v40[0]) = 0;
    }
    strcat((char *)v40, (char *)&v41);
    goto LABEL_18;
  }
  if ( strcmp(v6, (const char *)&off_64712C) )
  {
LABEL_6:
    v8 = *(unsigned __int8 *)(a1 + 210102);
    v9 = "not opt";
LABEL_7:
    v10 = (const char *)_GET_LANG_TEXT(12, v8, v9);
    goto LABEL_8;
  }
LABEL_34:
  v22 = httpd_get_parm(a1, "enable");
  v23 = httpd_get_parm(a1, "wan_br_iface");
  v24 = httpd_get_parm(a1, "wan_br_time");
  v25 = httpd_get_parm(a1, "wan_br_vlan");
  v27 = httpd_get_parm(a1, "wan_br_info");
  if ( v22 )
    jhl_parm_set("pppoe_br_enable", v22);
  if ( v23 )
  {
    v28 = split_string(v23, 124, &v41, 3);
    if ( v28 > 0 )
    {
      strcpy((char *)v40, "pppoe_br_wan");
      if ( v41 && v2 >= J_atoi(v41) )
      {
        v29 = v41;
      }
      else
      {
        v29 = "0";
        v41 = "0";
      }
      jhl_parm_set(v40, v29);
      if ( v28 != 1 )
      {
        sprintf((char *)v40, "pppoe_br_wan%d", 2);
        if ( v42 && v2 >= J_atoi(v42) )
        {
          v30 = v42;
        }
        else
        {
          v30 = "0";
          v42 = "0";
        }
        jhl_parm_set(v40, v30);
      }
    }
  }
  if ( v25 )
  {
    v31 = split_string(v25, 124, &v41, 3);
    if ( v31 > 0 )
    {
      strcpy((char *)v40, "pppoe_br_vlan");
      jhl_parm_set(v40, v41);
      if ( v31 != 1 )
      {
        sprintf((char *)v40, "pppoe_br_vlan%d", 2);
        jhl_parm_set(v40, v42);
      }
    }
  }
  if ( v27 )
  {
    v32 = split_string(v27, 124, &v41, 3);
    if ( v32 > 0 )
    {
      strcpy((char *)v40, "pppoe_br_info");
      jhl_parm_set(v40, v41);
      if ( v32 != 1 )
      {
        sprintf((char *)v40, "pppoe_br_info%d", 2);
        jhl_parm_set(v40, v42);
      }
    }
  }
  if ( v24 )
    jhl_parm_set("pppoe_br_time", v24);
  jhl_parm_commit(v26);
  jhl_gl_net_restart_timer(1000);
  v33 = "{\"code\":4,\"error\":\"\",\"data\":null}";
  v34 = &v41;
  do
  {
    v35 = *(char **)v33;
    v36 = (char *)*((_DWORD *)v33 + 1);
    v37 = (char *)*((_DWORD *)v33 + 2);
    v38 = (char *)*((_DWORD *)v33 + 3);
    v33 += 16;
    *v34 = v35;
    v34[1] = v36;
    v34[2] = v37;
    v34[3] = v38;
    v34 += 4;
  }
  while ( v33 != "}" );
  *(_WORD *)v34 = *(_WORD *)v33;
  v11 = 33;
  return httpd_cgi_ret(a1, (char *)&v41, v11, 4);
}
// 49C584: variable 'v13' is possibly undefined
// 49CBAC: variable 'v26' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86B0: using guessed type int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0049CE98) --------------------------------------------------------
int __fastcall pppoe_br_session_get_state(int a1, int a2)
{
  int *v4; // $v0
  int v5; // $a2
  int *v6; // $s3
  bool v7; // dc
  int v8; // $v0
  char *v9; // $s7
  int v10; // $s0
  int v11; // $s2
  int v12; // $v0
  int v13; // $v0
  int v14; // $a3
  int v15; // $a2
  char v17[32]; // [sp+48h] [-58h] BYREF
  char v18[32]; // [sp+68h] [-38h] BYREF
  int v19; // [sp+88h] [-18h]
  int v20; // [sp+8Ch] [-14h]
  char *format; // [sp+90h] [-10h]
  char *v22; // [sp+94h] [-Ch]
  char *v23; // [sp+98h] [-8h]
  char *v24; // [sp+9Ch] [-4h]

  v24 = "1\"";
  _mem_malloc(0x200000, "pppoe_br_session_get_state", 1537);
  v6 = v4;
  if ( !v4 )
    goto LABEL_12;
  *v4 = 41;
  v4[3] = 12;
  v4[1] = 0x200000;
  v7 = jianhl_order_opt_fun(v4, 0x200000, v5) != 0;
  v8 = 0;
  if ( v7 )
  {
LABEL_13:
    v10 = 0;
    goto LABEL_14;
  }
  if ( v6[5] <= 0 )
  {
LABEL_12:
    v8 = 0;
    goto LABEL_13;
  }
  v20 = a2 - 49;
  v9 = (char *)v6 + 26;
  v23 = "%u";
  v10 = 0;
  format = "%u.%u";
  v11 = 0;
  v22 = "{\"session\":%u,\"mac\":\"%s\",\"user\":\"%s\",\"in_dev\":\"%s\",\"out_dev\":\"%s\",\"odate\":%u,\"qup\":%u,\"qd"
        "w\":%u,\"zup\":%u,\"zdw\":%u,\"mem\":\"%s\",\"vlan\":\"%s\",\"name\":\"%s\"},";
  do
  {
    v14 = *((unsigned __int16 *)v9 + 142);
    v15 = *((unsigned __int16 *)v9 + 141);
    if ( *((_WORD *)v9 + 142) )
      sprintf(v17, format, v15, v14);
    else
      sprintf(v17, v23, v15, v14);
    v19 = ntohs(*((_WORD *)v9 - 1));
    v12 = MacToStr(v18, v9);
    v13 = snprintf(
            (char *)(a1 + v10),
            a2 - v10,
            v22,
            v19,
            v12,
            v9 + 58,
            v9 + 6,
            v9 + 22,
            *(_DWORD *)(v9 + 38),
            *(_DWORD *)(v9 + 42),
            *(_DWORD *)(v9 + 46),
            *(_DWORD *)(v9 + 50),
            *(_DWORD *)(v9 + 54),
            v9 + 122,
            v17,
            v9 + 250);
    if ( v13 >= a2 - v10 )
      v13 = a2 - v10 - 1;
    v10 += v13;
    ++v11;
    if ( v10 >= v20 )
      break;
    v9 += 292;
  }
  while ( v11 < v6[5] );
  if ( v10 <= 0 )
    goto LABEL_18;
  v8 = v10;
  if ( *(_BYTE *)(a1 + v10 - 1) == 44 )
  {
    --v10;
LABEL_18:
    v8 = v10;
  }
LABEL_14:
  *(_BYTE *)(a1 + v8) = 0;
  _mem_free(v6);
  return v10;
}
// 49CF00: variable 'v4' is possibly undefined
// 49CF24: variable 'v5' is possibly undefined
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0049D12C) --------------------------------------------------------
int __fastcall sub_49D12C(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $s2
  int v5; // $v0
  int v6; // $a2
  int result; // $v0
  const char *v8; // $v0
  unsigned int v9; // $v0
  char v10[128]; // [sp+20h] [-80h] BYREF

  memset(v10, 0, sizeof(v10));
  _mem_malloc(0x200000, "pppoe_br_session_list_data", 1619);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v4 = pppoe_br_session_get_state(v2 + 29, 2097123) + 29;
    v5 = snprintf(&v3[v4], 0x200000 - v4, "]}");
    if ( v5 >= 0x200000 - v4 )
      v6 = 0x1FFFFF - v4;
    else
      v6 = v5;
    result = jhl_data_giz(a1, v3, v6 + v4, 0x200000);
  }
  else
  {
    v8 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v9 = snprintf(v10, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
    if ( v9 >= 0x80 )
      v9 = 127;
    result = httpd_cgi_ret(a1, v10, v9, 4);
  }
  return result;
}
// 49D198: variable 'v2' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0049D328) --------------------------------------------------------
int __fastcall pppoe_br_user_get_state(char *a1, size_t a2)
{
  int *v4; // $v0
  int v5; // $a2
  int *v6; // $s0
  int v7; // $v0
  int v8; // $s7
  int *v10; // $s5
  int v11; // $s1
  int v12; // $a2
  char *v13; // $t3
  int v14; // $a3
  int v15; // $s6
  int v16; // $v0
  int v17; // $v0
  int v18; // $a2
  char v19[32]; // [sp+48h] [-60h] BYREF
  char v20[32]; // [sp+68h] [-40h] BYREF
  int v21; // [sp+88h] [-20h]
  char *v22; // [sp+8Ch] [-1Ch]
  char *v23; // [sp+90h] [-18h]
  int v24; // [sp+94h] [-14h]
  int v25; // [sp+98h] [-10h]
  char *v26; // [sp+9Ch] [-Ch]
  char *format; // [sp+A0h] [-8h]
  const char *v28; // [sp+A4h] [-4h]

  _mem_malloc(0x200000, "pppoe_br_user_get_state", 1650);
  v6 = v4;
  if ( !v4
    || (*v4 = 41, v4[3] = 10, v4[1] = 0x200000, jianhl_order_opt_fun(v4, 0x200000, v5))
    || (memset(a1, 0, a2), v10 = v6 + 12, v6[5] <= 0) )
  {
    v7 = 0;
    v8 = 0;
    goto LABEL_4;
  }
  v22 = "1\"";
  v8 = 0;
  v28 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
  v21 = a2 - 49;
  v11 = 0;
  v26 = "%u";
  format = "%u.%u";
  do
  {
    v18 = *((unsigned __int16 *)v10 - 8);
    if ( *((_WORD *)v10 - 7) )
    {
      sprintf(v19, format, v18);
      v12 = *((unsigned __int8 *)v10 - 23);
      v13 = &a1[v8];
      v14 = *((unsigned __int8 *)v10 - 24);
      v15 = a2 - v8;
      if ( v12 != 2 )
        goto LABEL_8;
    }
    else
    {
      sprintf(v19, v26, v18);
      v12 = *((unsigned __int8 *)v10 - 23);
      v13 = &a1[v8];
      v14 = *((unsigned __int8 *)v10 - 24);
      v15 = a2 - v8;
      if ( v12 != 2 )
      {
LABEL_8:
        v25 = v12;
        v24 = v14;
        v23 = v13;
        v16 = MacToStr(v20, (char *)v10 - 22);
        v13 = v23;
        v14 = v24;
        v12 = v25;
        goto LABEL_9;
      }
    }
    v16 = (int)(v28 - 1556);
LABEL_9:
    v17 = snprintf(
            v13,
            v15,
            v22 - 15024,
            v14,
            v10,
            v12,
            v16,
            *(v10 - 2),
            *(v10 - 1),
            v10 + 32,
            *(v10 - 3),
            v19,
            v10 + 64,
            v10 + 72,
            v10 + 80);
    if ( v17 >= v15 )
      v17 = v15 - 1;
    v8 += v17;
    ++v11;
    if ( v8 >= v21 )
      break;
    v10 += 94;
  }
  while ( v11 < v6[5] );
  if ( v8 <= 0 )
    goto LABEL_19;
  v7 = v8;
  if ( a1[v8 - 1] == 44 )
  {
    --v8;
LABEL_19:
    v7 = v8;
  }
LABEL_4:
  a1[v7] = 0;
  _mem_free(v6);
  return v8;
}
// 49D38C: variable 'v4' is possibly undefined
// 49D3B0: variable 'v5' is possibly undefined
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0049D5E4) --------------------------------------------------------
int __fastcall sub_49D5E4(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s3
  const char *v5; // $s4
  const char *v6; // $s5
  const char *v7; // $s6
  const char *v8; // $v0
  int v9; // $v0
  int v10; // $s1
  int v11; // $s3
  int v12; // $v0
  int v13; // $s1
  int v14; // $v0
  int v15; // $s1
  int v16; // $v0
  int v17; // $a2
  int result; // $v0
  const char *v19; // $v0
  unsigned int v20; // $v0
  char v21[132]; // [sp+30h] [-84h] BYREF

  _mem_malloc(0x200000, "pppoe_br_user_data", 1729);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error", 16);
    v4 = (const char *)nvram_get("pppoe_br_user_date_expire_en");
    if ( !v4 )
      v4 = "0";
    v5 = (const char *)nvram_get("pppoe_br_user_mac_err_en");
    if ( !v5 )
      v5 = "0";
    v6 = (const char *)nvram_get("pppoe_br_user_no_exist_en");
    if ( !v6 )
      v6 = "0";
    v7 = (const char *)nvram_get("pppoe_br_user_dev_err_en");
    if ( !v7 )
      v7 = "0";
    v8 = (const char *)jhl_nv_get_def("pppoe_br_user_time");
    v9 = snprintf(
           v3 + 29,
           2097123,
           "\"date_expire\":\"%s\",\"mac_err\":\"%s\",\"no_exist\":\"%s\",\"dev_err\":\"%s\",\"user_time\":\"%s\",\"wan_max\":\"%d\"",
           v4,
           v5,
           v6,
           v7,
           v8,
           2);
    if ( v9 >= 2097123 )
      v9 = 2097122;
    v10 = v9 + 29;
    v11 = 0x200000 - (v9 + 29);
    v12 = snprintf(&v3[v9 + 29], v11, ",\"all\":[");
    if ( v12 >= v11 )
      v12 = 0x1FFFFF - v10;
    v13 = v12 + v10 + pppoe_br_user_get_state(&v3[v12 + v10], 0x200000 - (v12 + v10));
    v14 = snprintf(&v3[v13], 0x200000 - v13, &byte_6445A0);
    if ( v14 >= 0x200000 - v13 )
      v14 = 0x1FFFFF - v13;
    v15 = v14 + v13;
    v16 = snprintf(&v3[v15], 0x200000 - v15, "}}");
    if ( v16 >= 0x200000 - v15 )
      v17 = 0x1FFFFF - v15;
    else
      v17 = v16;
    result = jhl_data_giz(a1, v3, v17 + v15, 0x200000);
  }
  else
  {
    v19 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v20 = snprintf(v21, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
    if ( v20 >= 0x80 )
      v20 = 127;
    result = httpd_cgi_ret(a1, v21, v20, 4);
  }
  return result;
}
// 49D640: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (0049D95C) --------------------------------------------------------
int __fastcall pppoe_br_user_asp(int a1)
{
  char *v1; // $v0
  const char *v3; // $s1
  char *v4; // $fp
  char *v5; // $s5
  char *v6; // $s7
  char *v7; // $s6
  void *v8; // $v0
  void *v9; // $s3
  int v10; // $a0
  _DWORD *v11; // $s1
  unsigned int v12; // $v0
  int v13; // $a1
  char *v14; // $a2
  int v15; // $a0
  const char *v16; // $v0
  unsigned int v17; // $s2
  char *v19; // $s5
  char *v20; // $s4
  char *v21; // $s3
  char *v22; // $v0
  char *v23; // $s2
  const char *v24; // $s1
  unsigned __int8 v25; // $s6
  unsigned __int8 v26; // $s7
  unsigned __int8 v27; // $fp
  int v28; // $v0
  int v29; // $a0
  char *v30; // $v1
  const char *v31; // $v0
  int v32; // $t0
  int v33; // $a3
  int v34; // $a2
  int v35; // $a1
  int v36; // $a2
  unsigned __int8 v37; // $s5
  char *v38; // $v0
  char *v39; // $a0
  unsigned __int8 v40; // $s7
  int v41; // $v0
  char *v42; // $v0
  unsigned __int16 v43; // $s2
  bool v44; // dc
  unsigned int v45; // $v0
  int v46; // $a1
  int v47; // $a2
  int v48; // $a0
  const char *v49; // $v0
  char *v50; // $v1
  const char *v51; // $v0
  int v52; // $t0
  int v53; // $a3
  int v54; // $a2
  int v55; // $a1
  char *v56; // $v0
  char *v57; // $a0
  char v58[128]; // [sp+48h] [-B0h] BYREF
  int v59[2]; // [sp+C8h] [-30h] BYREF
  int v60; // [sp+D0h] [-28h]
  char *v61; // [sp+D4h] [-24h]
  char *v62; // [sp+D8h] [-20h]
  char *v63; // [sp+DCh] [-1Ch]
  char *v64; // [sp+E0h] [-18h]
  char *v65; // [sp+E4h] [-14h]
  char *v66; // [sp+E8h] [-10h]
  char *v67; // [sp+ECh] [-Ch]
  char *v68; // [sp+F0h] [-8h]
  char *v69; // [sp+F4h] [-4h]

  v1 = httpd_get_parm(a1, "opt");
  if ( !v1 )
    goto LABEL_72;
  v3 = v1;
  if ( strcmp(v1, (const char *)&off_64712C) )
  {
    if ( strcmp(v3, (const char *)&off_646D8C)
      && strcmp(v3, (const char *)&off_648DDC)
      && strcmp(v3, "update")
      && strcmp(v3, "del")
      && strcmp(v3, "delall") )
    {
LABEL_72:
      v46 = *(unsigned __int8 *)(a1 + 210102);
      v47 = (int)"not opt";
      v48 = 12;
      goto LABEL_73;
    }
    v64 = httpd_get_parm(a1, "en");
    v4 = httpd_get_parm(a1, "user");
    v66 = httpd_get_parm(a1, "o_user");
    v5 = httpd_get_parm(a1, "bind");
    v6 = httpd_get_parm(a1, (char *)&off_646724);
    v61 = httpd_get_parm(a1, "cdate");
    v62 = httpd_get_parm(a1, "ddate");
    v65 = httpd_get_parm(a1, "mem");
    v63 = httpd_get_parm(a1, "dev");
    v7 = httpd_get_parm(a1, "vlan");
    v67 = httpd_get_parm(a1, "name");
    v68 = httpd_get_parm(a1, (char *)&off_64C72C);
    v69 = httpd_get_parm(a1, "phone");
    v60 = httpd_get_json_parm(a1, (int)"del_list");
    _mem_malloc(0x200000, "pppoe_br_user_asp", 1835);
    v9 = v8;
    if ( !v8 )
    {
      v46 = *(unsigned __int8 *)(a1 + 210102);
      v47 = 0x200000;
      v48 = 4;
LABEL_73:
      v49 = (const char *)_GET_LANG_TEXT(v48, v46, v47);
      v17 = snprintf(v58, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v49);
      if ( v17 >= 0x80 )
        v17 = 127;
      return httpd_cgi_ret(a1, v58, v17, 4);
    }
    if ( !strcmp(v3, "delall") )
    {
      v12 = pppoe_br_user_delall();
      if ( v12 == -1 )
        goto LABEL_17;
      if ( v12 )
        goto LABEL_63;
    }
    if ( !strcmp(v3, "del") && v60 && cJSON_IsArray(v60) )
    {
      v11 = *(_DWORD **)(v60 + 8);
      if ( v11 )
      {
        v10 = v11[4];
        if ( v10 )
        {
          while ( 1 )
          {
            v12 = pppoe_br_user_del();
            if ( v12 == -1 )
              goto LABEL_17;
            v10 = 196608;
            if ( v12 )
              goto LABEL_63;
            v11 = (_DWORD *)*v11;
            if ( v11 )
            {
              v10 = v11[4];
              if ( v10 )
                continue;
            }
            break;
          }
        }
      }
LABEL_82:
      jhl_parm_commit(v10);
      v50 = v58;
      v51 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v52 = *(_DWORD *)v51;
        v53 = *((_DWORD *)v51 + 1);
        v54 = *((_DWORD *)v51 + 2);
        v55 = *((_DWORD *)v51 + 3);
        v51 += 16;
        *(_DWORD *)v50 = v52;
        *((_DWORD *)v50 + 1) = v53;
        *((_DWORD *)v50 + 2) = v54;
        *((_DWORD *)v50 + 3) = v55;
        v50 += 16;
      }
      while ( v51 != "}" );
      v17 = 33;
      *(_WORD *)v50 = *(_WORD *)v51;
      goto LABEL_22;
    }
    if ( !strcmp(v3, (const char *)&off_646D8C) )
    {
      if ( strcmp(v3, (const char *)&off_648DDC) )
        goto LABEL_36;
    }
    else if ( strcmp(v3, (const char *)&off_648DDC) )
    {
      if ( strcmp(v3, "update") )
        goto LABEL_82;
LABEL_36:
      if ( !v4 )
      {
        v13 = *(unsigned __int8 *)(a1 + 210102);
        v14 = "not user";
        v15 = 12;
        goto LABEL_19;
      }
      if ( !v5 )
        v5 = "0";
      v37 = J_atoi(v5);
      v60 = v37;
      if ( !v6 || strlen(v6) != 17 || !strcmp(v6, "00:00:00:00:00:00") || !strcmp(v6, "00-00-00-00-00-00") )
      {
        if ( v37 == 1 )
        {
LABEL_92:
          v16 = (const char *)_GET_LANG_TEXT(205, *(unsigned __int8 *)(a1 + 210102), v36);
LABEL_20:
          v17 = snprintf(v58, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v16);
          if ( v17 >= 0x80 )
            v17 = 127;
LABEL_22:
          _mem_free(v9);
          return httpd_cgi_ret(a1, v58, v17, 4);
        }
        v60 = (int)v59;
        v59[0] = 0;
        v59[1] = 0;
      }
      else
      {
        v60 = (int)v59;
        if ( StrToMac(v6, v59) )
          goto LABEL_92;
      }
      if ( !v64 )
        v64 = "1";
      if ( !v62 )
        v62 = "0";
      if ( !v61 )
        v61 = "0";
      if ( !v65 )
        v65 = " ";
      if ( !v63 )
        v63 = "1";
      if ( v7 )
      {
        v62 = (char *)J_atoi(v62);
        v38 = (char *)J_atoi(v61);
        v39 = v64;
        v64 = v38;
        v40 = J_atoi(v39);
        v41 = (unsigned __int8)J_atoi(v63);
        if ( !v41 )
          v41 = 1;
      }
      else
      {
        v62 = (char *)J_atoi(v62);
        v56 = (char *)J_atoi(v61);
        v57 = v64;
        v64 = v56;
        v40 = J_atoi(v57);
        v41 = (unsigned __int8)J_atoi(v63);
        if ( !v41 )
        {
          v61 = 0;
          v63 = (char *)1;
          v7 = "0";
LABEL_58:
          v43 = J_atoi(v7);
          if ( !strcmp(v3, (const char *)&off_646D8C) )
          {
            v12 = pppoe_br_user_add(v40, v37, v60, v63, v64, v62, v4, v65, v43, v61, v67, v68, v69);
          }
          else if ( !strcmp(v3, "update") )
          {
            v12 = pppoe_br_user_mod(1, v40, v37, v60, v63, v64, v62, v4, v4, v65, v43, v61, v67, v68, v69);
          }
          else
          {
            v12 = pppoe_br_user_mod(0, v40, v37, v60, v63, v64, v62, v66, v4, v65, v43, v61, v67, v68, v69);
          }
          if ( v12 != -1 )
          {
            v10 = 196608;
            if ( !v12 )
              goto LABEL_82;
LABEL_63:
            v13 = *(unsigned __int8 *)(a1 + 210102);
            v44 = v12 >= 0x33;
            v45 = v12;
            if ( !v44 )
            {
              v14 = (char *)jhlret_err_str[v45];
              if ( v14 )
              {
                v15 = 3;
                goto LABEL_19;
              }
            }
            v14 = "not find err!";
LABEL_18:
            v15 = 3;
LABEL_19:
            v16 = (const char *)_GET_LANG_TEXT(v15, v13, v14);
            goto LABEL_20;
          }
LABEL_17:
          v13 = *(unsigned __int8 *)(a1 + 210102);
          v14 = "";
          goto LABEL_18;
        }
        v7 = "0";
      }
      v63 = (char *)v41;
      v42 = strchr(v7, 46);
      if ( v42 )
      {
        *v42 = 0;
        LOWORD(v61) = J_atoi(v42 + 1);
        v61 = (char *)(unsigned __int16)v61;
      }
      else
      {
        v61 = 0;
      }
      goto LABEL_58;
    }
    if ( !v66 )
    {
      v13 = *(unsigned __int8 *)(a1 + 210102);
      v14 = (char *)&unk_64C730;
      v15 = 12;
      goto LABEL_19;
    }
    goto LABEL_36;
  }
  v19 = httpd_get_parm(a1, "date_expire");
  v20 = httpd_get_parm(a1, "mac_err");
  v21 = httpd_get_parm(a1, "no_exist");
  v23 = httpd_get_parm(a1, "dev_err");
  v22 = httpd_get_parm(a1, "user_time");
  v24 = v22;
  if ( v19 )
  {
    if ( v20 )
      goto LABEL_26;
  }
  else
  {
    v19 = "0";
    if ( v20 )
    {
LABEL_26:
      if ( v21 )
        goto LABEL_27;
LABEL_76:
      v21 = "0";
      if ( v23 )
        goto LABEL_28;
      goto LABEL_75;
    }
  }
  v20 = "0";
  if ( !v21 )
    goto LABEL_76;
LABEL_27:
  if ( !v23 )
LABEL_75:
    v23 = "0";
LABEL_28:
  if ( !v22 )
    v24 = "600";
  v25 = J_atoi(v19);
  v26 = J_atoi(v20);
  v27 = J_atoi(v21);
  v60 = J_atoi(v23);
  v28 = J_atoi(v24);
  pppoe_br_user_conf(v25, v26, v27, (unsigned __int8)v60, v28);
  nvram_set("pppoe_br_user_date_expire_en", v19);
  nvram_set("pppoe_br_user_mac_err_en", v20);
  nvram_set("pppoe_br_user_no_exist_en", v21);
  nvram_set("pppoe_br_user_dev_err_en", v23);
  nvram_set("pppoe_br_user_time", v24);
  jhl_parm_commit(v29);
  v30 = v58;
  v31 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v32 = *(_DWORD *)v31;
    v33 = *((_DWORD *)v31 + 1);
    v34 = *((_DWORD *)v31 + 2);
    v35 = *((_DWORD *)v31 + 3);
    v31 += 16;
    *(_DWORD *)v30 = v32;
    *((_DWORD *)v30 + 1) = v33;
    *((_DWORD *)v30 + 2) = v34;
    *((_DWORD *)v30 + 3) = v35;
    v30 += 16;
  }
  while ( v31 != "}" );
  *(_WORD *)v30 = *(_WORD *)v31;
  return httpd_cgi_ret(a1, v58, 33, 4);
}
// 49DBC4: variable 'v8' is possibly undefined
// 49DF2C: variable 'v29' is possibly undefined
// 49E400: variable 'v10' is possibly undefined
// 49E518: variable 'v36' is possibly undefined
// 646724: using guessed type void *off_646724;
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 648DDC: using guessed type char *off_648DDC;
// 64C72C: using guessed type void *off_64C72C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8234: using guessed type int pppoe_br_user_delall(void);
// 6A82A8: using guessed type int __fastcall pppoe_br_user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8524: using guessed type int __fastcall pppoe_br_user_conf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A85EC: using guessed type int __fastcall StrToMac(_DWORD, _DWORD);
// 6A8654: using guessed type int pppoe_br_user_del(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8958: using guessed type int __fastcall pppoe_br_user_mod(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0049E740) --------------------------------------------------------
int __fastcall sub_49E740(int a1)
{
  void *v2; // $v0
  int v3; // $v0
  void *v4; // $s1
  int result; // $v0
  const char *v6; // $v0
  unsigned int v7; // $v0
  char v8[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "pppoe_br_users_txt", 2009);
  if ( v2 )
  {
    v4 = v2;
    v3 = pppoe_br_user_get_file(v2, 0x200000);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v3);
  }
  else
  {
    v6 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v7 = snprintf(v8, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v6);
    if ( v7 >= 0x100 )
      v7 = 255;
    result = httpd_cgi_ret(a1, v8, v7, 4);
  }
  return result;
}
// 49E780: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84B0: using guessed type int __fastcall pppoe_br_user_get_file(_DWORD, _DWORD);

//----- (0049E860) --------------------------------------------------------
int __fastcall sub_49E860(int a1)
{
  void *v1; // $v0
  int v2; // $s1
  char *v3; // $v0
  char *v4; // $fp
  char *v5; // $v0
  int v6; // $a0
  char *v7; // $a2
  char *v8; // $v1
  int v9; // $v0
  int v10; // $v0
  bool v11; // dc
  int v12; // $v0
  char *v13; // $a2
  char *v14; // $t1
  const char *v15; // $s1
  const char *v16; // $s0
  char *v17; // $s4
  char *v18; // $s5
  char *v19; // $s6
  const char *v20; // $s3
  const char *v21; // $s7
  char *i; // $v0
  int v23; // $v1
  const char *v24; // $v0
  unsigned int v25; // $v0
  _BOOL4 v27; // $s7
  time_t v28; // $s5
  time_t v29; // $s4
  int v30; // $s0
  char *v31; // $v0
  int v32; // $s6
  int v33; // $v0
  char *v34; // $v1
  const char *v35; // $v0
  int v36; // $t0
  int v37; // $a3
  int v38; // $a2
  int v39; // $a1
  __int16 v40; // $a0
  char v41[1024]; // [sp+40h] [-8E0h] BYREF
  char v42[1024]; // [sp+440h] [-4E0h] BYREF
  char v43[120]; // [sp+840h] [-E0h] BYREF
  struct tm v44; // [sp+8B8h] [-68h] BYREF
  int v45; // [sp+8E4h] [-3Ch] BYREF
  __int16 v46; // [sp+8E8h] [-38h]
  char *v47; // [sp+8F0h] [-30h]
  char *v48; // [sp+8F4h] [-2Ch]
  char *v49; // [sp+8F8h] [-28h]
  char *v50; // [sp+8FCh] [-24h]
  char *v51; // [sp+900h] [-20h]
  int v52; // [sp+904h] [-1Ch]
  void *v53; // [sp+908h] [-18h]
  char *v54; // [sp+90Ch] [-14h]
  char *v55; // [sp+910h] [-10h]
  char *v56; // [sp+914h] [-Ch]
  char *v57; // [sp+918h] [-8h]
  char *v58; // [sp+91Ch] [-4h]

  v54 = "1\"";
  _mem_malloc(0x200000, "pppoe_br_usersfile_cgi", 2035);
  v53 = v1;
  if ( v1
    && (v2 = *(_DWORD *)(a1 + 205364), find_file_head(a1, *(const char **)(a1 + 205564)), (v4 = v3) != 0)
    && (v5 = find_file_end(a1, v3, *(_DWORD *)(a1 + 205564) + v2 - (_DWORD)v3)) != 0 )
  {
    *v5 = 0;
    v55 = (char *)&off_643784;
    v56 = "1\"";
    v57 = (char *)&unk_64C76C;
    v58 = "1\"";
LABEL_5:
    while ( *v4 )
    {
      memset(v41, 0, sizeof(v41));
      v7 = v4 + 1002;
      v8 = v41;
      while ( 1 )
      {
        v9 = *v4;
        if ( !*v4 )
          break;
        if ( v9 == 10 )
          goto LABEL_58;
        ++v8;
        if ( v9 == 13 )
          goto LABEL_58;
        v6 = (int)(v4 + 1);
        *(v8 - 1) = v9;
        if ( v4 + 1 == v7 )
        {
          v9 = v4[1];
          v4 = v7;
LABEL_58:
          v6 = 13;
          while ( v9 == 10 || v9 == 13 )
            v9 = *++v4;
          break;
        }
        ++v4;
      }
      if ( v41[0] == 35 )
        goto LABEL_5;
      v10 = split_string(v41, 44, v43, 30);
      v11 = v10 <= 0;
      v12 = 4 * v10;
      if ( v11 )
        goto LABEL_5;
      v13 = v43;
      v14 = &v43[v12];
      v51 = 0;
      v50 = 0;
      v49 = 0;
      v15 = 0;
      v16 = 0;
      v48 = 0;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v47 = 0;
      v21 = 0;
      v6 = 32;
      do
      {
        for ( i = *(char **)v13; ; ++i )
        {
          v23 = *i;
          if ( v23 != 32 && v23 != 9 )
            break;
        }
        if ( i[1] == 58 )
        {
          switch ( (char)v23 )
          {
            case 'b':
              v20 = i + 2;
              break;
            case 'c':
              v18 = i + 2;
              break;
            case 'd':
              v21 = i + 2;
              break;
            case 'e':
              v17 = i + 2;
              break;
            case 'i':
              v16 = i + 2;
              break;
            case 'm':
              v19 = i + 2;
              break;
            case 'n':
              v48 = i + 2;
              break;
            case 'o':
              v49 = i + 2;
              break;
            case 'p':
              v51 = i + 2;
              break;
            case 'q':
              v50 = i + 2;
              break;
            case 'u':
              v47 = i + 2;
              break;
            case 'v':
              v15 = i + 2;
              break;
            default:
              break;
          }
        }
        v13 += 4;
      }
      while ( v13 != v14 );
      if ( !v47 )
        goto LABEL_5;
      if ( !v21 || !strncmp(v21, v58 - 14508, 4u) )
      {
        v27 = 1;
        if ( !v20 )
        {
LABEL_63:
          v52 = 0;
          if ( v19 )
            goto LABEL_31;
          goto LABEL_64;
        }
      }
      else
      {
        v27 = strncmp(v21, byte_64C75C, 4u) != 0;
        if ( !v20 )
          goto LABEL_63;
      }
      if ( !strncmp(v20, v56 - 14492, 6u) )
        v52 = 2;
      else
        v52 = strncmp(v20, v57, 4u) == 0;
      if ( v19 )
      {
LABEL_31:
        StrToMac(v19, &v45);
        if ( v18 )
          goto LABEL_32;
        goto LABEL_65;
      }
LABEL_64:
      v45 = 0;
      v46 = 0;
      if ( v18 )
      {
LABEL_32:
        v28 = timeconvert(v18, &v44);
        if ( v17 )
          goto LABEL_33;
        goto LABEL_66;
      }
LABEL_65:
      v28 = 0;
      if ( v17 )
      {
LABEL_33:
        v29 = timeconvert(v17, &v44);
        if ( !v16 )
          goto LABEL_67;
        goto LABEL_34;
      }
LABEL_66:
      v29 = 0;
      if ( !v16 )
      {
LABEL_67:
        v30 = 1;
        if ( v15 )
          goto LABEL_37;
        goto LABEL_68;
      }
LABEL_34:
      if ( !strncmp(v16, v55, 3u) )
        v16 += 3;
      v30 = (unsigned __int8)J_atoi(v16);
      if ( v15 )
      {
LABEL_37:
        v31 = strchr(v15, 46);
        v32 = 0;
        if ( v31 )
        {
          *v4 = 0;
          v32 = (unsigned __int16)J_atoi(v31);
          ++v4;
        }
        v33 = (unsigned __int16)J_atoi(v15);
        goto LABEL_40;
      }
LABEL_68:
      v32 = 0;
      v33 = 0;
LABEL_40:
      pppoe_br_user_add(v27, v52, &v45, v30, v28, v29, v47, v48, v33, v32, v49, v50, v51);
    }
    jhl_parm_commit(v6);
    _mem_free(v53);
    v34 = v42;
    v35 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v36 = *(_DWORD *)v35;
      v37 = *((_DWORD *)v35 + 1);
      v38 = *((_DWORD *)v35 + 2);
      v39 = *((_DWORD *)v35 + 3);
      v35 += 16;
      *(_DWORD *)v34 = v36;
      *((_DWORD *)v34 + 1) = v37;
      *((_DWORD *)v34 + 2) = v38;
      *((_DWORD *)v34 + 3) = v39;
      v34 += 16;
    }
    while ( v35 != "}" );
    v40 = *(_WORD *)v35;
    v25 = 33;
    *(_WORD *)v34 = v40;
  }
  else
  {
    _mem_free(v53);
    v24 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
    v25 = snprintf(v42, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
    if ( v25 >= 0x400 )
      v25 = 1023;
  }
  return httpd_cgi_ret(a1, v42, v25, 4);
}
// 49E8BC: variable 'v1' is possibly undefined
// 49E8F8: variable 'v3' is possibly undefined
// 49ED40: variable 'v6' is possibly undefined
// 643784: using guessed type void *off_643784;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82A8: using guessed type int __fastcall pppoe_br_user_add(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A85EC: using guessed type int __fastcall StrToMac(_DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0049EEF0) --------------------------------------------------------
int __fastcall pppoe_bridge_md5(char *a1, int a2, int a3)
{
  char v5[104]; // [sp+50h] [-74h] BYREF
  int v6; // [sp+B8h] [-Ch]
  int v7; // [sp+BCh] [-8h]

  v7 = a2;
  v6 = a3;
  MD5Init(v5);
  MD5Update(v5, v7, v6);
  MD5Final(v5);
  return sprintf(
           a1,
           "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
           (unsigned __int8)v5[88],
           (unsigned __int8)v5[89],
           (unsigned __int8)v5[90],
           (unsigned __int8)v5[91],
           (unsigned __int8)v5[92],
           (unsigned __int8)v5[93],
           (unsigned __int8)v5[94],
           (unsigned __int8)v5[95],
           (unsigned __int8)v5[96],
           (unsigned __int8)v5[97],
           (unsigned __int8)v5[98],
           (unsigned __int8)v5[99],
           (unsigned __int8)v5[100],
           (unsigned __int8)v5[101],
           (unsigned __int8)v5[102],
           (unsigned __int8)v5[103]);
}
// 6A8384: using guessed type int __fastcall MD5Init(_DWORD);
// 6A8850: using guessed type int __fastcall MD5Final(_DWORD);
// 6A8928: using guessed type int __fastcall MD5Update(_DWORD, _DWORD, _DWORD);

//----- (0049F004) --------------------------------------------------------
int __fastcall pppoe_bridge_user_md5(char *a1, const char *a2, const char *a3)
{
  int v6; // $v0
  int v7; // $v0
  char v9[132]; // [sp+18h] [-84h] BYREF

  memset(v9, 0, 0x80u);
  v6 = strlen(a2);
  pppoe_bridge_md5(v9, (int)a2, v6);
  snprintf(&v9[6], 122, "+%s+wayos", a3);
  v7 = strlen(v9);
  return pppoe_bridge_md5(a1, (int)v9, v7);
}

//----- (0049F0EC) --------------------------------------------------------
int __fastcall pppoe_bridge_check_token(int a1)
{
  char *v2; // $v0
  char *v3; // $s3
  int v4; // $v0
  int v6; // $s0
  unsigned int v7; // $v0
  char v8[128]; // [sp+20h] [-100h] BYREF
  char v9[64]; // [sp+A0h] [-80h] BYREF
  char v10[64]; // [sp+E0h] [-40h] BYREF

  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  v3 = httpd_get_parm(a1, "token");
  v2 = httpd_get_parm(a1, "random");
  if ( v3 && v2 )
  {
    v4 = snprintf(v8, 128, "%s+%s", gl_httpd_pppoe_br_md5, v2);
    pppoe_bridge_md5(v9, (int)v8, v4);
    if ( !strcmp(v3, v9) )
      return 0;
    v6 = -3;
  }
  else
  {
    v6 = -2;
  }
  v7 = snprintf(v10, 64, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, "token error");
  if ( v7 >= 0x40 )
    v7 = 63;
  httpd_cgi_ret(a1, v10, v7, 4);
  return v6;
}

//----- (0049F2B8) --------------------------------------------------------
int __fastcall sub_49F2B8(int a1)
{
  bool v2; // dc
  int result; // $v0
  int v4; // $v0
  char *v5; // $s0
  int v6; // $s2
  int v7; // $v0
  int v8; // $a2
  const char *v9; // $v0
  unsigned int v10; // $v0
  char v11[128]; // [sp+20h] [-80h] BYREF

  v2 = pppoe_bridge_check_token(a1) == 0;
  result = 0;
  if ( v2 )
  {
    _mem_malloc(0x200000, "pppoe_bridge_user_data", 2311);
    v5 = (char *)v4;
    if ( v4 )
    {
      strcpy((char *)v4, "{\"code\":0,\"error\":\"\",\"data\":[");
      qmemcpy((void *)v4, "{\"code\":0,\"error\":\"\"", 20);
      *(_DWORD *)(v4 + 24) = 975331700;
      v6 = pppoe_br_user_get_state((char *)(v4 + 29), 0x1FFFE3u) + 29;
      v7 = snprintf(&v5[v6], 0x200000 - v6, "]}");
      if ( v7 >= 0x200000 - v6 )
        v8 = 0x1FFFFF - v6;
      else
        v8 = v7;
      result = jhl_data_giz(a1, v5, v8 + v6, 0x200000);
    }
    else
    {
      v9 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
      v10 = snprintf(v11, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
      if ( v10 >= 0x80 )
        v10 = 127;
      result = httpd_cgi_ret(a1, v11, v10, 4);
    }
  }
  return result;
}
// 49F33C: variable 'v4' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (0049F4B8) --------------------------------------------------------
int __fastcall sub_49F4B8(int a1)
{
  char *v2; // $s2
  bool v3; // dc
  int result; // $v0
  int v5; // $a1
  char *v6; // $a2
  int v7; // $a0
  const char *v8; // $v0
  unsigned int v9; // $v0
  int v10; // $a2
  int v11; // $a2
  int v12; // $s2
  int v13; // $s5
  int v14; // $v0
  const char *v15; // $s6
  int v16; // $fp
  int v17; // $s1
  int v18; // $v0
  const char *v19; // $s7
  unsigned int v20; // $v0
  int v21; // $s1
  unsigned int v22; // $v0
  const char *v23; // $v0
  char v24[2048]; // [sp+68h] [-1080h] BYREF
  int v25[512]; // [sp+868h] [-880h] BYREF
  char v26[32]; // [sp+1068h] [-80h] BYREF
  char v27[32]; // [sp+1088h] [-60h] BYREF
  char v28[32]; // [sp+10A8h] [-40h] BYREF
  int v29; // [sp+10C8h] [-20h]
  int v30; // [sp+10CCh] [-1Ch]
  int v31; // [sp+10D0h] [-18h]
  int v32; // [sp+10D4h] [-14h]
  int v33; // [sp+10D8h] [-10h]
  int v34; // [sp+10DCh] [-Ch]
  char *v35; // [sp+10E0h] [-8h]

  memset(v25, 0, sizeof(v25));
  memset(v24, 0, sizeof(v24));
  v2 = httpd_get_parm(a1, "user");
  v3 = pppoe_bridge_check_token(a1) != 0;
  result = 0;
  if ( !v3 )
  {
    if ( !v2 || !*v2 )
    {
      v5 = *(unsigned __int8 *)(a1 + 210102);
      v6 = "not user";
      v7 = 12;
      goto LABEL_5;
    }
    v25[0] = 41;
    v25[3] = 18;
    v25[1] = 2048;
    strlcpy(&v25[10], v2, 64);
    if ( jianhl_order_opt_fun(v25, v25[1], v10) )
    {
      v5 = *(unsigned __int8 *)(a1 + 210102);
      v6 = "";
      v7 = 3;
LABEL_5:
      v8 = (const char *)_GET_LANG_TEXT(v7, v5, v6);
      v9 = snprintf((char *)v25, 2048, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
      if ( v9 < 0x800 )
        return httpd_cgi_ret(a1, (char *)v25, v9, 4);
LABEL_18:
      v9 = 2047;
      return httpd_cgi_ret(a1, (char *)v25, v9, 4);
    }
    if ( v25[2] == 3 )
    {
      v23 = (const char *)_GET_LANG_TEXT(206, *(unsigned __int8 *)(a1 + 210102), v11);
      v9 = snprintf(v24, 2048, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v23);
      if ( v9 < 0x800 )
        return httpd_cgi_ret(a1, (char *)v25, v9, 4);
      goto LABEL_18;
    }
    v35 = v28;
    if ( HIWORD(v25[6]) )
      sprintf(v28, "%u.%u", LOWORD(v25[6]), HIWORD(v25[6]));
    else
      sprintf(v28, "%u", LOWORD(v25[6]));
    strcpy(v24, "{\"code\":0,\"error\":\"\",\"data\":{");
    v12 = LOBYTE(v25[4]);
    v13 = BYTE1(v25[4]);
    v15 = (const char *)MacToStr(v27, (char *)&v25[4] + 2);
    v14 = MacToStr(v26, &v25[83]);
    v34 = v25[7];
    v33 = v25[98];
    v32 = v25[94];
    v31 = v25[95];
    v30 = v25[96];
    v29 = v25[97];
    v16 = v25[8];
    v17 = v25[9];
    v19 = (const char *)v14;
    v18 = ntohs(v25[82]);
    v20 = snprintf(
            &v24[29],
            2019,
            "\"en\":%d,\"user\":\"%s\",\"bind\":%d,\"mac_bind\":\"%s\",\"mac_cur\":\"%s\",\"c_data\":%u,\"d_date\":%u,\"m"
            "em\":\"%s\",\"dev\":%d,\"vlan_id\":\"%s\",name\":\"%s\",\"cid\":\"%s\",\"phone\":\"%s\",\"online_time\":%lu,"
            "\"qup\":%u,\"qdw\":%u,\"zup\":%u,\"zdw\":%u,\"in_dev\":\"%s\",\"out_dev\":\"%s\",\"session\":%u",
            v12,
            (const char *)&v25[10],
            v13,
            v15,
            v19,
            v16,
            v17,
            (const char *)&v25[26],
            v34,
            v35,
            (const char *)&v25[58],
            (const char *)&v25[66],
            (const char *)&v25[74],
            v33,
            v32,
            v31,
            v30,
            v29,
            (const char *)&v25[85],
            (const char *)&v25[89],
            v18);
    v21 = v20 + 29;
    if ( v20 >= 0x7E3 )
      v21 = 2047;
    v22 = snprintf(&v24[v21], 2048 - v21, "}}");
    if ( v22 >= 2048 - v21 )
      v22 = 2047 - v21;
    result = httpd_cgi_ret(a1, v24, v22 + v21, 4);
  }
  return result;
}
// 49F660: variable 'v10' is possibly undefined
// 49F89C: variable 'v11' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0049F91C) --------------------------------------------------------
int __fastcall sub_49F91C(int a1)
{
  bool v2; // dc
  int result; // $v0

  v2 = pppoe_bridge_check_token(a1) == 0;
  result = 0;
  if ( v2 )
    result = pppoe_br_user_asp(a1);
  return result;
}

//----- (0049F978) --------------------------------------------------------
int __fastcall pppoe_bridge_session_get_state(int a1, int a2, int a3)
{
  _DWORD *v6; // $v0
  int v7; // $a2
  _DWORD *v8; // $s4
  int v9; // $v0
  int v10; // $fp
  int v12; // $v0
  char *v13; // $s6
  int v14; // $s2
  int v15; // $v0
  int v16; // $v0
  int v17; // $a3
  int v18; // $a2
  const char *v19; // $s5
  int v20; // $s7
  int v21; // $v0
  char v22[32]; // [sp+48h] [-58h] BYREF
  char v23[32]; // [sp+68h] [-38h] BYREF
  int v24; // [sp+88h] [-18h]
  int v25; // [sp+8Ch] [-14h]
  char *format; // [sp+90h] [-10h]
  char *v27; // [sp+94h] [-Ch]
  char *v28; // [sp+98h] [-8h]
  char *v29; // [sp+9Ch] [-4h]

  v28 = "1\"";
  _mem_malloc(0x200000, "pppoe_bridge_session_get_state", 2425);
  v8 = v6;
  if ( !v6 )
    goto LABEL_3;
  *v6 = 41;
  v6[3] = 12;
  v6[1] = 0x200000;
  if ( jianhl_order_opt_fun(v6, 0x200000, v7) )
    goto LABEL_3;
  v12 = v8[5];
  if ( a3 )
  {
    if ( v12 > 0 )
    {
      v25 = a2 - 49;
      v13 = (char *)v8 + 26;
      v29 = "%u";
      v10 = 0;
      format = "%u.%u";
      v14 = 0;
      v27 = "{\"session\":%u,\"mac\":\"%s\",\"user\":\"%s\",\"in_dev\":\"%s\",\"out_dev\":\"%s\",\"online_time\":%lu,\"qu"
            "p\":%u,\"qdw\":%u,\"zup\":%u,\"zdw\":%u,\"mem\":\"%s\",\"vlan\":\"%s\",\"vlan\":\"%s\"},";
      do
      {
        v17 = *((unsigned __int16 *)v13 + 142);
        v18 = *((unsigned __int16 *)v13 + 141);
        if ( *((_WORD *)v13 + 142) )
          sprintf(v22, format, v18, v17);
        else
          sprintf(v22, v29, v18, v17);
        v24 = ntohs(*((_WORD *)v13 - 1));
        v15 = MacToStr(v23, v13);
        v16 = snprintf(
                (char *)(a1 + v10),
                a2 - v10,
                v27,
                v24,
                v15,
                v13 + 58,
                v13 + 6,
                v13 + 22,
                *(_DWORD *)(v13 + 286),
                *(_DWORD *)(v13 + 42),
                *(_DWORD *)(v13 + 46),
                *(_DWORD *)(v13 + 50),
                *(_DWORD *)(v13 + 54),
                v13 + 122,
                v22,
                v13 + 250);
        if ( v16 >= a2 - v10 )
          v16 = a2 - v10 - 1;
        v10 += v16;
        ++v14;
        if ( v10 >= v25 )
          break;
        v13 += 292;
      }
      while ( v14 < v8[5] );
      goto LABEL_21;
    }
  }
  else if ( v12 > 0 )
  {
    v19 = (const char *)(v8 + 21);
    v10 = 0;
    v20 = 0;
    do
    {
      v21 = snprintf((char *)(a1 + v10), a2 - v10, "{\"user\":\"%s\",\"online_time\":%lu},", v19, *((_DWORD *)v19 + 57));
      if ( v21 >= a2 - v10 )
        v21 = a2 - v10 - 1;
      v10 += v21;
      ++v20;
      if ( v10 >= a2 - 49 )
        break;
      v19 += 292;
    }
    while ( v20 < v8[5] );
LABEL_21:
    if ( v10 > 0 )
    {
      v9 = v10;
      if ( *(_BYTE *)(a1 + v10 - 1) != 44 )
        goto LABEL_4;
      --v10;
    }
    v9 = v10;
    goto LABEL_4;
  }
LABEL_3:
  v9 = 0;
  v10 = 0;
LABEL_4:
  *(_BYTE *)(a1 + v9) = 0;
  _mem_free(v8);
  return v10;
}
// 49F9E4: variable 'v6' is possibly undefined
// 49FA08: variable 'v7' is possibly undefined
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (0049FC90) --------------------------------------------------------
int __fastcall sub_49FC90(int a1)
{
  char *v2; // $s2
  bool v3; // dc
  int result; // $v0
  char *v5; // $v0
  char *v6; // $s0
  int v7; // $v0
  int v8; // $s3
  int v9; // $v0
  int v10; // $a2
  const char *v11; // $v0
  unsigned int v12; // $v0
  char v13[104]; // [sp+20h] [-68h] BYREF

  v2 = httpd_get_parm(a1, "all");
  v3 = pppoe_bridge_check_token(a1) == 0;
  result = 0;
  if ( v3 )
  {
    _mem_malloc(0x200000, "pppoe_bridge_session_data", 2526);
    v6 = v5;
    if ( v5 )
    {
      strcpy(v5, "{\"code\":0,\"error\":\"\",\"data\":[");
      qmemcpy(v5, "{\"code\":0,\"error\":\"\"", 20);
      v7 = J_atoi(v2);
      v8 = pppoe_bridge_session_get_state((int)(v6 + 29), 2097123, v7) + 29;
      v9 = snprintf(&v6[v8], 0x200000 - v8, "]}");
      if ( v9 >= 0x200000 - v8 )
        v10 = 0x1FFFFF - v8;
      else
        v10 = v9;
      result = jhl_data_giz(a1, v6, v10 + v8, 0x200000);
    }
    else
    {
      v11 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
      v12 = snprintf(v13, 100, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
      if ( v12 >= 0x64 )
        v12 = 99;
      result = httpd_cgi_ret(a1, v13, v12, 4);
    }
  }
  return result;
}
// 49FD34: variable 'v5' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (0049FEC4) --------------------------------------------------------
int __fastcall sub_49FEC4(int a1)
{
  bool v2; // dc
  int result; // $v0
  int v4; // $s2
  int v5; // $s0
  const char *v6; // $v0
  unsigned int v7; // $v0
  const char *v8; // $v0
  char v9[1024]; // [sp+18h] [-428h] BYREF
  int v10; // [sp+418h] [-28h] BYREF
  char v11[12]; // [sp+41Ch] [-24h] BYREF
  int v12; // [sp+438h] [-8h]

  memset(v9, 0, sizeof(v9));
  v2 = pppoe_bridge_check_token(a1) == 0;
  result = 0;
  if ( !v2 )
    return result;
  strcpy(v9, "{\"code\":0,\"error\":\"\",\"data\":[");
  v4 = 2;
  v5 = 29;
  v12 = 1869639792;
  while ( v4 == 2 )
  {
    v10 = v12;
    strcpy(v11, "e_br_wan");
    v8 = (const char *)jhl_nv_get_def(&v10);
    v5 += sprintf(&v9[v5], "\"%s\",", v8);
LABEL_13:
    ++v4;
  }
  sprintf((char *)&v10, "pppoe_br_wan%d", 2);
  v6 = (const char *)jhl_nv_get_def(&v10);
  v5 += sprintf(&v9[v5], "\"%s\",", v6);
  if ( v4 != 3 )
    goto LABEL_13;
  if ( v5 > 0 && v9[v5 - 1] == 44 )
    --v5;
  v9[v5] = 0;
  v7 = snprintf(&v9[v5], 1024 - v5, "]}");
  if ( v7 >= 1024 - v5 )
    v7 = 1023 - v5;
  return httpd_cgi_ret(a1, v9, v7 + v5, 4);
}
// 642A04: using guessed type __int16 word_642A04;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004A0120) --------------------------------------------------------
void __fastcall speed_test_mr_list(int a1)
{
  int v1; // $s0
  int v3; // $s1
  unsigned int v4; // $v0
  int (__fastcall **v5)(_DWORD, _DWORD); // $t9
  const char *v6; // $a0
  unsigned int v7; // $a1
  int v8; // $v0
  char *v9; // $v0
  int v10[5]; // [sp+8h] [-38h] BYREF

  if ( *(int *)(a1 + 4) > 0 )
  {
    v1 = a1 + 8;
    v3 = 0;
    do
    {
      v4 = *(unsigned __int16 *)(v1 + 8);
      v5 = &jhl_vpnget;
      v6 = (const char *)&unk_645880;
      v7 = v4 - 101;
      if ( v4 < 0x65 )
      {
        v6 = "wan_name";
        v7 = v4 - 1;
        v5 = &jhl_nvget;
      }
      v8 = ((int (__fastcall *)(const char *, unsigned int, int (__fastcall **)(_DWORD, _DWORD)))v5)(v6, v7, &jhl_nvget);
      v9 = (char *)nvram_get(v8);
      if ( !v9 )
        v9 = "";
      v10[0] = (int)"speedTest";
      v10[1] = (int)v9;
      v10[2] = 0;
      eval_nowait(v10, 0, 0, 0);
      ++v3;
      v1 += 340;
    }
    while ( v3 < *(_DWORD *)(a1 + 4) );
  }
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (004A0268) --------------------------------------------------------
int __fastcall sub_4A0268(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s5
  const char *v5; // $s1
  const char *v6; // $s2
  const char *v7; // $s4
  const char *v8; // $v0
  int v9; // $s1
  int v10; // $s1
  int v11; // $v0
  int v12; // $a2
  int result; // $v0
  const char *v14; // $v0
  unsigned int v15; // $v0
  char v16[1024]; // [sp+28h] [-400h] BYREF

  memset(v16, 0, sizeof(v16));
  _mem_malloc(0x100000, "speed_test_data", 44);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error", 16);
    v4 = (const char *)nvram_get("speed_test_en");
    if ( !v4 )
      v4 = "";
    v5 = (const char *)nvram_get("speed_test_iface");
    if ( !v5 )
      v5 = "";
    v6 = (const char *)nvram_get("speed_test_time");
    if ( !v6 )
      v6 = "";
    v7 = (const char *)nvram_get("speed_test_result");
    if ( !v7 )
      v7 = "";
    v8 = (const char *)nvram_get("speed_test_state");
    if ( !v8 )
      v8 = "";
    v9 = sprintf(
           v3 + 29,
           "\"state\":\"%s\",\"iface\":\"%s\",\"time\":\"%s\",\"msg\":\"%s\",\"ret\":\"0\",\"real_state\":\"%s\",\"wans\":",
           v4,
           v5,
           v6,
           v7,
           v8)
       + 29;
    v10 = v9 + get_wans_data(&v3[v9], 0x100000 - v9);
    v11 = snprintf(&v3[v10], 0x100000 - v10, "}}");
    if ( v11 >= 0x100000 - v10 )
      v12 = 0xFFFFF - v10;
    else
      v12 = v11;
    result = httpd_cgi_ret(a1, v3, v12 + v10, 8);
  }
  else
  {
    v14 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x100000);
    v15 = snprintf(v16, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v15 >= 0x400 )
      v15 = 1023;
    result = httpd_cgi_ret(a1, v16, v15, 4);
  }
  return result;
}
// 4A02DC: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004A0564) --------------------------------------------------------
int __fastcall sub_4A0564(int a1)
{
  char *v2; // $s2
  char *v3; // $v0
  char *v4; // $s3
  const char *v5; // $s1
  int v6; // $v0
  const char *v7; // $a0
  const char **v8; // $v1
  const char *v9; // $v0
  const char *v10; // $t0
  const char *v11; // $a3
  const char *v12; // $a2
  const char *v13; // $a1
  unsigned int v14; // $a2
  const char *v16; // $t0
  const char *v17; // $a3
  const char *v18; // $a2
  const char *v19; // $a1
  int v20; // $a1
  const char *v21; // $a2
  const char *v22; // $v0
  const char *v23; // [sp+20h] [-84h] BYREF
  const char *v24; // [sp+24h] [-80h]
  int v25; // [sp+28h] [-7Ch]
  int v26; // [sp+2Ch] [-78h]
  int v27; // [sp+30h] [-74h]

  v2 = httpd_get_parm(a1, "iface");
  v4 = httpd_get_parm(a1, "time");
  v3 = httpd_get_parm(a1, "opt");
  if ( !v3 )
    goto LABEL_18;
  v5 = v3;
  if ( !strcmp(v3, "stop") )
  {
    killall_tk("speedTest");
    nvram_set("speed_test_result", "");
    v8 = &v23;
    v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v16 = *(const char **)v9;
      v17 = (const char *)*((_DWORD *)v9 + 1);
      v18 = (const char *)*((_DWORD *)v9 + 2);
      v19 = (const char *)*((_DWORD *)v9 + 3);
      v9 += 16;
      *v8 = v16;
      v8[1] = v17;
      v8[2] = v18;
      v8[3] = v19;
      v8 += 4;
    }
    while ( v9 != "}" );
    goto LABEL_10;
  }
  if ( v2 )
  {
    if ( v4 )
    {
      nvram_set("speed_test_time", v4);
      nvram_set("speed_test_iface", v2);
      nvram_set("speed_test_result", "");
      if ( !strcmp(v5, "save") )
      {
        v23 = "speed_test_del.sh";
        v24 = "speed_test";
        v25 = 0;
        eval(&v23, 0, 0, 0);
        v6 = strcmp(v4, "OFF");
        v7 = "speed_test_time";
        if ( v6 )
        {
          v23 = "speed_test_add.sh";
          v24 = "speed_test";
          v25 = jhl_nv_get_def("speed_test_time");
          v26 = jhl_nv_get_def("speed_test_iface");
          v27 = 0;
          eval(&v23, 0, 0, 0);
        }
LABEL_8:
        jhl_parm_commit(v7);
        v8 = &v23;
        v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v10 = *(const char **)v9;
          v11 = (const char *)*((_DWORD *)v9 + 1);
          v12 = (const char *)*((_DWORD *)v9 + 2);
          v13 = (const char *)*((_DWORD *)v9 + 3);
          v9 += 16;
          *v8 = v10;
          v8[1] = v11;
          v8[2] = v12;
          v8[3] = v13;
          v8 += 4;
        }
        while ( v9 != "}" );
LABEL_10:
        v14 = 33;
        *(_WORD *)v8 = *(_WORD *)v9;
        return httpd_cgi_ret(a1, (char *)&v23, v14, 4);
      }
LABEL_13:
      if ( !strcmp(v5, "speedtest") )
      {
        killall_tk("speedTest");
        v23 = "speedTest";
        v24 = v2;
        v25 = 0;
        eval_nowait(&v23, 0, 0, 0);
      }
      goto LABEL_8;
    }
    nvram_set("speed_test_iface", v2);
    nvram_set("speed_test_result", "");
    if ( strcmp(v5, "save") )
      goto LABEL_13;
    v20 = *(unsigned __int8 *)(a1 + 210102);
    v21 = (const char *)&unk_646EE4;
  }
  else
  {
LABEL_18:
    v20 = *(unsigned __int8 *)(a1 + 210102);
    v21 = "not opt or iface";
  }
  v22 = (const char *)_GET_LANG_TEXT(12, v20, v21);
  v14 = snprintf((char *)&v23, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v22);
  if ( v14 >= 0x80 )
    v14 = 127;
  return httpd_cgi_ret(a1, (char *)&v23, v14, 4);
}
// 4A06F8: variable 'v7' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004A09B8) --------------------------------------------------------
int __fastcall sub_4A09B8(int a1)
{
  char *v1; // $v0
  char *v2; // $s0
  int v3; // $s2
  char *v4; // $s1
  int i; // $s0
  int v6; // $v0
  int (__fastcall **v7)(_DWORD, _DWORD); // $t9
  const char *v8; // $a0
  int v9; // $a1
  int v10; // $v0
  char *v11; // $v0
  char *v12; // $v1
  const char *v13; // $v0
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  char v19[520]; // [sp+28h] [-218h] BYREF
  int v20[4]; // [sp+230h] [-10h] BYREF

  v2 = httpd_get_parm(a1, "iface");
  v1 = httpd_get_parm(a1, "opt");
  if ( v1 && !strcmp(v1, "del") )
  {
    killall_tk("speedTest");
    nvram_set("speed_test_result", "");
  }
  else
  {
    if ( !v2 )
      v2 = "all";
    if ( !strnicmp(v2, "all", 3) )
    {
      cgi_signal_to_kernel(10, 5, 1024000);
    }
    else
    {
      v3 = split_string(v2, 44, v19, 128);
      if ( v3 > 0 )
      {
        v4 = v19;
        for ( i = 0; i != v3; ++i )
        {
          v6 = J_atoi(*(_DWORD *)v4);
          if ( v6 > 0 )
          {
            v7 = &jhl_vpnget;
            v8 = (const char *)&unk_645880;
            v9 = v6 - 101;
            if ( v6 < 101 )
            {
              v8 = "wan_name";
              v9 = v6 - 1;
              v7 = &jhl_nvget;
            }
            v10 = ((int (__fastcall *)(const char *, int, int (__fastcall **)(_DWORD, _DWORD)))v7)(v8, v9, &jhl_nvget);
            v11 = (char *)nvram_get(v10);
            if ( !v11 )
              v11 = "";
            v20[0] = (int)"speedTest";
            v20[1] = (int)v11;
            v20[2] = 0;
            eval_nowait(v20, 0, 0, 0);
          }
          v4 += 4;
        }
      }
    }
  }
  v12 = v19;
  v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v14 = *(_DWORD *)v13;
    v15 = *((_DWORD *)v13 + 1);
    v16 = *((_DWORD *)v13 + 2);
    v17 = *((_DWORD *)v13 + 3);
    v13 += 16;
    *(_DWORD *)v12 = v14;
    *((_DWORD *)v12 + 1) = v15;
    *((_DWORD *)v12 + 2) = v16;
    *((_DWORD *)v12 + 3) = v17;
    v12 += 16;
  }
  while ( v13 != "}" );
  *(_WORD *)v12 = *(_WORD *)v13;
  return httpd_cgi_ret(a1, v19, 33, 4);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8764: using guessed type int __fastcall cgi_signal_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A88B8: using guessed type int __fastcall strnicmp(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004A0C78) --------------------------------------------------------
int __fastcall ping_data(int a1)
{
  char *v2; // $v0
  char *v3; // $fp
  const char *v4; // $s2
  int v5; // $s1
  int v6; // $v0
  char *v7; // $v0
  __pid_t v8; // $s6
  void *v9; // $v0
  int v10; // $v0
  int v11; // $s0
  void *v12; // $s5
  int v13; // $v0
  const char *v14; // $v0
  int v15; // $s1
  size_t v16; // $v0
  size_t v17; // $s1
  int v18; // $v0
  int v19; // $s1
  int result; // $v0
  int v21; // $s2
  unsigned int v22; // $v0
  int v23; // $v0
  const char *v24; // $v0
  int v25; // $v0
  const char *v26; // $v0
  const char *v27; // $v0
  unsigned int v28; // $v0
  char v29[1024]; // [sp+20h] [-480h] BYREF
  char v30[128]; // [sp+420h] [-80h] BYREF

  memset(v30, 0, sizeof(v30));
  v3 = httpd_get_parm(a1, (char *)&off_64CC40);
  v2 = httpd_get_parm(a1, "iface");
  if ( !v2 )
  {
    v5 = 0;
    if ( v3 )
    {
      v8 = J_atoi(v3);
      sprintf(v30, "/tmp/ping/ping_%d", v8);
      v5 = 0;
      v4 = "1";
      if ( v8 > 0 )
      {
LABEL_8:
        _mem_malloc(0x200000, "ping_data", 258);
        v11 = v10;
        _mem_malloc(0x200000, "ping_data", 259);
        v12 = v9;
        if ( v11 && v9 )
        {
          strcpy((char *)v11, "{\"code\":0,\"error\":\"\",\"data\":{");
          qmemcpy((void *)v11, "{\"code\":0,\"error\":\"\"", 20);
          *(_DWORD *)(v11 + 24) = 975331700;
          *((_BYTE *)v9 + f_read(v30, v9, 2097142)) = 0;
          if ( kill(v8, 0) )
          {
            v13 = jhl_nvget("wan_pinggw", v5);
            v14 = (const char *)nvram_get(v13);
            if ( !v14 )
              v14 = (const char *)jhl_get_wangw(v5);
            v15 = sprintf((char *)(v11 + 29), "\"iface\":\"%s\",\"gw\":\"%s\",\"msg\":\"", v4, v14) + 29;
            if ( v3 )
              unlink(v30);
          }
          else
          {
            v25 = jhl_nvget("wan_pinggw", v5);
            v26 = (const char *)nvram_get(v25);
            if ( !v26 )
              v26 = (const char *)jhl_get_wangw(v5);
            v15 = sprintf((char *)(v11 + 29), "\"iface\":\"%s\",\"gw\":\"%s\",\"msg\":\"", v4, v26) + 29;
          }
          get_json_data_safe2(v12, v11 + v15);
          v16 = strlen((const char *)v11);
          v17 = v16 + 1;
          *(_WORD *)(v11 + v16) = 34;
          v18 = snprintf((char *)(v11 + v16 + 1), 0x200000 - (v16 + 1), "}}");
          if ( v18 >= (int)(0x200000 - v17) )
            v18 = 0x1FFFFF - v17;
          v19 = v18 + v17;
          _mem_free(v12);
          result = httpd_cgi_ret(a1, (char *)v11, v19, 8);
        }
        else
        {
          _mem_free((void *)v11);
          _mem_free(v12);
          v27 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
          v28 = snprintf(v29, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
          if ( v28 >= 0x400 )
            v28 = 1023;
          result = httpd_cgi_ret(a1, v29, v28, 4);
        }
        return result;
      }
    }
    else
    {
      v4 = "1";
    }
    goto LABEL_24;
  }
  v4 = v2;
  v5 = J_atoi(v2);
  if ( v5 < 101 )
  {
    if ( v5 > 0 )
      --v5;
    v6 = jhl_nvget(&unk_64CC38, v5);
    v7 = (char *)nvram_get(v6);
    if ( !v7 )
      v7 = "0";
    v8 = J_atoi(v7);
    sprintf(v30, "/tmp/ping/ping_%d_%d", v5, v8);
    if ( v8 > 0 )
      goto LABEL_8;
LABEL_24:
    strcpy(v29, "{\"code\":0,\"error\":\"\",\"data\":{");
    v23 = jhl_nvget("wan_pinggw", v5);
    v24 = (const char *)nvram_get(v23);
    if ( !v24 )
      v24 = (const char *)jhl_get_wangw(v5);
    v21 = sprintf(&v29[29], "\"iface\":\"%s\",\"gw\":\"%s\",\"msg\":\"\"", v4, v24) + 29;
    goto LABEL_19;
  }
  strcpy(v29, "{\"code\":0,\"error\":\"\",\"data\":{");
  v21 = sprintf(&v29[29], "\"iface\":\"%s\",\"gw\":\"\",\"msg\":\"\"", v4) + 29;
LABEL_19:
  v22 = snprintf(&v29[v21], 1024 - v21, "}}");
  if ( v22 >= 1024 - v21 )
    v22 = 1023 - v21;
  return httpd_cgi_ret(a1, v29, v22 + v21, 4);
}
// 4A0DEC: variable 'v10' is possibly undefined
// 4A0DF8: variable 'v9' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 64CC40: using guessed type void *off_64CC40;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A81FC: using guessed type int __fastcall get_json_data_safe2(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8920: using guessed type int __fastcall jhl_get_wangw(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004A131C) --------------------------------------------------------
int __fastcall sub_4A131C(int a1)
{
  char *v2; // $s3
  char *v3; // $s5
  char *v4; // $s4
  char *v5; // $s2
  char *v6; // $v0
  char *v7; // $s1
  char *v8; // $s2
  int v9; // $s2
  const char *v11; // $v0
  char *v12; // $v1
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  int v16; // $a1
  const char *v17; // $s6
  int *v18; // $v0
  int v19; // $v0
  int v20; // $s3
  unsigned int v21; // $v0
  int v22; // $a1
  int v23; // $v0
  int v24; // $a1
  char v25[256]; // [sp+20h] [-18Ch] BYREF
  int v26[32]; // [sp+120h] [-8Ch] BYREF
  int v27[3]; // [sp+1A0h] [-Ch] BYREF

  v27[0] = 0;
  v2 = httpd_get_parm(a1, "addr");
  v3 = httpd_get_parm(a1, "count");
  v4 = httpd_get_parm(a1, "size");
  v5 = httpd_get_parm(a1, "dev");
  v7 = httpd_get_parm(a1, "opt");
  v6 = httpd_get_parm(a1, "ipv");
  if ( !v7 )
  {
    v17 = v6;
    if ( !v5 )
      goto LABEL_15;
    if ( !*v5 )
    {
      v5 = 0;
      goto LABEL_15;
    }
    if ( strnicmp(v5, &off_645568, 3) )
    {
      if ( !strcmp(v5, (const char *)&off_64CCE8) )
      {
        v5 = (char *)nvram_get("lan_ifname");
        if ( !v5 )
        {
LABEL_35:
          v5 = "";
          goto LABEL_15;
        }
      }
      else
      {
        if ( !strnicmp(v5, "vpn", 3) )
        {
          v24 = atoi(v5 + 3) - 1;
          v23 = jhl_vpnget(&unk_645880, v24);
LABEL_34:
          v5 = (char *)nvram_get(v23);
          if ( v5 )
            goto LABEL_15;
          goto LABEL_35;
        }
        if ( !strcmp(v5, "3G") || !strcmp(v5, "4G") || !strcmp(v5, "5G") )
        {
          v22 = jhl_get_3g_iface();
          if ( v22 >= 0 )
          {
LABEL_33:
            v23 = jhl_nvget("wan_name", v22);
            goto LABEL_34;
          }
        }
      }
LABEL_15:
      v18 = v26;
      do
        *v18++ = 0;
      while ( v18 != &v26[12] );
      v26[0] = (int)"ping";
      if ( v17 && !strcmp(v17, "6") )
        v26[1] = (int)&unk_64CCF0;
      else
        v26[1] = (int)&unk_64CCF4;
      v26[3] = (int)v3;
      v26[2] = (int)"-c";
      v26[5] = (int)v4;
      v26[4] = (int)"-s";
      if ( v5 )
      {
        v26[7] = (int)v5;
        v26[6] = (int)&unk_64CCF8;
        v19 = 8;
      }
      else
      {
        v19 = 6;
      }
      *(_DWORD *)&v25[4 * v19 + 256] = v2;
      eval_nowait_file(v26, &unk_64CCFC, 0, v27);
      strcpy(v25, "{\"code\":0,\"error\":\"\",\"data\":{");
      v20 = sprintf(&v25[29], "\"msg\":\"ping...\",\"pid\":\"%d\"", v27[0]) + 29;
      v21 = snprintf(&v25[v20], 256 - v20, "}}");
      if ( v21 >= 256 - v20 )
        v21 = 255 - v20;
      httpd_cgi_ret(a1, v25, v21 + v20, 4);
      return 0;
    }
    v22 = atoi(v5 + 3) - 1;
    goto LABEL_33;
  }
  v8 = httpd_get_parm(a1, (char *)&off_64CC40);
  memset(v26, 0, sizeof(v26));
  if ( v8 )
  {
    v9 = J_atoi(v8);
    if ( !strcmp(v7, "stop") )
    {
      if ( v9 >= 2 )
      {
        kill_by_pid_name(v9, "ping", 15, 9, 0);
        return ping_data(a1);
      }
    }
    else if ( !strcmp(v7, "back") && v9 >= 2 )
    {
      kill_by_pid_name(v9, "ping", 15, 9, 0);
      sprintf((char *)v26, "/tmp/ping/ping_%d", v9);
      unlink((const char *)v26);
    }
  }
  v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v12 = v25;
  do
  {
    v13 = *(_DWORD *)v11;
    v14 = *((_DWORD *)v11 + 1);
    v15 = *((_DWORD *)v11 + 2);
    v16 = *((_DWORD *)v11 + 3);
    v11 += 16;
    *(_DWORD *)v12 = v13;
    *((_DWORD *)v12 + 1) = v14;
    *((_DWORD *)v12 + 2) = v15;
    *((_DWORD *)v12 + 3) = v16;
    v12 += 16;
  }
  while ( v11 != "}" );
  *(_WORD *)v12 = *(_WORD *)v11;
  return httpd_cgi_ret(a1, v25, 33, 4);
}
// 642164: using guessed type __int16 word_642164;
// 645568: using guessed type void *off_645568;
// 64CC40: using guessed type void *off_64CC40;
// 64CCE8: using guessed type void *off_64CCE8;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8640: using guessed type int __fastcall eval_nowait_file(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A880C: using guessed type int jhl_get_3g_iface(void);
// 6A88B8: using guessed type int __fastcall strnicmp(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);
// 6A89A0: using guessed type int __fastcall kill_by_pid_name(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004A1924) --------------------------------------------------------
int __fastcall trace_data(int a1)
{
  char *v1; // $v0
  __pid_t v3; // $s2
  size_t v4; // $v0
  int v5; // $s1
  unsigned int v6; // $s2
  unsigned int v7; // $v0
  char *v9; // $v0
  char v10[4096]; // [sp+18h] [-2080h] BYREF
  char v11[4096]; // [sp+1018h] [-1080h] BYREF
  char v12[128]; // [sp+2018h] [-80h] BYREF

  v1 = httpd_get_parm(a1, (char *)&off_64CC40);
  if ( !v1 )
  {
    strcpy(v11, "{\"code\":0,\"error\":\"\",\"data\":{");
    goto LABEL_10;
  }
  v3 = J_atoi(v1);
  strcpy(v11, "{\"code\":0,\"error\":\"\",\"data\":{");
  if ( v3 <= 0 )
  {
LABEL_10:
    strcpy(&v11[29], "\"msg\":\"\"");
    v6 = 4059;
    v5 = 37;
    goto LABEL_6;
  }
  strcpy(&v11[29], "\"msg\":\"");
  sprintf(v12, "/tmp/trace_%d", v3);
  v10[f_read(v12, v10, 5000)] = 0;
  if ( kill(v3, 0) )
  {
    v9 = &v10[strlen(v10)];
    *(_DWORD *)v9 = -491590468;
    *(_DWORD *)v9 = -491590468;
    *((_DWORD *)v9 + 1) = -120921667;
    v9[8] = 10;
    v9[9] = 0;
    unlink(v12);
  }
  get_json_data_safe2(v10, &v11[36]);
  v4 = strlen(v11);
  v5 = v4 + 1;
  v6 = 4096 - (v4 + 1);
  *(_WORD *)&v11[v4] = 34;
LABEL_6:
  v7 = snprintf(&v11[v5], v6, "}}");
  if ( v7 >= v6 )
    v7 = 4095 - v5;
  return httpd_cgi_ret(a1, v11, v7 + v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 64CC40: using guessed type void *off_64CC40;
// 6A81FC: using guessed type int __fastcall get_json_data_safe2(_DWORD, _DWORD);
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004A1BEC) --------------------------------------------------------
int __fastcall sub_4A1BEC(int a1)
{
  char *v2; // $s4
  char *v3; // $s5
  char *v4; // $s3
  char *v5; // $v0
  char *v6; // $s2
  const char *v7; // $s1
  char *v8; // $s2
  int v9; // $s2
  const char *v11; // $v0
  char *v12; // $v1
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  int v16; // $a1
  int *v17; // $v0
  int v18; // $v0
  int v19; // $s3
  unsigned int v20; // $v0
  int v21; // $a1
  int v22; // $v0
  int v23; // $a1
  char v24[256]; // [sp+20h] [-18Ch] BYREF
  int v25[32]; // [sp+120h] [-8Ch] BYREF
  int v26[3]; // [sp+1A0h] [-Ch] BYREF

  v26[0] = 0;
  v2 = httpd_get_parm(a1, "addr");
  v3 = httpd_get_parm(a1, "hops");
  v4 = httpd_get_parm(a1, "wait");
  v6 = httpd_get_parm(a1, "dev");
  v5 = httpd_get_parm(a1, "opt");
  if ( !v5 )
  {
    if ( !v6 || !*v6 )
      goto LABEL_14;
    if ( !strnicmp(v6, &off_645568, 3) )
    {
      v21 = atoi(v6 + 3) - 1;
    }
    else
    {
      if ( !strcmp(v6, (const char *)&off_64CCE8) )
      {
        v6 = (char *)nvram_get("lan_ifname");
        if ( v6 )
        {
          if ( v3 )
            goto LABEL_16;
          goto LABEL_35;
        }
        goto LABEL_34;
      }
      if ( !strnicmp(v6, "vpn", 3) )
      {
        v23 = atoi(v6 + 3) - 1;
        v22 = jhl_vpnget(&unk_645880, v23);
LABEL_33:
        v6 = (char *)nvram_get(v22);
        if ( !v6 )
        {
LABEL_34:
          v6 = "";
          if ( v3 )
            goto LABEL_16;
          goto LABEL_35;
        }
LABEL_15:
        if ( v3 )
        {
LABEL_16:
          if ( !v4 )
            v4 = "2";
          v17 = v25;
          do
            *v17++ = 0;
          while ( &v25[12] != v17 );
          v25[3] = (int)v3;
          v25[0] = (int)"traceroute";
          v25[5] = (int)v4;
          v25[1] = (int)&unk_64CCF8;
          v25[2] = (int)"-m";
          v25[4] = (int)"-w";
          if ( v6 )
          {
            v25[7] = (int)v6;
            v25[6] = (int)"-i";
            v18 = 8;
          }
          else
          {
            v18 = 6;
          }
          *(_DWORD *)&v24[4 * v18 + 256] = v2;
          eval_nowait_file(v25, ">>/tmp/trace", 0, v26);
          strcpy(v24, "{\"code\":0,\"error\":\"\",\"data\":{");
          v19 = sprintf(&v24[29], "\"msg\":\"trace...\",\"pid\":\"%d\"", v26[0]) + 29;
          v20 = snprintf(&v24[v19], 256 - v19, "}}");
          if ( v20 >= 256 - v19 )
            v20 = 255 - v19;
          httpd_cgi_ret(a1, v24, v20 + v19, 4);
          return 0;
        }
LABEL_35:
        v3 = "20";
        goto LABEL_16;
      }
      if ( strcmp(v6, "3G") && strcmp(v6, "4G") && strcmp(v6, "5G") )
        goto LABEL_15;
      v21 = jhl_get_3g_iface();
      if ( v21 < 0 )
      {
LABEL_14:
        v6 = 0;
        goto LABEL_15;
      }
    }
    v22 = jhl_nvget("wan_name", v21);
    goto LABEL_33;
  }
  v7 = v5;
  v8 = httpd_get_parm(a1, (char *)&off_64CC40);
  memset(v25, 0, sizeof(v25));
  if ( v8 )
  {
    v9 = J_atoi(v8);
    if ( !strcmp(v7, "stop") )
    {
      if ( v9 >= 2 )
      {
        kill_by_pid_name(v9, "traceroute", 15, 9, 0);
        return trace_data(a1);
      }
    }
    else if ( !strcmp(v7, "back") && v9 >= 2 )
    {
      kill_by_pid_name(v9, "traceroute", 15, 9, 0);
      sprintf((char *)v25, "/tmp/trace_%d", v9);
      unlink((const char *)v25);
    }
  }
  v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v12 = v24;
  do
  {
    v13 = *(_DWORD *)v11;
    v14 = *((_DWORD *)v11 + 1);
    v15 = *((_DWORD *)v11 + 2);
    v16 = *((_DWORD *)v11 + 3);
    v11 += 16;
    *(_DWORD *)v12 = v13;
    *((_DWORD *)v12 + 1) = v14;
    *((_DWORD *)v12 + 2) = v15;
    *((_DWORD *)v12 + 3) = v16;
    v12 += 16;
  }
  while ( v11 != "}" );
  *(_WORD *)v12 = *(_WORD *)v11;
  return httpd_cgi_ret(a1, v24, 33, 4);
}
// 642164: using guessed type __int16 word_642164;
// 645568: using guessed type void *off_645568;
// 64CC40: using guessed type void *off_64CC40;
// 64CCE8: using guessed type void *off_64CCE8;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8640: using guessed type int __fastcall eval_nowait_file(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A880C: using guessed type int jhl_get_3g_iface(void);
// 6A88B8: using guessed type int __fastcall strnicmp(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);
// 6A89A0: using guessed type int __fastcall kill_by_pid_name(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004A21C4) --------------------------------------------------------
int __fastcall sub_4A21C4(int a1)
{
  int v1; // $v0
  int v3; // $s0
  _DWORD *i; // $s0
  char *v5; // $v0
  int *v6; // $v1
  const char *v7; // $v0
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  int v11; // $a1
  unsigned int v12; // $a2
  const char *v13; // $v0
  int v15[64]; // [sp+20h] [-100h] BYREF

  v1 = httpd_get_json_parm(a1, (int)&off_646724);
  if ( v1 && (v3 = v1, cJSON_IsArray(v1)) )
  {
    for ( i = *(_DWORD **)(v3 + 8); i; i = (_DWORD *)*i )
    {
      if ( i[4] )
      {
        v15[0] = (int)"ether-wake";
        v15[1] = (int)"-i";
        v5 = (char *)nvram_get("lan_ifname");
        if ( !v5 )
          v5 = "";
        v15[2] = (int)v5;
        v15[3] = i[4];
        v15[4] = 0;
        eval(v15, 0, 0, 0);
      }
    }
    v6 = v15;
    v7 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v8 = *(_DWORD *)v7;
      v9 = *((_DWORD *)v7 + 1);
      v10 = *((_DWORD *)v7 + 2);
      v11 = *((_DWORD *)v7 + 3);
      v7 += 16;
      *v6 = v8;
      v6[1] = v9;
      v6[2] = v10;
      v6[3] = v11;
      v6 += 4;
    }
    while ( v7 != "}" );
    v12 = 33;
    *(_WORD *)v6 = *(_WORD *)v7;
  }
  else
  {
    v13 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "error mac");
    v12 = snprintf((char *)v15, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
    if ( v12 >= 0x100 )
      v12 = 255;
  }
  httpd_cgi_ret(a1, (char *)v15, v12, 4);
  return 0;
}
// 646724: using guessed type void *off_646724;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A23C0) --------------------------------------------------------
int __fastcall sub_4A23C0(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s1
  const char *v5; // $s2
  const char *v6; // $s4
  const char *v7; // $v0
  int v8; // $v0
  int v9; // $s1
  int v10; // $s2
  int v11; // $v0
  int v12; // $a2
  int result; // $v0
  const char *v14; // $v0
  unsigned int v15; // $v0
  char v16[104]; // [sp+30h] [-68h] BYREF

  _mem_malloc(10240, "alert_weixin_data", 1485);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\",\"da", 24);
    v4 = (const char *)jhl_nv_get_def("alert_weixin_en");
    v5 = (const char *)jhl_nv_get_def("alert_weixin_name");
    v6 = (const char *)jhl_nv_get_def("alert_weixin_phone");
    v7 = (const char *)jhl_nv_get_def("alert_weixin_type");
    v8 = snprintf(
           v3 + 29,
           10211,
           "\"enable\":%s,\"name\":\"%s\",\"phone\":\"%s\",\"type\":%s,\"ac\":%d,\"wtclient\":%d",
           v4,
           v5,
           v6,
           v7,
           1,
           1);
    if ( v8 >= 10211 )
      v8 = 10210;
    v9 = v8 + 29;
    v10 = 10240 - (v8 + 29);
    v11 = snprintf(&v3[v8 + 29], v10, "}}");
    if ( v11 >= v10 )
      v12 = 10239 - v9;
    else
      v12 = v11;
    result = httpd_cgi_ret(a1, v3, v12 + v9, 8);
  }
  else
  {
    v14 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v15 = snprintf(v16, 100, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v15 >= 0x64 )
      v15 = 99;
    result = httpd_cgi_ret(a1, v16, v15, 4);
  }
  return result;
}
// 4A2410: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004A2640) --------------------------------------------------------
int __fastcall sub_4A2640(int a1)
{
  char *v2; // $s4
  char *v3; // $s3
  char *v4; // $s2
  int v5; // $a0
  char *v6; // $s5
  int v7; // $s4
  char *v8; // $v1
  const char *v9; // $v0
  int v10; // $t0
  int v11; // $a3
  int v12; // $a2
  int v13; // $a1
  char v15[256]; // [sp+18h] [-110h] BYREF
  int v16[4]; // [sp+118h] [-10h] BYREF

  memset(v15, 0, sizeof(v15));
  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "name");
  v4 = httpd_get_parm(a1, "phone");
  v6 = httpd_get_parm(a1, "type");
  if ( v2 && !nvram_match_def("alert_weixin_en", v2) )
  {
    nvram_set("alert_weixin_en", v2);
    if ( nvram_match_def("alert_weixin_en", "1") )
    {
      v16[0] = (int)"alert_log_send";
      v16[1] = (int)"0";
      v16[2] = 0;
      eval_nowait(v16, 0, 0, 0);
    }
    else
    {
      killall_tk("alert_log_send");
    }
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  if ( v3 && !nvram_match_def("alert_weixin_name", v3) )
  {
    nvram_set("alert_weixin_name", v3);
    ++v7;
  }
  if ( v4 && !nvram_match_def("alert_weixin_phone", v4) )
  {
    nvram_set("alert_weixin_phone", v4);
    if ( !v6 || nvram_match_def("alert_weixin_type", v6) )
      goto LABEL_18;
    goto LABEL_17;
  }
  if ( v6 && !nvram_match_def("alert_weixin_type", v6) )
  {
LABEL_17:
    nvram_set("alert_weixin_type", v6);
    goto LABEL_18;
  }
  if ( v7 )
LABEL_18:
    jhl_parm_commit(v5);
  v8 = v15;
  v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v10 = *(_DWORD *)v9;
    v11 = *((_DWORD *)v9 + 1);
    v12 = *((_DWORD *)v9 + 2);
    v13 = *((_DWORD *)v9 + 3);
    v9 += 16;
    *(_DWORD *)v8 = v10;
    *((_DWORD *)v8 + 1) = v11;
    *((_DWORD *)v8 + 2) = v12;
    *((_DWORD *)v8 + 3) = v13;
    v8 += 16;
  }
  while ( v9 != "}" );
  *(_WORD *)v8 = *(_WORD *)v9;
  return httpd_cgi_ret(a1, v15, 33, 4);
}
// 4A2890: variable 'v5' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004A2958) --------------------------------------------------------
int __fastcall dhcp_detect_list_data_send(int a1)
{
  char *v1; // $v0
  char *v2; // $s1
  int v3; // $a2
  int v4; // $s0
  int *v5; // $fp
  int v6; // $s3
  int v7; // $s7
  const char *v8; // $v0
  int v9; // $v0
  int v10; // $a0
  int v11; // $v0
  char *v12; // $a0
  int v13; // $v0
  int v14; // $a2
  const char *v15; // $v0
  const char *v17; // $v0
  unsigned int v18; // $a2
  int v19[2560]; // [sp+20h] [-2848h] BYREF
  char v20[32]; // [sp+2820h] [-48h] BYREF
  char v21[32]; // [sp+2840h] [-28h] BYREF
  const char *v22; // [sp+2860h] [-8h]

  _mem_malloc(20240, "dhcp_detect_list_data_send", 1575);
  if ( v1 )
  {
    v2 = v1;
    memset(v19, 0, sizeof(v19));
    v19[0] = 5;
    v19[3] = 11;
    v19[1] = 10240;
    if ( jianhl_order_opt_fun(v19, 10240, v3) )
    {
      v15 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
      v14 = snprintf(v2, 20240, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v15);
      if ( v14 >= 20240 )
        v14 = 20239;
      return httpd_cgi_ret(a1, v2, v14, 8);
    }
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy(v2, "{\"code\":0,\"error", 16);
    v4 = 20211;
    if ( v19[5] <= 0 )
    {
      v11 = 28;
      v10 = 29;
      v7 = 29;
    }
    else
    {
      v5 = &v19[7];
      v6 = 0;
      v7 = 29;
      do
      {
        v22 = (const char *)IpToStr(v21, *(v5 - 1));
        v8 = (const char *)MacToStr(v20, v5);
        v9 = snprintf(&v2[v7], v4, "{\"i\":\"%s\",\"m\":\"%s\"},", v22, v8);
        if ( v9 >= v4 )
          v9 = 20239 - v7;
        v7 += v9;
        ++v6;
        v4 = 20240 - v7;
        if ( v6 >= v19[5] )
          break;
        v5 += 3;
      }
      while ( 20240 - v7 >= 100 );
      v10 = v7;
      if ( v7 <= 0 )
        goto LABEL_13;
      v11 = v7 - 1;
    }
    if ( v2[v11] == 44 )
      v10 = --v7;
LABEL_13:
    v12 = &v2[v10];
    *v12 = 0;
    v13 = snprintf(v12, 20240 - v7, "]}");
    if ( v13 >= 20240 - v7 )
      v13 = 20239 - v7;
    v14 = v7 + v13;
    return httpd_cgi_ret(a1, v2, v14, 8);
  }
  v17 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 20240);
  v18 = snprintf((char *)v19, 10240, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v17);
  if ( v18 >= 0x2800 )
    v18 = 10239;
  return httpd_cgi_ret(a1, (char *)v19, v18, 4);
}
// 4A29B4: variable 'v1' is possibly undefined
// 4A29F8: variable 'v3' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (004A2CD8) --------------------------------------------------------
int __fastcall dhcp_detect_list_data_timeout(_DWORD *a1)
{
  _DWORD *v1; // $s0
  int v2; // $v0
  int result; // $v0

  v1 = a1 + 49152;
  v2 = a1[51393];
  if ( v2 < 3 )
  {
    a1[51393] = v2 + 1;
    a1[51387] = jiffies_get() + 1000;
    v1[2237] = a1;
    v1[2236] = dhcp_detect_list_data_timeout;
    result = add_timer(a1 + 51385);
  }
  else
  {
    a1[51388] = httpd_keep_alive_timeout;
    a1[51387] = jiffies_get() + 5000;
    add_timer(a1 + 51385);
    result = dhcp_detect_list_data_send((int)a1);
  }
  return result;
}
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (004A2DB8) --------------------------------------------------------
int __fastcall sub_4A2DB8(int a1)
{
  int v2; // $a2
  int result; // $v0
  const char *v4; // $v0
  unsigned int v5; // $v0
  int v6[256]; // [sp+20h] [-40Ch] BYREF
  int v7; // [sp+420h] [-Ch]

  memset(v6, 0, sizeof(v6));
  v6[0] = 5;
  v6[3] = 10;
  v6[1] = 1024;
  v6[5] = 0;
  v6[6] = 0;
  v6[7] = 0;
  v6[8] = 0;
  if ( jianhl_order_opt_fun(v6, 1024, v2) )
  {
    v4 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), "");
    v5 = snprintf((char *)v6, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v4);
    if ( v5 >= 0x400 )
      result = httpd_cgi_ret(a1, (char *)v6, 1023, 4);
    else
      result = httpd_cgi_ret(a1, (char *)v6, v5, 4);
  }
  else
  {
    v7 = 0;
    *(_DWORD *)(a1 + 205572) = 0;
    dhcp_detect_list_data_timeout((_DWORD *)a1);
    result = v7;
  }
  return result;
}
// 4A2E28: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (004A2F10) --------------------------------------------------------
int __fastcall sub_4A2F10(int a1)
{
  const char *v2; // $v0
  const char *v3; // $s0
  unsigned int v4; // $v0
  int v5; // $s0
  unsigned int v6; // $v0
  char v8[4100]; // [sp+18h] [-1004h] BYREF

  v2 = (const char *)nvram_get("vue_customeze_menus");
  if ( !v2 || (v3 = v2, strlen(v2) < 2) )
    v3 = "[]";
  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v4 = snprintf(&v8[29], 4067, "\"menus\":%s", v3);
  v5 = v4 + 29;
  if ( v4 >= 0xFE3 )
    v5 = 4095;
  v6 = snprintf(&v8[v5], 4096 - v5, "}}");
  if ( v6 >= 4096 - v5 )
    v6 = 4095 - v5;
  return httpd_cgi_ret(a1, v8, v6 + v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (004A3070) --------------------------------------------------------
int __fastcall sub_4A3070(int a1)
{
  int v1; // $v0
  int v3; // $v0
  const char *v4; // $v0
  char *v5; // $s0
  const char *v6; // $a1
  int v7; // $a0
  const char *v8; // $v0
  char *v9; // $v1
  int v10; // $t1
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  char v15[512]; // [sp+18h] [-200h] BYREF

  v1 = httpd_get_json_parm(a1, (int)"menus");
  v3 = cJSON_PrintUnformatted(v1);
  if ( v3 )
  {
    v5 = (char *)v3;
    v4 = (const char *)nvram_get("vue_customeze_menus");
    if ( !v4 || strcmp(v4, v5) )
    {
      v6 = v5;
      if ( !*v5 )
        v6 = "[]";
      nvram_set("vue_customeze_menus", v6);
      jhl_parm_commit(v7);
    }
    free(v5);
  }
  v8 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v9 = v15;
  do
  {
    v10 = *(_DWORD *)v8;
    v11 = *((_DWORD *)v8 + 1);
    v12 = *((_DWORD *)v8 + 2);
    v13 = *((_DWORD *)v8 + 3);
    v8 += 16;
    *(_DWORD *)v9 = v10;
    *((_DWORD *)v9 + 1) = v11;
    *((_DWORD *)v9 + 2) = v12;
    *((_DWORD *)v9 + 3) = v13;
    v9 += 16;
  }
  while ( v8 != "}" );
  *(_WORD *)v9 = *(_WORD *)v8;
  return httpd_cgi_ret(a1, v15, 33, 4);
}
// 4A3144: variable 'v7' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A85D0: using guessed type int __fastcall cJSON_PrintUnformatted(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004A31E0) --------------------------------------------------------
int __fastcall menus_js_replace_text(int a1, const char *a2, int a3, int a4)
{
  int v8; // $fp
  int v9; // $s4
  int v10; // $s5
  _BYTE *v11; // $v0
  bool v13; // dc
  const char *v14; // $a3
  int v15; // $v0
  const char *v16; // $s7
  const char *v17; // $s7
  int v18; // $v0
  const char *v19; // $s7
  int v20; // $v0
  const char *v21; // $v0
  int v22; // $v0
  const char *v23; // $s7
  int v24; // $v0
  int v25; // $v0
  char *v26; // $a0
  const char *v27; // $a3
  int v28; // $v0
  int v29; // $v0

  v8 = 0;
LABEL_2:
  while ( 1 )
  {
    v9 = *a2;
    if ( !*a2 )
      break;
    while ( 1 )
    {
      v10 = a4 - v8;
      if ( a4 - v8 < 257 )
        goto LABEL_7;
      if ( v9 != 91 )
      {
        v11 = (_BYTE *)(a3 + v8);
        goto LABEL_6;
      }
      if ( !memcmp(a2, "[TEXT:", 6u) )
        break;
      v13 = memcmp(a2, "[HIDDEN:", 8u) != 0;
      v11 = (_BYTE *)(a3 + v8);
      if ( !v13 )
      {
        if ( !memcmp(a2 + 8, "WTOKEN:", 7u) )
        {
          v16 = a2 + 15;
          v25 = atoi(v16);
          v26 = (char *)(a3 + v8);
          if ( v25 == *(unsigned __int8 *)(a1 + 210100) )
            goto LABEL_32;
        }
        else
        {
          if ( memcmp(a2 + 8, "AUTHXX:", 7u) )
          {
            if ( !memcmp(a2 + 8, "BRIDGE:", 7u) )
              v14 = "false";
            else
              v14 = "true";
            v15 = snprintf((char *)(a3 + v8), a4 - v8, "%s", v14);
            if ( v15 >= v10 )
              v15 = v10 - 1;
            v8 += v15;
            v16 = a2 + 8;
LABEL_17:
            v17 = v16 + 1;
            do
              v18 = *(v17++ - 1);
            while ( v18 != 93 );
            a2 = v17 - 1;
            goto LABEL_2;
          }
          v16 = a2 + 15;
          v29 = atoi(v16);
          v26 = (char *)(a3 + v8);
          if ( *(_DWORD *)(a1 + 205588) < v29 )
          {
LABEL_32:
            v27 = "true";
            goto LABEL_28;
          }
        }
        v27 = "false";
LABEL_28:
        v28 = snprintf(v26, a4 - v8, "%s", v27);
        if ( v28 >= v10 )
          v28 = v10 - 1;
        v8 += v28;
        goto LABEL_17;
      }
LABEL_6:
      *v11 = v9;
      v9 = *++a2;
      ++v8;
      if ( !*a2 )
        goto LABEL_7;
    }
    v19 = a2 + 6;
    v20 = atoi(v19);
    v21 = (const char *)GET_MENU_JS_TEXT(v20, *(unsigned __int8 *)(a1 + 210102));
    v22 = snprintf((char *)(a3 + v8), a4 - v8, "%s", v21);
    if ( v22 >= v10 )
      v22 = v10 - 1;
    v8 += v22;
    v23 = v19 + 1;
    do
      v24 = *(v23++ - 1);
    while ( v24 != 93 );
    a2 = v23 - 1;
  }
LABEL_7:
  *(_BYTE *)(a3 + v8) = 0;
  return v8;
}
// 6A821C: using guessed type int __fastcall GET_MENU_JS_TEXT(_DWORD, _DWORD);

//----- (004A3510) --------------------------------------------------------
int __fastcall sub_4A3510(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  const char *v4; // $a1
  int v5; // $s2
  int v6; // $v0
  int v7; // $a2
  int result; // $v0
  const char *v9; // $v0
  unsigned int v10; // $v0
  char v11[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(0x200000, "menus_data", 216);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    v4 = menu_js_router_str;
    *(_DWORD *)(v2 + 24) = *(_DWORD *)"ta\":";
    v5 = menus_js_replace_text(a1, v4, v2 + 28, 2097124) + 28;
    v6 = snprintf(&v3[v5], 0x200000 - v5, "}");
    if ( v6 >= 0x200000 - v5 )
      v7 = 0x1FFFFF - v5;
    else
      v7 = v6;
    result = jhl_data_giz(a1, v3, v7 + v5, 0x200000);
  }
  else
  {
    v9 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v10 = snprintf(v11, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 >= 0x100 )
      v10 = 255;
    result = httpd_cgi_ret(a1, v11, v10, 4);
  }
  return result;
}
// 4A3560: variable 'v2' is possibly undefined
// 67BF24: using guessed type char *menu_js_router_str;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004A3700) --------------------------------------------------------
int __fastcall upnp_ctrl_file_exists(int a1)
{
  _DWORD *v1; // $s1
  const char *v3; // $v0
  char *v4; // $v1
  int v5; // $t1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  int result; // $v0
  char v10[512]; // [sp+18h] [-200h] BYREF

  v1 = (_DWORD *)(a1 + 196608);
  if ( *(int *)(a1 + 205572) < 5 && f_exists("/var/spool/upnp.js") == 1 )
  {
    ++v1[2241];
    v1[2235] = jiffies_get() + 1000;
    v1[2237] = a1;
    v1[2236] = upnp_ctrl_file_exists;
    result = add_timer(a1 + 205540);
  }
  else
  {
    v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v4 = v10;
    do
    {
      v5 = *(_DWORD *)v3;
      v6 = *((_DWORD *)v3 + 1);
      v7 = *((_DWORD *)v3 + 2);
      v8 = *((_DWORD *)v3 + 3);
      v3 += 16;
      *(_DWORD *)v4 = v5;
      *((_DWORD *)v4 + 1) = v6;
      *((_DWORD *)v4 + 2) = v7;
      *((_DWORD *)v4 + 3) = v8;
      v4 += 16;
    }
    while ( v3 != "}" );
    *(_WORD *)v4 = *(_WORD *)v3;
    result = httpd_cgi_ret(a1, v10, 33, 4);
  }
  return result;
}
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (004A3818) --------------------------------------------------------
int __fastcall asp_lipp(char *a1)
{
  char *v2; // $v0
  char *v3; // $v0
  char v5[68]; // [sp+18h] [-44h] BYREF

  v2 = (char *)nvram_get("lan_ipaddr");
  if ( !v2 )
    return 0;
  strcpy(v5, v2);
  v3 = strrchr(v5, 46);
  if ( v3 )
    *v3 = 0;
  return sprintf(a1, "%s", v5);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (004A38D4) --------------------------------------------------------
void __fastcall format_nat_base_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 8 )
    snprintf(
      a3,
      a4,
      "{\"en\":%s,\"prot\":\"%s\",\"src\":\"%s\",\"fport\":\"%s\",\"inport\":\"%s\",\"inip\":\"%s\",\"name\":\"%s\",\"wans\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7]);
}

//----- (004A3984) --------------------------------------------------------
int __fastcall sub_4A3984(int a1)
{
  int v1; // $v0
  int v2; // $fp
  const char *v3; // $s3
  const char *v4; // $s1
  const char *v5; // $s2
  const char *v6; // $v0
  int v7; // $v0
  char *v8; // $a1
  int v9; // $s3
  int v10; // $s1
  int v11; // $s4
  int v12; // $s5
  int v13; // $s0
  const char **v14; // $s2
  void *v15; // $v0
  _DWORD *v16; // $s6
  int v17; // $a1
  void *v18; // $s5
  int v19; // $s5
  int i; // $s7
  int v21; // $v0
  int v22; // $v0
  char *v23; // $a0
  int v24; // $s1
  int v25; // $v0
  int v26; // $s3
  _DWORD *v27; // $v0
  int v28; // $s3
  int v29; // $v0
  int v30; // $a2
  int result; // $v0
  const char *v32; // $v0
  unsigned int v33; // $v0
  char v34[256]; // [sp+28h] [-108h] BYREF
  _DWORD *v35; // [sp+128h] [-8h]
  void *ptr; // [sp+12Ch] [-4h]

  _mem_malloc(0x200000, "nat_base_data", 74);
  if ( v1 )
  {
    v2 = v1;
    asp_lipp(v34);
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v3 = (const char *)jhl_nv_get_def("nf_loopback");
    v4 = (const char *)jhl_nv_get_def("nf_sports");
    v5 = (const char *)jhl_nv_get_def("nf_dxtong");
    v6 = (const char *)jhl_nv_get_def("nf_fullcone");
    v7 = sprintf(
           (char *)(v2 + 29),
           "\"mode\":\"%s\",\"nf_sports\":\"%s\",\"nf_dxtong\":\"%s\",\"nf_fullcone\":\"%s\",\"fullcone_show\":%d,\"lipp\""
           ":\"%s\",\"karten_modus\":0",
           v3,
           v4,
           v5,
           v6,
           1,
           v34);
    v8 = (char *)(v2 + v7 + 29);
    strcpy(v8, ",\"portforward\":");
    strcpy(v8, ",\"portforward\":");
    v9 = v7 + 44;
    v10 = 0x200000 - (v7 + 44);
    v11 = v2 + v7 + 44;
    v12 = nvram_get("portforward");
    v13 = snprintf((char *)(v2 + v9), 0x200000 - v9, (char *)&word_642A04);
    if ( v13 >= 0x200000 - v9 )
      v13 = 0x1FFFFF - v9;
    if ( v12 )
    {
      v14 = (const char **)malloc(0x28u);
      v35 = malloc(0x4008u);
      v16 = v35;
      v15 = malloc(0x200000u);
      ptr = v15;
      if ( v15 )
      {
        if ( v14 )
        {
          v17 = v12;
          if ( v16 )
          {
            v18 = v15;
            strlcpy(v15, v17, 0x200000);
            v19 = split_string(v18, 62, v16, 4096);
            if ( v19 > 0 )
            {
              for ( i = 0; i != v19; ++i )
              {
                v21 = split_string(*v16, 60, v14, 8);
                format_nat_base_data(v14, v21, (char *)(v11 + v13), v10 - v13);
                v13 += v22;
                ++v16;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v14 )
        free(v14);
      if ( v35 )
        free(v35);
    }
    v23 = (char *)(v11 + v13);
    if ( v13 > 0 && *(v23 - 1) == 44 )
    {
      --v13;
      v23 = (char *)(v11 + v13);
    }
    v24 = v10 - v13;
    *v23 = 0;
    v25 = snprintf(v23, v24, &byte_6445A0);
    if ( v25 >= v24 )
      v25 = v24 - 1;
    v26 = v13 + v25 + v9;
    v27 = (_DWORD *)(v2 + v26);
    strcpy((char *)(v2 + v26), ",\"wans\":");
    *v27 = 1635197484;
    v27[1] = 975336302;
    v28 = v26 + 8 + get_wans_data((char *)(v2 + v26 + 8), 0x200000 - (v26 + 8));
    v29 = snprintf((char *)(v2 + v28), 0x200000 - v28, "}}");
    if ( v29 >= 0x200000 - v28 )
      v30 = 0x1FFFFF - v28;
    else
      v30 = v29;
    result = httpd_cgi_ret(a1, (char *)v2, v30 + v28, 8);
  }
  else
  {
    v32 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v33 = snprintf(v34, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v32);
    if ( v33 >= 0x100 )
      v33 = 255;
    result = httpd_cgi_ret(a1, v34, v33, 4);
  }
  return result;
}
// 4A39E0: variable 'v1' is possibly undefined
// 4A3C84: variable 'v22' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6448E0: using guessed type int dword_6448E0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A3E98) --------------------------------------------------------
int __fastcall sub_4A3E98(int a1)
{
  char *v2; // $s1
  int v3; // $a0
  const char *v4; // $v0
  char *v5; // $v1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  int v9; // $a1
  unsigned int v10; // $a2
  int v12; // $s1
  char *v13; // $v0
  const char *v14; // $v0
  char v15[512]; // [sp+20h] [-200h] BYREF

  v2 = httpd_get_parm(a1, "exec_service");
  if ( save_variables(a1, 0) )
  {
    if ( save_variables(a1, 1) )
      jhl_parm_commit(v3);
    if ( v2 )
    {
      if ( !strcmp(v2, "upnp-restart") )
      {
        exec_service("upnp-restart");
      }
      else if ( !strcmp(v2, "firewall-restart") )
      {
        exec_service("firewall-restart");
      }
      else if ( !strcmp(v2, "telnetd-start") )
      {
        exec_service("telnetd-start");
      }
      else if ( !strcmp(v2, "telnetd-stop") )
      {
        exec_service("telnetd-stop");
      }
    }
    v4 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v5 = v15;
    do
    {
      v6 = *(_DWORD *)v4;
      v7 = *((_DWORD *)v4 + 1);
      v8 = *((_DWORD *)v4 + 2);
      v9 = *((_DWORD *)v4 + 3);
      v4 += 16;
      *(_DWORD *)v5 = v6;
      *((_DWORD *)v5 + 1) = v7;
      *((_DWORD *)v5 + 2) = v8;
      *((_DWORD *)v5 + 3) = v9;
      v5 += 16;
    }
    while ( v4 != "}" );
    v10 = 33;
    *(_WORD *)v5 = *(_WORD *)v4;
  }
  else
  {
    v12 = *(unsigned __int8 *)(a1 + 210102);
    v13 = resmsg_get();
    v14 = (const char *)_GET_LANG_TEXT(12, v12, v13);
    v10 = snprintf(v15, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
    if ( v10 >= 0x200 )
      v10 = 511;
  }
  return httpd_cgi_ret(a1, v15, v10, 4);
}
// 4A40A4: variable 'v3' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004A410C) --------------------------------------------------------
int __fastcall sub_4A410C(int a1)
{
  char *v2; // $s5
  char *v3; // $s7
  int v4; // $s6
  char *v5; // $s2
  int v6; // $v0
  char *v7; // $v0
  char *v8; // $s3
  int v9; // $s1
  int v10; // $a0
  char *v11; // $fp
  char *v12; // $s7
  int v13; // $a0
  const char *v14; // $v0
  const char *v15; // $v0
  const char *v16; // $v0
  char *v17; // $v1
  const char *v18; // $v0
  int v19; // $t0
  int v20; // $a3
  int v21; // $a2
  int v22; // $a1
  int v23; // $s6
  char *v25; // $a3
  _DWORD *v26; // $fp
  int v27; // $s7
  int v28; // $t0
  int v29; // $a3
  int v30; // $a2
  int v31; // $a1
  int v32; // $a1
  int v33; // $a2
  int v34; // $a0
  const char *v35; // $v0
  const char *v36; // $v0
  char s[1024]; // [sp+30h] [-420h] BYREF
  char *v38; // [sp+430h] [-20h]
  char *v39; // [sp+434h] [-1Ch]
  char *v40; // [sp+438h] [-18h]
  char *v41; // [sp+43Ch] [-14h]
  char *v42; // [sp+440h] [-10h]
  char *v43; // [sp+444h] [-Ch]
  char *v44; // [sp+448h] [-8h]
  char *v45; // [sp+44Ch] [-4h]

  v2 = httpd_get_parm(a1, "name");
  v3 = httpd_get_parm(a1, "old_name");
  v38 = httpd_get_parm(a1, "en");
  v39 = httpd_get_parm(a1, (char *)&off_647174);
  v40 = httpd_get_parm(a1, "inip");
  v41 = httpd_get_parm(a1, "fport");
  v42 = httpd_get_parm(a1, "inport");
  v43 = httpd_get_parm(a1, "prot");
  v44 = httpd_get_parm(a1, "wans");
  v4 = httpd_get_json_parm(a1, (int)"del_list");
  v5 = httpd_get_parm(a1, "opt");
  _mem_malloc(0x200000, "nat_base2_asp", 186);
  v8 = v7;
  _mem_malloc(0x200000, "nat_base2_asp", 187);
  v9 = v6;
  if ( v8 )
  {
    if ( !v6 )
    {
      v32 = *(unsigned __int8 *)(a1 + 210102);
      v33 = 0x200000;
      v34 = 4;
      goto LABEL_56;
    }
    if ( !v5 )
      goto LABEL_62;
    if ( !strcmp(v5, (const char *)&off_64712C) )
    {
      v11 = httpd_get_parm(a1, "nf_loopback");
      v12 = httpd_get_parm(a1, "nf_dxtong");
      v38 = httpd_get_parm(a1, "nf_fullcone");
      if ( v11 )
      {
        v14 = (const char *)nvram_get("nf_loopback");
        if ( !v14 || strcmp(v14, v11) )
          nvram_set("nf_loopback", v11);
      }
      if ( v12 )
      {
        v15 = (const char *)nvram_get("nf_dxtong");
        if ( !v15 || strcmp(v15, v12) )
          nvram_set("nf_dxtong", v12);
      }
      if ( v38 )
      {
        v16 = (const char *)nvram_get("nf_fullcone");
        if ( !v16 || strcmp(v16, v38) )
          nvram_set("nf_fullcone", v38);
      }
      jhl_parm_commit(v13);
      jhl_start_firewall();
      v17 = s;
      v18 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v19 = *(_DWORD *)v18;
        v20 = *((_DWORD *)v18 + 1);
        v21 = *((_DWORD *)v18 + 2);
        v22 = *((_DWORD *)v18 + 3);
        v18 += 16;
        *(_DWORD *)v17 = v19;
        *((_DWORD *)v17 + 1) = v20;
        *((_DWORD *)v17 + 2) = v21;
        *((_DWORD *)v17 + 3) = v22;
        v17 += 16;
      }
      while ( v18 != "}" );
      goto LABEL_25;
    }
    if ( !strcmp(v5, (const char *)&off_646D8C) || !strcmp(v5, (const char *)&off_648DDC) )
    {
      if ( !strcmp(v5, "delall") )
        goto LABEL_9;
      if ( strcmp(v5, "del") )
        goto LABEL_32;
    }
    else
    {
      if ( strcmp(v5, "del") )
      {
        if ( !strcmp(v5, "delall") )
        {
LABEL_9:
          *(_BYTE *)v9 = 32;
          *(_BYTE *)(v9 + 1) = 0;
          v45 = "a";
          goto LABEL_10;
        }
LABEL_62:
        v32 = *(unsigned __int8 *)(a1 + 210102);
        v33 = (int)"not opt";
        v34 = 12;
        goto LABEL_56;
      }
      if ( !strcmp(v5, "delall") )
        goto LABEL_9;
    }
    if ( v4 && cJSON_IsArray(v4) )
    {
      v26 = *(_DWORD **)(v4 + 8);
      if ( !v26 )
        goto LABEL_52;
      v27 = 0;
      if ( !v26[4] )
        goto LABEL_52;
      v45 = "a";
      v38 = "portforward";
      do
      {
        jhl_parm_get("portforward", v8, 0x200000);
        if ( nvparm_del_str(v8, 62, 10, v26[4], 60, 6, v9) )
        {
          jhl_parm_set(v38, v9);
          v27 = 1;
        }
        v26 = (_DWORD *)*v26;
      }
      while ( v26 && v26[4] );
      if ( !v27 )
        goto LABEL_52;
      goto LABEL_10;
    }
LABEL_32:
    if ( v2 )
    {
      if ( strcmp(v5, (const char *)&off_646D8C) && strcmp(v5, (const char *)&off_648DDC) )
        goto LABEL_52;
      v45 = "a";
      jhl_parm_get("portforward", v8, 0x200000);
      if ( v3 )
        v25 = v3;
      else
        v25 = v2;
      if ( nvparm_del_str(v8, 62, 10, v25, 60, 6, v9) )
      {
        if ( !strcmp(v5, (const char *)&off_646D8C) )
        {
          v23 = check_rule_num_limit(a1, 27, (int)(v45 + 7376), 62, s, 0x400u);
          if ( v23 > 0 )
            goto LABEL_26;
          sprintf(v8, "%s<%s<%s<%s<%s<%s<%s<%s>", v38, v43, v39, v41, v42, v40, v2, v44);
        }
        else
        {
          sprintf(v8, "%s<%s<%s<%s<%s<%s<%s<%s>", v38, v43, v39, v41, v42, v40, v2, v44);
        }
      }
      else
      {
        if ( !strcmp(v5, (const char *)&off_646D8C) )
        {
          v23 = check_rule_num_limit(a1, 27, (int)(v45 + 7376), 62, s, 0x400u);
          if ( v23 > 0 )
            goto LABEL_26;
          sprintf(v8, "%s<%s<%s<%s<%s<%s<%s<%s>", v38, v43, v39, v41, v42, v40, v2, v44);
        }
        else
        {
          sprintf(v8, "%s<%s<%s<%s<%s<%s<%s<%s>", v38, v43, v39, v41, v42, v40, v2, v44);
        }
        jhl_parm_get(v45 + 7376, v9, 0x200000);
        if ( !strcmp((const char *)v9, " ") )
          *(_BYTE *)v9 = 0;
      }
      strcat((char *)v9, v8);
LABEL_10:
      jhl_parm_set(v45 + 7376, v9);
      jhl_parm_commit(v10);
      jhl_start_firewall();
LABEL_52:
      v17 = s;
      v18 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v28 = *(_DWORD *)v18;
        v29 = *((_DWORD *)v18 + 1);
        v30 = *((_DWORD *)v18 + 2);
        v31 = *((_DWORD *)v18 + 3);
        v18 += 16;
        *(_DWORD *)v17 = v28;
        *((_DWORD *)v17 + 1) = v29;
        *((_DWORD *)v17 + 2) = v30;
        *((_DWORD *)v17 + 3) = v31;
        v17 += 16;
      }
      while ( v18 != "}" );
LABEL_25:
      v23 = 33;
      *(_WORD *)v17 = *(_WORD *)v18;
LABEL_26:
      _mem_free(v8);
      goto LABEL_27;
    }
    v32 = *(unsigned __int8 *)(a1 + 210102);
    v33 = (int)&unk_6442E4;
    v34 = 12;
LABEL_56:
    v35 = (const char *)_GET_LANG_TEXT(v34, v32, v33);
    v23 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v35);
    if ( (unsigned int)v23 >= 0x400 )
      v23 = 1023;
    goto LABEL_26;
  }
  v36 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v23 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v36);
  if ( (unsigned int)v23 >= 0x400 )
    v23 = 1023;
LABEL_27:
  if ( v9 )
    _mem_free((void *)v9);
  return httpd_cgi_ret(a1, s, v23, 4);
}
// 4A42AC: variable 'v7' is possibly undefined
// 4A42B8: variable 'v6' is possibly undefined
// 4A43A8: variable 'v10' is possibly undefined
// 4A4534: variable 'v13' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 647174: using guessed type void *off_647174;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004A4BA4) --------------------------------------------------------
int __fastcall sub_4A4BA4(int a1)
{
  int v2; // $s6
  void *v3; // $v0
  void *v4; // $s3
  void *v5; // $v0
  void *v6; // $s1
  char *v7; // $v0
  char *v8; // $v0
  char *v9; // $s4
  char *v10; // $v0
  char *v11; // $s7
  char *v12; // $s0
  char *v13; // $v0
  int v14; // $a0
  int v15; // $v1
  _BOOL4 v16; // $a2
  char *v17; // $s0
  int v18; // $s6
  int v19; // $s7
  int v20; // $v0
  char *v21; // $v0
  int v22; // $a0
  const char *v23; // $s0
  int v24; // $a1
  const char *v25; // $v0
  unsigned int v26; // $v0
  const char *v28; // $v0
  char v29[5120]; // [sp+20h] [-2440h] BYREF
  char v30[4096]; // [sp+1420h] [-1040h] BYREF
  char v31[24]; // [sp+2420h] [-40h] BYREF
  int v32; // [sp+2438h] [-28h]
  char *src; // [sp+2448h] [-18h]
  int v34; // [sp+244Ch] [-14h]
  int v35; // [sp+2450h] [-10h]
  int v36; // [sp+2454h] [-Ch]
  char *format; // [sp+2458h] [-8h]
  char *v38; // [sp+245Ch] [-4h]

  v34 = get_rule_num_limit(27);
  v2 = *(_DWORD *)(a1 + 205364);
  _mem_malloc(0x200000, "nat_base_cgi", 361);
  v4 = v3;
  _mem_malloc(0x100000, "nat_base_cgi", 362);
  v6 = v5;
  _mem_malloc(0x200000, "nat_base_cgi", 363);
  v9 = v8;
  _mem_malloc(0x200000, "nat_base_cgi", 364);
  src = v7;
  if ( !v4 )
  {
    v23 = "mem_malloc failed";
    goto LABEL_23;
  }
  if ( !v6 || !v9 || !v7 )
  {
    v23 = "mem_malloc failed";
LABEL_33:
    _mem_free(v4);
    goto LABEL_23;
  }
  find_file_head(a1, *(const char **)(a1 + 205564));
  v11 = v10;
  if ( !v10 || (v12 = find_file_end(a1, v10, *(_DWORD *)(a1 + 205564) + v2 - (_DWORD)v10)) == 0 )
  {
    v23 = "Error reading file";
    goto LABEL_33;
  }
  v38 = "a";
  *v12 = 0;
  jhl_parm_get("portforward", v9, 0x200000);
  if ( v12 - v11 <= 0 )
  {
    v14 = 0;
  }
  else
  {
    v13 = v11;
    v14 = 0;
    do
    {
      v15 = *v13++;
      v16 = v14 + 1 < 0x1FFFFF;
      if ( v15 != 13 && v15 != 10 )
      {
        *((_BYTE *)v4 + v14++) = v15;
        if ( !v16 )
          break;
      }
    }
    while ( v12 != v13 );
  }
  v17 = v30;
  *((_BYTE *)v4 + v14) = 0;
  v18 = split_string(v4, 62, v30, 1024);
  if ( v18 > 0 )
  {
    v36 = 0;
    v35 = 0;
    v19 = 0;
    format = "%s>";
    do
    {
      memset(v6, 0, 0x100000u);
      strlcpy(v6, *(_DWORD *)v17, 0x100000);
      ++v19;
      if ( split_string(*(_DWORD *)v17, 60, v31, 8) >= 7 && !nvparm_find_str_too_loog(v9, 62, 9, v32, 60, 6) )
      {
        ++v36;
        v20 = sprintf(&src[v35], format, v6);
        v35 += v20;
        if ( v36 >= v34 )
          break;
      }
      v17 += 4;
    }
    while ( v18 != v19 );
  }
  if ( *v9 )
  {
    v21 = &v9[strlen(v9)];
    if ( *(v21 - 1) != 62 )
      *(_WORD *)v21 = 62;
  }
  strcat(v9, src);
  jhl_parm_set(v38 + 7376, v9);
  v23 = 0;
  jhl_parm_commit(v22);
  jhl_start_firewall();
  _mem_free(v4);
LABEL_23:
  if ( v9 )
    _mem_free(v9);
  if ( v6 )
    _mem_free(v6);
  if ( src )
    _mem_free(src);
  v24 = *(unsigned __int8 *)(a1 + 210102);
  if ( !v23 )
  {
    v28 = (const char *)_GET_LANG_TEXT(34, v24, 0);
    v26 = snprintf(v29, 5120, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v28);
    if ( v26 < 0x1400 )
      return httpd_cgi_ret(a1, v29, v26, 4);
LABEL_35:
    v26 = 5119;
    return httpd_cgi_ret(a1, v29, v26, 4);
  }
  v25 = (const char *)_GET_LANG_TEXT(33, v24, v23);
  v26 = snprintf(v29, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v25);
  if ( v26 >= 0x1400 )
    goto LABEL_35;
  return httpd_cgi_ret(a1, v29, v26, 4);
}
// 4A4C34: variable 'v3' is possibly undefined
// 4A4C50: variable 'v5' is possibly undefined
// 4A4C6C: variable 'v8' is possibly undefined
// 4A4C70: variable 'v7' is possibly undefined
// 4A4CB0: variable 'v10' is possibly undefined
// 4A4EF8: variable 'v22' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A865C: using guessed type int __fastcall nvparm_find_str_too_loog(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A50C0) --------------------------------------------------------
int __fastcall sub_4A50C0(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "nat_base_txt", 465);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("portforward");
    if ( !v3 )
      v3 = " ";
    v5 = sprintf(v4, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 4A5100: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004A5210) --------------------------------------------------------
int __fastcall sub_4A5210(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $s1
  int v5; // $s1
  int v6; // $s1
  int v7; // $v0
  int v8; // $a2
  int result; // $v0
  const char *v10; // $v0
  unsigned int v11; // $v0
  char v12[256]; // [sp+20h] [-11Ch] BYREF
  const char *v13[7]; // [sp+120h] [-1Ch] BYREF

  v13[0] = "dmz_enable";
  v13[1] = "dmz_ipaddr";
  v13[2] = "dmz_sip";
  v13[3] = "dmz_wan";
  v13[4] = "";
  v13[5] = "";
  _mem_malloc(10240, "dmz_data", 491);
  if ( v2 )
  {
    v3 = v2;
    asp_lipp(v12);
    strcpy(v3, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v3, "{\"code\":0,\"error\":\"\"", 20);
    v4 = get_nvarms(v13, (int)(v3 + 29), 10211) + 29;
    v5 = v4 + sprintf(&v3[v4], "\"lipp\":\"%s\",\"wans\":", v12);
    v6 = v5 + get_wans_data(&v3[v5], 10240 - v5);
    v7 = snprintf(&v3[v6], 10240 - v6, "}}");
    if ( v7 >= 10240 - v6 )
      v8 = 10239 - v6;
    else
      v8 = v7;
    result = httpd_cgi_ret(a1, v3, v8 + v6, 8);
  }
  else
  {
    v10 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v11 = snprintf(v12, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
    if ( v11 >= 0x100 )
      v11 = 255;
    result = httpd_cgi_ret(a1, v12, v11, 4);
  }
  return result;
}
// 4A5298: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004A5478) --------------------------------------------------------
int __fastcall format_upnp_state_data(int a1, int a2)
{
  FILE *v4; // $s3
  int i; // $s1
  int v6; // $s7
  char *v7; // $v0
  char *v8; // $v0
  int v9; // $v0
  char v11[1028]; // [sp+18h] [-404h] BYREF

  v4 = fopen("/var/spool/upnp.js", "r");
  if ( v4 )
  {
    for ( i = 0; ; i += v9 )
    {
      v6 = a2 - i;
      if ( !fgets(v11, 1024, v4) )
        break;
      printf("%s", v11);
      v7 = strchr(v11, 13);
      if ( v7 )
        *v7 = 0;
      v8 = strchr(v11, 10);
      if ( v8 )
        *v8 = 0;
      v9 = snprintf((char *)(a1 + i), a2 - i, "%s", v11);
      if ( v9 >= v6 )
        v9 = v6 - 1;
    }
    fclose(v4);
  }
  else
  {
    i = 0;
  }
  unlink("/var/spool/upnp.js");
  return i;
}

//----- (004A55FC) --------------------------------------------------------
int __fastcall upnp_data_send(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  int v5; // $s1
  char *v6; // $v1
  int v7; // $s1
  int v8; // $v0
  int v9; // $a2
  int result; // $v0
  const char *v11; // $v0
  unsigned int v12; // $v0
  char v13[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(1024000, "upnp_data_send", 546);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{\"upnnp_data\":[");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    v4 = format_upnp_state_data(v2 + 42, 1023958);
    v5 = v4 + 42;
    v6 = &v3[v4 + 42];
    if ( v4 + 42 > 0 && *(v6 - 1) == 44 )
    {
      v5 = v4 + 41;
      v6 = &v3[v4 + 41];
    }
    v7 = v5 + 1;
    *(_WORD *)v6 = 93;
    v8 = snprintf(&v3[v7], 1024000 - v7, "}}");
    if ( v8 >= 1024000 - v7 )
      v9 = 1023999 - v7;
    else
      v9 = v8;
    result = httpd_cgi_ret(a1, v3, v9 + v7, 8);
  }
  else
  {
    v11 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v12 = snprintf(v13, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
    if ( v12 >= 0x100 )
      v12 = 255;
    result = httpd_cgi_ret(a1, v13, v12, 4);
  }
  return result;
}
// 4A5650: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004A584C) --------------------------------------------------------
int __fastcall upnp_data_timeout(_DWORD *a1)
{
  _DWORD *v1; // $s1
  int result; // $v0

  v1 = a1 + 49152;
  if ( (int)a1[51393] >= 5 || f_exists("/var/spool/upnp.js") )
  {
    a1[51388] = httpd_keep_alive_timeout;
    a1[51387] = jiffies_get() + 5000;
    add_timer(a1 + 51385);
    result = upnp_data_send((int)a1);
  }
  else
  {
    ++v1[2241];
    v1[2235] = jiffies_get() + 1000;
    v1[2237] = a1;
    v1[2236] = upnp_data_timeout;
    result = add_timer(a1 + 51385);
  }
  return result;
}
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (004A5958) --------------------------------------------------------
int __fastcall sub_4A5958(_DWORD *a1)
{
  const char *v2; // $v0
  int result; // $v0

  unlink("/var/spool/upnp.js");
  v2 = (const char *)nvram_get("upnp_enable");
  if ( v2 && !strcmp(v2, "1") && !killall("upnp", 17) )
  {
    a1[51393] = 0;
    upnp_data_timeout(a1);
    result = 0;
  }
  else
  {
    upnp_data_send((int)a1);
    result = 0;
  }
  return result;
}
// 6A8178: using guessed type int __fastcall killall(_DWORD, _DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (004A5A3C) --------------------------------------------------------
void __fastcall format_upnp_list_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 4 )
    snprintf(a3, a4, "{\"en\":%s,\"name\":\"%s\",\"inip\":\"%s\",\"wan\":%s},", *a1, a1[1], a1[2], a1[3]);
}

//----- (004A5ACC) --------------------------------------------------------
int __fastcall sub_4A5ACC(int a1)
{
  char *v1; // $v0
  char *v2; // $fp
  int v3; // $v0
  char *v4; // $a2
  int v5; // $s1
  char *v6; // $a1
  int v7; // $s1
  int v8; // $s2
  char *v9; // $s4
  int v10; // $s5
  int v11; // $s0
  const char **v12; // $s3
  void *v13; // $v0
  _DWORD *v14; // $s6
  int v15; // $a1
  void *v16; // $s5
  int v17; // $s5
  int i; // $s7
  int v19; // $v0
  int v20; // $v0
  char *v21; // $a0
  int v22; // $s2
  int v23; // $v0
  int v24; // $s1
  char *v25; // $a0
  int v26; // $v0
  int v27; // $a2
  int result; // $v0
  const char *v29; // $v0
  unsigned int v30; // $v0
  char v31[256]; // [sp+20h] [-120h] BYREF
  const char *v32[6]; // [sp+120h] [-20h] BYREF
  _DWORD *v33; // [sp+138h] [-8h]
  void *ptr; // [sp+13Ch] [-4h]

  v32[0] = "upnp_enable";
  v32[1] = "upnp_mnp";
  v32[2] = "upnp_waniface";
  v32[3] = "";
  v32[4] = "";
  _mem_malloc(1024000, "upnp_data", 645);
  v2 = v1;
  if ( v1 )
  {
    strcpy(v1, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v1, "{\"code\":0,\"error\":\"\"", 20);
    v3 = get_nvarms(v32, (int)(v1 + 29), 1023971);
    v4 = &v2[v3 + 29];
    strcpy(v4, "\"wans\":");
    strcpy(v4, "\"wans\":");
    v5 = v3 + 36 + get_wans_data(&v2[v3 + 36], 1024000 - (v3 + 36));
    v6 = &v2[v5];
    strcpy(&v2[v5], ",\"upnp_list\":");
    *(_DWORD *)v6 = 1886724652;
    *((_DWORD *)v6 + 1) = 1818194030;
    v7 = v5 + 13;
    v8 = 1024000 - v7;
    v9 = &v2[v7];
    v10 = nvram_get("upnp_list");
    v11 = snprintf(&v2[v7], 1024000 - v7, (char *)&word_642A04);
    if ( v11 >= 1024000 - v7 )
      v11 = 1023999 - v7;
    if ( v10 )
    {
      v12 = (const char **)malloc(0x18u);
      v33 = malloc(0x4008u);
      v14 = v33;
      v13 = malloc(0x200000u);
      ptr = v13;
      if ( v13 )
      {
        if ( v12 )
        {
          v15 = v10;
          if ( v14 )
          {
            v16 = v13;
            strlcpy(v13, v15, 0x200000);
            v17 = split_string(v16, 60, v14, 4096);
            if ( v17 > 0 )
            {
              for ( i = 0; i != v17; ++i )
              {
                v19 = split_string(*v14, 124, v12, 4);
                format_upnp_list_data(v12, v19, &v9[v11], v8 - v11);
                v11 += v20;
                ++v14;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v12 )
        free(v12);
      if ( v33 )
        free(v33);
    }
    v21 = &v9[v11];
    if ( v11 > 0 && *(v21 - 1) == 44 )
      v21 = &v9[--v11];
    v22 = v8 - v11;
    *v21 = 0;
    v23 = snprintf(v21, v22, &byte_6445A0);
    if ( v23 >= v22 )
      v23 = v22 - 1;
    v24 = v11 + v23 + v7;
    v25 = &v2[v24];
    if ( v24 > 0 && *(v25 - 1) == 44 )
      v25 = &v2[--v24];
    *v25 = 0;
    v26 = snprintf(v25, 1024000 - v24, "}}");
    if ( v26 >= 1024000 - v24 )
      v27 = 1023999 - v24;
    else
      v27 = v26;
    result = httpd_cgi_ret(a1, v2, v24 + v27, 8);
  }
  else
  {
    v29 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v30 = snprintf(v31, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v29);
    if ( v30 >= 0x100 )
      v30 = 255;
    result = httpd_cgi_ret(a1, v31, v30, 4);
  }
  return result;
}
// 4A5B64: variable 'v1' is possibly undefined
// 4A5DA8: variable 'v20' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A5F98) --------------------------------------------------------
int __fastcall sub_4A5F98(int a1)
{
  const char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $v1
  int v5; // $t1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  int result; // $v0
  char *v10; // $s1
  char *v11; // $v0
  char v12[512]; // [sp+18h] [-30Ch] BYREF
  char v13[256]; // [sp+218h] [-10Ch] BYREF
  int v14; // [sp+318h] [-Ch]

  v2 = (const char *)nvram_get("upnp_enable");
  if ( v2
    && !strcmp(v2, "1")
    && (v10 = httpd_get_parm(a1, "remove_ext_proto")) != 0
    && *v10
    && (v11 = httpd_get_parm(a1, "remove_ext_port")) != 0
    && *v11
    && (sprintf(v13, "%s %s\n", v10, v11), f_write_string("/var/spool/upnp.delete", v13, 0, 0), !killall("upnp", 17)) )
  {
    v14 = 0;
    *(_DWORD *)(a1 + 205572) = 0;
    upnp_ctrl_file_exists(a1);
    result = v14;
  }
  else
  {
    v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v4 = v12;
    do
    {
      v5 = *(_DWORD *)v3;
      v6 = *((_DWORD *)v3 + 1);
      v7 = *((_DWORD *)v3 + 2);
      v8 = *((_DWORD *)v3 + 3);
      v3 += 16;
      *(_DWORD *)v4 = v5;
      *((_DWORD *)v4 + 1) = v6;
      *((_DWORD *)v4 + 2) = v7;
      *((_DWORD *)v4 + 3) = v8;
      v4 += 16;
    }
    while ( v3 != "}" );
    *(_WORD *)v4 = *(_WORD *)v3;
    result = httpd_cgi_ret(a1, v12, 33, 4);
  }
  return result;
}
// 6A8178: using guessed type int __fastcall killall(_DWORD, _DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8940: using guessed type int __fastcall f_write_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A6154) --------------------------------------------------------
int __fastcall sub_4A6154(int a1)
{
  char *v2; // $s5
  char *v3; // $s7
  int v4; // $s6
  char *v5; // $s3
  char *v6; // $v0
  char *v7; // $v0
  char *v8; // $s2
  char *v9; // $s1
  int v10; // $v0
  int v11; // $a0
  char *v12; // $v1
  const char *v13; // $v0
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  int v18; // $s6
  char *v20; // $a3
  _DWORD *v21; // $fp
  int v22; // $s7
  int v23; // $a1
  int v24; // $a2
  int v25; // $a0
  const char *v26; // $v0
  const char *v27; // $v0
  char s[1024]; // [sp+28h] [-410h] BYREF
  char *v29; // [sp+428h] [-10h]
  char *v30; // [sp+42Ch] [-Ch]
  char *v31; // [sp+430h] [-8h]
  char *v32; // [sp+434h] [-4h]

  v2 = httpd_get_parm(a1, "name");
  v3 = httpd_get_parm(a1, "old_name");
  v29 = httpd_get_parm(a1, "en");
  v30 = httpd_get_parm(a1, "inip");
  v31 = httpd_get_parm(a1, "wan");
  v4 = httpd_get_json_parm(a1, (int)"del_list");
  v5 = httpd_get_parm(a1, "opt");
  _mem_malloc(0x200000, "upnp_asp", 755);
  v8 = v7;
  _mem_malloc(0x200000, "upnp_asp", 756);
  v9 = v6;
  if ( v8 )
  {
    if ( !v6 )
    {
      v23 = *(unsigned __int8 *)(a1 + 210102);
      v24 = 0x200000;
      v25 = 4;
      goto LABEL_46;
    }
    v10 = a1 + 196608;
    if ( !v5 )
    {
LABEL_45:
      v23 = *(unsigned __int8 *)(v10 + 13494);
      v24 = (int)"not opt";
      v25 = 12;
      goto LABEL_46;
    }
    if ( !strcmp(v5, (const char *)&off_646D8C) || !strcmp(v5, (const char *)&off_648DDC) )
    {
      if ( !strcmp(v5, "delall") )
        goto LABEL_8;
      if ( strcmp(v5, "del") )
        goto LABEL_19;
    }
    else
    {
      if ( strcmp(v5, "del") )
      {
        if ( !strcmp(v5, "delall") )
        {
LABEL_8:
          *v9 = 32;
          v9[1] = 0;
          v32 = "1\"";
LABEL_9:
          jhl_parm_set(v32 - 11988, v9);
          jhl_parm_commit(v11);
LABEL_10:
          v12 = s;
          v13 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          do
          {
            v14 = *(_DWORD *)v13;
            v15 = *((_DWORD *)v13 + 1);
            v16 = *((_DWORD *)v13 + 2);
            v17 = *((_DWORD *)v13 + 3);
            v13 += 16;
            *(_DWORD *)v12 = v14;
            *((_DWORD *)v12 + 1) = v15;
            *((_DWORD *)v12 + 2) = v16;
            *((_DWORD *)v12 + 3) = v17;
            v12 += 16;
          }
          while ( v13 != "}" );
          v18 = 33;
          *(_WORD *)v12 = *(_WORD *)v13;
          goto LABEL_13;
        }
        v10 = a1 + 196608;
        goto LABEL_45;
      }
      if ( !strcmp(v5, "delall") )
        goto LABEL_8;
    }
    if ( v4 && cJSON_IsArray(v4) )
    {
      v21 = *(_DWORD **)(v4 + 8);
      if ( !v21 || !v21[4] )
        goto LABEL_10;
      v22 = 0;
      v32 = "1\"";
      v29 = "upnp_list";
      do
      {
        jhl_parm_get("upnp_list", v8, 0x200000);
        if ( nvparm_del_str(v8, 60, 6, v21[4], 124, 1, v9) )
        {
          jhl_parm_set(v29, v9);
          v22 = 1;
        }
        v21 = (_DWORD *)*v21;
      }
      while ( v21 && v21[4] );
      if ( !v22 )
        goto LABEL_10;
      goto LABEL_9;
    }
LABEL_19:
    if ( v2 )
    {
      if ( strcmp(v5, (const char *)&off_646D8C) && strcmp(v5, (const char *)&off_648DDC) )
        goto LABEL_10;
      v32 = "1\"";
      jhl_parm_get("upnp_list", v8, 0x200000);
      if ( v3 )
        v20 = v3;
      else
        v20 = v2;
      if ( nvparm_del_str(v8, 60, 6, v20, 124, 1, v9) )
      {
        if ( strcmp(v5, (const char *)&off_646D8C) )
        {
          sprintf(v8, "%s|%s|%s|%s<", v29, v2, v30, v31);
LABEL_27:
          strcat(v9, v8);
          goto LABEL_9;
        }
        v18 = check_rule_num_limit(a1, 27, (int)(v32 - 11988), 60, s, 0x400u);
        if ( v18 <= 0 )
        {
          sprintf(v8, "%s|%s|%s|%s<", v29, v2, v30, v31);
          goto LABEL_27;
        }
LABEL_13:
        _mem_free(v8);
        goto LABEL_14;
      }
      if ( !strcmp(v5, (const char *)&off_646D8C) )
      {
        v18 = check_rule_num_limit(a1, 27, (int)(v32 - 11988), 60, s, 0x400u);
        if ( v18 > 0 )
          goto LABEL_13;
        sprintf(v8, "%s|%s|%s|%s<", v29, v2, v30, v31);
      }
      else
      {
        sprintf(v8, "%s|%s|%s|%s<", v29, v2, v30, v31);
      }
      jhl_parm_get(v32 - 11988, v9, 0x200000);
      if ( !strcmp(v9, " ") )
        *v9 = 0;
      goto LABEL_27;
    }
    v23 = *(unsigned __int8 *)(a1 + 210102);
    v24 = (int)&unk_6442E4;
    v25 = 12;
LABEL_46:
    v26 = (const char *)_GET_LANG_TEXT(v25, v23, v24);
    v18 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v26);
    if ( (unsigned int)v18 >= 0x400 )
      v18 = 1023;
    goto LABEL_13;
  }
  v27 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v18 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v27);
  if ( (unsigned int)v18 >= 0x400 )
    v18 = 1023;
LABEL_14:
  if ( v9 )
    _mem_free(v9);
  return httpd_cgi_ret(a1, s, v18, 4);
}
// 4A6284: variable 'v7' is possibly undefined
// 4A6290: variable 'v6' is possibly undefined
// 4A6360: variable 'v11' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (004A6904) --------------------------------------------------------
int __fastcall sub_4A6904(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s0
  int v5; // $s3
  int v6; // $v0
  int v7; // $a2
  int result; // $v0
  const char *v9; // $v0
  unsigned int v10; // $v0
  char v11[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(10240, "nat_trig_data", 872);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("trigforward");
    strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v4, "{\"code\":0,\"error\":\"\"", 20);
    v5 = sprintf(v4 + 29, "\"trigforward\":\"%s\"", v3) + 29;
    v6 = snprintf(&v4[v5], 10240 - v5, "}}");
    if ( v6 >= 10240 - v5 )
      v7 = 10239 - v5;
    else
      v7 = v6;
    result = httpd_cgi_ret(a1, v4, v7 + v5, 8);
  }
  else
  {
    v9 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v10 = snprintf(v11, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v10 >= 0x100 )
      v10 = 255;
    result = httpd_cgi_ret(a1, v11, v10, 4);
  }
  return result;
}
// 4A694C: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004A6AF4) --------------------------------------------------------
void __fastcall format_menu_nat_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 7 )
    snprintf(
      a3,
      a4,
      "{\"en\":%s,\"in_addr\":\"%s\",\"out_addr\":\"%s\",\"interface_id\":\"%s\",\"src\":\"%s\",\"out_port\":\"%s\",\"proto\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6]);
}

//----- (004A6B9C) --------------------------------------------------------
int __fastcall sub_4A6B9C(int a1)
{
  int v1; // $v0
  char *v2; // $fp
  int v3; // $v0
  char *v4; // $a0
  int v5; // $s3
  int v6; // $s1
  char *v7; // $s4
  int v8; // $s5
  int v9; // $s0
  const char **v10; // $s2
  void *v11; // $v0
  _DWORD *v12; // $s6
  int v13; // $a1
  void *v14; // $s5
  int v15; // $s5
  int i; // $s7
  int v17; // $v0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $s1
  int v21; // $v0
  int v22; // $s3
  int v23; // $v0
  int v24; // $a2
  int result; // $v0
  const char *v26; // $v0
  unsigned int v27; // $v0
  char v28[256]; // [sp+20h] [-108h] BYREF
  _DWORD *v29; // [sp+120h] [-8h]
  void *ptr; // [sp+124h] [-4h]

  _mem_malloc(102400, "menu_nat_data", 931);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{\"wans\":");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    strcpy((char *)(v1 + 32), "ns\":");
    v3 = get_wans_data((char *)(v1 + 36), 102364);
    v4 = &v2[v3 + 36];
    strcpy(v4, ",\"nat_list_onebyone\":");
    qmemcpy(v4, ",\"nat_list_oneby", 16);
    v5 = v3 + 57;
    v6 = 102400 - (v3 + 57);
    v7 = &v2[v3 + 57];
    v8 = nvram_get("nat_list_onebyone");
    v9 = snprintf(&v2[v5], 102400 - v5, (char *)&word_642A04);
    if ( v9 >= 102400 - v5 )
      v9 = 102399 - v5;
    if ( v8 )
    {
      v10 = (const char **)malloc(0x24u);
      v29 = malloc(0x4008u);
      v12 = v29;
      v11 = malloc(0x200000u);
      ptr = v11;
      if ( v11 )
      {
        if ( v10 )
        {
          v13 = v8;
          if ( v29 )
          {
            v14 = v11;
            strlcpy(v11, v13, 0x200000);
            v15 = split_string(v14, 60, v29, 4096);
            if ( v15 > 0 )
            {
              for ( i = 0; i != v15; ++i )
              {
                v17 = split_string(*v12, 124, v10, 7);
                format_menu_nat_data(v10, v17, &v7[v9], v6 - v9);
                v9 += v18;
                ++v12;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v10 )
        free(v10);
      if ( v29 )
        free(v29);
    }
    v19 = &v7[v9];
    if ( v9 > 0 && *(v19 - 1) == 44 )
      v19 = &v7[--v9];
    v20 = v6 - v9;
    *v19 = 0;
    v21 = snprintf(v19, v20, &byte_6445A0);
    if ( v21 >= v20 )
      v21 = v20 - 1;
    v22 = v9 + v21 + v5;
    v23 = snprintf(&v2[v22], 102400 - v22, "}}");
    if ( v23 >= 102400 - v22 )
      v24 = 102399 - v22;
    else
      v24 = v23;
    result = httpd_cgi_ret(a1, v2, v24 + v22, 8);
  }
  else
  {
    v26 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v27 = snprintf(v28, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v26);
    if ( v27 >= 0x100 )
      v27 = 255;
    result = httpd_cgi_ret(a1, v28, v27, 4);
  }
  return result;
}
// 4A6C00: variable 'v1' is possibly undefined
// 4A6E34: variable 'v18' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A7000) --------------------------------------------------------
int __fastcall jhl_nat_onebyone_add_iface(int a1, int a2)
{
  int v4; // $v0
  int v5; // $v0
  char *v6; // $s3
  int v7; // $v0
  char *v8; // $s1
  int v9; // $s2
  int v11; // $v0
  const char *v12; // $v0
  int v13; // $v0
  int v14; // $v0
  char v15[256]; // [sp+18h] [-124h] BYREF
  int v16[9]; // [sp+118h] [-24h] BYREF

  memset(v15, 0, sizeof(v15));
  v4 = jhl_nvget("wan_ifname", a1);
  v5 = nvram_get(v4);
  if ( v5 )
    v6 = (char *)v5;
  else
    v6 = "";
  v7 = jhl_nvget("wan_name", a1);
  v8 = (char *)nvram_get(v7);
  if ( !v8 )
    v8 = "";
  v9 = get_duolan_ip(0, 0, a2, 0);
  if ( v9 )
    return -1;
  if ( *v8 )
  {
    if ( *v6 )
    {
      v11 = jhl_nvget("wan_down", a1);
      v12 = (const char *)nvram_get(v11);
      if ( (!v12 || strcmp(v12, "1"))
        && !jhl_iface_link_up_check(v6, a1)
        && (jhl_get_wan_proto(a1) & 0xFFFFFFF7) != 0
        && jhl_check_wanup(a1) )
      {
        v13 = jhl_nvget("wan_netmask", a1);
        v9 = 0;
        v14 = jhl_nv_get_def(v13);
        ip_get_duolan(a2, v14, v15);
        v16[0] = (int)"ip";
        v16[1] = (int)"addr";
        v16[2] = (int)&off_646D8C;
        v16[3] = (int)v15;
        v16[4] = (int)"dev";
        v16[5] = (int)v8;
        v16[6] = 0;
        eval(v16, 0, 0, 0);
      }
    }
  }
  return v9;
}
// 646D8C: using guessed type char *off_646D8C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A8558: using guessed type int __fastcall get_duolan_ip(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A881C: using guessed type int __fastcall ip_get_duolan(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (004A72B0) --------------------------------------------------------
int __fastcall jhl_nat_onebyone_del_iface(int a1, const char *a2)
{
  int v4; // $v0
  int v5; // $v0
  char *v6; // $s4
  int v7; // $v0
  char *v8; // $s0
  int result; // $v0
  int v10; // $v0
  const char *v11; // $v0
  int v12; // $v0
  int v13; // $v0
  const char *v14; // $a1
  int v15; // $v0
  int v16; // $v0
  char v17[256]; // [sp+18h] [-120h] BYREF
  int v18[8]; // [sp+118h] [-20h] BYREF

  memset(v17, 0, sizeof(v17));
  v4 = jhl_nvget("wan_ifname", a1);
  v5 = nvram_get(v4);
  if ( v5 )
    v6 = (char *)v5;
  else
    v6 = "";
  v7 = jhl_nvget("wan_name", a1);
  v8 = (char *)nvram_get(v7);
  if ( !v8 )
    v8 = "";
  result = *v8;
  if ( *v8 )
  {
    result = *v6;
    if ( *v6 )
    {
      v10 = jhl_nvget("wan_down", a1);
      v11 = (const char *)nvram_get(v10);
      if ( !v11 || (result = strcmp(v11, "1")) != 0 )
      {
        result = jhl_iface_link_up_check(v6, a1);
        if ( !result )
        {
          result = jhl_get_wan_proto(a1) & 0xFFFFFFF7;
          if ( result )
          {
            result = jhl_check_wanup(a1);
            if ( result )
            {
              v12 = jhl_nvget("wan_ipaddr", a1);
              v13 = nvram_get(v12);
              if ( v13 )
                v14 = (const char *)v13;
              else
                v14 = "";
              result = strcmp(a2, v14);
              if ( result )
              {
                v15 = jhl_nvget("wan_netmask", a1);
                v16 = jhl_nv_get_def(v15);
                ip_get_duolan(a2, v16, v17);
                v18[0] = (int)"ip";
                v18[1] = (int)"addr";
                v18[2] = (int)"del";
                v18[3] = (int)v17;
                v18[4] = (int)"dev";
                v18[5] = (int)v8;
                v18[6] = 0;
                eval(v18, 0, 0, 0);
                result = start_qos_iface(a1, v6);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A881C: using guessed type int __fastcall ip_get_duolan(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A89B8: using guessed type int __fastcall start_qos_iface(_DWORD, _DWORD);

//----- (004A75A4) --------------------------------------------------------
int __fastcall sub_4A75A4(int a1)
{
  char *v2; // $fp
  char *v3; // $s7
  char *v4; // $s6
  char *v5; // $s3
  char *v6; // $v0
  void *v7; // $v0
  void *v8; // $s1
  char *v9; // $s2
  int v10; // $v0
  int v11; // $a1
  const char *v12; // $a2
  int v13; // $a0
  const char *v14; // $v0
  int v15; // $s5
  int v17; // $a0
  char *v18; // $v1
  const char *v19; // $v0
  int v20; // $t0
  int v21; // $a3
  int v22; // $a2
  int v23; // $a1
  _DWORD *v24; // $s3
  int v25; // $v0
  int v26; // $v0
  const char *v27; // $a3
  const char *v28; // $v0
  const char *v29; // $v1
  int v30; // $v0
  const char *v31; // $v0
  int v32; // $v0
  int v33; // $v0
  char s[256]; // [sp+30h] [-148h] BYREF
  char *v35; // [sp+130h] [-48h] BYREF
  char *v36; // [sp+134h] [-44h]
  char *v37; // [sp+138h] [-40h]
  char *v38; // [sp+13Ch] [-3Ch]
  char *v39; // [sp+140h] [-38h]
  char *v40; // [sp+144h] [-34h]
  char *v41; // [sp+148h] [-30h]
  char *v42; // [sp+158h] [-20h]
  char *v43; // [sp+15Ch] [-1Ch]
  char *v44; // [sp+160h] [-18h]
  char *v45; // [sp+164h] [-14h]
  char *v46; // [sp+168h] [-10h]
  int v47; // [sp+16Ch] [-Ch]
  char *v48; // [sp+170h] [-8h]
  int v49; // [sp+174h] [-4h]

  v2 = httpd_get_parm(a1, (char *)&off_647174);
  v47 = (int)httpd_get_parm(a1, "old_src");
  v46 = httpd_get_parm(a1, "en");
  v42 = httpd_get_parm(a1, "in_addr");
  v3 = httpd_get_parm(a1, "out_addr");
  v4 = httpd_get_parm(a1, "interface");
  v43 = httpd_get_parm(a1, "out_port");
  v44 = httpd_get_parm(a1, "proto");
  v45 = (char *)httpd_get_json_parm(a1, (int)"del_list");
  v5 = httpd_get_parm(a1, "opt");
  _mem_malloc(102400, "menu_nat_asp", 1058);
  v8 = v7;
  _mem_malloc(102400, "menu_nat_asp", 1059);
  v9 = v6;
  if ( v8 )
  {
    if ( !v6 )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = (const char *)102400;
      v13 = 4;
      goto LABEL_10;
    }
    v10 = a1 + 196608;
    if ( !v5 )
      goto LABEL_9;
    if ( !strcmp(v5, (const char *)&off_646D8C) || !strcmp(v5, (const char *)&off_648DDC) )
    {
      if ( !strcmp(v5, "delall") )
        goto LABEL_25;
      if ( strcmp(v5, "del") )
        goto LABEL_18;
    }
    else
    {
      if ( strcmp(v5, "del") )
      {
        if ( strcmp(v5, "delall") )
        {
          v10 = a1 + 196608;
LABEL_9:
          v11 = *(unsigned __int8 *)(v10 + 13494);
          v12 = "not opt";
          v13 = 12;
LABEL_10:
          v14 = (const char *)_GET_LANG_TEXT(v13, v11, v12);
          goto LABEL_11;
        }
        goto LABEL_25;
      }
      if ( !strcmp(v5, "delall") )
      {
LABEL_25:
        v45 = "1\"";
LABEL_26:
        jhl_parm_set(v45 - 11760, v9);
        jhl_parm_commit(v17);
        goto LABEL_27;
      }
    }
    if ( v45 && cJSON_IsArray(v45) )
    {
      v24 = (_DWORD *)*((_DWORD *)v45 + 2);
      if ( !v24 || !v24[4] )
        goto LABEL_27;
      v45 = "1\"";
      v47 = 0;
      v42 = "nat_list_onebyone";
      do
      {
        jhl_parm_get("nat_list_onebyone", v8, 102400);
        if ( nvparm_get_str(v8, 60, 9, v24[4], 124, 4, &v35) && !strcmp(v35, "1") )
        {
          v30 = J_atoi(v38);
          jhl_nat_onebyone_del_iface(v30, v37);
        }
        memset(v8, 0, 0x19000u);
        jhl_parm_get("nat_list_onebyone", v8, 102400);
        if ( nvparm_del_str(v8, 60, 9, v24[4], 124, 4, v9) )
        {
          jhl_parm_set(v42, v9);
          v47 = 1;
        }
        v24 = (_DWORD *)*v24;
      }
      while ( v24 && v24[4] );
LABEL_73:
      if ( v47 )
        goto LABEL_26;
LABEL_27:
      jhl_start_firewall();
      v18 = s;
      v19 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v20 = *(_DWORD *)v19;
        v21 = *((_DWORD *)v19 + 1);
        v22 = *((_DWORD *)v19 + 2);
        v23 = *((_DWORD *)v19 + 3);
        v19 += 16;
        *(_DWORD *)v18 = v20;
        *((_DWORD *)v18 + 1) = v21;
        *((_DWORD *)v18 + 2) = v22;
        *((_DWORD *)v18 + 3) = v23;
        v18 += 16;
      }
      while ( v19 != "}" );
      v15 = 33;
      *(_WORD *)v18 = *(_WORD *)v19;
      goto LABEL_30;
    }
LABEL_18:
    if ( !v2 )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = (const char *)&unk_6442E4;
      v13 = 12;
      goto LABEL_10;
    }
    v48 = "1\"";
    if ( !strcmp(v5, (const char *)&off_648DDC) )
    {
      v45 = "1\"";
      jhl_parm_get("nat_list_onebyone", v8, 102400);
      if ( v47 )
      {
        if ( nvparm_get_str(v8, 60, 9, v47, 124, 4, &v35) && !strcmp(v35, "1") )
        {
          v32 = J_atoi(v38);
          jhl_nat_onebyone_del_iface(v32, v37);
        }
        v49 = 102400;
        memset(v8, 0, 0x19000u);
        jhl_parm_get(v45 - 11760, v8, v49);
        v25 = nvparm_del_str(v8, 60, 9, v47, 124, 4, v9);
      }
      else
      {
        if ( nvparm_get_str(v8, 60, 9, v2, 124, 4, &v35) && !strcmp(v35, "1") )
        {
          v33 = J_atoi(v38);
          jhl_nat_onebyone_del_iface(v33, v37);
        }
        v47 = 102400;
        memset(v8, 0, 0x19000u);
        jhl_parm_get(v45 - 11760, v8, v47);
        v25 = nvparm_del_str(v8, 60, 9, v2, 124, 4, v9);
      }
      v47 = v25 != 0;
      if ( strcmp(v5, (const char *)&off_646D8C) )
      {
        if ( strcmp(v5, v48 - 29220) )
          goto LABEL_73;
LABEL_48:
        v39 = v2;
        if ( !v42 || !*v42 )
          v42 = "0.0.0.0";
        v36 = v42;
        if ( !v3 || !*v3 )
          v3 = "0.0.0.0";
        v37 = v3;
        if ( !v4 || !*v4 )
          v4 = "0";
        v38 = v4;
        if ( !v44 )
          v44 = "";
        if ( !v43 )
          v43 = "";
        v40 = v43;
        v41 = v44;
        if ( !strcmp(v46, "1") )
        {
          v26 = J_atoi(v4);
          if ( jhl_nat_onebyone_add_iface(v26, (int)v37) )
          {
            v14 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_64D23C);
LABEL_11:
            v15 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
            if ( (unsigned int)v15 >= 0x100 )
            {
              _mem_free(v8);
              v15 = 255;
              goto LABEL_13;
            }
            goto LABEL_30;
          }
          v27 = v36;
          v3 = v37;
          v4 = v38;
          v2 = v39;
          v28 = v40;
          v29 = v41;
        }
        else
        {
          v29 = v44;
          v28 = v43;
          v27 = v42;
          v46 = "0";
        }
        v35 = v46;
        sprintf((char *)v8, "%s|%s|%s|%s|%s|%s|%s<", v46, v27, v3, v4, v2, v28, v29);
        if ( !v47 )
        {
          jhl_parm_get(v45 - 11760, v9, 102400);
          if ( !strcmp(v9, " ") )
            *v9 = 0;
        }
        strcat(v9, (char *)v8);
        goto LABEL_26;
      }
    }
    else
    {
      if ( strcmp(v5, (const char *)&off_646D8C) )
        goto LABEL_27;
      v47 = 0;
      v45 = "1\"";
    }
    jhl_parm_get(v45 - 11760, v9, 102400);
    if ( nvparm_find_str(v9, 60, 9, v2, 124, 4) )
    {
      v11 = *(unsigned __int8 *)(a1 + 210102);
      v12 = "same name";
      v13 = 12;
      goto LABEL_10;
    }
    v15 = check_rule_num_limit(a1, 28, (int)(v45 - 11760), 60, s, 0x100u);
    if ( v15 > 0 )
    {
LABEL_30:
      _mem_free(v8);
      goto LABEL_13;
    }
    goto LABEL_48;
  }
  v31 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v15 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
  if ( (unsigned int)v15 >= 0x100 )
    v15 = 255;
LABEL_13:
  if ( v9 )
    _mem_free(v9);
  return httpd_cgi_ret(a1, s, v15, 4);
}
// 4A772C: variable 'v7' is possibly undefined
// 4A7738: variable 'v6' is possibly undefined
// 4A79F4: variable 'v17' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 647174: using guessed type void *off_647174;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86B0: using guessed type int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004A81C4) --------------------------------------------------------
void __fastcall format_portward_nat_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 9 )
    snprintf(
      a3,
      a4,
      "{\"en\":%s,\"proto\":\"%s\",\"src\":\"%s\",\"out_port\":\"%s\",\"in_port\":\"%s\",\"in_addr\":\"%s\",\"name\":\"%s"
      "\",\"interface\":\"%s\",\"convert_addr\":\"%s\"}",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7],
      a1[8]);
}

//----- (004A827C) --------------------------------------------------------
int __fastcall sub_4A827C(int a1)
{
  int v1; // $v0
  char *v2; // $fp
  int v3; // $v0
  char *v4; // $a0
  int v5; // $s3
  int v6; // $s1
  char *v7; // $s4
  int v8; // $s5
  int v9; // $s0
  const char **v10; // $s2
  void *v11; // $v0
  _DWORD *v12; // $s6
  int v13; // $a1
  void *v14; // $s5
  int v15; // $s5
  int i; // $s7
  int v17; // $v0
  int v18; // $v0
  char *v19; // $a0
  int v20; // $s1
  int v21; // $v0
  int v22; // $s0
  const char *v23; // $s1
  int v24; // $s3
  const char *v25; // $v0
  const char *v26; // $s0
  int v27; // $s3
  int v28; // $v0
  int v29; // $a2
  int result; // $v0
  const char *v31; // $v0
  unsigned int v32; // $v0
  char v33[256]; // [sp+20h] [-108h] BYREF
  _DWORD *v34; // [sp+120h] [-8h]
  void *ptr; // [sp+124h] [-4h]

  _mem_malloc(102400, "portward_nat_data", 1306);
  v2 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{\"wans\":");
    qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v1 + 24) = 975331700;
    strcpy((char *)(v1 + 32), "ns\":");
    v3 = get_wans_data((char *)(v1 + 36), 102364);
    v4 = &v2[v3 + 36];
    strcpy(v4, ",\"portward_nat_list\":");
    qmemcpy(v4, ",\"portward_nat_l", 16);
    v5 = v3 + 57;
    v6 = 102400 - (v3 + 57);
    v7 = &v2[v3 + 57];
    v8 = nvram_get("portward_nat_list");
    v9 = snprintf(&v2[v5], 102400 - v5, (char *)&word_642A04);
    if ( v9 >= 102400 - v5 )
      v9 = 102399 - v5;
    if ( v8 )
    {
      v10 = (const char **)malloc(0x2Cu);
      v34 = malloc(0x4008u);
      v12 = v34;
      v11 = malloc(0x200000u);
      ptr = v11;
      if ( v11 )
      {
        if ( v10 )
        {
          v13 = v8;
          if ( v34 )
          {
            v14 = v11;
            strlcpy(v11, v13, 0x200000);
            v15 = split_string(v14, 60, v34, 4096);
            if ( v15 > 0 )
            {
              for ( i = 0; i != v15; ++i )
              {
                v17 = split_string(*v12, 124, v10, 9);
                format_portward_nat_data(v10, v17, &v7[v9], v6 - v9);
                v9 += v18;
                ++v12;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v10 )
        free(v10);
      if ( v34 )
        free(v34);
    }
    v19 = &v7[v9];
    if ( v9 > 0 && *(v19 - 1) == 44 )
      v19 = &v7[--v9];
    v20 = v6 - v9;
    *v19 = 0;
    v21 = snprintf(v19, v20, &byte_6445A0);
    if ( v21 >= v20 )
      v21 = v20 - 1;
    v22 = v9 + v21;
    v23 = (const char *)jhl_nv_get_def("nf_loopback");
    v24 = v22 + v5;
    v26 = (const char *)jhl_nv_get_def("nf_dxtong");
    v25 = (const char *)jhl_nv_get_def("nf_fullcone");
    v27 = v24
        + sprintf(
            &v2[v24],
            ",\"mode\":\"%s\",\"nf_dxtong\":\"%s\",\"nf_fullcone\":\"%s\",\"fullcone_show\":%d",
            v23,
            v26,
            v25,
            1);
    v28 = snprintf(&v2[v27], 102400 - v27, "}}");
    if ( v28 >= 102400 - v27 )
      v29 = 102399 - v27;
    else
      v29 = v28;
    result = httpd_cgi_ret(a1, v2, v29 + v27, 8);
  }
  else
  {
    v31 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v32 = snprintf(v33, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
    if ( v32 >= 0x100 )
      v32 = 255;
    result = httpd_cgi_ret(a1, v33, v32, 4);
  }
  return result;
}
// 4A82E0: variable 'v1' is possibly undefined
// 4A8514: variable 'v18' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004A8758) --------------------------------------------------------
int __fastcall sub_4A8758(int a1)
{
  char *v2; // $s6
  char *v3; // $s4
  char *v4; // $v0
  const char *v5; // $s1
  const char *v6; // $v0
  unsigned int v7; // $s4
  _BYTE *v9; // $v0
  void *v10; // $v0
  void *v11; // $s2
  _BYTE *v12; // $s3
  _DWORD *v13; // $s1
  char *v14; // $s5
  char *v15; // $s3
  int v16; // $a0
  char *v17; // $s6
  int v18; // $v0
  const char *v19; // $v0
  char *v20; // $v1
  int v21; // $t0
  int v22; // $a3
  int v23; // $a2
  int v24; // $a1
  const char *v25; // $a1
  const char *v26; // $s7
  const char *v27; // $v1
  const char *v28; // $a3
  int v29; // $a0
  char *v30; // $v1
  const char *v31; // $v0
  int v32; // $t0
  int v33; // $a3
  int v34; // $a2
  int v35; // $a1
  int v36; // $v0
  int v37; // $a1
  int v38; // $a2
  int v39; // $a0
  const char *v40; // $v0
  int v41; // $v0
  const char *v42; // $v0
  int v43; // $v0
  const char *v44; // [sp+14h] [-17Ch]
  char v45[256]; // [sp+38h] [-158h] BYREF
  char *v46; // [sp+138h] [-58h] BYREF
  char *v47; // [sp+13Ch] [-54h]
  char *v48; // [sp+140h] [-50h]
  char *v49; // [sp+144h] [-4Ch]
  char *v50; // [sp+148h] [-48h]
  char *v51; // [sp+14Ch] [-44h]
  char *v52; // [sp+150h] [-40h]
  char *v53; // [sp+154h] [-3Ch]
  char *v54; // [sp+158h] [-38h]
  int v55; // [sp+168h] [-28h]
  char *v56; // [sp+16Ch] [-24h]
  char *v57; // [sp+170h] [-20h]
  char *v58; // [sp+174h] [-1Ch]
  char *v59; // [sp+178h] [-18h]
  char *v60; // [sp+17Ch] [-14h]
  char *v61; // [sp+180h] [-10h]
  char *v62; // [sp+184h] [-Ch]
  char *v63; // [sp+188h] [-8h]

  v61 = httpd_get_parm(a1, "en");
  v60 = httpd_get_parm(a1, "proto");
  v62 = httpd_get_parm(a1, (char *)&off_647174);
  v57 = httpd_get_parm(a1, "out_port");
  v58 = httpd_get_parm(a1, "in_port");
  v2 = httpd_get_parm(a1, "in_addr");
  v3 = httpd_get_parm(a1, "name");
  v56 = httpd_get_parm(a1, "interface");
  v59 = httpd_get_parm(a1, "convert_addr");
  v55 = httpd_get_json_parm(a1, (int)"del_list");
  v4 = httpd_get_parm(a1, "opt");
  if ( !v4 )
    goto LABEL_6;
  v5 = v4;
  if ( !strcmp(v4, (const char *)&off_646D8C) || !strcmp(v5, (const char *)&off_648DDC) || !strcmp(v5, "del") )
  {
    if ( !strcmp(v5, (const char *)&off_64712C) )
      goto LABEL_24;
    _mem_malloc(102400, "portward_nat_asp", 1423);
    v11 = v10;
    _mem_malloc(102400, "portward_nat_asp", 1424);
    v12 = v9;
    if ( !v11 )
    {
      v42 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
      v7 = snprintf(v45, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v42);
      if ( v7 >= 0x100 )
        v7 = 255;
      goto LABEL_64;
    }
    if ( v9 )
    {
      if ( !strcmp(v5, "del") && v55 && cJSON_IsArray(v55) )
      {
        v13 = *(_DWORD **)(v55 + 8);
        if ( !v13 || !v13[4] )
          goto LABEL_60;
        v63 = "1\"";
        v55 = 0;
        v56 = "portward_nat_list";
        do
        {
          jhl_parm_get("portward_nat_list", v11, 102400);
          if ( nvparm_get_str(v11, 60, 11, v13[4], 124, 6, &v46) )
          {
            if ( !strcmp(v46, "1") )
            {
              v41 = J_atoi(v53);
              if ( v54 )
              {
                if ( *v54 )
                  jhl_nat_onebyone_del_iface(v41, v54);
              }
            }
          }
          memset(v11, 0, 0x19000u);
          jhl_parm_get("portward_nat_list", v11, 102400);
          if ( nvparm_del_str(v11, 60, 11, v13[4], 124, 6, v12) )
          {
            jhl_parm_set(v56, v12);
            v55 = 1;
          }
          v13 = (_DWORD *)*v13;
        }
        while ( v13 && v13[4] );
LABEL_73:
        if ( !v55 )
        {
LABEL_60:
          jhl_start_firewall();
          v30 = v45;
          v31 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          do
          {
            v32 = *(_DWORD *)v31;
            v33 = *((_DWORD *)v31 + 1);
            v34 = *((_DWORD *)v31 + 2);
            v35 = *((_DWORD *)v31 + 3);
            v31 += 16;
            *(_DWORD *)v30 = v32;
            *((_DWORD *)v30 + 1) = v33;
            *((_DWORD *)v30 + 2) = v34;
            *((_DWORD *)v30 + 3) = v35;
            v30 += 16;
          }
          while ( v31 != "}" );
          v7 = 33;
          *(_WORD *)v30 = *(_WORD *)v31;
LABEL_63:
          _mem_free(v11);
LABEL_64:
          if ( v12 )
            _mem_free(v12);
          return httpd_cgi_ret(a1, v45, v7, 4);
        }
LABEL_59:
        jhl_parm_set(v63 - 11548, v12);
        jhl_parm_commit(v29);
        goto LABEL_60;
      }
      if ( v3 )
      {
        if ( !strcmp(v5, (const char *)&off_648DDC) )
        {
          v63 = "1\"";
          jhl_parm_get("portward_nat_list", v11, 102400);
          if ( nvparm_get_str(v11, 60, 11, v3, 124, 6, &v46) )
          {
            if ( !strcmp(v46, "1") )
            {
              v36 = J_atoi(v53);
              if ( v54 )
              {
                if ( *v54 )
                  jhl_nat_onebyone_del_iface(v36, v54);
              }
            }
          }
          v55 = 102400;
          memset(v11, 0, 0x19000u);
          jhl_parm_get(v63 - 11548, v11, v55);
          v55 = nvparm_del_str(v11, 60, 11, v3, 124, 6, v12) != 0;
          if ( strcmp(v5, (const char *)&off_646D8C) && strcmp(v5, (const char *)&off_648DDC) )
            goto LABEL_73;
        }
        else
        {
          if ( strcmp(v5, (const char *)&off_646D8C) )
            goto LABEL_60;
          v55 = 0;
        }
        v52 = v3;
        if ( v2 && *v2 )
        {
          v51 = v2;
          if ( !v59 || !*v59 )
            v59 = "";
          v54 = v59;
          if ( !v56 || !*v56 )
            v56 = "0";
          v53 = v56;
          if ( !v60 )
            v60 = "";
          v47 = v60;
          if ( !v57 || !*v57 )
            v57 = "";
          v49 = v57;
          if ( !v58 || !*v58 )
            v58 = "";
          v50 = v58;
          if ( v62 && *v62 )
            v48 = v62;
          else
            v48 = "";
          if ( !v61 || strcmp(v61, "1") )
          {
            v25 = v59;
            v26 = v56;
            v27 = v58;
            v28 = v60;
            v61 = "0";
            v44 = v57;
            goto LABEL_55;
          }
          v43 = J_atoi(v56);
          v25 = v54;
          if ( !v54 || !*v54 )
          {
            v28 = v47;
            v27 = v50;
            v2 = v51;
            v3 = v52;
            v26 = v53;
            v44 = v49;
            goto LABEL_55;
          }
          if ( !jhl_nat_onebyone_add_iface(v43, (int)v54) )
          {
            v28 = v47;
            v27 = v50;
            v2 = v51;
            v3 = v52;
            v26 = v53;
            v25 = v54;
            v44 = v49;
LABEL_55:
            v46 = v61;
            sprintf((char *)v11, "%s|%s|%s|%s|%s|%s|%s|%s|%s<", v61, v28, v48, v44, v27, v2, v3, v26, v25);
            if ( v55 )
            {
              strcat(v12, (char *)v11);
              v63 = "1\"";
            }
            else
            {
              v63 = "1\"";
              jhl_parm_get("portward_nat_list", v12, 102400);
              if ( !strcmp(v12, " ") )
                *v12 = 0;
              strcat(v12, (char *)v11);
            }
            goto LABEL_59;
          }
          v37 = *(unsigned __int8 *)(a1 + 210102);
          v38 = (int)&unk_64D350;
          v39 = 12;
        }
        else
        {
          v37 = *(unsigned __int8 *)(a1 + 210102);
          v38 = (int)&unk_64D344;
          v39 = 12;
        }
      }
      else
      {
        v37 = *(unsigned __int8 *)(a1 + 210102);
        v38 = (int)&unk_6442E4;
        v39 = 12;
      }
    }
    else
    {
      v37 = *(unsigned __int8 *)(a1 + 210102);
      v38 = 102400;
      v39 = 4;
    }
    v40 = (const char *)_GET_LANG_TEXT(v39, v37, v38);
    v7 = snprintf(v45, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v40);
    if ( v7 >= 0x100 )
      v7 = 255;
    goto LABEL_63;
  }
  if ( strcmp(v5, (const char *)&off_64712C) )
  {
LABEL_6:
    v6 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    v7 = snprintf(v45, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v6);
    if ( v7 >= 0x100 )
      v7 = 255;
    return httpd_cgi_ret(a1, v45, v7, 4);
  }
LABEL_24:
  v14 = httpd_get_parm(a1, "nf_loopback");
  v15 = httpd_get_parm(a1, "nf_dxtong");
  v17 = httpd_get_parm(a1, "nf_fullcone");
  if ( v14 )
  {
    nvram_set("nf_loopback", v14);
    v18 = 1;
  }
  else
  {
    v18 = 0;
  }
  if ( v15 )
  {
    nvram_set("nf_dxtong", v15);
    if ( !v17 )
    {
LABEL_29:
      jhl_parm_commit(v16);
      jhl_start_firewall();
      goto LABEL_30;
    }
LABEL_28:
    nvram_set("nf_fullcone", v17);
    goto LABEL_29;
  }
  if ( v17 )
    goto LABEL_28;
  if ( v18 )
    goto LABEL_29;
LABEL_30:
  v19 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v20 = v45;
  do
  {
    v21 = *(_DWORD *)v19;
    v22 = *((_DWORD *)v19 + 1);
    v23 = *((_DWORD *)v19 + 2);
    v24 = *((_DWORD *)v19 + 3);
    v19 += 16;
    *(_DWORD *)v20 = v21;
    *((_DWORD *)v20 + 1) = v22;
    *((_DWORD *)v20 + 2) = v23;
    *((_DWORD *)v20 + 3) = v24;
    v20 += 16;
  }
  while ( v19 != "}" );
  *(_WORD *)v20 = *(_WORD *)v19;
  return httpd_cgi_ret(a1, v45, 33, 4);
}
// 4A8A1C: variable 'v10' is possibly undefined
// 4A8A28: variable 'v9' is possibly undefined
// 4A8C98: variable 'v16' is possibly undefined
// 4A8FCC: variable 'v29' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 64712C: using guessed type char **off_64712C;
// 647174: using guessed type void *off_647174;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86B0: using guessed type int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004A94B0) --------------------------------------------------------
int __fastcall sub_4A94B0(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "nat_convert_cfg", 1595);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("nat_list_onebyone");
    if ( !v3 )
      v3 = "";
    v5 = snprintf(v4, 0x200000, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    if ( v5 >= 0x200000 )
      v5 = 0x1FFFFF;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 4A94F0: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004A9618) --------------------------------------------------------
int __fastcall sub_4A9618(int a1)
{
  _BYTE *v1; // $v0
  _BYTE *v2; // $s2
  char *v3; // $v0
  char *v4; // $v0
  char *v5; // $s1
  int v6; // $s4
  char *v7; // $v0
  char *v8; // $s2
  char *v9; // $v0
  char *v10; // $v1
  int v11; // $a1
  int v12; // $a0
  _BOOL4 v13; // $a3
  _BYTE *v14; // $v0
  char *v15; // $s3
  int v16; // $s4
  int v17; // $s5
  int v18; // $s0
  int v19; // $v0
  char *v20; // $s6
  int i; // $s7
  char *v22; // $v0
  _BOOL4 v23; // $a0
  char *v24; // $s0
  int v25; // $a0
  char *v26; // $v1
  const char *v27; // $v0
  int v28; // $t0
  int v29; // $a3
  int v30; // $a2
  int v31; // $a1
  int v32; // $a1
  const char *v33; // $v0
  unsigned int v34; // $v0
  int v36; // $a1
  const char *v37; // $a2
  int v38; // $a0
  const char *v39; // $v0
  char v40[2048]; // [sp+20h] [-B20h] BYREF
  char v41[4]; // [sp+820h] [-320h] BYREF
  int v42; // [sp+824h] [-31Ch]
  int v43; // [sp+828h] [-318h]
  int v44; // [sp+82Ch] [-314h]
  int v45; // [sp+830h] [-310h]
  char v46[256]; // [sp+A20h] [-120h] BYREF
  char *v47; // [sp+B20h] [-20h]
  _BYTE *v48; // [sp+B24h] [-1Ch]
  int v49; // [sp+B28h] [-18h]
  int v50; // [sp+B2Ch] [-14h]
  int v51; // [sp+B30h] [-10h]
  char *v52; // [sp+B34h] [-Ch]
  char *v53; // [sp+B38h] [-8h]

  v52 = "1\"";
  v51 = get_rule_num_limit(28);
  _mem_malloc(102400, "nat_convert_cgi", 1644);
  v48 = v1;
  v2 = v1;
  _mem_malloc(102400, "nat_convert_cgi", 1645);
  v5 = v4;
  _mem_malloc(102400, "nat_convert_cgi", 1646);
  v47 = v3;
  if ( !v2 || !v5 || !v3 )
  {
    v36 = *(unsigned __int8 *)(a1 + 210102);
    v37 = (const char *)102400;
    v38 = 4;
    goto LABEL_30;
  }
  v53 = "1\"";
  jhl_parm_get("nat_list_onebyone", v47, 102400);
  v6 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  v8 = v7;
  if ( !v7 || (v9 = find_file_end(a1, v7, *(_DWORD *)(a1 + 205564) + v6 - (_DWORD)v7)) == 0 )
  {
    v36 = *(unsigned __int8 *)(a1 + 210102);
    v37 = "Error reading file";
    v38 = 33;
LABEL_30:
    v39 = (const char *)_GET_LANG_TEXT(v38, v36, v37);
    goto LABEL_31;
  }
  *v9 = 0;
  if ( v9 - v8 <= 0 )
  {
    v11 = 0;
  }
  else
  {
    v10 = v8;
    v11 = 0;
    do
    {
      v12 = *v10++;
      v13 = v11 + 1 < 102399;
      if ( v12 != 13 && v12 != 10 )
      {
        v48[v11++] = v12;
        if ( !v13 )
          break;
      }
    }
    while ( v9 != v10 );
  }
  v14 = v48;
  v15 = v40;
  v48[v11] = 0;
  v49 = split_string(v14, 60, v40, 512);
  if ( v49 <= 0 )
  {
LABEL_25:
    v24 = v47;
    strcat(v47, v5);
    jhl_parm_set(v53 - 11760, v24);
    jhl_parm_commit(v25);
    jhl_start_firewall();
    v26 = v46;
    v27 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v28 = *(_DWORD *)v27;
      v29 = *((_DWORD *)v27 + 1);
      v30 = *((_DWORD *)v27 + 2);
      v31 = *((_DWORD *)v27 + 3);
      v27 += 16;
      *(_DWORD *)v26 = v28;
      *((_DWORD *)v26 + 1) = v29;
      *((_DWORD *)v26 + 2) = v30;
      *((_DWORD *)v26 + 3) = v31;
      v26 += 16;
    }
    while ( v27 != "}" );
    v32 = *(unsigned __int8 *)(a1 + 210102);
    *(_WORD *)v26 = *(_WORD *)v27;
    v33 = (const char *)_GET_LANG_TEXT(34, v32, v30);
    v34 = snprintf(v46, 256, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v33);
    if ( v34 >= 0x100 )
      goto LABEL_32;
    goto LABEL_28;
  }
  v50 = 0;
  v16 = 0;
  v17 = 0;
  while ( 1 )
  {
    v18 = split_string(*(_DWORD *)v15, 124, v41, 128);
    if ( v18 < 7 )
      goto LABEL_14;
    if ( nvparm_find_str(v47, 60, 9, v45, 124, 4) )
      break;
    if ( nvparm_find_str(v47, 60, 9, v42, 124, 1) )
    {
      v39 = (const char *)_GET_LANG_TEXT(84, *(unsigned __int8 *)(a1 + 210102), "in_addr");
      goto LABEL_31;
    }
    if ( nvparm_find_str(v47, 60, 9, v43, 124, 2) )
    {
      v39 = (const char *)_GET_LANG_TEXT(84, *(unsigned __int8 *)(a1 + 210102), "out_addr");
      goto LABEL_31;
    }
    if ( !v42 )
    {
      v36 = *(unsigned __int8 *)(a1 + 210102);
      v37 = (const char *)&unk_64D344;
      v38 = 12;
      goto LABEL_30;
    }
    if ( !v43 )
    {
      v36 = *(unsigned __int8 *)(a1 + 210102);
      v37 = (const char *)&unk_64D364;
      v38 = 12;
      goto LABEL_30;
    }
    v19 = J_atoi(v44);
    v20 = v41;
    if ( jhl_nat_onebyone_add_iface(v19, v43) )
    {
      v36 = *(unsigned __int8 *)(a1 + 210102);
      v37 = "error out_addr";
      v38 = 12;
      goto LABEL_30;
    }
    for ( i = 0; i != v18; ++i )
    {
      v17 += sprintf(&v5[v17], "%s|", *(const char **)v20);
      v20 += 4;
    }
    v22 = &v5[v17 - 1];
    v23 = ++v50 < v51;
    *v22 = 60;
    v22[1] = 0;
    if ( !v23 )
      goto LABEL_25;
LABEL_14:
    ++v16;
    v15 += 4;
    if ( v49 == v16 )
      goto LABEL_25;
  }
  v39 = (const char *)_GET_LANG_TEXT(84, *(unsigned __int8 *)(a1 + 210102), &off_647174);
LABEL_31:
  v34 = snprintf(v46, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v39);
  if ( v34 >= 0x100 )
LABEL_32:
    v34 = 255;
LABEL_28:
  v49 = v34;
  _mem_free(v48);
  _mem_free(v47);
  _mem_free(v5);
  return httpd_cgi_ret(a1, v46, v49, 4);
}
// 4A96A4: variable 'v1' is possibly undefined
// 4A96C8: variable 'v4' is possibly undefined
// 4A96CC: variable 'v3' is possibly undefined
// 4A9738: variable 'v7' is possibly undefined
// 4A99B8: variable 'v25' is possibly undefined
// 647174: using guessed type void *off_647174;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004A9CA0) --------------------------------------------------------
int __fastcall jhl_nat_more_add_iface(int a1, int a2)
{
  char *v4; // $s1
  char v6[256]; // [sp+18h] [-124h] BYREF
  int v7[9]; // [sp+118h] [-24h] BYREF

  memset(v6, 0, sizeof(v6));
  v4 = (char *)nvram_get("lan_ifname");
  if ( !v4 )
    v4 = "";
  ip_get_duolan(a1, a2, v6);
  v7[0] = (int)"ip";
  v7[3] = (int)v6;
  v7[1] = (int)"addr";
  v7[5] = (int)v4;
  v7[2] = (int)&off_646D8C;
  v7[4] = (int)"dev";
  v7[6] = 0;
  return eval(v7, 0, 0, 0);
}
// 646D8C: using guessed type char *off_646D8C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A881C: using guessed type int __fastcall ip_get_duolan(_DWORD, _DWORD, _DWORD);

//----- (004A9DA4) --------------------------------------------------------
int __fastcall jhl_nat_more_del_iface(int a1, int a2)
{
  char *v4; // $s1
  char v6[256]; // [sp+18h] [-124h] BYREF
  int v7[9]; // [sp+118h] [-24h] BYREF

  memset(v6, 0, sizeof(v6));
  v4 = (char *)nvram_get("lan_ifname");
  if ( !v4 )
    v4 = "";
  ip_get_duolan(a1, a2, v6);
  v7[0] = (int)"ip";
  v7[3] = (int)v6;
  v7[1] = (int)"addr";
  v7[5] = (int)v4;
  v7[2] = (int)"del";
  v7[4] = (int)"dev";
  v7[6] = 0;
  return eval(v7, 0, 0, 0);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A881C: using guessed type int __fastcall ip_get_duolan(_DWORD, _DWORD, _DWORD);

//----- (004A9EA8) --------------------------------------------------------
int __fastcall jhl_nat_more_add_wanip(int a1, int a2)
{
  int v4; // $v0
  int v5; // $v0
  char *v6; // $s2
  int v7; // $v0
  char *v8; // $s7
  int result; // $v0
  int v10; // $v0
  const char *v11; // $v0
  uint32_t v12; // $s2
  uint32_t v13; // $s6
  uint32_t v14; // $a0
  uint32_t v15; // $v0
  int v16; // $v0
  int v17; // $v0
  uint32_t netlong[64]; // [sp+18h] [-248h] BYREF
  char v19[256]; // [sp+118h] [-148h] BYREF
  char v20[32]; // [sp+218h] [-48h] BYREF
  int v21[8]; // [sp+238h] [-28h] BYREF
  char *v22; // [sp+258h] [-8h]
  char *v23; // [sp+25Ch] [-4h]

  memset(v19, 0, sizeof(v19));
  v4 = jhl_nvget("wan_ifname", a1);
  v5 = nvram_get(v4);
  if ( v5 )
    v6 = (char *)v5;
  else
    v6 = "";
  v7 = jhl_nvget("wan_name", a1);
  v8 = (char *)nvram_get(v7);
  if ( !v8 )
    v8 = "";
  result = *v8;
  if ( *v8 )
  {
    result = *v6;
    if ( *v6 )
    {
      v10 = jhl_nvget("wan_down", a1);
      v11 = (const char *)nvram_get(v10);
      if ( !v11 || (result = strcmp(v11, "1")) != 0 )
      {
        result = jhl_iface_link_up_check(v6, a1);
        if ( !result )
        {
          result = jhl_get_wan_proto(a1) & 0xFFFFFFF7;
          if ( result )
          {
            result = jhl_check_wanup(a1);
            if ( result )
            {
              memset(netlong, 0, sizeof(netlong));
              result = get_iplist_str(netlong, a2);
              if ( result )
              {
                v12 = ntohl(netlong[0]);
                v13 = ntohl(netlong[1]);
                result = v13 < v12;
                if ( v13 >= v12 )
                {
                  v22 = "a";
                  v23 = "a";
                  do
                  {
                    memset(v19, 0, sizeof(v19));
                    v14 = v12++;
                    v15 = htonl(v14);
                    IpToStr(v20, v15);
                    if ( !get_duolan_ip(0, 0, v20, 0) )
                    {
                      v16 = jhl_nvget(v22 + 6792, a1);
                      v17 = jhl_nv_get_def(v16);
                      ip_get_duolan(v20, v17, v19);
                      v21[0] = (int)"ip";
                      v21[1] = (int)"addr";
                      v21[2] = (int)&off_646D8C;
                      v21[3] = (int)v19;
                      v21[4] = (int)(v23 + 6704);
                      v21[5] = (int)v8;
                      v21[6] = 0;
                      eval(v21, 0, 0, 0);
                    }
                    result = v13 < v12;
                  }
                  while ( v13 >= v12 );
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 646D8C: using guessed type char *off_646D8C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A8558: using guessed type int __fastcall get_duolan_ip(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A881C: using guessed type int __fastcall ip_get_duolan(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8924: using guessed type int __fastcall get_iplist_str(_DWORD, _DWORD);

//----- (004AA244) --------------------------------------------------------
int __fastcall jhl_nat_more_del_wanip(int a1, int a2)
{
  int v4; // $v0
  int v5; // $v0
  char *v6; // $s2
  int v7; // $v0
  char *v8; // $s0
  int result; // $v0
  int v10; // $v0
  const char *v11; // $v0
  uint32_t v12; // $s2
  uint32_t v13; // $t0
  uint32_t v14; // $a0
  uint32_t v15; // $v0
  int v16; // $v0
  int v17; // $v0
  uint32_t netlong[64]; // [sp+18h] [-250h] BYREF
  char v19[256]; // [sp+118h] [-150h] BYREF
  char v20[32]; // [sp+218h] [-50h] BYREF
  int v21[8]; // [sp+238h] [-30h] BYREF
  unsigned int v22; // [sp+258h] [-10h]
  char *v23; // [sp+25Ch] [-Ch]
  const char *v24; // [sp+260h] [-8h]

  memset(v19, 0, sizeof(v19));
  v4 = jhl_nvget("wan_ifname", a1);
  v5 = nvram_get(v4);
  if ( v5 )
    v6 = (char *)v5;
  else
    v6 = "";
  v7 = jhl_nvget("wan_name", a1);
  v8 = (char *)nvram_get(v7);
  if ( !v8 )
    v8 = "";
  result = *v8;
  if ( *v8 )
  {
    result = *v6;
    if ( *v6 )
    {
      v10 = jhl_nvget("wan_down", a1);
      v11 = (const char *)nvram_get(v10);
      if ( !v11 || (result = strcmp(v11, "1")) != 0 )
      {
        result = jhl_iface_link_up_check(v6, a1);
        if ( !result )
        {
          result = jhl_get_wan_proto(a1) & 0xFFFFFFF7;
          if ( result )
          {
            result = jhl_check_wanup(a1);
            if ( result )
            {
              memset(netlong, 0, sizeof(netlong));
              result = get_iplist_str(netlong, a2);
              if ( result )
              {
                v12 = ntohl(netlong[0]);
                v13 = ntohl(netlong[1]);
                result = v13 < v12;
                if ( v13 >= v12 )
                {
                  v23 = "dev";
                  v24 = "wan_netmask";
                  do
                  {
                    v22 = v13;
                    memset(v19, 0, sizeof(v19));
                    v14 = v12++;
                    v15 = htonl(v14);
                    IpToStr(v20, v15);
                    v16 = jhl_nvget(v24, a1);
                    v17 = jhl_nv_get_def(v16);
                    ip_get_duolan(v20, v17, v19);
                    v21[0] = (int)"ip";
                    v21[1] = (int)"addr";
                    v21[2] = (int)"del";
                    v21[3] = (int)v19;
                    v21[4] = (int)v23;
                    v21[5] = (int)v8;
                    v21[6] = 0;
                    eval(v21, 0, 0, 0);
                    v13 = v22;
                    result = v22 < v12;
                  }
                  while ( v22 >= v12 );
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A8644: using guessed type int __fastcall IpToStr(_DWORD, _DWORD);
// 6A881C: using guessed type int __fastcall ip_get_duolan(_DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8924: using guessed type int __fastcall get_iplist_str(_DWORD, _DWORD);

//----- (004AA5C8) --------------------------------------------------------
int __fastcall sub_4AA5C8(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "nat_convert_more_cfg", 1893);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("nat_list_more");
    if ( !v3 )
      v3 = "";
    v5 = snprintf(v4, 0x200000, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    if ( v5 >= 0x200000 )
      v5 = 0x1FFFFF;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 4AA608: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004AA730) --------------------------------------------------------
int __fastcall sub_4AA730(int a1)
{
  _BYTE *v1; // $v0
  _BYTE *v2; // $s2
  char *v3; // $v0
  char *v4; // $v0
  char *v5; // $s1
  int v6; // $s4
  char *v7; // $v0
  char *v8; // $s2
  char *v9; // $v0
  char *v10; // $v1
  int v11; // $a1
  int v12; // $a0
  _BOOL4 v13; // $a3
  _BYTE *v14; // $v0
  char *v15; // $s3
  int v16; // $s4
  int v17; // $s7
  int v18; // $s0
  const char *v19; // $fp
  const char *v20; // $fp
  char *v21; // $s5
  int i; // $fp
  char *v23; // $v0
  _BOOL4 v24; // $a0
  char *v25; // $s0
  int v26; // $a0
  int v27; // $a2
  const char *v28; // $v0
  unsigned int v29; // $s0
  int v31; // $v0
  int v32; // $a1
  const char *v33; // $a2
  int v34; // $a0
  const char *v35; // $v0
  char v36[2048]; // [sp+20h] [-B28h] BYREF
  char v37[4]; // [sp+820h] [-328h] BYREF
  char *v38; // [sp+824h] [-324h]
  const char *v39; // [sp+828h] [-320h]
  int v40; // [sp+82Ch] [-31Ch]
  char *s; // [sp+834h] [-314h]
  const char *v42; // [sp+83Ch] [-30Ch]
  int v43; // [sp+840h] [-308h]
  int v44; // [sp+844h] [-304h]
  char v45[256]; // [sp+A20h] [-128h] BYREF
  _BYTE *v46; // [sp+B20h] [-28h]
  int v47; // [sp+B24h] [-24h]
  char *v48; // [sp+B28h] [-20h]
  int v49; // [sp+B2Ch] [-1Ch]
  int v50; // [sp+B30h] [-18h]
  char *v51; // [sp+B34h] [-14h]
  char *v52; // [sp+B38h] [-10h]
  char *v53; // [sp+B3Ch] [-Ch]
  char *v54; // [sp+B40h] [-8h]

  v53 = "1\"";
  v50 = get_rule_num_limit(29);
  _mem_malloc(102400, "nat_convert_more_cgi", 1944);
  v46 = v1;
  v2 = v1;
  _mem_malloc(102400, "nat_convert_more_cgi", 1945);
  v5 = v4;
  _mem_malloc(102400, "nat_convert_more_cgi", 1946);
  v48 = v3;
  if ( !v2 || !v5 || !v3 )
  {
    v32 = *(unsigned __int8 *)(a1 + 210102);
    v33 = (const char *)102400;
    v34 = 4;
    goto LABEL_32;
  }
  v54 = "1\"";
  jhl_parm_get("nat_list_more", v48, 102400);
  v6 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  v8 = v7;
  if ( !v7 || (v9 = find_file_end(a1, v7, *(_DWORD *)(a1 + 205564) + v6 - (_DWORD)v7)) == 0 )
  {
    v32 = *(unsigned __int8 *)(a1 + 210102);
    v33 = "Error reading file";
    v34 = 33;
LABEL_32:
    v35 = (const char *)_GET_LANG_TEXT(v34, v32, v33);
    goto LABEL_33;
  }
  *v9 = 0;
  if ( v9 - v8 <= 0 )
  {
    v11 = 0;
  }
  else
  {
    v10 = v8;
    v11 = 0;
    do
    {
      v12 = *v10++;
      v13 = v11 + 1 < 102399;
      if ( v12 != 13 && v12 != 10 )
      {
        v46[v11++] = v12;
        if ( !v13 )
          break;
      }
    }
    while ( v9 != v10 );
  }
  v14 = v46;
  v15 = v36;
  v46[v11] = 0;
  v47 = split_string(v14, 60, v36, 512);
  v16 = 0;
  if ( v47 <= 0 )
  {
LABEL_29:
    v25 = v48;
    strcat(v48, v5);
    jhl_parm_set(v54 - 11388, v25);
    jhl_parm_commit(v26);
    jhl_start_firewall();
    v28 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v27);
    v29 = snprintf(v45, 256, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v28);
    if ( v29 >= 0x100 )
      goto LABEL_34;
    goto LABEL_30;
  }
  v52 = "a";
  v49 = 0;
  v17 = 0;
  v51 = "1";
  while ( 1 )
  {
    v18 = split_string(*(_DWORD *)v15, 124, v37, 128);
    if ( v18 < 9 )
      goto LABEL_14;
    if ( nvparm_find_str(v48, 60, 12, v44, 124, 9) )
      break;
    if ( nvparm_find_str(v48, 60, 12, v39, 124, 2) )
    {
      v35 = (const char *)_GET_LANG_TEXT(84, *(unsigned __int8 *)(a1 + 210102), "src_ip");
      goto LABEL_33;
    }
    v19 = v39;
    if ( !v39 || strlen(v39) < 7 )
    {
      v32 = *(unsigned __int8 *)(a1 + 210102);
      v33 = "not src_ip";
      v34 = 12;
      goto LABEL_32;
    }
    if ( !s || strlen(s) < 7 )
    {
      v32 = *(unsigned __int8 *)(a1 + 210102);
      v33 = "not target_ip";
      v34 = 12;
      goto LABEL_32;
    }
    if ( !strcmp(v38, v51) )
      jhl_nat_more_add_iface((int)v19, v40);
    v20 = v42;
    if ( strcmp(v42, v52 + 12480) )
    {
      v31 = J_atoi(v20);
      jhl_nat_more_add_wanip(v31, v43);
    }
    v21 = v37;
    for ( i = 0; i != v18; ++i )
    {
      v17 += sprintf(&v5[v17], "%s|", *(const char **)v21);
      v21 += 4;
    }
    v23 = &v5[v17 - 1];
    v24 = ++v49 < v50;
    *v23 = 60;
    v23[1] = 0;
    if ( !v24 )
      goto LABEL_29;
LABEL_14:
    ++v16;
    v15 += 4;
    if ( v47 == v16 )
      goto LABEL_29;
  }
  v35 = (const char *)_GET_LANG_TEXT(84, *(unsigned __int8 *)(a1 + 210102), "src_id");
LABEL_33:
  v29 = snprintf(v45, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v35);
  if ( v29 >= 0x100 )
LABEL_34:
    v29 = 255;
LABEL_30:
  _mem_free(v46);
  _mem_free(v48);
  _mem_free(v5);
  return httpd_cgi_ret(a1, v45, v29, 4);
}
// 4AA7BC: variable 'v1' is possibly undefined
// 4AA7E0: variable 'v4' is possibly undefined
// 4AA7E4: variable 'v3' is possibly undefined
// 4AA850: variable 'v7' is possibly undefined
// 4AAB08: variable 'v26' is possibly undefined
// 4AAB44: variable 'v27' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004AADAC) --------------------------------------------------------
void __fastcall format_menu_nat_more_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 10 )
    snprintf(
      a3,
      a4,
      "{\"en\":%s,\"nat_inter_en\":\"%s\",\"src_addr\":\"%s\",\"src_netmask\":\"%s\",\"target_addr_type\":\"%s\",\"target"
      "_addr\":\"%s\",\"target_netmask\":\"%s\",\"interface\":\"%s\",\"to_address\":\"%s\",\"src\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3],
      a1[4],
      a1[5],
      a1[6],
      a1[7],
      a1[8],
      a1[9]);
}

//----- (004AAE6C) --------------------------------------------------------
int __fastcall sub_4AAE6C(int a1)
{
  int v1; // $v0
  int v2; // $s0
  char *v3; // $fp
  int v4; // $v0
  char *v5; // $a0
  int v6; // $s1
  int v7; // $s2
  int v8; // $v0
  const char *v9; // $v0
  char *v10; // $a0
  char *v11; // $a1
  int v12; // $s1
  int v13; // $s2
  char *v14; // $s4
  int v15; // $s5
  int v16; // $s0
  const char **v17; // $s3
  void *v18; // $v0
  _DWORD *v19; // $s6
  int v20; // $a1
  void *v21; // $s5
  int v22; // $s5
  int i; // $s7
  int v24; // $v0
  int v25; // $v0
  char *v26; // $a0
  int v27; // $s2
  int v28; // $v0
  int v29; // $s1
  int v30; // $v0
  int v31; // $a2
  int result; // $v0
  const char *v33; // $v0
  unsigned int v34; // $v0
  char v35[256]; // [sp+20h] [-108h] BYREF
  _DWORD *v36; // [sp+120h] [-8h]
  void *ptr; // [sp+124h] [-4h]

  v2 = sq_file_get_max_wan();
  _mem_malloc(102400, "menu_nat_more_data", 2113);
  v3 = (char *)v1;
  if ( v1 )
  {
    strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{\"wans\":");
    qmemcpy((void *)v1, "{\"code\":0,\"error", 16);
    *(_DWORD *)(v1 + 24) = 975331700;
    strcpy((char *)(v1 + 32), "ns\":");
    v4 = get_wans_data((char *)(v1 + 36), 102364);
    v5 = &v3[v4 + 36];
    strcpy(v5, ",\"vpns\":[ ");
    *(_DWORD *)v5 = *(_DWORD *)",\"vpns\":[ ";
    v6 = v4 + 46;
    if ( v2 > 0 )
    {
      v7 = 0;
      do
      {
        v8 = jhl_vpnget("vpn_proto", v7);
        v9 = (const char *)nvram_get(v8);
        if ( !v9 || strcmp(v9, (const char *)&off_63F984) )
          v6 += sprintf(&v3[v6], "{\"iface\":%d},", v7);
        ++v7;
      }
      while ( v7 != 5 && v2 != v7 );
    }
    v10 = &v3[v6];
    if ( v6 > 0 && *(v10 - 1) == 44 )
      v10 = &v3[--v6];
    *(_WORD *)v10 = 93;
    v11 = &v3[v6 + 1];
    strcpy(v11, ",\"nat_list_more\":");
    qmemcpy(v11, ",\"nat_list_m", 12);
    v12 = v6 + 18;
    v13 = 102400 - v12;
    v14 = &v3[v12];
    v15 = nvram_get("nat_list_more");
    v16 = snprintf(&v3[v12], 102400 - v12, (char *)&word_642A04);
    if ( v16 >= 102400 - v12 )
      v16 = 102399 - v12;
    if ( v15 )
    {
      v17 = (const char **)malloc(0x30u);
      v36 = malloc(0x4008u);
      v19 = v36;
      v18 = malloc(0x200000u);
      ptr = v18;
      if ( v18 )
      {
        if ( v17 )
        {
          v20 = v15;
          if ( v36 )
          {
            v21 = v18;
            strlcpy(v18, v20, 0x200000);
            v22 = split_string(v21, 60, v36, 4096);
            if ( v22 > 0 )
            {
              for ( i = 0; i != v22; ++i )
              {
                v24 = split_string(*v19, 124, v17, 10);
                format_menu_nat_more_data(v17, v24, &v14[v16], v13 - v16);
                v16 += v25;
                ++v19;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v17 )
        free(v17);
      if ( v36 )
        free(v36);
    }
    v26 = &v14[v16];
    if ( v16 > 0 && *(v26 - 1) == 44 )
      v26 = &v14[--v16];
    v27 = v13 - v16;
    *v26 = 0;
    v28 = snprintf(v26, v27, &byte_6445A0);
    if ( v28 >= v27 )
      v28 = v27 - 1;
    v29 = v16 + v28 + v12;
    v30 = snprintf(&v3[v29], 102400 - v29, "}}");
    if ( v30 >= 102400 - v29 )
      v31 = 102399 - v29;
    else
      v31 = v30;
    result = httpd_cgi_ret(a1, v3, v31 + v29, 8);
  }
  else
  {
    v33 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v34 = snprintf(v35, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v33);
    if ( v34 >= 0x100 )
      v34 = 255;
    result = httpd_cgi_ret(a1, v35, v34, 4);
  }
  return result;
}
// 4AAEE4: variable 'v1' is possibly undefined
// 4AB21C: variable 'v25' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (004AB3F4) --------------------------------------------------------
int __fastcall sub_4AB3F4(int a1)
{
  char *v2; // $s2
  char *v3; // $s3
  char *v4; // $fp
  char *v5; // $s1
  int v6; // $s7
  char *v7; // $s0
  char *v8; // $v0
  void *v9; // $v0
  void *v10; // $s5
  char *v11; // $s6
  int v12; // $v0
  _DWORD *v14; // $s0
  const char *v15; // $fp
  int v16; // $a1
  const char *v17; // $a2
  int v18; // $a0
  const char *v19; // $v0
  const char *v20; // $s7
  int v21; // $v0
  int v22; // $v0
  int v23; // $v0
  char *v24; // $a3
  char *v25; // $v0
  const char *v26; // $v1
  const char *v27; // $a0
  char *v28; // $a1
  const char *v29; // $a2
  const char *v30; // $t0
  char *v31; // $s0
  int v32; // $s3
  int v33; // $s1
  const char *v34; // $fp
  int v35; // $v0
  char *v36; // $v1
  const char *v37; // $v0
  int v38; // $t0
  int v39; // $a3
  int v40; // $a2
  int v41; // $a1
  __int16 v42; // $a0
  int v43; // $a0
  int v44; // $v0
  int v45; // $v0
  int v46; // $v0
  const char *v47; // $s7
  int v48; // $v0
  const char *v49; // [sp+20h] [-4178h]
  char v50[16384]; // [sp+38h] [-4160h] BYREF
  char s[256]; // [sp+4038h] [-160h] BYREF
  char *v52; // [sp+4138h] [-60h] BYREF
  char *v53; // [sp+413Ch] [-5Ch]
  char *v54; // [sp+4140h] [-58h]
  char *v55; // [sp+4144h] [-54h]
  char *v56; // [sp+4148h] [-50h]
  char *v57; // [sp+414Ch] [-4Ch]
  char *v58; // [sp+4150h] [-48h]
  char *v59; // [sp+4154h] [-44h]
  char *v60; // [sp+4158h] [-40h]
  char *v61; // [sp+415Ch] [-3Ch]
  char *v62; // [sp+4168h] [-30h]
  int v63; // [sp+416Ch] [-2Ch]
  char *v64; // [sp+4170h] [-28h]
  char *v65; // [sp+4174h] [-24h]
  char *v66; // [sp+4178h] [-20h]
  char *v67; // [sp+417Ch] [-1Ch]
  char *v68; // [sp+4180h] [-18h]
  char *v69; // [sp+4184h] [-14h]
  char *v70; // [sp+4188h] [-10h]
  char *v71; // [sp+418Ch] [-Ch]
  char *v72; // [sp+4190h] [-8h]
  char *v73; // [sp+4194h] [-4h]

  v69 = httpd_get_parm(a1, (char *)&off_647174);
  v73 = httpd_get_parm(a1, "old_src");
  v2 = httpd_get_parm(a1, "en");
  v3 = httpd_get_parm(a1, "nat_inter_en");
  v62 = httpd_get_parm(a1, "src_addr");
  v4 = httpd_get_parm(a1, "src_netmask");
  v65 = httpd_get_parm(a1, "target_addr_type");
  v66 = httpd_get_parm(a1, "target_addr");
  v67 = httpd_get_parm(a1, "target_netmask");
  v68 = httpd_get_parm(a1, "to_address");
  v5 = httpd_get_parm(a1, "interface");
  v70 = "1\"";
  v6 = httpd_get_json_parm(a1, (int)"del_list");
  v7 = httpd_get_parm(a1, "opt");
  _mem_malloc(10240, "menu_nat_more_asp", 2187);
  v10 = v9;
  _mem_malloc(10240, "menu_nat_more_asp", 2188);
  v11 = v8;
  if ( v10 && v8 )
  {
    if ( !v7 )
    {
LABEL_108:
      v16 = *(unsigned __int8 *)(a1 + 210102);
      v17 = "not opt";
LABEL_35:
      v18 = 12;
      goto LABEL_36;
    }
    v71 = "a";
    if ( !strcmp(v7, (const char *)&off_646D8C) || (v64 = "1\"", !strcmp(v7, (const char *)&off_648DDC)) )
    {
      if ( strcmp(v7, "del") )
        goto LABEL_10;
    }
    else if ( strcmp(v7, "del") )
    {
      if ( !strcmp(v7, "delall") )
      {
        v63 = 1;
        goto LABEL_13;
      }
      goto LABEL_108;
    }
    if ( v6 && cJSON_IsArray(v6) )
    {
      v14 = *(_DWORD **)(v6 + 8);
      if ( !v14 || !v14[4] )
      {
        v64 = s;
LABEL_97:
        jhl_start_firewall();
        v36 = v64;
        v37 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v38 = *(_DWORD *)v37;
          v39 = *((_DWORD *)v37 + 1);
          v40 = *((_DWORD *)v37 + 2);
          v41 = *((_DWORD *)v37 + 3);
          v37 += 16;
          *(_DWORD *)v36 = v38;
          *((_DWORD *)v36 + 1) = v39;
          *((_DWORD *)v36 + 2) = v40;
          *((_DWORD *)v36 + 3) = v41;
          v36 += 16;
        }
        while ( v37 != "}" );
        v42 = *(_WORD *)v37;
        v12 = 33;
        *(_WORD *)v36 = v42;
        goto LABEL_18;
      }
      v63 = 0;
      do
      {
        jhl_parm_get("nat_list_more", v10, 10240);
        if ( nvparm_get_str(v10, 60, 12, v14[4], 124, 9, &v52) )
        {
          if ( !strcmp(v52, "1") )
          {
            if ( !strcmp(v53, "1") )
              jhl_nat_more_del_iface((int)v54, (int)v55);
            v15 = v59;
            if ( strcmp(v59, "255") )
            {
              v45 = J_atoi(v15);
              jhl_nat_more_del_wanip(v45, (int)v60);
            }
          }
          jhl_parm_set("nat_list_more", v11);
          v63 = 1;
        }
        v14 = (_DWORD *)*v14;
      }
      while ( v14 && v14[4] );
      v64 = s;
      goto LABEL_96;
    }
LABEL_10:
    if ( !strcmp(v7, "delall") )
    {
      v63 = 1;
      v64 = "1\"";
    }
    else
    {
      if ( !v69 )
      {
        v16 = *(unsigned __int8 *)(a1 + 210102);
        v17 = (const char *)&unk_6442E4;
        goto LABEL_35;
      }
      v63 = 0;
      v64 = "1\"";
    }
LABEL_13:
    if ( !strcmp(v7, v64 - 29220) )
    {
      v72 = "1\"";
      jhl_parm_get("nat_list_more", v10, 10240);
      if ( v73 )
      {
        if ( nvparm_get_str(v10, 60, 12, v73, 124, 9, &v52) && !strcmp(v52, "1") )
        {
          if ( !strcmp(v53, "1") )
            jhl_nat_more_del_iface((int)v54, (int)v55);
          v20 = v59;
          if ( strcmp(v59, "255") )
          {
            v21 = J_atoi(v20);
            jhl_nat_more_del_wanip(v21, (int)v60);
          }
        }
        memset(v10, 0, 0x2800u);
        jhl_parm_get(v72 - 11388, v10, 10240);
        v22 = nvparm_del_str(v10, 60, 12, v73, 124, 9, v11);
      }
      else
      {
        if ( nvparm_get_str(v10, 60, 12, v69, 124, 9, &v52) && !strcmp(v52, "1") )
        {
          if ( !strcmp(v53, "1") )
            jhl_nat_more_del_iface((int)v54, (int)v55);
          v47 = v59;
          if ( strcmp(v59, "255") )
          {
            v48 = J_atoi(v47);
            jhl_nat_more_del_wanip(v48, (int)v60);
          }
        }
        memset(v10, 0, 0x2800u);
        jhl_parm_get(v72 - 11388, v10, 10240);
        v22 = nvparm_del_str(v10, 60, 12, v69, 124, 9, v11);
      }
      if ( v22 )
        v63 = 1;
      if ( !strcmp(v7, v71 + 28044) )
        goto LABEL_16;
      v23 = strcmp(v7, v64 - 29220);
      v64 = s;
      if ( !v23 )
        goto LABEL_50;
    }
    else if ( !strcmp(v7, v71 + 28044) )
    {
      v72 = "1\"";
LABEL_16:
      jhl_parm_get(v72 - 11388, v11, 10240);
      if ( !nvparm_find_str(v11, 60, 12, v69, 124, 9) )
      {
        v64 = s;
        v12 = check_rule_num_limit(a1, 29, (int)(v72 - 11388), 60, s, 0x100u);
        if ( v12 > 0 )
          goto LABEL_18;
LABEL_50:
        v61 = v69;
        if ( !v2 || !*v2 )
          v2 = "0";
        v52 = v2;
        if ( !v3 || !*v3 )
          v3 = "0";
        v53 = v3;
        if ( !v62 || !*v62 )
          v62 = "0.0.0.0";
        v54 = v62;
        if ( !v4 || !*v4 )
          v4 = "0.0.0.0";
        v55 = v4;
        if ( !v65 || !*v65 )
          v65 = "0";
        v56 = v65;
        if ( !v66 || !*v66 )
          v66 = "0.0.0.0";
        v57 = v66;
        if ( !v67 || !*v67 )
          v67 = "0.0.0.0";
        v58 = v67;
        if ( !v5 || !*v5 )
          v5 = "255";
        v59 = v5;
        if ( !v68 || !*v68 )
          v68 = "";
        v60 = v68;
        if ( !strcmp(v2, "1") )
        {
          if ( !strcmp(v3, "1") )
          {
            jhl_nat_more_add_iface((int)v62, (int)v4);
            v5 = v59;
          }
          if ( strcmp(v5, "255") )
          {
            v46 = J_atoi(v5);
            jhl_nat_more_add_wanip(v46, (int)v60);
            v24 = v53;
            v25 = v54;
            v4 = v55;
            v26 = v56;
            v27 = v57;
            v5 = v59;
            v29 = v60;
            v30 = v61;
            v49 = v58;
            goto LABEL_83;
          }
          v24 = v53;
          v25 = v54;
          v4 = v55;
          v26 = v56;
          v27 = v57;
          v28 = v58;
          v29 = v60;
          v30 = v61;
        }
        else
        {
          v30 = v69;
          v29 = v68;
          v28 = v67;
          v27 = v66;
          v26 = v65;
          v25 = v62;
          v24 = v3;
        }
        v49 = v28;
LABEL_83:
        v52 = v2;
        sprintf((char *)v10, "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<", v2, v24, v25, v4, v26, v27, v49, v5, v29, v30);
        if ( !v63 )
        {
          jhl_parm_get(v72 - 11388, v11, 10240);
          if ( !strcmp(v11, " ") )
            *v11 = 0;
        }
        strcat(v11, (char *)v10);
        if ( strcmp(v7, "addall")
          || (jhl_parm_get(v72 - 11388, v10, 10240), v31 = v50,
                                                     v32 = split_string(v10, 60, v50, 4096),
                                                     v63 = 1,
                                                     v32 <= 0) )
        {
LABEL_101:
          jhl_parm_set(v72 - 11388, v11);
          jhl_parm_commit(v43);
          goto LABEL_97;
        }
        goto LABEL_88;
      }
      v16 = *(unsigned __int8 *)(a1 + 210102);
      v17 = "same name";
      goto LABEL_35;
    }
    v44 = strcmp(v7, "addall");
    v64 = s;
    if ( v44 || (jhl_parm_get("nat_list_more", v10, 10240), v31 = v50, v32 = split_string(v10, 60, v50, 4096), v32 <= 0) )
    {
LABEL_96:
      if ( !v63 )
        goto LABEL_97;
      v72 = "1\"";
      goto LABEL_101;
    }
LABEL_88:
    v33 = 0;
    v62 = "255";
    do
    {
      while ( 1 )
      {
        ++v33;
        if ( split_string(*(_DWORD *)v31, 124, &v52, 10) >= 5 && !strcmp(v52, "1") )
        {
          if ( !strcmp(v53, "1") )
            jhl_nat_more_del_iface((int)v54, (int)v55);
          v34 = v59;
          if ( strcmp(v59, v62) )
            break;
        }
        v31 += 4;
        if ( v33 >= v32 )
          goto LABEL_96;
      }
      v35 = J_atoi(v34);
      jhl_nat_more_del_wanip(v35, (int)v60);
      v31 += 4;
    }
    while ( v33 < v32 );
    goto LABEL_96;
  }
  v16 = *(unsigned __int8 *)(a1 + 210102);
  v17 = (const char *)10240;
  v18 = 4;
LABEL_36:
  v19 = (const char *)_GET_LANG_TEXT(v18, v16, v17);
  v64 = s;
  v12 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
  if ( (unsigned int)v12 >= 0x100 )
    v12 = 255;
LABEL_18:
  v62 = (char *)v12;
  _mem_free(v10);
  _mem_free(v11);
  return httpd_cgi_ret(a1, v64, (int)v62, 4);
}
// 4AB5D4: variable 'v9' is possibly undefined
// 4AB5E0: variable 'v8' is possibly undefined
// 4AC0AC: variable 'v43' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 647174: using guessed type void *off_647174;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86B0: using guessed type int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004AC3C0) --------------------------------------------------------
int __fastcall sub_4AC3C0(int a1)
{
  void *v2; // $v0
  char *v3; // $v0
  char *v4; // $s0
  void *v5; // $s2
  int v6; // $s1
  int v7; // $s1
  int v8; // $v0
  int v9; // $s1
  int result; // $v0
  const char *v11; // $v0
  unsigned int v12; // $v0
  char *v13; // [sp+30h] [-100h] BYREF
  char *v14; // [sp+34h] [-FCh]
  const char *v15; // [sp+38h] [-F8h]
  char *v16; // [sp+3Ch] [-F4h]
  const char *v17; // [sp+40h] [-F0h]
  char *v18; // [sp+44h] [-ECh]

  _mem_malloc(0x200000, "jingx_data", 190);
  v4 = v3;
  _mem_malloc(10240, "jingx_data", 191);
  v5 = v2;
  if ( !v4 || !v2 )
  {
    _mem_free(v4);
    _mem_free(v5);
    v11 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v12 = snprintf((char *)&v13, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
    if ( v12 >= 0x100 )
      result = httpd_cgi_ret(a1, (char *)&v13, 255, 4);
    else
      result = httpd_cgi_ret(a1, (char *)&v13, v12, 4);
    return result;
  }
  jhl_parm_get("jingx2", v2, 10240);
  split_string(v5, 60, &v13, 6);
  if ( !v13 )
    v13 = "0";
  if ( v14 )
  {
    if ( v15 )
      goto LABEL_7;
  }
  else
  {
    v14 = "all";
    if ( v15 )
    {
LABEL_7:
      if ( v16 )
        goto LABEL_8;
      goto LABEL_19;
    }
  }
  v15 = "192.168.1.2";
  if ( v16 )
  {
LABEL_8:
    if ( v17 )
      goto LABEL_9;
LABEL_20:
    v17 = "WAN1";
    if ( v18 )
      goto LABEL_10;
LABEL_21:
    v18 = "0";
    goto LABEL_10;
  }
LABEL_19:
  v16 = "0";
  if ( !v17 )
    goto LABEL_20;
LABEL_9:
  if ( !v18 )
    goto LABEL_21;
LABEL_10:
  strcpy(v4, "{\"code\":0,\"error\":\"\",\"data\":{");
  qmemcpy(v4, "{\"code\":0,\"error\":\"\"", 20);
  v6 = sprintf(
         v4 + 29,
         "\"en\":%s,\"fx\":\"%s\",\"ip\":\"%s\",\"type\":\"%s\",\"outdev\":\"%s\",\"dual_show\":%d,\"indev\":\"%s\",\"wans\":",
         v13,
         v14,
         v15,
         v16,
         v17,
         1,
         v18)
     + 29;
  v7 = v6 + get_wans_data(&v4[v6], 0x200000 - v6);
  v8 = snprintf(&v4[v7], 0x200000 - v7, "}}");
  if ( v8 >= 0x200000 - v7 )
    v8 = 0x1FFFFF - v7;
  v9 = v8 + v7;
  _mem_free(v5);
  return httpd_cgi_ret(a1, v4, v9, 8);
}
// 4AC428: variable 'v3' is possibly undefined
// 4AC434: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004AC7A0) --------------------------------------------------------
int __fastcall sub_4AC7A0(int a1)
{
  char *v2; // $s1
  char *v3; // $s4
  char *v4; // $s7
  char *v5; // $s5
  char *v6; // $s6
  char *v7; // $s3
  char *v8; // $v1
  const char *v9; // $v0
  int v10; // $t0
  int v11; // $a3
  int v12; // $a2
  int v13; // $a1
  char v15[1028]; // [sp+28h] [-404h] BYREF

  v2 = httpd_get_parm(a1, "en");
  v3 = httpd_get_parm(a1, "fx");
  v4 = httpd_get_parm(a1, "ip");
  v5 = httpd_get_parm(a1, "type");
  v6 = httpd_get_parm(a1, "outdev");
  v7 = httpd_get_parm(a1, "indev");
  if ( !v2 || strcmp(v2, "1") )
    v2 = "0";
  if ( v3 )
  {
    if ( v5 )
      goto LABEL_6;
  }
  else
  {
    v3 = "all";
    if ( v5 )
    {
LABEL_6:
      if ( v6 )
        goto LABEL_7;
      goto LABEL_12;
    }
  }
  v5 = "0";
  if ( !v6 )
LABEL_12:
    v6 = "WAN1";
LABEL_7:
  if ( !v7 )
    v7 = "0";
  sprintf(v15, "%s<%s<%s<%s<%s<%s", v2, v3, v4, v5, v6, v7);
  jhl_parm_set("jingx2", v15);
  jingx_do(-1, 0);
  v8 = v15;
  v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v10 = *(_DWORD *)v9;
    v11 = *((_DWORD *)v9 + 1);
    v12 = *((_DWORD *)v9 + 2);
    v13 = *((_DWORD *)v9 + 3);
    v9 += 16;
    *(_DWORD *)v8 = v10;
    *((_DWORD *)v8 + 1) = v11;
    *((_DWORD *)v8 + 2) = v12;
    *((_DWORD *)v8 + 3) = v13;
    v8 += 16;
  }
  while ( v9 != "}" );
  *(_WORD *)v8 = *(_WORD *)v9;
  jhl_parm_commit("}");
  return httpd_cgi_ret(a1, v15, 33, 4);
}
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82E8: using guessed type int __fastcall jingx_do(_DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);

//----- (004ACA0C) --------------------------------------------------------
int __fastcall sub_4ACA0C(int a1)
{
  int v1; // $v0
  int v2; // $fp
  char *v3; // $s2
  int v4; // $s1
  int v5; // $s3
  int v6; // $v0
  const char *v7; // $v0
  char *v8; // $s4
  char *v9; // $v0
  char *v10; // $s0
  int v11; // $v0
  int v12; // $s5
  char *v13; // $v1
  int v14; // $v0
  unsigned int v15; // $v0
  char *v16; // $v1
  char *v17; // $a0
  struct tm *v18; // $v0
  const char *v19; // $v0
  char *v20; // $v0
  int v21; // $a0
  int v22; // $v0
  char *v23; // $a0
  int v24; // $v0
  int v25; // $s3
  int v26; // $v0
  int v27; // $s3
  int v28; // $v0
  int v29; // $a2
  struct tm *v31; // $v0
  const char *v32; // $v0
  char *v33; // $v0
  const char *v34; // $v0
  unsigned int v35; // $v0
  char v36[1024]; // [sp+48h] [-1448h] BYREF
  __int16 v37[512]; // [sp+448h] [-1048h] BYREF
  __int16 v38; // [sp+848h] [-C48h] BYREF
  char v39[1024]; // [sp+C48h] [-848h] BYREF
  char v40[256]; // [sp+1048h] [-448h] BYREF
  char v41[256]; // [sp+1148h] [-348h] BYREF
  struct stat v42; // [sp+1248h] [-248h] BYREF
  char v43[128]; // [sp+12E8h] [-1A8h] BYREF
  char v44[64]; // [sp+1368h] [-128h] BYREF
  char v45[64]; // [sp+13A8h] [-E8h] BYREF
  char *nptr; // [sp+13E8h] [-A8h] BYREF
  char *v47; // [sp+13ECh] [-A4h]
  int v48; // [sp+13F0h] [-A0h]
  char *src; // [sp+13F4h] [-9Ch]
  int v50; // [sp+13F8h] [-98h]
  int v51; // [sp+13FCh] [-94h]
  int v52; // [sp+1400h] [-90h]
  int v53; // [sp+1404h] [-8Ch]
  int v54; // [sp+1408h] [-88h]
  int v55[8]; // [sp+1414h] [-7Ch] BYREF
  char v56[32]; // [sp+1434h] [-5Ch] BYREF
  unsigned int v57; // [sp+1454h] [-3Ch] BYREF
  char *v58; // [sp+1458h] [-38h] BYREF
  char *v59; // [sp+1460h] [-30h]
  char *v60; // [sp+1464h] [-2Ch]
  char *dest; // [sp+1468h] [-28h]
  char *v62; // [sp+146Ch] [-24h]
  char *str; // [sp+1470h] [-20h]
  char *s; // [sp+1474h] [-1Ch]
  char *format; // [sp+1478h] [-18h]
  char *v66; // [sp+147Ch] [-14h]
  char *v67; // [sp+1480h] [-10h]
  char *v68; // [sp+1484h] [-Ch]
  const char *v69; // [sp+1488h] [-8h]
  char *v70; // [sp+148Ch] [-4h]

  s = v45;
  memset(v45, 0, sizeof(v45));
  memset(v36, 0, sizeof(v36));
  v2 = sq_file_get_max_wan();
  _mem_malloc(0x200000, "base_ddns_data", 361);
  v3 = (char *)v1;
  if ( !v1 )
  {
    v34 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    str = (char *)v37;
    v35 = snprintf((char *)v37, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v34);
    if ( v35 >= 0x100 )
      v35 = 255;
    return httpd_cgi_ret(a1, str, v35, 4);
  }
  qmemcpy((void *)v1, "{\"code\":0,\"error\":\"\",\"data\":{\"all", 33);
  qmemcpy((void *)v1, "{\"code\":0,\"error", 16);
  *(_DWORD *)(v1 + 24) = 975331700;
  *(_BYTE *)(v1 + 32) = 108;
  *(_DWORD *)(v1 + 33) = &unk_5B3A22;
  *(_DWORD *)(v1 + 33) = &unk_5B3A22;
  if ( v2 <= 0 )
  {
    v22 = 35;
    v21 = 36;
    v5 = 36;
    goto LABEL_38;
  }
  v4 = 0;
  v59 = "1\"";
  v5 = 36;
  v69 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
  v66 = "1\"";
  v62 = "oray";
  format = (char *)&unk_64D734;
  v67 = "{\"wans\":%d,\"id\":%d,\"serv\":\"%s\",\"user\":\"%s\",\"host\":\"%s\",\"wild\":\"%s\",\"mx\":\"%s\",\"bmx\":\"%"
        "s\",\"cust\":\"%s\",\"ip\":\"%s\",\"msg\":\"%s\",\"state\":\"%s\",\"type\":\"%s\"},";
  do
  {
    v6 = jhl_nvget(v59 - 10548, v4);
    v7 = (const char *)nvram_get(v6);
    if ( !v7 )
      v7 = v69 - 1556;
    v8 = v39;
    if ( *v7 )
    {
      strlcpy(v39, v7, 1024);
      v68 = "1\"";
      while ( 1 )
      {
        while ( 1 )
        {
          if ( !*v8 )
            goto LABEL_4;
          v9 = strchr(v8, 60);
          v10 = v9;
          if ( v9 )
            break;
          if ( split_string(v8, 124, &nptr, 9) != 9 )
          {
            ++v4;
            goto LABEL_5;
          }
LABEL_16:
          v12 = atoi(nptr);
          if ( !strcmp(v47, v62) )
          {
            sprintf(v56, "orayddnsx%d_%d", v4, v12);
            sprintf(s, "/var/lib/mdu/domainfile%d_%d.url", v4, v12);
            sprintf(v44, "/var/lib/mdu/orayusertype%d_%d", v4, v12);
          }
          else
          {
            sprintf(v56, "ddnsx%d_%d", v4, v12);
          }
          sprintf(v43, format, v56);
          v60 = v40;
          v38 = 32;
          v37[0] = 32;
          f_read_string(v43, v40, 256);
          dest = (char *)&v38;
          str = (char *)v37;
          if ( v40[0] )
          {
            if ( stat(v43, &v42) || v42.st_ctim.tv_sec < 0x5FEDF581u )
            {
              v20 = (char *)get_json_data(v60);
              strcpy(dest, v20);
            }
            else
            {
              v31 = localtime(&v42.st_ctim.tv_sec);
              v70 = v41;
              strftime(v41, 0x100u, "%F %H:%M:%S ", v31);
              v32 = (const char *)get_json_data(v60);
              sprintf(dest, "%s %s", v70, v32);
            }
          }
          sprintf(v43, v66 - 10400, v56);
          f_read_string(v43, v60, 256);
          if ( v40[0] )
          {
            v15 = strtoul(v60, &v58, 10);
            v16 = v58;
            v57 = v15;
            v17 = ++v58;
            if ( *v16 == 44 )
            {
              if ( v15 < 0x5FEDF581 )
              {
                v33 = (char *)get_json_data(v17);
                strcpy(str, v33);
              }
              else
              {
                v18 = localtime((const time_t *)&v57);
                strftime(v41, 0x100u, v68 - 10376, v18);
                v19 = (const char *)get_json_data(v58);
                sprintf(str, "%s %s", v41, v19);
              }
            }
          }
          memset(v36, 0, sizeof(v36));
          v55[0] = 0;
          v60 = v47;
          v55[1] = 0;
          v55[2] = 0;
          v55[3] = 0;
          v55[4] = 0;
          v55[5] = 0;
          v55[6] = 0;
          v55[7] = 0;
          if ( !strcmp(v47, v62) )
          {
            f_read_string(s, v36, 1024);
            f_read_string(v44, v55, 32);
            v13 = v47;
          }
          else
          {
            strcpy(v36, src);
            v13 = v60;
          }
          v60 = (char *)0x200000;
          v14 = snprintf(&v3[v5], 0x200000 - v5, v67, v4, v12, v13, v48, v36, v50, v51, v52, v53, v54, dest, str, v55);
          v8 = v10;
          if ( v14 >= 0x200000 - v5 )
            v14 = (int)&v60[-v5 - 1];
          v5 += v14;
          if ( !v10 )
          {
            ++v4;
            goto LABEL_5;
          }
        }
        *v9 = 0;
        v11 = split_string(v8, 124, &nptr, 9);
        v8 = v10 + 1;
        if ( v11 == 9 )
        {
          ++v10;
          goto LABEL_16;
        }
        if ( v10 == (char *)-1 )
        {
          ++v4;
          goto LABEL_5;
        }
      }
    }
LABEL_4:
    ++v4;
LABEL_5:
    ;
  }
  while ( v2 != v4 );
  v21 = v5;
  if ( v5 > 0 )
  {
    v22 = v5 - 1;
LABEL_38:
    if ( v3[v22] == 44 )
      v21 = --v5;
  }
  v23 = &v3[v21];
  *v23 = 0;
  v24 = snprintf(v23, 0x200000 - v5, (char *)&dword_6463E0);
  if ( v24 >= 0x200000 - v5 )
    v24 = 0x1FFFFF - v5;
  v25 = v5 + v24 + get_wans_data(&v3[v5 + v24], 0x200000 - (v5 + v24));
  v26 = snprintf(&v3[v25], 0x200000 - v25, ",\"ddns_show\":\"%d\",\"dnspod\":\"%d\"", 0, 1);
  if ( v26 >= 0x200000 - v25 )
    v26 = 0x1FFFFF - v25;
  v27 = v26 + v25;
  v28 = snprintf(&v3[v27], 0x200000 - v27, "}}");
  if ( v28 >= 0x200000 - v27 )
    v29 = 0x1FFFFF - v27;
  else
    v29 = v28;
  return httpd_cgi_ret(a1, v3, v29 + v27, 8);
}
// 4ACAC4: variable 'v1' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6463E0: using guessed type int dword_6463E0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83D4: using guessed type int __fastcall f_read_string(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A871C: using guessed type int __fastcall get_json_data(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (004AD338) --------------------------------------------------------
int __fastcall sub_4AD338(int a1)
{
  char *v1; // $v0
  const char *v3; // $s4
  char *v4; // $s3
  char *v5; // $s4
  char *v6; // $fp
  char *v7; // $s2
  char *v8; // $s5
  char *v9; // $s6
  char *v10; // $s7
  int v11; // $v0
  int v12; // $s2
  int v13; // $v0
  char *v14; // $s2
  int v15; // $a0
  const char **v16; // $v1
  const char *v17; // $v0
  const char *v18; // $t0
  const char *v19; // $a3
  const char *v20; // $a2
  const char *v21; // $a1
  unsigned int v22; // $a2
  char *v24; // $v0
  char *v25; // $s3
  char *v26; // $s6
  int v27; // $s7
  int v28; // $s6
  int v29; // $v0
  int v30; // $s1
  _DWORD *v31; // $s2
  int v32; // $v0
  int v33; // $s3
  int v34; // $v0
  int v35; // $s3
  int v36; // $s6
  int v37; // $a1
  const char *v38; // $a2
  const char *v39; // $v0
  int v40; // $v0
  const char *v41; // [sp+10h] [-4D8h]
  const char *v42; // [sp+30h] [-4B8h] BYREF
  const char *v43; // [sp+34h] [-4B4h]
  const char *v44; // [sp+38h] [-4B0h]
  char *v45; // [sp+3Ch] [-4ACh]
  int v46; // [sp+40h] [-4A8h]
  char v47[128]; // [sp+430h] [-B8h] BYREF
  int v48[6]; // [sp+4B0h] [-38h] BYREF
  char *v49; // [sp+4C8h] [-20h]
  char *v50; // [sp+4CCh] [-1Ch]
  char *v51; // [sp+4D0h] [-18h]
  char *v52; // [sp+4D4h] [-14h]
  char *v53; // [sp+4D8h] [-10h]
  const char *v54; // [sp+4DCh] [-Ch]
  const char *v55; // [sp+4E0h] [-8h]

  v1 = httpd_get_parm(a1, "opt");
  if ( !v1 )
    goto LABEL_41;
  v3 = v1;
  if ( !strcmp(v1, (const char *)&off_646D8C) )
  {
    if ( strcmp(v3, "del") )
    {
      if ( strcmp(v3, (const char *)&off_648DDC) )
      {
LABEL_5:
        v52 = "1\"";
        v54 = "service";
        v55 = "ddns";
        v53 = v47;
        v51 = "a";
        goto LABEL_6;
      }
      goto LABEL_26;
    }
    goto LABEL_31;
  }
  if ( strcmp(v3, "del") )
  {
    if ( !strcmp(v3, (const char *)&off_648DDC) )
      goto LABEL_26;
LABEL_41:
    v39 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    goto LABEL_42;
  }
LABEL_31:
  v29 = httpd_get_json_parm(a1, (int)"del_list");
  v30 = v29;
  if ( !v29 || !cJSON_IsArray(v29) )
  {
    v39 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_64D83C);
    goto LABEL_42;
  }
  v31 = *(_DWORD **)(v30 + 8);
  if ( v31 )
  {
    v49 = "wan";
    v50 = "service";
    v51 = "ddns";
    v52 = "stop";
    do
    {
      v35 = cJSON_GetObjectItem(v31, v49);
      v34 = cJSON_GetObjectItem(v31, "id");
      v36 = v34;
      if ( !v35 || !v34 )
      {
        v37 = *(unsigned __int8 *)(a1 + 210102);
        v38 = "del not wan or id";
        goto LABEL_39;
      }
      nvram_set("action_p1", *(_DWORD *)(v34 + 16));
      v42 = v50;
      v43 = v51;
      v44 = v52;
      v45 = *(char **)(v35 + 16);
      v46 = 0;
      eval(&v42, 0, 0, 0);
      v33 = J_atoi(*(_DWORD *)(v35 + 16));
      v32 = J_atoi(*(_DWORD *)(v36 + 16));
      jhl_ddns_del(v33, v32);
      v31 = (_DWORD *)*v31;
    }
    while ( v31 );
    v40 = strcmp(v3, (const char *)&off_648DDC);
  }
  else
  {
    v40 = strcmp(v3, (const char *)&off_648DDC);
  }
  if ( v40 )
  {
    if ( strcmp(v3, (const char *)&off_646D8C) )
    {
LABEL_20:
      jhl_parm_commit(v15);
      v16 = &v42;
      v17 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v18 = *(const char **)v17;
        v19 = (const char *)*((_DWORD *)v17 + 1);
        v20 = (const char *)*((_DWORD *)v17 + 2);
        v21 = (const char *)*((_DWORD *)v17 + 3);
        v17 += 16;
        *v16 = v18;
        v16[1] = v19;
        v16[2] = v20;
        v16[3] = v21;
        v16 += 4;
      }
      while ( v17 != "}" );
      v22 = 33;
      *(_WORD *)v16 = *(_WORD *)v17;
      return httpd_cgi_ret(a1, (char *)&v42, v22, 4);
    }
    goto LABEL_5;
  }
LABEL_26:
  v25 = httpd_get_parm(a1, "oldwans");
  v24 = httpd_get_parm(a1, "oldid");
  v26 = v24;
  if ( v25 && v24 )
  {
    v27 = J_atoi(v25);
    v51 = "a";
    v28 = J_atoi(v26);
    v53 = v47;
    v52 = "1\"";
    sprintf(v47, v51 + 24872, v28);
    nvram_set(v52 - 10144, v47);
    v54 = "service";
    v55 = "ddns";
    v42 = "service";
    v43 = "ddns";
    v44 = "stop";
    v45 = v25;
    v46 = 0;
    eval(&v42, 0, 0, 0);
    jhl_ddns_del(v27, v28);
    if ( strcmp(v3, (const char *)&off_646D8C) && strcmp(v3, (const char *)&off_648DDC) )
      goto LABEL_20;
LABEL_6:
    v4 = httpd_get_parm(a1, "wans");
    v5 = httpd_get_parm(a1, "serv");
    v6 = httpd_get_parm(a1, "user");
    v7 = httpd_get_parm(a1, "host");
    v49 = httpd_get_parm(a1, "wild");
    v50 = httpd_get_parm(a1, "mx");
    v8 = httpd_get_parm(a1, "bmx");
    v9 = httpd_get_parm(a1, "cust");
    v10 = httpd_get_parm(a1, "ip");
    if ( !v4 )
      v4 = "0";
    v11 = -1;
    if ( v5 )
    {
      v11 = strcmp(v5, "oray");
      if ( v6 )
        goto LABEL_10;
    }
    else
    {
      v5 = "";
      if ( v6 )
      {
LABEL_10:
        if ( !v7 )
          v7 = "";
        if ( !v49 )
          v49 = "";
        if ( v50 )
        {
          if ( v8 )
            goto LABEL_16;
        }
        else
        {
          v50 = "";
          if ( v8 )
          {
LABEL_16:
            if ( v9 )
              goto LABEL_17;
            goto LABEL_50;
          }
        }
        v8 = "";
        if ( v9 )
        {
LABEL_17:
          if ( v10 )
            goto LABEL_18;
          goto LABEL_48;
        }
LABEL_50:
        v9 = "";
        if ( v10 )
        {
LABEL_18:
          if ( v11 )
          {
LABEL_19:
            v41 = v7;
            v12 = J_atoi(v4);
            sprintf((char *)&v42, "%s|%s|%s|%s|%s|%s|%s|%s", v5, v6, v41, v49, v50, v8, v9, v10);
            v13 = jhl_ddns_add(v12, &v42);
            v14 = v53;
            sprintf(v53, v51 + 24872, v13);
            nvram_set(v52 - 10144, v14);
            v48[0] = (int)v54;
            v48[1] = (int)v55;
            v48[2] = (int)"start";
            v48[3] = (int)v4;
            v48[4] = 0;
            eval(v48, 0, 0, 0);
            goto LABEL_20;
          }
LABEL_40:
          v7 = "";
          goto LABEL_19;
        }
LABEL_48:
        v10 = "";
        if ( v11 )
          goto LABEL_19;
        goto LABEL_40;
      }
    }
    v6 = "";
    goto LABEL_10;
  }
  v37 = *(unsigned __int8 *)(a1 + 210102);
  v38 = (const char *)&unk_64D87C;
LABEL_39:
  v39 = (const char *)_GET_LANG_TEXT(12, v37, v38);
LABEL_42:
  v22 = snprintf((char *)&v42, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v39);
  if ( v22 >= 0x400 )
    v22 = 1023;
  return httpd_cgi_ret(a1, (char *)&v42, v22, 4);
}
// 4AD698: variable 'v15' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8794: using guessed type int __fastcall jhl_ddns_add(_DWORD, _DWORD);
// 6A886C: using guessed type int __fastcall jhl_ddns_del(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004ADC40) --------------------------------------------------------
int __fastcall sub_4ADC40(int a1)
{
  const char *v2; // $v0
  int v3; // $a2
  const char *v4; // $s0
  int v5; // $v0
  int v6; // $a1
  int v7; // $a0
  int v8; // $v0
  const char *v9; // $s0
  const char *v10; // $s4
  const char *v11; // $v0
  unsigned int v12; // $v0
  int v13; // $s0
  unsigned int v14; // $v0
  char v16[1024]; // [sp+28h] [-500h] BYREF
  char v17[256]; // [sp+428h] [-100h] BYREF

  memset(v16, 0, sizeof(v16));
  v2 = (const char *)jhl_nv_get_def("task_manage_state");
  if ( v2 )
  {
    v4 = v2;
    if ( !strcmp(v2, "Exit") )
    {
      v6 = *(unsigned __int8 *)(a1 + 210102);
      v7 = 67;
      goto LABEL_10;
    }
    if ( !strcmp(v4, "Start") )
    {
      v6 = *(unsigned __int8 *)(a1 + 210102);
      v7 = 68;
      goto LABEL_10;
    }
    if ( !strcmp(v4, "Connecting") )
    {
      v6 = *(unsigned __int8 *)(a1 + 210102);
      v7 = 69;
      goto LABEL_10;
    }
    if ( !strcmp(v4, "Connected") )
    {
      v6 = *(unsigned __int8 *)(a1 + 210102);
      v7 = 70;
      goto LABEL_10;
    }
    if ( !*v4 )
    {
      v5 = a1 + 196608;
LABEL_8:
      v6 = *(unsigned __int8 *)(v5 + 13494);
      v7 = 71;
LABEL_10:
      v8 = _GET_LANG_TEXT(v7, v6, v3);
      strlcpy(v17, v8, 256);
      goto LABEL_11;
    }
  }
  else
  {
    v4 = "";
    if ( !asc_4CF9E8[4] )
    {
      v5 = a1 + 196608;
      goto LABEL_8;
    }
  }
  strlcpy(v17, v4, 256);
LABEL_11:
  strcpy(v16, "{\"code\":0,\"error\":\"\",\"data\":{");
  v9 = (const char *)jhl_nv_get_def("task_manage_en");
  v10 = (const char *)jhl_nv_get_def("task_server_addr");
  v11 = (const char *)jhl_nv_get_def("task_server_port");
  v12 = snprintf(
          &v16[29],
          995,
          "\"enable\":\"%s\",\"srv_addr\":\"%s\",\"srv_port\":\"%s\",\"state\":\"%s\"",
          v9,
          v10,
          v11,
          v17);
  v13 = v12 + 29;
  if ( v12 >= 0x3E3 )
    v13 = 1023;
  v14 = snprintf(&v16[v13], 1024 - v13, "}}");
  if ( v14 >= 1024 - v13 )
    v14 = 1023 - v13;
  return httpd_cgi_ret(a1, v16, v14 + v13, 4);
}
// 4ADD64: variable 'v3' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004ADF58) --------------------------------------------------------
int __fastcall sub_4ADF58(int a1)
{
  char *v2; // $s3
  char *v3; // $s2
  char *v4; // $s0
  const char *v5; // $v0
  int v6; // $s3
  const char *v7; // $v0
  const char *v8; // $v0
  int v9; // $a0
  const char *v10; // $v0
  char *v11; // $v1
  int v12; // $t1
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  char v17[256]; // [sp+18h] [-100h] BYREF

  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "srv_addr");
  v4 = httpd_get_parm(a1, "srv_port");
  if ( !v2 || (v5 = (const char *)nvram_get("task_manage_en")) != 0 && !strcmp(v5, v2) )
  {
    v6 = 0;
  }
  else
  {
    nvram_set("task_manage_en", v2);
    v6 = 1;
  }
  if ( !v3 || (v7 = (const char *)nvram_get("task_server_addr")) != 0 && !strcmp(v7, v3) )
  {
    if ( !v4 )
      goto LABEL_18;
    v8 = (const char *)nvram_get("task_server_port");
    if ( !v8 )
      goto LABEL_10;
LABEL_17:
    if ( strcmp(v8, v4) )
      goto LABEL_10;
LABEL_18:
    if ( !v6 )
      goto LABEL_12;
    goto LABEL_11;
  }
  nvram_set("task_server_addr", v3);
  if ( v4 )
  {
    v8 = (const char *)nvram_get("task_server_port");
    v6 = 1;
    if ( !v8 )
    {
LABEL_10:
      nvram_set("task_server_port", v4);
      goto LABEL_11;
    }
    goto LABEL_17;
  }
LABEL_11:
  exec_service("task_manage-restart");
  jhl_parm_commit(v9);
LABEL_12:
  v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v11 = v17;
  do
  {
    v12 = *(_DWORD *)v10;
    v13 = *((_DWORD *)v10 + 1);
    v14 = *((_DWORD *)v10 + 2);
    v15 = *((_DWORD *)v10 + 3);
    v10 += 16;
    *(_DWORD *)v11 = v12;
    *((_DWORD *)v11 + 1) = v13;
    *((_DWORD *)v11 + 2) = v14;
    *((_DWORD *)v11 + 3) = v15;
    v11 += 16;
  }
  while ( v10 != "}" );
  *(_WORD *)v11 = *(_WORD *)v10;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 4AE0EC: variable 'v9' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004AE1D4) --------------------------------------------------------
int __fastcall sub_4AE1D4(int a1)
{
  int v2; // $v0
  char *v3; // $s1
  int v4; // $s0
  int v5; // $a2
  int v6; // $v0
  int v7; // $a2
  bool v8; // dc
  __int16 v9; // $v0
  int v10; // $v0
  _BOOL4 v11; // $v1
  int v12; // $a2
  int result; // $v0
  int v14; // $v0
  int v15; // $v0
  const char *v16; // $a2
  _DWORD v17[1251]; // [sp+18h] [-138Ch] BYREF

  v3 = httpd_get_parm(a1, "num");
  _mem_malloc(102400, "errinfo_htm", 833);
  if ( v2 )
  {
    v4 = v2;
    memset(v17, 0, 0x1388u);
    v5 = 3;
    if ( v3 )
    {
      v6 = memcmp(v3, "mem", 3u);
      v7 = 4;
      if ( !v6 )
      {
        v9 = 1;
LABEL_5:
        v17[0] = 1;
        v17[3] = 8;
        LOWORD(v17[4]) = v9;
        v17[1] = 5000;
        v17[5] = 4976;
        if ( !jianhl_order_opt_fun(v17, 5000, v7) )
        {
          v10 = v17[2];
          v11 = v17[2] < 0x33u;
          if ( !v17[2] )
          {
            if ( HIWORD(v17[4]) >= 2u )
            {
LABEL_8:
              v12 = sprintf((char *)v4, "%s", (const char *)&v17[6]);
              return httpd_cgi_ret(a1, (char *)v4, v12, 8);
            }
LABEL_14:
            v12 = 9;
            *(_DWORD *)v4 = 544501614;
            *(_DWORD *)v4 = 544501614;
            *(_DWORD *)(v4 + 4) = 1868983913;
            *(_BYTE *)(v4 + 8) = 10;
            *(_BYTE *)(v4 + 9) = 0;
            return httpd_cgi_ret(a1, (char *)v4, v12, 8);
          }
          goto LABEL_15;
        }
LABEL_18:
        result = 11;
        strcpy((char *)v4, "get opt err");
        *(_DWORD *)v4 = 544499047;
        *(_DWORD *)(v4 + 4) = 544501871;
        return result;
      }
      v8 = memcmp(v3, "cache", 4u) != 0;
      v9 = 2;
      if ( !v8 )
        goto LABEL_5;
      v14 = atoi(v3);
    }
    else
    {
      v14 = 0;
    }
    v17[3] = 5;
    v17[0] = 1;
    v17[1] = 5000;
    v17[4] = v14;
    if ( !jianhl_order_opt_fun(v17, 5000, v5) )
    {
      v10 = v17[2];
      v11 = v17[2] < 0x33u;
      if ( !v17[2] )
      {
        if ( v17[5] == 1 )
          goto LABEL_8;
        goto LABEL_14;
      }
LABEL_15:
      v15 = v10;
      if ( !v11 || (v16 = (const char *)jhlret_err_str[v15]) == 0 )
        v16 = "not find err!";
      v12 = sprintf((char *)v4, "err:%s \n", v16);
      return httpd_cgi_ret(a1, (char *)v4, v12, 8);
    }
    goto LABEL_18;
  }
  strcpy((char *)v17, "malloc err\n");
  return httpd_cgi_ret(a1, (char *)v17, 11, 4);
}
// 4AE238: variable 'v2' is possibly undefined
// 4AE2D0: variable 'v7' is possibly undefined
// 4AE390: variable 'v5' is possibly undefined
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (004AE504) --------------------------------------------------------
int __fastcall sub_4AE504(int a1)
{
  int *v2; // $v1
  const char *v3; // $v0
  int v4; // $t0
  int v5; // $a3
  int v6; // $a2
  int v7; // $a1
  int v9[1251]; // [sp+18h] [-138Ch] BYREF

  v9[0] = (int)"wys";
  v9[1] = (int)"errinfo";
  v9[2] = (int)"erase";
  v9[3] = 0;
  eval(v9, 0, 0, 0);
  v2 = v9;
  v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v4 = *(_DWORD *)v3;
    v5 = *((_DWORD *)v3 + 1);
    v6 = *((_DWORD *)v3 + 2);
    v7 = *((_DWORD *)v3 + 3);
    v3 += 16;
    *v2 = v4;
    v2[1] = v5;
    v2[2] = v6;
    v2[3] = v7;
    v2 += 4;
  }
  while ( v3 != "}" );
  *(_WORD *)v2 = *(_WORD *)v3;
  return httpd_cgi_ret(a1, (char *)v9, 33, 4);
}
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004AE5E4) --------------------------------------------------------
int __fastcall sub_4AE5E4(int a1)
{
  char *v1; // $v0
  const char *v3; // $v0
  char *v4; // $v1
  int v5; // $t1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  int v10; // $v0
  int v11; // $v0
  int i; // $s0
  int v13; // $v0
  int v14; // $s6
  char v15[1024]; // [sp+18h] [-490h] BYREF
  char v16[128]; // [sp+418h] [-90h] BYREF
  char v17[5]; // [sp+498h] [-10h] BYREF
  char v18; // [sp+49Dh] [-Bh]

  v1 = httpd_get_parm(a1, "def_mac");
  if ( v1 && !str2mac(v1, v17) )
  {
    v10 = MacToStr(v16, v17);
    nvram_set("mac_deflan", v10);
    ++v18;
    v11 = MacToStr(v16, v17);
    nvram_set("mac_defwl", v11);
    for ( i = 0; i != 9; ++i )
    {
      ++v18;
      v14 = jhl_nvget("mac_defwan", i);
      v13 = MacToStr(v16, v17);
      nvram_set(v14, v13);
    }
  }
  v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v4 = v15;
  do
  {
    v5 = *(_DWORD *)v3;
    v6 = *((_DWORD *)v3 + 1);
    v7 = *((_DWORD *)v3 + 2);
    v8 = *((_DWORD *)v3 + 3);
    v3 += 16;
    *(_DWORD *)v4 = v5;
    *((_DWORD *)v4 + 1) = v6;
    *((_DWORD *)v4 + 2) = v7;
    *((_DWORD *)v4 + 3) = v8;
    v4 += 16;
  }
  while ( v3 != "}" );
  *(_WORD *)v4 = *(_WORD *)v3;
  return httpd_cgi_ret(a1, v15, 33, 4);
}
// 6A8220: using guessed type int __fastcall str2mac(_DWORD, _DWORD);
// 6A88C8: using guessed type int __fastcall MacToStr(_DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004AE7B8) --------------------------------------------------------
int sq_file_del_fun()
{
  int v0; // $a2
  bool v1; // dc
  int result; // $v0
  int v3[256]; // [sp+18h] [-400h] BYREF

  memset(v3, 0, sizeof(v3));
  v3[0] = 6;
  v3[3] = 2;
  v3[1] = 1024;
  v1 = jianhl_order_opt_fun(v3, 1024, v0) != 0;
  result = -1;
  if ( !v1 )
    result = v3[2];
  return result;
}
// 4AE810: variable 'v0' is possibly undefined
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (004AE834) --------------------------------------------------------
int __fastcall sq_file_get_fun(char *a1)
{
  int v2; // $a2
  int result; // $v0
  unsigned int v4; // $s1
  int v5; // $v0
  unsigned int v6; // $hi
  unsigned int v7; // $s1
  unsigned int v8; // $lo
  unsigned int v9; // $hi
  int v10[257]; // [sp+50h] [-404h] BYREF

  memset(v10, 0, 0x400u);
  v10[0] = 6;
  v10[3] = 1;
  v10[1] = 1024;
  if ( jianhl_order_opt_fun(v10, 1024, v2) || (v4 = v10[54], v5 = sq_file_get_max_wan(), !v10[5]) )
  {
    result = 3;
    *(_DWORD *)a1 = 8200315;
  }
  else
  {
    v6 = v4 % 0x174;
    v7 = v4 / 0x174 + 1970;
    v8 = v6 / 0x1F;
    v9 = v6 % 0x1F;
    if ( v10[16] == 40 )
      result = sprintf(
                 a1,
                 "{\"xlh\":\"%s\",\"jb_s\":\"0\",\"jb\":\"%s\",\"dtime\":%u,\"state\":%u,\"hi_num\":%u,\"wan_num\":%d,\"s"
                 "id_pre\":\"%s\",\"sid_mid\":\"%s\",\"sid_end\":\"%s\",\"sb_dtime\":\"%04d-%02d-%02d\",\"test\":%d,\"tti"
                 "me\":%u,\"ttype\":%d}",
                 (const char *)&v10[24],
                 byte_64D9E0,
                 v10[15],
                 v10[5],
                 v10[48],
                 v5,
                 (const char *)&v10[57],
                 (const char *)&v10[62],
                 (const char *)&v10[66],
                 v7,
                 v8 + 1,
                 v9 + 1,
                 0,
                 0,
                 0);
    else
      result = sprintf(
                 a1,
                 "{\"xlh\":\"%s\",\"jb_s\":\"1\",\"jb\":\"%u\",\"dtime\":%u,\"state\":%u,\"hi_num\":%u,\"wan_num\":%d,\"s"
                 "id_pre\":\"%s\",\"sid_mid\":\"%s\",\"sid_end\":\"%s\",\"sb_dtime\":\"%04d-%02d-%02d\",\"test\":%d,\"tti"
                 "me\":%u,\"ttype\":%d}",
                 (const char *)&v10[24],
                 v10[16] / 0xAu,
                 v10[15],
                 v10[5],
                 v10[48],
                 v5,
                 (const char *)&v10[57],
                 (const char *)&v10[62],
                 (const char *)&v10[66],
                 v7,
                 v8 + 1,
                 v9 + 1,
                 0,
                 0,
                 0);
  }
  return result;
}
// 4AE894: variable 'v2' is possibly undefined
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (004AEA34) --------------------------------------------------------
int __fastcall sub_4AEA34(int a1)
{
  int v1; // $s0
  int v2; // $s3
  char *v3; // $v0
  char *v5; // $v0
  char *v6; // $s1
  signed int v7; // $v0
  int v8; // $s0
  const char *v9; // $a2
  const char *v10; // $v0
  unsigned int v11; // $v0
  int v13; // $a2
  const char *v14; // $v0
  unsigned int v15; // $a2
  char v16[1028]; // [sp+20h] [-404h] BYREF

  v1 = a1 + 196608;
  v2 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( !v3 || (v6 = v3, (v5 = find_file_end(a1, v3, *(_DWORD *)(v1 + 8956) + v2 - (_DWORD)v3)) == 0) )
  {
    v9 = "Error reading file";
    goto LABEL_6;
  }
  v8 = v5 - v6;
  v7 = strlen(v6);
  if ( v7 < v8 )
  {
    v8 = v7;
    if ( v7 >= 1025 )
      goto LABEL_5;
  }
  else if ( v8 >= 1025 )
  {
LABEL_5:
    v9 = "file too long err!";
LABEL_6:
    v10 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v9);
    v11 = snprintf(v16, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
    if ( v11 >= 0x400 )
      v11 = 1023;
    return httpd_cgi_ret(a1, v16, v11, 4);
  }
  memset(v16, 0, 0x400u);
  memcpy(v16, v6, v8);
  v14 = (const char *)_GET_LANG_TEXT(72, *(unsigned __int8 *)(a1 + 210102), v13);
  v15 = snprintf(v16, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
  if ( v15 >= 0x400 )
    v15 = 1023;
  return httpd_cgi_ret(a1, v16, v15, 4);
}
// 4AEA80: variable 'v3' is possibly undefined
// 4AEBDC: variable 'v13' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004AEC50) --------------------------------------------------------
int __fastcall sq_data(int a1, int a2)
{
  int v4; // $a0
  int v5; // $s0
  int v6; // $v0
  char *v7; // $v0
  int v8; // $s0
  int v9; // $s0
  int v10; // $v0
  int v11; // $s0
  const char *v12; // $v0
  int v13; // $s0
  const char *v14; // $v0
  int v15; // $s0
  int v16; // $s0
  unsigned int v17; // $v0
  int v18; // $a2
  char v20[4096]; // [sp+18h] [-1400h] BYREF
  char v21[1024]; // [sp+1018h] [-400h] BYREF

  memset(v21, 0, sizeof(v21));
  if ( a2 )
  {
    v4 = 34;
    strcpy(v20, "{\"code\":0,\"error\":\"\",\"data\":{");
    v5 = 34;
    v6 = 29;
  }
  else
  {
    strcpy(v20, "{");
    v4 = 6;
    v5 = 6;
    v6 = 1;
  }
  v7 = &v20[v6];
  strcpy(v7, "\"sq\":");
  *(_DWORD *)v7 = 577860386;
  v8 = sq_file_get_fun(&v20[v4]) + v5;
  sq2_file_get_auth_errinfo(1023, v21);
  v9 = v8 + sprintf(&v20[v8], ",\"errinfo\":\"%s\"", v21);
  v10 = flash_get_sec_status();
  v11 = v9 + sprintf(&v20[v9], ",\"hardid_info\":\"%d\"", v10);
  strcpy(&v20[v11], ",\"hd_info\":\"1\"");
  qmemcpy(&v20[v11], ",\"hd_info\":\"", 12);
  v12 = (const char *)custom_tb_version();
  v13 = v11 + 14 + sprintf(&v20[v11 + 14], ",\"version\":\"%s\"", v12);
  strcpy(&v20[v13], ",\"ff\":{");
  *(_DWORD *)&v20[v13 + 4] = 8075810;
  v14 = (const char *)nvram_get("mac_deflan");
  v15 = v13 + 7 + sprintf(&v20[v13 + 7], "\"def_mac\":\"%s\"", v14);
  *(_WORD *)&v20[v15] = 125;
  v16 = v15 + 1 + sprintf(&v20[v15 + 1], ",\"x86\":%d", 0);
  if ( a2 )
  {
    v17 = snprintf(&v20[v16], 4096 - v16, "}}");
    if ( v17 >= 4096 - v16 )
      v17 = 4095 - v16;
    v18 = v17 + v16;
  }
  else
  {
    *(_WORD *)&v20[v16] = 125;
    v18 = v16 + 1;
  }
  return httpd_cgi_ret(a1, v20, v18, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83D8: using guessed type int flash_get_sec_status(void);
// 6A84C0: using guessed type int __fastcall sq2_file_get_auth_errinfo(_DWORD, _DWORD);
// 6A8788: using guessed type int custom_tb_version(void);

//----- (004AEF40) --------------------------------------------------------
int __fastcall sub_4AEF40(int a1)
{
  return sq_data(a1, 0);
}

//----- (004AEF5C) --------------------------------------------------------
int __fastcall sub_4AEF5C(int a1)
{
  return sq_data(a1, 1);
}

//----- (004AEF78) --------------------------------------------------------
int __fastcall sub_4AEF78(int a1)
{
  char *v2; // $a1
  const char *v3; // $v0
  char *v4; // $v1
  int v5; // $t1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  char v10[1024]; // [sp+18h] [-400h] BYREF

  v2 = httpd_get_parm(a1, "num");
  if ( v2 )
    sq2_file_send_sq_num(2, v2);
  v3 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v4 = v10;
  do
  {
    v5 = *(_DWORD *)v3;
    v6 = *((_DWORD *)v3 + 1);
    v7 = *((_DWORD *)v3 + 2);
    v8 = *((_DWORD *)v3 + 3);
    v3 += 16;
    *(_DWORD *)v4 = v5;
    *((_DWORD *)v4 + 1) = v6;
    *((_DWORD *)v4 + 2) = v7;
    *((_DWORD *)v4 + 3) = v8;
    v4 += 16;
  }
  while ( v3 != "}" );
  *(_WORD *)v4 = *(_WORD *)v3;
  return httpd_cgi_ret(a1, v10, 33, 4);
}
// 6A8494: using guessed type int __fastcall sq2_file_send_sq_num(_DWORD, _DWORD);

//----- (004AF038) --------------------------------------------------------
int __fastcall sub_4AF038(int a1)
{
  char *v1; // $v0
  int v3; // $a0
  const char *v4; // $v0
  char *v5; // $v1
  int v6; // $t1
  int v7; // $t0
  int v8; // $a3
  int v9; // $a2
  char v11[1028]; // [sp+18h] [-404h] BYREF

  v1 = httpd_get_parm(a1, "opt");
  if ( v1 && !strcmp(v1, "del") )
  {
    sq_file_del_fun();
    jhl_parm_set("sq_file2", "");
    flash_sq_file_set(0, 2);
    jhl_parm_set("sq_file", "");
    flash_sq_file_set(0, 1);
    jhl_parm_commit(v3);
  }
  v4 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v5 = v11;
  do
  {
    v6 = *(_DWORD *)v4;
    v7 = *((_DWORD *)v4 + 1);
    v8 = *((_DWORD *)v4 + 2);
    v9 = *((_DWORD *)v4 + 3);
    v4 += 16;
    *(_DWORD *)v5 = v6;
    *((_DWORD *)v5 + 1) = v7;
    *((_DWORD *)v5 + 2) = v8;
    *((_DWORD *)v5 + 3) = v9;
    v5 += 16;
  }
  while ( v4 != "}" );
  *(_WORD *)v5 = *(_WORD *)v4;
  return httpd_cgi_ret(a1, v11, 33, 4);
}
// 4AF120: variable 'v3' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8554: using guessed type int __fastcall flash_sq_file_set(_DWORD, _DWORD);

//----- (004AF1A0) --------------------------------------------------------
int __fastcall sub_4AF1A0(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s6
  const char *v5; // $s7
  const char *v6; // $s1
  const char *v7; // $s2
  const char *v8; // $s4
  const char *v9; // $s5
  const char *v10; // $v1
  const char *v11; // $v0
  int v12; // $s1
  const char *v13; // $v0
  int v14; // $s1
  int v15; // $v0
  int v16; // $a2
  int result; // $v0
  const char *v18; // $v0
  unsigned int v19; // $v0
  char v20[256]; // [sp+40h] [-110h] BYREF
  const char *v21; // [sp+140h] [-10h]
  const char *v22; // [sp+144h] [-Ch]
  const char *v23; // [sp+148h] [-8h]
  const char *v24; // [sp+14Ch] [-4h]

  _mem_malloc(10240, "wan_3g_data", 823);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\"", 20);
    v4 = (const char *)jhl_nv_get_def("wan_3g_enable");
    v5 = (const char *)jhl_nv_get_def("wan_3g_isp");
    v6 = (const char *)nvram_get("wan_3g_apn");
    if ( !v6 )
      v6 = "";
    v7 = (const char *)nvram_get("wan_3g_dial");
    if ( !v7 )
      v7 = "";
    v8 = (const char *)nvram_get("wan_3g_pin");
    if ( !v8 )
      v8 = "";
    v9 = (const char *)nvram_get("wan_3g_user");
    if ( !v9 )
      v9 = "";
    v10 = (const char *)nvram_get("wan_3g_pass");
    if ( !v10 )
      v10 = "";
    v24 = v10;
    v23 = (const char *)jhl_nv_get_def("wan_3g_connect_mode");
    v22 = (const char *)jhl_nv_get_def("wan_3g_enable_dk");
    v21 = (const char *)jhl_nv_get_def("g3_warn_bytes");
    v11 = (const char *)jhl_nv_get_def("g3_warn_time");
    v12 = sprintf(
            v3 + 29,
            "\"wan_3g_enable\":\"%s\",\"wan_3g_isp\":\"%s\",\"wan_3g_apn\":\"%s\",\"wan_3g_dial\":\"%s\",\"wan_3g_pin\":\""
            "%s\",\"wan_3g_user\":\"%s\",\"wan_3g_pass\":\"%s\",\"wan_3g_connect_mode\":\"%s\",\"wan_3g_enable_dk\":\"%s\""
            ",\"g3_warn_bytes\":\"%s\",\"g3_warn_time\":\"%s\"",
            v4,
            v5,
            v6,
            v7,
            v8,
            v9,
            v24,
            v23,
            v22,
            v21,
            v11)
        + 29;
    v13 = (const char *)nvram_get("wan_3g_user_mode");
    if ( !v13 )
      v13 = "";
    v14 = v12 + sprintf(&v3[v12], ",\"user_mode\":\"%s\"", v13);
    v15 = snprintf(&v3[v14], 10240 - v14, "}}");
    if ( v15 >= 10240 - v14 )
      v16 = 10239 - v14;
    else
      v16 = v15;
    result = httpd_cgi_ret(a1, v3, v16 + v14, 8);
  }
  else
  {
    v18 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v19 = snprintf(v20, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v18);
    if ( v19 >= 0x100 )
      v19 = 255;
    result = httpd_cgi_ret(a1, v20, v19, 4);
  }
  return result;
}
// 4AF200: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004AF590) --------------------------------------------------------
int __fastcall sub_4AF590(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s1
  const char **v5; // $v1
  const char *v6; // $v0
  const char *v7; // $t0
  const char *v8; // $a3
  const char *v9; // $a2
  const char *v10; // $a1
  int v11; // $a2
  unsigned int v13; // $v0
  int v14; // $a1
  const char *v15; // $a2
  const char *v16; // [sp+10h] [-490h]
  const char *v17; // [sp+20h] [-480h] BYREF
  const char *v18; // [sp+24h] [-47Ch]
  const char *v19; // [sp+28h] [-478h]
  int v20; // [sp+2Ch] [-474h]
  char v21[128]; // [sp+420h] [-80h] BYREF

  v3 = httpd_get_parm(a1, "opt");
  v2 = httpd_get_parm(a1, "device");
  if ( !v3 )
    goto LABEL_19;
  v4 = v2;
  if ( !strcmp(v3, "mount") )
  {
    if ( v4 )
    {
      if ( !strncmp(v4, "/dev/sd", 7u) )
      {
        v17 = "umount";
        v18 = "/tmp/mnt/sda1/";
        v19 = 0;
        eval(&v17, 0, 0, 0);
        v17 = "mount";
        v18 = v4;
        v19 = "/tmp/mnt/sda1/";
        v20 = 0;
        eval(&v17, 0, 0, 0);
      }
      else
      {
        v4 = "";
      }
      nvram_set("usb_mount_dev", v4);
      nvram_commit();
      goto LABEL_7;
    }
    goto LABEL_25;
  }
  if ( strcmp(v3, "mkfs") )
  {
    if ( !strcmp(v3, "umount") )
    {
      if ( v4 )
      {
        if ( !strcmp(v3, "umount") )
        {
          v17 = "umount";
          v18 = "/tmp/mnt/sda1/";
          v19 = 0;
          eval(&v17, 0, 0, 0);
        }
        goto LABEL_7;
      }
      goto LABEL_25;
    }
LABEL_19:
    v14 = *(unsigned __int8 *)(a1 + 210102);
    v15 = "not opt";
LABEL_20:
    v16 = (const char *)_GET_LANG_TEXT(12, v14, v15);
    v13 = snprintf((char *)&v17, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v16);
    goto LABEL_21;
  }
  if ( !v4 )
  {
LABEL_25:
    v14 = *(unsigned __int8 *)(a1 + 210102);
    v15 = (const char *)&unk_64DDD0;
    goto LABEL_20;
  }
  memset(v21, 0, sizeof(v21));
  if ( !mkfs_disk_device(*(unsigned __int8 *)(a1 + 210102), v4, v21, 128) )
  {
LABEL_7:
    v5 = &v17;
    v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v7 = *(const char **)v6;
      v8 = (const char *)*((_DWORD *)v6 + 1);
      v9 = (const char *)*((_DWORD *)v6 + 2);
      v10 = (const char *)*((_DWORD *)v6 + 3);
      v6 += 16;
      *v5 = v7;
      v5[1] = v8;
      v5[2] = v9;
      v5[3] = v10;
      v5 += 4;
    }
    while ( v6 != "}" );
    v11 = 33;
    *(_WORD *)v5 = *(_WORD *)v6;
    return httpd_cgi_ret(a1, (char *)&v17, v11, 4);
  }
  v13 = snprintf((char *)&v17, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v21);
LABEL_21:
  v11 = v13;
  if ( v13 >= 0x400 )
    v11 = 1023;
  return httpd_cgi_ret(a1, (char *)&v17, v11, 4);
}
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8564: using guessed type int __fastcall mkfs_disk_device(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A87C4: using guessed type int nvram_commit(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004AF8F4) --------------------------------------------------------
int __fastcall sub_4AF8F4(int a1)
{
  char *v1; // $v0
  FILE *v2; // $v0
  FILE *v3; // $s2
  int v4; // $s1
  const char **v5; // $v1
  const char *v6; // $v0
  const char *v7; // $t0
  const char *v8; // $a3
  const char *v9; // $a2
  const char *v10; // $a1
  const char *v12; // $t0
  const char *v13; // $a3
  const char *v14; // $a2
  const char *v15; // $a1
  const char *v16; // [sp+18h] [-520h] BYREF
  int *v17; // [sp+1Ch] [-51Ch]
  int v18; // [sp+20h] [-518h]
  char v19[256]; // [sp+418h] [-120h] BYREF
  int v20; // [sp+518h] [-20h] BYREF
  int v21; // [sp+51Ch] [-1Ch]
  int v22; // [sp+520h] [-18h]
  int v23; // [sp+524h] [-14h]
  int v24; // [sp+528h] [-10h]
  int v25; // [sp+52Ch] [-Ch]
  const char *v26; // [sp+530h] [-8h]

  memset(v19, 0, sizeof(v19));
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v1 = httpd_get_parm(a1, "disk_name");
  if ( v1 && *v1 )
  {
    v16 = "umount";
    v17 = (int *)v1;
    v18 = 0;
    eval(&v16, 0, 0, 0);
    v5 = &v16;
    v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v12 = *(const char **)v6;
      v13 = (const char *)*((_DWORD *)v6 + 1);
      v14 = (const char *)*((_DWORD *)v6 + 2);
      v15 = (const char *)*((_DWORD *)v6 + 3);
      v6 += 16;
      *v5 = v12;
      v5[1] = v13;
      v5[2] = v14;
      v5[3] = v15;
      v5 += 4;
    }
    while ( v6 != "}" );
  }
  else
  {
    jhl_system("df > /tmp/df_file");
    v2 = fopen("/tmp/df_file", "r");
    v3 = v2;
    if ( v2 )
    {
      fgets(v19, 256, v2);
      memset(v19, 0, sizeof(v19));
      v4 = 0;
      v26 = "smbd";
      while ( fgets(v19, 256, v3) )
      {
        if ( strstr(v19, "/dev/") )
        {
          if ( ++v4 == 1 )
          {
            killall_tk(v26);
            sleep(1u);
          }
          sscanf(v19, "%s", &v20);
          v16 = "umount";
          v17 = &v20;
          v18 = 0;
          eval(&v16, 0, 0, 0);
        }
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v25 = 0;
        memset(v19, 0, sizeof(v19));
      }
      fclose(v3);
    }
    remove("/tmp/df_file");
    v5 = &v16;
    v6 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v7 = *(const char **)v6;
      v8 = (const char *)*((_DWORD *)v6 + 1);
      v9 = (const char *)*((_DWORD *)v6 + 2);
      v10 = (const char *)*((_DWORD *)v6 + 3);
      v6 += 16;
      *v5 = v7;
      v5[1] = v8;
      v5[2] = v9;
      v5[3] = v10;
      v5 += 4;
    }
    while ( v6 != "}" );
  }
  *(_WORD *)v5 = *(_WORD *)v6;
  return httpd_cgi_ret(a1, (char *)&v16, 33, 4);
}
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8594: using guessed type int __fastcall jhl_system(_DWORD);

//----- (004AFC68) --------------------------------------------------------
int __fastcall sub_4AFC68(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  const char *v4; // $s0
  const char *v5; // $v0
  char *v6; // $v1
  int v7; // $t1
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  int v12; // $a0
  char v13[1028]; // [sp+20h] [-404h] BYREF

  v3 = httpd_get_parm(a1, "printer_enable");
  v2 = httpd_get_parm(a1, "printer_port");
  if ( v2 && (v4 = v2, !nvram_match_def(&unk_64DE5C, v2)) )
  {
    if ( !J_atoi(v4) )
      v4 = "9100";
    nvram_set(&unk_64DE5C, v4);
    if ( !v3 || nvram_match_def("usb_printer_en", v3) )
      goto LABEL_13;
  }
  else if ( !v3 || nvram_match_def("usb_printer_en", v3) )
  {
    goto LABEL_5;
  }
  nvram_set("usb_printer_en", v3);
LABEL_13:
  killall_tk("p910nd");
  if ( nvram_match_def("usb_printer_en", "1") )
  {
    jhl_nv_get_def(&unk_64DE5C);
    xstart("p910nd", "-f");
  }
  jhl_parm_commit(v12);
LABEL_5:
  v5 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v6 = v13;
  do
  {
    v7 = *(_DWORD *)v5;
    v8 = *((_DWORD *)v5 + 1);
    v9 = *((_DWORD *)v5 + 2);
    v10 = *((_DWORD *)v5 + 3);
    v5 += 16;
    *(_DWORD *)v6 = v7;
    *((_DWORD *)v6 + 1) = v8;
    *((_DWORD *)v6 + 2) = v9;
    *((_DWORD *)v6 + 3) = v10;
    v6 += 16;
  }
  while ( v5 != "}" );
  *(_WORD *)v6 = *(_WORD *)v5;
  return httpd_cgi_ret(a1, v13, 33, 4);
}
// 4AFE50: variable 'v12' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85AC: using guessed type int __fastcall xstart(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004AFEB4) --------------------------------------------------------
int __fastcall sub_4AFEB4(int a1)
{
  char *v1; // $v1
  int *v2; // $v0
  int v3; // $t0
  int v4; // $a3
  int v5; // $a2
  int v6; // $a1
  int v7; // $t4
  const char *v8; // $s4
  const char *v9; // $s0
  const char *v10; // $v0
  int v11; // $s0
  int v12; // $s3
  unsigned int v13; // $v0
  const char **v15; // $s7
  int v16; // $a0
  int v17; // $a2
  const char *v18; // $v0
  char v19[10240]; // [sp+20h] [-2B20h] BYREF
  char v20[256]; // [sp+2820h] [-320h] BYREF
  char v21[256]; // [sp+2920h] [-220h] BYREF
  _BYTE v22[160]; // [sp+2A20h] [-120h] BYREF
  char v23; // [sp+2AC0h] [-80h] BYREF
  char v24; // [sp+2AC4h] [-7Ch] BYREF
  char *v25; // [sp+2B38h] [-8h]
  char v26; // [sp+2B3Ch] [-4h] BYREF

  memset(v21, 0, sizeof(v21));
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  v1 = &v23;
  v2 = (int *)&unk_676DA0;
  do
  {
    v3 = *v2;
    v4 = v2[1];
    v5 = v2[2];
    v6 = v2[3];
    v2 += 4;
    *(_DWORD *)v1 = v3;
    *((_DWORD *)v1 + 1) = v4;
    *((_DWORD *)v1 + 2) = v5;
    *((_DWORD *)v1 + 3) = v6;
    v1 += 16;
  }
  while ( v2 != (int *)&unk_676E10 );
  v7 = v2[1];
  *(_DWORD *)v1 = *v2;
  *((_DWORD *)v1 + 1) = v7;
  strcpy(v19, "{\"code\":0,\"error\":\"\",\"data\":{");
  v8 = (const char *)nvram_get("usblogd_en");
  if ( !v8 )
    v8 = "0";
  v9 = (const char *)nvram_get("usblog_time_h");
  if ( v9 )
  {
    v10 = (const char *)nvram_get("usblog_time_m");
    if ( v10 )
      goto LABEL_7;
  }
  else
  {
    v10 = (const char *)nvram_get("usblog_time_m");
    v9 = "20";
    if ( v10 )
      goto LABEL_7;
  }
  v10 = "25";
LABEL_7:
  v11 = sprintf(&v19[29], "\"usblogd_en\":\"%s\",\"time_h\":\"%s\",\"time_m\":\"%s\",\"list\":[", v8, v9, v10) + 29;
  if ( get_usb_mount_dir(v20, 256) )
  {
    v25 = &v26;
    v15 = (const char **)&v24;
    do
    {
      sprintf(v21, "%s/%s", v20, *v15);
      memset(v22, 0, sizeof(v22));
      stat(v21, (struct stat *)v22);
      v16 = (int)*(v15 - 1);
      v15 += 2;
      v18 = (const char *)_GET_LANG_TEXT(v16, *(unsigned __int8 *)(a1 + 210102), v17);
      v11 += sprintf(&v19[v11], "{\"name\":\"%s\",\"file\":\"%s\",\"size\":%lld},", v18, v21, *(_QWORD *)&v22[56]);
    }
    while ( v25 != (char *)v15 );
  }
  if ( v11 > 0 && v19[v11 - 1] == 44 )
    --v11;
  v12 = v11 + 1;
  *(_WORD *)&v19[v11] = 93;
  v13 = snprintf(&v19[v11 + 1], 10240 - (v11 + 1), "}}");
  if ( v13 >= 10240 - (v11 + 1) )
    v13 = 10239 - v12;
  return httpd_cgi_ret(a1, v19, v13 + v12, 4);
}
// 4B01BC: variable 'v17' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A864C: using guessed type int __fastcall get_usb_mount_dir(_DWORD, _DWORD);

//----- (004B0240) --------------------------------------------------------
int __fastcall sub_4B0240(int a1)
{
  char *v2; // $s1
  char *v3; // $s3
  char *v4; // $s4
  char *v5; // $v0
  char *v6; // $s5
  const char *v7; // $s6
  int v8; // $a0
  char *v9; // $v1
  const char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  unsigned int v15; // $a2
  int v16; // $a2
  int v17; // $t0
  int v18; // $a3
  int v19; // $a2
  int v20; // $a1
  int v21; // $a1
  const char *v22; // $a2
  const char *v23; // $v0
  char v25[1024]; // [sp+20h] [-400h] BYREF

  v2 = httpd_get_parm(a1, "opt");
  v3 = httpd_get_parm(a1, "path");
  v4 = httpd_get_parm(a1, "time_h");
  v6 = httpd_get_parm(a1, "time_m");
  v5 = httpd_get_parm(a1, "usblogd_en");
  if ( !v2 )
  {
LABEL_17:
    v21 = *(unsigned __int8 *)(a1 + 210102);
    v22 = "not opt";
LABEL_18:
    v23 = (const char *)_GET_LANG_TEXT(12, v21, v22);
    goto LABEL_19;
  }
  v7 = v5;
  if ( strcmp(v2, "del") )
  {
    if ( !strcmp(v2, "set") )
    {
      if ( v4 && v6 && v7 )
      {
        if ( !strcmp(v7, "1") )
          nvram_set("usblogd_en", "1");
        else
          nvram_set("usblogd_en", "0");
        nvram_set("usblog_time_h", v4);
        nvram_set("usblog_time_m", v6);
        jhl_parm_commit(v8);
        usblogd_check_restart();
        v9 = v25;
        v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
        do
        {
          v11 = *(_DWORD *)v10;
          v12 = *((_DWORD *)v10 + 1);
          v13 = *((_DWORD *)v10 + 2);
          v14 = *((_DWORD *)v10 + 3);
          v10 += 16;
          *(_DWORD *)v9 = v11;
          *((_DWORD *)v9 + 1) = v12;
          *((_DWORD *)v9 + 2) = v13;
          *((_DWORD *)v9 + 3) = v14;
          v9 += 16;
        }
        while ( v10 != "}" );
        goto LABEL_11;
      }
      v21 = *(unsigned __int8 *)(a1 + 210102);
      v22 = (const char *)&unk_64E0EC;
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if ( !v3 )
  {
    v21 = *(unsigned __int8 *)(a1 + 210102);
    v22 = (const char *)&unk_64E0E0;
    goto LABEL_18;
  }
  if ( !remove(v3) )
  {
    v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v9 = v25;
    do
    {
      v17 = *(_DWORD *)v10;
      v18 = *((_DWORD *)v10 + 1);
      v19 = *((_DWORD *)v10 + 2);
      v20 = *((_DWORD *)v10 + 3);
      v10 += 16;
      *(_DWORD *)v9 = v17;
      *((_DWORD *)v9 + 1) = v18;
      *((_DWORD *)v9 + 2) = v19;
      *((_DWORD *)v9 + 3) = v20;
      v9 += 16;
    }
    while ( v10 != "}" );
LABEL_11:
    v15 = 33;
    *(_WORD *)v9 = *(_WORD *)v10;
    return httpd_cgi_ret(a1, v25, v15, 4);
  }
  v23 = (const char *)_GET_LANG_TEXT(60, *(unsigned __int8 *)(a1 + 210102), v16);
LABEL_19:
  v15 = snprintf(v25, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v23);
  if ( v15 >= 0x400 )
    v15 = 1023;
  return httpd_cgi_ret(a1, v25, v15, 4);
}
// 4B03D8: variable 'v8' is possibly undefined
// 4B0564: variable 'v16' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A894C: using guessed type int usblogd_check_restart(void);

//----- (004B05C8) --------------------------------------------------------
int __fastcall sub_4B05C8(int a1)
{
  char *v2; // $fp
  char *v3; // $s7
  char *v4; // $s6
  char *v5; // $s5
  char *v6; // $s4
  char *v7; // $s2
  int v8; // $s1
  int v9; // $a0
  char *v10; // $a1
  const char *v11; // $v0
  int v12; // $v0
  int *v13; // $v1
  const char *v14; // $v0
  int v15; // $t0
  int v16; // $a3
  int v17; // $a2
  int v18; // $a1
  int v20[64]; // [sp+18h] [-138h] BYREF
  char *v21; // [sp+118h] [-38h]
  char *v22; // [sp+11Ch] [-34h]
  char *v23; // [sp+120h] [-30h]
  char *v24; // [sp+124h] [-2Ch]
  char *v25; // [sp+128h] [-28h]
  char *v26; // [sp+12Ch] [-24h]
  char *v27; // [sp+130h] [-20h]
  char *v28; // [sp+134h] [-1Ch]
  char *v29; // [sp+138h] [-18h]
  char *v30; // [sp+13Ch] [-14h]
  char *v31; // [sp+140h] [-10h]
  char *v32; // [sp+144h] [-Ch]
  char *v33; // [sp+148h] [-8h]

  v25 = "1\"";
  v26 = "1\"";
  v27 = "1\"";
  v2 = httpd_get_parm(a1, "wan_3g_isp");
  v28 = "1\"";
  v3 = httpd_get_parm(a1, "wan_3g_apn");
  v29 = "1\"";
  v4 = httpd_get_parm(a1, "wan_3g_dial");
  v30 = "1\"";
  v5 = httpd_get_parm(a1, "wan_3g_pin");
  v31 = "1\"";
  v6 = httpd_get_parm(a1, "wan_3g_user");
  v32 = "1\"";
  v21 = httpd_get_parm(a1, "wan_3g_pass");
  v33 = "1\"";
  v7 = httpd_get_parm(a1, "wan_3g_connect_mode");
  v22 = httpd_get_parm(a1, "g3_warn_bytes");
  v23 = httpd_get_parm(a1, "g3_warn_time");
  v8 = jhl_get_3g_iface();
  v24 = httpd_get_parm(a1, "user_mode");
  v10 = httpd_get_parm(a1, "wan_3g_enable");
  if ( v10 )
    nvram_set("wan_3g_enable", v10);
  if ( v2 )
    nvram_set(v25 - 9184, v2);
  if ( v3 )
    nvram_set(v26 - 9172, v3);
  if ( v4 )
    nvram_set(v27 - 9160, v4);
  if ( v5 )
    nvram_set(v28 - 9148, v5);
  if ( v6 )
    nvram_set(v29 - 9136, v6);
  if ( v21 )
    nvram_set(v30 - 9124, v21);
  if ( v7 )
    nvram_set(v31 - 9112, v7);
  if ( v22 )
    nvram_set(v32 - 9072, v22);
  if ( v23 )
    nvram_set(v33 - 9056, v23);
  if ( v24 )
    nvram_set("wan_3g_user_mode", v24);
  if ( v8 >= 0 )
  {
    v11 = (const char *)nvram_get("wan_3g_enable");
    if ( v11 && !strncmp(v11, "enable", 6u) )
    {
      v20[0] = 0;
      v20[1] = 0;
      v20[2] = 0;
      v20[3] = 0;
      sprintf((char *)v20, "ppp%d", v8);
      jhl_set_wan_name(v8, v20);
      v12 = jhl_nvget("wan_proto", v8);
      nvram_set(v12, "3G");
      if ( !strncmp(v7, "auto", 4u) )
      {
        jhl_start_redial(v8);
      }
      else
      {
        jhl_stop_redial(v8);
        jhl_stop_3g(v8);
        system("echo -n \"WAN 4G manual connect\" >/var/3gstatus");
      }
    }
    else
    {
      jhl_stop_redial(v8);
      jhl_stop_3g(v8);
      system("echo -n \"WAN 4G manual connect\" >/var/3gstatus");
    }
  }
  jhl_parm_commit(v9);
  v13 = v20;
  v14 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v15 = *(_DWORD *)v14;
    v16 = *((_DWORD *)v14 + 1);
    v17 = *((_DWORD *)v14 + 2);
    v18 = *((_DWORD *)v14 + 3);
    v14 += 16;
    *v13 = v15;
    v13[1] = v16;
    v13[2] = v17;
    v13[3] = v18;
    v13 += 4;
  }
  while ( v14 != "}" );
  *(_WORD *)v13 = *(_WORD *)v14;
  return httpd_cgi_ret(a1, (char *)v20, 33, 4);
}
// 4B0A60: variable 'v9' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82AC: using guessed type int __fastcall jhl_set_wan_name(_DWORD, _DWORD);
// 6A8504: using guessed type int __fastcall jhl_stop_3g(_DWORD);
// 6A85A8: using guessed type int __fastcall jhl_start_redial(_DWORD);
// 6A880C: using guessed type int jhl_get_3g_iface(void);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89A8: using guessed type int __fastcall jhl_stop_redial(_DWORD);

//----- (004B0B54) --------------------------------------------------------
int __fastcall sub_4B0B54(int a1)
{
  int v2; // $s5
  int v3; // $v0
  int v4; // $s1
  ssize_t v5; // $s4
  int v6; // $s0
  const char *v7; // $a2
  int v8; // $s0
  unsigned int v9; // $v0
  int v11; // $v0
  char v12[1024]; // [sp+18h] [-444h] BYREF
  char v13[68]; // [sp+418h] [-44h] BYREF

  v2 = jhl_get_3g_iface();
  memset(v13, 0, 0x40u);
  v3 = open("/var/3gstatus", 0);
  if ( v3 < 0 || (v4 = v3, v5 = read(v3, v13, 0x40u), close(v4), v5 < 8) )
    strcpy(v13, "Disconnect");
  else
    v12[v5 + 1024] = 0;
  strcpy(v12, "{\"code\":0,\"error\":\"\",\"data\":{");
  v6 = sprintf(&v12[29], "\"usb_3g_status\":\"%s\"", v13) + 29;
  if ( jhl_check_wanup(v2) )
  {
    v11 = jhl_nvget("ppp_get_ip", v2);
    v7 = (const char *)nvram_get(v11);
  }
  else
  {
    v7 = "0.0.0.0";
  }
  v8 = v6 + sprintf(&v12[v6], ",\"ip\":\"%s\"", v7);
  v9 = snprintf(&v12[v8], 1024 - v8, "}}");
  if ( v9 >= 1024 - v8 )
    v9 = 1023 - v8;
  return httpd_cgi_ret(a1, v12, v9 + v8, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A880C: using guessed type int jhl_get_3g_iface(void);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (004B0DA8) --------------------------------------------------------
int __fastcall sub_4B0DA8(int a1)
{
  char *v1; // $v0
  const char *v3; // $s0
  int v4; // $s2
  const char *v5; // $v0
  char *v6; // $v1
  int v7; // $t1
  int v8; // $t0
  int v9; // $a3
  int v10; // $a2
  char *v12; // $v0
  int v13; // $a0
  char v14[512]; // [sp+18h] [-200h] BYREF

  v1 = httpd_get_parm(a1, "act");
  if ( v1 )
  {
    v3 = v1;
    v4 = jhl_get_3g_iface();
    if ( v4 >= 0 )
    {
      if ( !strcmp(v3, "stop") )
      {
        jhl_stop_3g(v4);
      }
      else if ( !strcmp(v3, "restart") )
      {
        v12 = (char *)nvram_get("wan_3g_connect_mode");
        if ( !v12 )
          v12 = "";
        if ( !memcmp(v12, "manual", 6u) )
          jhl_start_3g(v4);
      }
      else if ( !strcmp(v3, "empty") )
      {
        jhl_stop_3g(v4);
        nvram_set("saved_3g_flow", "0");
        nvram_set("saved_3g_flow_tmp", "0");
        jhl_parm_commit(v13);
      }
    }
  }
  v5 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v6 = v14;
  do
  {
    v7 = *(_DWORD *)v5;
    v8 = *((_DWORD *)v5 + 1);
    v9 = *((_DWORD *)v5 + 2);
    v10 = *((_DWORD *)v5 + 3);
    v5 += 16;
    *(_DWORD *)v6 = v7;
    *((_DWORD *)v6 + 1) = v8;
    *((_DWORD *)v6 + 2) = v9;
    *((_DWORD *)v6 + 3) = v10;
    v6 += 16;
  }
  while ( v5 != "}" );
  *(_WORD *)v6 = *(_WORD *)v5;
  return httpd_cgi_ret(a1, v14, 33, 4);
}
// 4B0F98: variable 'v13' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8504: using guessed type int __fastcall jhl_stop_3g(_DWORD);
// 6A880C: using guessed type int jhl_get_3g_iface(void);
// 6A884C: using guessed type int __fastcall jhl_start_3g(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004B0FD4) --------------------------------------------------------
int __fastcall usb_upload_do_rcv(int a1)
{
  char *v2; // $v0
  int v3; // $a2
  int v4; // $v1
  const char *v5; // $s5
  void *v6; // $a0
  int v7; // $v0
  FILE *v8; // $a0
  FILE *v9; // $v0
  int v10; // $a2
  int v11; // $a1
  int v12; // $s7
  const void *v13; // $s6
  char *v14; // $a0
  void *v15; // $s7
  int v16; // $v0
  unsigned int v17; // $a2
  int v18; // $s2
  int v19; // $v0
  int v20; // $v0
  _BYTE *v21; // $a1
  _BYTE *v22; // $a0
  int v23; // $a2
  int v24; // $a1
  int v25; // $v0
  const void *v26; // $a0
  size_t v27; // $s2
  int v28; // $s7
  size_t v29; // $v0
  int v30; // $a0
  int v31; // $a1
  char *v32; // $v0
  FILE *v33; // $a0
  void *v34; // $a0
  const char *v35; // $a3
  char *v36; // $a0
  int v37; // $a2
  FILE *v38; // $a0
  void *v39; // $a0
  int v40; // $a2
  char *v41; // $v0
  unsigned int v42; // $v0
  int result; // $v0
  int v44; // $s2
  ssize_t v45; // $v0
  int v46; // $v0
  int v47; // $a1
  void *v48; // $s7
  int v49; // $v0
  int v50; // $v0
  _BYTE *v51; // $a1
  _BYTE *v52; // $a0
  int v53; // $a2
  int v54; // $v0
  int v55; // $v0
  int v56; // $s2
  bool v57; // dc
  _DWORD *v58; // $v0
  _DWORD *v59; // $v1
  _DWORD *v60; // $a0
  int v61; // $a1
  int v62; // $a3
  int v63; // $a2
  int v64; // $v1
  char *v65; // $v0
  int v66; // $v0
  int v67; // $fp
  char v68[512]; // [sp+20h] [-680h] BYREF
  char v69[512]; // [sp+220h] [-480h] BYREF
  int v70[128]; // [sp+420h] [-280h] BYREF
  char v71[128]; // [sp+620h] [-80h] BYREF

  memset(v71, 0, sizeof(v71));
  memset(v69, 0, sizeof(v69));
  memset(v68, 0, sizeof(v68));
  v2 = httpd_get_parm(a1, "filename");
  v4 = *(unsigned __int8 *)(a1 + 41);
  v5 = v2;
  if ( *(_BYTE *)(a1 + 41) )
  {
    if ( v4 != 7 )
    {
      if ( v4 != 8 )
      {
        v31 = *(unsigned __int8 *)(a1 + 210102);
        v30 = 13;
        goto LABEL_21;
      }
      v44 = a1 + 196608;
      if ( !*(_DWORD *)(a1 + 209984) )
      {
        v45 = recv(
                *(_DWORD *)(a1 + 205416),
                (void *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)),
                102400 - *(_DWORD *)(a1 + 209704),
                0);
        if ( v45 )
        {
          if ( v45 > 0 )
          {
LABEL_59:
            v24 = v45 + *(_DWORD *)(a1 + 209704);
            *(_DWORD *)(a1 + 209704) = v24;
            v13 = (const void *)(a1 + 209708);
            goto LABEL_17;
          }
        }
        else
        {
          result = 0;
          if ( *(_BYTE *)(a1 + 210101) )
            return result;
        }
        v31 = *(unsigned __int8 *)(a1 + 210102);
        v30 = 140;
        goto LABEL_21;
      }
      v45 = https_ssl_read(a1);
      if ( v45 == -2 )
      {
        v24 = *(_DWORD *)(a1 + 209704);
        v13 = (const void *)(a1 + 209708);
        goto LABEL_17;
      }
      if ( v45 >= 0 )
      {
        if ( !v45 )
          goto LABEL_23;
        goto LABEL_59;
      }
      result = 0;
      if ( *(_BYTE *)(a1 + 210101) )
        return result;
LABEL_72:
      v31 = *(unsigned __int8 *)(v44 + 13494);
      v30 = 140;
      goto LABEL_21;
    }
    v44 = a1 + 196608;
    if ( *(_DWORD *)(a1 + 209984) )
    {
      v46 = https_ssl_read(a1);
      if ( v46 == -2 )
      {
        v47 = *(_DWORD *)(a1 + 209704);
        goto LABEL_52;
      }
      if ( !v46 )
        goto LABEL_23;
      if ( v46 < 0 )
        goto LABEL_72;
    }
    else
    {
      v46 = recv(
              *(_DWORD *)(a1 + 205416),
              (void *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)),
              102400 - *(_DWORD *)(a1 + 209704),
              0);
      if ( v46 < 0 )
        goto LABEL_72;
      if ( !v46 )
        goto LABEL_23;
    }
    v47 = v46 + *(_DWORD *)(a1 + 209704);
    *(_DWORD *)(a1 + 209704) = v47;
LABEL_52:
    if ( *(_DWORD *)(a1 + 209836) )
    {
      v48 = *(void **)(a1 + 209700);
    }
    else
    {
      search_str(*(char **)(a1 + 209700), v47, "\r\n", 2u);
      v48 = *(void **)(a1 + 209700);
      v67 = v66 - (_DWORD)v48;
      if ( v66 )
      {
        *(_BYTE *)(a1 + 209708) = 13;
        *(_BYTE *)(a1 + 209709) = 10;
        memcpy((void *)(a1 + 209710), v48, v67);
        v47 = *(_DWORD *)(a1 + 209704);
        *(_DWORD *)(a1 + 209836) = v67 + 2;
      }
      else
      {
        v47 = *(_DWORD *)(a1 + 209704);
      }
    }
    search_str((char *)v48, v47, "filename=", 9u);
    if ( !v49
      || (search_str((char *)(v49 + 9), *(_DWORD *)(a1 + 209704) - (v49 + 9 - *(_DWORD *)(a1 + 209700)), "\r\n\r\n", 4u),
          v51 = (_BYTE *)(v50 + 4),
          !v50) )
    {
      if ( *(_DWORD *)(a1 + 209704) == 102400 )
      {
        v58 = *(_DWORD **)(a1 + 209700);
        v59 = v58 + 12800;
        v60 = v58 + 25600;
        do
        {
          v61 = v59[3];
          v62 = v59[1];
          v63 = v59[2];
          *v58 = *v59;
          v58[1] = v62;
          v58[2] = v63;
          v59 += 4;
          v58[3] = v61;
          v58 += 4;
        }
        while ( v59 != v60 );
        v64 = *(_DWORD *)(a1 + 209700) + 0x10000;
        *(_DWORD *)(a1 + 209704) = 51200;
        *(_BYTE *)(v64 - 14336) = 0;
      }
      goto LABEL_61;
    }
    v52 = *(_BYTE **)(a1 + 209700);
    v53 = *(_DWORD *)(a1 + 209704) - (v51 - v52);
    *(_DWORD *)(a1 + 209704) = v53;
    memmove(v52, v51, v53);
    *(_BYTE *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)) = 0;
    *(_BYTE *)(a1 + 41) = 8;
    v24 = *(_DWORD *)(a1 + 209704);
    v13 = (const void *)(a1 + 209708);
    goto LABEL_17;
  }
  v6 = *(void **)(a1 + 209700);
  if ( v6 )
  {
    _mem_free(v6);
    *(_DWORD *)(a1 + 209700) = 0;
  }
  *(_DWORD *)(a1 + 209704) = 0;
  _mem_malloc(102400, "usb_upload_do_rcv", 1568);
  *(_DWORD *)(a1 + 209700) = v7;
  if ( !v7 )
  {
    v32 = (char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    goto LABEL_22;
  }
  snprintf(v69, 512, "/tmp/mnt/sda1/upload/%s", v5);
  snprintf(v68, 512, "/tmp/mnt/sda1/tmp/%s", v5);
  create_dir2(v69);
  create_dir2(v68);
  v8 = *(FILE **)(a1 + 209696);
  if ( v8 )
  {
    fclose(v8);
    *(_DWORD *)(a1 + 209696) = 0;
  }
  v9 = fopen(v68, "wb");
  *(_DWORD *)(a1 + 209696) = v9;
  if ( !v9 )
  {
    v65 = (char *)_GET_LANG_TEXT(181, *(unsigned __int8 *)(a1 + 210102), v10);
    strcpy(v71, v65);
    goto LABEL_23;
  }
  v11 = *(_DWORD *)(a1 + 205484);
  v12 = *(_DWORD *)(a1 + 205364) - v11;
  *(_DWORD *)(a1 + 209704) = v12;
  if ( v12 > 0 )
  {
    memcpy(*(void **)(a1 + 209700), (void *)(a1 + v11 + 564), v12);
    v12 = *(_DWORD *)(a1 + 209704);
  }
  v13 = (const void *)(a1 + 209708);
  *(_DWORD *)(a1 + 205560) = usb_upload_do_rcv;
  memset((void *)(a1 + 209708), 0, 0x80u);
  v14 = *(char **)(a1 + 209700);
  *(_DWORD *)(a1 + 209836) = 0;
  search_str(v14, v12, "\r\n", 2u);
  v15 = *(void **)(a1 + 209700);
  v17 = v16 - (_DWORD)v15;
  if ( v16 )
  {
    v18 = 126;
    if ( v17 >= 0x7D )
      v17 = 124;
    else
      v18 = v17 + 2;
    *(_BYTE *)(a1 + 209708) = 13;
    *(_BYTE *)(a1 + 209709) = 10;
    memcpy((void *)(a1 + 209710), v15, v17);
    *(_DWORD *)(a1 + 209836) = v18;
  }
  search_str((char *)v15, *(_DWORD *)(a1 + 209704), "filename=", 9u);
  if ( !v19
    || (search_str((char *)(v19 + 9), *(_DWORD *)(a1 + 209704) - (v19 + 9 - *(_DWORD *)(a1 + 209700)), "\r\n\r\n", 4u),
        v21 = (_BYTE *)(v20 + 4),
        !v20) )
  {
    *(_BYTE *)(a1 + 41) = 7;
    goto LABEL_61;
  }
  v22 = *(_BYTE **)(a1 + 209700);
  v23 = *(_DWORD *)(a1 + 209704) - (v21 - v22);
  *(_DWORD *)(a1 + 209704) = v23;
  memmove(v22, v21, v23);
  *(_BYTE *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)) = 0;
  *(_BYTE *)(a1 + 41) = 8;
  v24 = *(_DWORD *)(a1 + 209704);
LABEL_17:
  search_str(*(char **)(a1 + 209700), v24, v13, *(_DWORD *)(a1 + 209836));
  if ( v25 )
  {
    v26 = *(const void **)(a1 + 209700);
    v27 = v25 - (_DWORD)v26;
    v28 = 1;
    if ( v25 - (int)v26 <= 0 )
    {
LABEL_32:
      v38 = *(FILE **)(a1 + 209696);
      if ( v38 )
      {
        fclose(v38);
        *(_DWORD *)(a1 + 209696) = 0;
      }
      v39 = *(void **)(a1 + 209700);
      if ( v39 )
      {
        _mem_free(v39);
        *(_DWORD *)(a1 + 209700) = 0;
      }
      *(_DWORD *)(a1 + 209704) = 0;
      snprintf(v69, 512, "/tmp/mnt/sda1/upload/%s", v5);
      snprintf(v68, 512, "/tmp/mnt/sda1/tmp/%s", v5);
      v70[0] = (int)&unk_4D17B4;
      v70[1] = (int)"-f";
      v70[2] = (int)v68;
      v70[3] = (int)v69;
      v70[4] = 0;
      eval(v70, 0, 0, 0);
      v41 = (char *)_GET_LANG_TEXT(182, *(unsigned __int8 *)(a1 + 210102), v40);
      strcpy(v71, v41);
      httpd_release_caches();
      v35 = "true";
      goto LABEL_37;
    }
  }
  else
  {
    v55 = *(_DWORD *)(a1 + 209704);
    v56 = *(_DWORD *)(a1 + 209836);
    v57 = v56 >= v55;
    v27 = v55 - v56;
    if ( v57 )
      goto LABEL_61;
    v26 = *(const void **)(a1 + 209700);
    v28 = 0;
  }
  v29 = fwrite(v26, 1u, v27, *(FILE **)(a1 + 209696));
  v30 = 141;
  if ( v29 == v27 )
  {
    fflush(*(FILE **)(a1 + 209696));
    v36 = *(char **)(a1 + 209700);
    v37 = *(_DWORD *)(a1 + 209704) - v27;
    *(_DWORD *)(a1 + 209704) = v37;
    memmove(v36, &v36[v27], v37);
    *(_BYTE *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)) = 0;
    if ( v28 )
      goto LABEL_32;
LABEL_61:
    v54 = jiffies_get();
    mod_timer(a1 + 205540, v54 + 30000);
    return 0;
  }
  v31 = *(unsigned __int8 *)(a1 + 210102);
LABEL_21:
  v32 = (char *)_GET_LANG_TEXT(v30, v31, v3);
LABEL_22:
  strcpy(v71, v32);
LABEL_23:
  v33 = *(FILE **)(a1 + 209696);
  if ( v33 )
  {
    fclose(v33);
    *(_DWORD *)(a1 + 209696) = 0;
  }
  v34 = *(void **)(a1 + 209700);
  if ( v34 )
  {
    _mem_free(v34);
    *(_DWORD *)(a1 + 209700) = 0;
  }
  *(_DWORD *)(a1 + 209704) = 0;
  snprintf(v68, 512, "/tmp/mnt/sda1/tmp/%s", v5);
  unlink(v68);
  httpd_release_caches();
  v35 = "false";
LABEL_37:
  v42 = snprintf((char *)v70, 512, "{\"success\":%s,\"message\":\"%s\"}", v35, v71);
  if ( v42 >= 0x200 )
    v42 = 511;
  return httpd_cgi_ret(a1, (char *)v70, v42, 4);
}
// 4B10EC: variable 'v7' is possibly undefined
// 4B1240: variable 'v16' is possibly undefined
// 4B12B0: variable 'v19' is possibly undefined
// 4B12E4: variable 'v20' is possibly undefined
// 4B1344: variable 'v25' is possibly undefined
// 4B1394: variable 'v3' is possibly undefined
// 4B15FC: variable 'v40' is possibly undefined
// 4B17C4: variable 'v49' is possibly undefined
// 4B1800: variable 'v50' is possibly undefined
// 4B19D0: variable 'v10' is possibly undefined
// 4B1A64: variable 'v66' is possibly undefined
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8584: using guessed type int __fastcall create_dir2(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (004B1AE4) --------------------------------------------------------
int __fastcall sub_4B1AE4(int a1)
{
  char *v2; // $v0
  int v3; // $a2
  char *v4; // $s5
  const char *v5; // $s6
  unsigned int v6; // $fp
  int v7; // $a2
  int v8; // $a2
  int v9; // $a1
  int v10; // $a0
  char *v11; // $v0
  unsigned int v12; // $v0
  char *v14; // $v0
  char v15[512]; // [sp+58h] [-528h] BYREF
  char v16[512]; // [sp+258h] [-328h] BYREF
  char v17[128]; // [sp+458h] [-128h] BYREF
  char v18[104]; // [sp+4D8h] [-A8h] BYREF
  char v19[64]; // [sp+540h] [-40h] BYREF

  memset(v15, 0, sizeof(v15));
  memset(v19, 0, sizeof(v19));
  memset(v17, 0, sizeof(v17));
  v4 = httpd_get_parm(a1, "filename");
  v2 = httpd_get_parm(a1, "sign");
  if ( v4 && (v5 = v2) != 0 )
  {
    v6 = snprintf(v16, 512, "%s%s", v4, "d1d7855dc37411e387c300163e0c16e5");
    MD5Init(v18);
    v7 = v6;
    if ( v6 >= 0x200 )
      v7 = 511;
    MD5Update(v18, v16, v7);
    MD5Final(v18);
    snprintf(
      v19,
      64,
      "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
      (unsigned __int8)v18[88],
      (unsigned __int8)v18[89],
      (unsigned __int8)v18[90],
      (unsigned __int8)v18[91],
      (unsigned __int8)v18[92],
      (unsigned __int8)v18[93],
      (unsigned __int8)v18[94],
      (unsigned __int8)v18[95],
      (unsigned __int8)v18[96],
      (unsigned __int8)v18[97],
      (unsigned __int8)v18[98],
      (unsigned __int8)v18[99],
      (unsigned __int8)v18[100],
      (unsigned __int8)v18[101],
      (unsigned __int8)v18[102],
      (unsigned __int8)v18[103]);
    if ( !strcmp(v5, v19) )
    {
      if ( check_usb_state() )
      {
        snprintf(v15, 512, "/tmp/mnt/sda1/upload/%s", v4);
        if ( !f_exists(v15) )
          return usb_upload_do_rcv(a1);
        v9 = *(unsigned __int8 *)(a1 + 210102);
        v10 = 187;
      }
      else
      {
        v9 = *(unsigned __int8 *)(a1 + 210102);
        v10 = 186;
      }
    }
    else
    {
      v9 = *(unsigned __int8 *)(a1 + 210102);
      v10 = 185;
    }
    v11 = (char *)_GET_LANG_TEXT(v10, v9, v8);
    strcpy(v17, v11);
  }
  else
  {
    v14 = (char *)_GET_LANG_TEXT(183, *(unsigned __int8 *)(a1 + 210102), v3);
    strcpy(v17, v14);
  }
  v12 = snprintf(v16, 512, "{\"success\":%s,\"message\":\"%s\"}", "false", v17);
  if ( v12 >= 0x200 )
    v12 = 511;
  return httpd_cgi_ret(a1, v16, v12, 4);
}
// 4B1D08: variable 'v8' is possibly undefined
// 4B1E3C: variable 'v3' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8384: using guessed type int __fastcall MD5Init(_DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);
// 6A8850: using guessed type int __fastcall MD5Final(_DWORD);
// 6A88E0: using guessed type int check_usb_state(void);
// 6A8928: using guessed type int __fastcall MD5Update(_DWORD, _DWORD, _DWORD);

//----- (004B1E94) --------------------------------------------------------
int __fastcall usb_upload_do_rcv2(int a1)
{
  char *v2; // $s1
  int v3; // $a2
  char *v4; // $s6
  char *v5; // $v0
  const char *v6; // $s2
  int v7; // $v0
  void *v8; // $a0
  char *v9; // $v0
  int v10; // $a1
  int v11; // $s7
  char *v12; // $fp
  const void *v13; // $s4
  void *v14; // $s7
  int v15; // $v0
  unsigned int v16; // $a2
  int v17; // $fp
  int v18; // $v0
  int v19; // $fp
  const char *v20; // $s1
  int v21; // $v1
  char *v22; // $s7
  _BYTE *v23; // $a1
  _BYTE *v24; // $a0
  FILE *v25; // $a0
  FILE *v26; // $v0
  int v27; // $a2
  int v28; // $a1
  char *v29; // $v0
  int v30; // $v0
  _BYTE *v31; // $a1
  _BYTE *v32; // $a0
  int v33; // $a2
  _DWORD *v34; // $v1
  int v35; // $a1
  int v36; // $v0
  const void *v37; // $a0
  size_t v38; // $s4
  int v39; // $s7
  size_t v40; // $v0
  int v41; // $a0
  int v42; // $a1
  char *v43; // $v0
  FILE *v44; // $a0
  void *v45; // $a0
  int v46; // $s1
  char *v47; // $a0
  int v48; // $a2
  FILE *v49; // $a0
  void *v50; // $a0
  int v51; // $a2
  int v52; // $a1
  char *v53; // $v0
  int v54; // $a1
  const char *v55; // $v0
  unsigned int v56; // $v0
  int result; // $v0
  int v58; // $v0
  const char *v59; // $v0
  int v60; // $v0
  int v61; // $a1
  void *v62; // $s7
  int v63; // $v0
  int v64; // $s7
  int v65; // $v0
  _BYTE *v66; // $a0
  _BYTE *v67; // $v1
  FILE *v68; // $a0
  FILE *v69; // $v0
  int v70; // $v0
  _BYTE *v71; // $a1
  _BYTE *v72; // $a0
  int v73; // $a2
  _DWORD *v74; // $v0
  _DWORD *v75; // $v1
  _DWORD *v76; // $a0
  int v77; // $a1
  int v78; // $a3
  int v79; // $a2
  int v80; // $v1
  int v81; // $v0
  int v82; // $v0
  int v83; // $s4
  bool v84; // dc
  int v85; // $a1
  char *v86; // $v0
  char *v87; // $v0
  int v88; // $v0
  int v89; // $fp
  char v90[512]; // [sp+20h] [-488h] BYREF
  char v91[512]; // [sp+220h] [-288h] BYREF
  char v92[128]; // [sp+420h] [-88h] BYREF
  _DWORD *v93; // [sp+4A0h] [-8h]

  memset(v92, 0, sizeof(v92));
  memset(v90, 0, sizeof(v90));
  v2 = httpd_get_parm(a1, "path");
  v4 = httpd_find_ext_name(*(const char **)(a1 + 44));
  if ( !v2 || (v5 = strstr(v2, "/usb/")) == 0 || (v6 = v5 + 5, v5 == (char *)-5) )
    v6 = "";
  v7 = *(unsigned __int8 *)(a1 + 41);
  if ( !*(_BYTE *)(a1 + 41) )
  {
    v8 = *(void **)(a1 + 209700);
    if ( v8 )
    {
      _mem_free(v8);
      *(_DWORD *)(a1 + 209700) = 0;
    }
    *(_DWORD *)(a1 + 209704) = 0;
    _mem_malloc(102400, "usb_upload_do_rcv2", 2055);
    *(_DWORD *)(a1 + 209700) = v9;
    if ( !v9 )
    {
      v87 = (char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
      strcpy(v92, v87);
      v20 = (const char *)(a1 + 209840);
      goto LABEL_34;
    }
    v10 = *(_DWORD *)(a1 + 205484);
    v11 = *(_DWORD *)(a1 + 205364) - v10;
    *(_DWORD *)(a1 + 209704) = v11;
    if ( v11 <= 0 )
    {
      v12 = v9;
    }
    else
    {
      memcpy(v9, (void *)(a1 + v10 + 564), v11);
      v12 = *(char **)(a1 + 209700);
      v11 = *(_DWORD *)(a1 + 209704);
    }
    v13 = (const void *)(a1 + 209708);
    *(_DWORD *)(a1 + 205560) = usb_upload_do_rcv2;
    memset((void *)(a1 + 209708), 0, 0x80u);
    *(_DWORD *)(a1 + 209836) = 0;
    search_str(v12, v11, "\r\n", 2u);
    v14 = *(void **)(a1 + 209700);
    v16 = v15 - (_DWORD)v14;
    if ( v15 )
    {
      if ( v16 >= 0x7D )
      {
        v17 = 126;
        v16 = 124;
      }
      else
      {
        v17 = v16 + 2;
      }
      *(_BYTE *)(a1 + 209708) = 13;
      *(_BYTE *)(a1 + 209709) = 10;
      memcpy((void *)(a1 + 209710), v14, v16);
      *(_DWORD *)(a1 + 209836) = v17;
    }
    search_str((char *)v14, *(_DWORD *)(a1 + 209704), "filename=", 9u);
    v19 = v18;
    if ( !v18 )
      goto LABEL_86;
    v20 = (const char *)(a1 + 209840);
    memset((void *)(a1 + 209840), 0, 0x80u);
    v21 = *(unsigned __int8 *)(v19 + 10);
    v22 = (char *)(v19 + 10);
    if ( *(_BYTE *)(v19 + 10) )
    {
      v23 = (_BYTE *)(a1 + 209840);
      if ( v21 != 34 )
      {
        v24 = (_BYTE *)(v19 + 10);
        do
        {
          *v23 = v21;
          v21 = (unsigned __int8)*++v24;
          ++v23;
        }
        while ( *v24 && v24 != (_BYTE *)(v19 + 137) && v21 != 34 );
      }
    }
    snprintf(v90, 512, "/tmp/mnt/sda1/%s/%s", v6, (const char *)(a1 + 209840));
    create_dir2(v90);
    v25 = *(FILE **)(a1 + 209696);
    if ( v25 )
    {
      v93 = (_DWORD *)(a1 + 196608);
      fclose(v25);
      v93[3272] = 0;
    }
    v26 = fopen(v90, "wb");
    *(_DWORD *)(a1 + 209696) = v26;
    if ( v26 )
    {
      v28 = *(_DWORD *)(a1 + 209704);
      v29 = &v22[-*(_DWORD *)(a1 + 209700)];
      v93 = (_DWORD *)(a1 + 196608);
      search_str(v22, v28 - (_DWORD)v29, "\r\n\r\n", 4u);
      v31 = (_BYTE *)(v30 + 4);
      if ( v30 )
      {
        v32 = (_BYTE *)v93[3273];
        v33 = v93[3274] - (v31 - v32);
        v93[3274] = v33;
        memmove(v32, v31, v33);
        v34 = v93;
        *(_BYTE *)(v93[3273] + v93[3274]) = 0;
        *(_BYTE *)(a1 + 41) = 8;
        v35 = v34[3274];
LABEL_26:
        search_str(*(char **)(a1 + 209700), v35, v13, *(_DWORD *)(a1 + 209836));
        if ( v36 )
        {
          v37 = *(const void **)(a1 + 209700);
          v38 = v36 - (_DWORD)v37;
          v39 = 1;
          if ( v36 - (int)v37 <= 0 )
            goto LABEL_41;
        }
        else
        {
          v82 = *(_DWORD *)(a1 + 209704);
          v83 = *(_DWORD *)(a1 + 209836);
          v84 = v83 >= v82;
          v38 = v82 - v83;
          if ( v84 )
            goto LABEL_85;
          v37 = *(const void **)(a1 + 209700);
          v39 = 0;
        }
        v40 = fwrite(v37, 1u, v38, *(FILE **)(a1 + 209696));
        v41 = 141;
        if ( v40 != v38 )
        {
          v42 = *(unsigned __int8 *)(a1 + 210102);
LABEL_33:
          v43 = (char *)_GET_LANG_TEXT(v41, v42, v3);
          strcpy(v92, v43);
          v20 = (const char *)(a1 + 209840);
LABEL_34:
          v44 = *(FILE **)(a1 + 209696);
          if ( v44 )
          {
            fclose(v44);
            *(_DWORD *)(a1 + 209696) = 0;
          }
          v45 = *(void **)(a1 + 209700);
          if ( v45 )
          {
            _mem_free(v45);
            *(_DWORD *)(a1 + 209700) = 0;
          }
          *(_DWORD *)(a1 + 209704) = 0;
          snprintf(v90, 512, "/tmp/mnt/sda1/%s/%s", v6, v20);
          v46 = -1;
          unlink(v90);
          httpd_release_caches();
          goto LABEL_46;
        }
        fflush(*(FILE **)(a1 + 209696));
        v47 = *(char **)(a1 + 209700);
        v48 = *(_DWORD *)(a1 + 209704) - v38;
        *(_DWORD *)(a1 + 209704) = v48;
        memmove(v47, &v47[v38], v48);
        *(_BYTE *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)) = 0;
        if ( v39 )
        {
LABEL_41:
          v49 = *(FILE **)(a1 + 209696);
          if ( v49 )
          {
            fclose(v49);
            *(_DWORD *)(a1 + 209696) = 0;
          }
          v50 = *(void **)(a1 + 209700);
          v51 = 2337;
          if ( v50 )
          {
            _mem_free(v50);
            *(_DWORD *)(a1 + 209700) = 0;
          }
          v52 = *(unsigned __int8 *)(a1 + 210102);
          *(_DWORD *)(a1 + 209704) = 0;
          v53 = (char *)_GET_LANG_TEXT(182, v52, v51);
          strcpy(v92, v53);
          v46 = 0;
          httpd_release_caches();
LABEL_46:
          sync();
          if ( v4 && !strcmp(v4, (const char *)&off_4CFE60) )
          {
            v54 = *(unsigned __int8 *)(a1 + 210102);
            if ( !v46 )
            {
              v59 = (const char *)_GET_LANG_TEXT(34, v54, v92);
              v56 = snprintf(v91, 512, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v59);
              if ( v56 >= 0x200 )
                v56 = 511;
              return httpd_cgi_ret(a1, v91, v56, 4);
            }
            v55 = (const char *)_GET_LANG_TEXT(33, v54, v92);
            v56 = snprintf(v91, 512, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v55);
            if ( v56 < 0x200 )
              return httpd_cgi_ret(a1, v91, v56, 4);
          }
          else
          {
            v56 = snprintf(
                    v91,
                    512,
                    "<html><head><script type='text/javascript'>function init(){alert('%s');window.parent.location.href='"
                    "/usb/%s';}</script><body onLoad='init();'></body></head></html>",
                    v92,
                    v6);
            if ( v56 < 0x200 )
              return httpd_cgi_ret(a1, v91, v56, 4);
          }
          v56 = 511;
          return httpd_cgi_ret(a1, v91, v56, 4);
        }
LABEL_85:
        v81 = jiffies_get();
        mod_timer(a1 + 205540, v81 + 30000);
        return 0;
      }
LABEL_86:
      *(_BYTE *)(a1 + 41) = 7;
      goto LABEL_85;
    }
    v85 = *(unsigned __int8 *)(a1 + 210102);
LABEL_90:
    v86 = (char *)_GET_LANG_TEXT(139, v85, v27);
    strcpy(v92, v86);
    goto LABEL_34;
  }
  if ( v7 == 7 )
  {
    if ( *(_DWORD *)(a1 + 209984) )
    {
      v60 = https_ssl_read(a1);
      if ( v60 == -2 )
      {
        v61 = *(_DWORD *)(a1 + 209704);
        goto LABEL_67;
      }
    }
    else
    {
      v60 = recv(
              *(_DWORD *)(a1 + 205416),
              (void *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)),
              102400 - *(_DWORD *)(a1 + 209704),
              0);
    }
    if ( v60 <= 0 )
    {
      v42 = *(unsigned __int8 *)(a1 + 210102);
      v41 = 140;
      goto LABEL_33;
    }
    v61 = v60 + *(_DWORD *)(a1 + 209704);
    *(_DWORD *)(a1 + 209704) = v61;
LABEL_67:
    if ( *(_DWORD *)(a1 + 209836) )
    {
      v62 = *(void **)(a1 + 209700);
    }
    else
    {
      search_str(*(char **)(a1 + 209700), v61, "\r\n", 2u);
      v62 = *(void **)(a1 + 209700);
      v89 = v88 - (_DWORD)v62;
      if ( v88 )
      {
        *(_BYTE *)(a1 + 209708) = 13;
        *(_BYTE *)(a1 + 209709) = 10;
        memcpy((void *)(a1 + 209710), v62, v89);
        v61 = *(_DWORD *)(a1 + 209704);
        *(_DWORD *)(a1 + 209836) = v89 + 2;
      }
      else
      {
        v61 = *(_DWORD *)(a1 + 209704);
      }
    }
    search_str((char *)v62, v61, "filename=", 9u);
    v64 = v63;
    if ( v63 )
    {
      v20 = (const char *)(a1 + 209840);
      memset((void *)(a1 + 209840), 0, 0x80u);
      v65 = *(unsigned __int8 *)(v64 + 10);
      if ( *(_BYTE *)(v64 + 10) )
      {
        v66 = (_BYTE *)(a1 + 209840);
        if ( v65 != 34 )
        {
          v67 = (_BYTE *)(v64 + 10);
          do
          {
            *v66 = v65;
            v65 = (unsigned __int8)*++v67;
            ++v66;
          }
          while ( *v67 && (_BYTE *)(v64 + 137) != v67 && v65 != 34 );
        }
      }
      snprintf(v90, 512, "/tmp/mnt/sda1/%s/%s", v6, (const char *)(a1 + 209840));
      create_dir2(v90);
      v68 = *(FILE **)(a1 + 209696);
      if ( v68 )
      {
        fclose(v68);
        *(_DWORD *)(a1 + 209696) = 0;
      }
      v69 = fopen(v90, "wb");
      *(_DWORD *)(a1 + 209696) = v69;
      if ( !v69 )
      {
        v85 = *(unsigned __int8 *)(a1 + 210102);
        goto LABEL_90;
      }
      search_str((char *)(v64 + 10), *(_DWORD *)(a1 + 209704) - (v64 + 10 - *(_DWORD *)(a1 + 209700)), "\r\n\r\n", 4u);
      v71 = (_BYTE *)(v70 + 4);
      if ( v70 )
      {
        v72 = *(_BYTE **)(a1 + 209700);
        v73 = *(_DWORD *)(a1 + 209704) - (v71 - v72);
        *(_DWORD *)(a1 + 209704) = v73;
        memmove(v72, v71, v73);
        *(_BYTE *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)) = 0;
        *(_BYTE *)(a1 + 41) = 8;
        v35 = *(_DWORD *)(a1 + 209704);
        v13 = (const void *)(a1 + 209708);
        goto LABEL_26;
      }
    }
    if ( *(_DWORD *)(a1 + 209704) == 102400 )
    {
      v74 = *(_DWORD **)(a1 + 209700);
      v75 = v74 + 12800;
      v76 = v74 + 25600;
      do
      {
        v77 = v75[3];
        v78 = v75[1];
        v79 = v75[2];
        *v74 = *v75;
        v74[1] = v78;
        v74[2] = v79;
        v75 += 4;
        v74[3] = v77;
        v74 += 4;
      }
      while ( v75 != v76 );
      v80 = *(_DWORD *)(a1 + 209700) + 0x10000;
      *(_DWORD *)(a1 + 209704) = 51200;
      *(_BYTE *)(v80 - 14336) = 0;
    }
    goto LABEL_85;
  }
  if ( v7 != 8 )
  {
    v42 = *(unsigned __int8 *)(a1 + 210102);
    v41 = 13;
    goto LABEL_33;
  }
  if ( *(_DWORD *)(a1 + 209984) )
  {
    v58 = https_ssl_read(a1);
    if ( v58 == -2 )
    {
      v35 = *(_DWORD *)(a1 + 209704);
      v13 = (const void *)(a1 + 209708);
      goto LABEL_26;
    }
    if ( v58 >= 0 )
    {
      if ( v58 )
      {
LABEL_60:
        v35 = v58 + *(_DWORD *)(a1 + 209704);
        *(_DWORD *)(a1 + 209704) = v35;
        v13 = (const void *)(a1 + 209708);
        goto LABEL_26;
      }
LABEL_94:
      v42 = *(unsigned __int8 *)(a1 + 210102);
      v41 = 140;
      goto LABEL_33;
    }
  }
  else
  {
    v58 = recv(
            *(_DWORD *)(a1 + 205416),
            (void *)(*(_DWORD *)(a1 + 209700) + *(_DWORD *)(a1 + 209704)),
            102400 - *(_DWORD *)(a1 + 209704),
            0);
    if ( v58 )
    {
      if ( v58 > 0 )
        goto LABEL_60;
      goto LABEL_94;
    }
  }
  result = 0;
  if ( !*(_BYTE *)(a1 + 210101) )
    goto LABEL_94;
  return result;
}
// 4B1FE0: variable 'v9' is possibly undefined
// 4B207C: variable 'v15' is possibly undefined
// 4B20F0: variable 'v18' is possibly undefined
// 4B222C: variable 'v30' is possibly undefined
// 4B229C: variable 'v36' is possibly undefined
// 4B2310: variable 'v3' is possibly undefined
// 4B24D4: variable 'v51' is possibly undefined
// 4B2784: variable 'v63' is possibly undefined
// 4B28B4: variable 'v70' is possibly undefined
// 4B2A10: variable 'v27' is possibly undefined
// 4B2AE0: variable 'v88' is possibly undefined
// 4CFE60: using guessed type void *off_4CFE60;
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8584: using guessed type int __fastcall create_dir2(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (004B2B98) --------------------------------------------------------
int __fastcall sub_4B2B98(int a1)
{
  char *v2; // $s3
  int v3; // $a2
  char *v4; // $s1
  int v5; // $a1
  int v6; // $a0
  char *v7; // $v0
  unsigned int v8; // $v0
  char *v10; // $v0
  int v11; // [sp+10h] [-494h]
  char v12[1024]; // [sp+20h] [-484h] BYREF
  char v13[132]; // [sp+420h] [-84h] BYREF

  memset(v13, 0, 0x80u);
  v2 = httpd_find_ext_name(*(const char **)(a1 + 44));
  v4 = httpd_get_parm(a1, "path");
  usb_httpd_conn_check_user(a1);
  if ( *(_BYTE *)(a1 + 43) == 1 )
  {
    if ( !v4 || (v10 = strstr(v4, "/usb/")) == 0 || (v4 = v10 + 5, v10 == (char *)-5) )
      v4 = "";
    if ( check_usb_state() )
      return usb_upload_do_rcv2(a1);
    v5 = *(unsigned __int8 *)(a1 + 210102);
    v6 = 186;
  }
  else
  {
    v5 = *(unsigned __int8 *)(a1 + 210102);
    v6 = 2;
  }
  v7 = (char *)_GET_LANG_TEXT(v6, v5, v3);
  strcpy(v13, v7);
  sync();
  if ( v2 && !strcmp(v2, (const char *)&off_4CFE60) )
  {
    v11 = _GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v13);
    v8 = snprintf(v12, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
  }
  else
  {
    v8 = snprintf(
           v12,
           1024,
           "<html><head><script type='text/javascript'>function init(){alert('%s');window.parent.location.href='/usb/%s';"
           "}</script><body onLoad='init();'></body></head></html>",
           v13,
           v4);
  }
  if ( v8 >= 0x400 )
    v8 = 1023;
  return httpd_cgi_ret(a1, v12, v8, 4);
}
// 4B2C4C: variable 'v3' is possibly undefined
// 4CFE60: using guessed type void *off_4CFE60;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (004B2DF4) --------------------------------------------------------
int __fastcall sub_4B2DF4(int a1)
{
  const char *v1; // $s4
  char *v3; // $s6
  char *v4; // $s3
  const char *v5; // $v0
  unsigned int v6; // $a2
  int v7; // $s2
  int v9; // $s7
  int v10; // $a2
  int v11; // $a1
  int v12; // $a0
  char *v13; // $v1
  const char *v14; // $v0
  int v15; // $t0
  int v16; // $a3
  int v17; // $a2
  int v18; // $a1
  char v19[512]; // [sp+20h] [-5B4h] BYREF
  char v20[512]; // [sp+220h] [-3B4h] BYREF
  char v21[256]; // [sp+420h] [-1B4h] BYREF
  struct stat v22; // [sp+520h] [-B4h] BYREF
  int v23[5]; // [sp+5C0h] [-14h] BYREF

  v1 = v20;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  memset(v21, 0, sizeof(v21));
  v3 = httpd_get_parm(a1, "opt");
  v4 = httpd_get_parm(a1, "path");
  if ( strstr(v4, "..") )
  {
    v5 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "error path");
    goto LABEL_3;
  }
  if ( nvram_match_def("usb_share_enable", "0") || (v7 = usb_acc_check((int *)(a1 + 205460))) != 0 )
  {
    httpd_conn_close((int *)a1);
    return 0;
  }
  if ( nvram_match_def("usb_acc_auth", "1") )
  {
    v9 = 1;
    if ( usb_httpd_check_user(a1, 1) )
      return v7;
  }
  else
  {
    v9 = 0;
  }
  if ( !check_usb_state() )
  {
    v11 = *(unsigned __int8 *)(a1 + 210102);
    v12 = 186;
LABEL_23:
    v5 = (const char *)_GET_LANG_TEXT(v12, v11, v10);
    goto LABEL_3;
  }
  if ( !v3 || strcmp(v3, "del") && strcmp(v3, "dir") )
  {
    v5 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    goto LABEL_3;
  }
  if ( !*v4 )
  {
    v5 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_64E0E0);
LABEL_3:
    v6 = snprintf(v21, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v5);
    if ( v6 >= 0x100 )
      v6 = 255;
    return httpd_cgi_ret(a1, v21, v6, 4);
  }
  if ( !v9 )
  {
    v5 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "error opt");
    goto LABEL_3;
  }
  snprintf(v20, 512, "/tmp/mnt/sda1/%s", v4);
  strcpy(v19, "/tmp/mnt/sda1/");
  unescape(v4);
  gbk_to_utf8(v4, &v19[14], 498);
  if ( !strcmp(v3, "del") )
  {
    if ( stat(v20, &v22) )
    {
      v1 = v19;
      if ( stat(v19, &v22) )
      {
        v11 = *(unsigned __int8 *)(a1 + 210102);
        v12 = 143;
        goto LABEL_23;
      }
    }
    v23[0] = (int)"rm";
    v23[1] = (int)&off_64E318;
    v23[2] = (int)v1;
    v23[3] = 0;
    eval(v23, 0, 0, 0);
  }
  if ( strcmp(v3, "dir") )
    goto LABEL_30;
  if ( !stat(v1, &v22) || !stat(v19, &v22) )
  {
    v11 = *(unsigned __int8 *)(a1 + 210102);
    v12 = 187;
    goto LABEL_23;
  }
  create_dir(v19);
LABEL_30:
  v13 = v21;
  v14 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v15 = *(_DWORD *)v14;
    v16 = *((_DWORD *)v14 + 1);
    v17 = *((_DWORD *)v14 + 2);
    v18 = *((_DWORD *)v14 + 3);
    v14 += 16;
    *(_DWORD *)v13 = v15;
    *((_DWORD *)v13 + 1) = v16;
    *((_DWORD *)v13 + 2) = v17;
    *((_DWORD *)v13 + 3) = v18;
    v13 += 16;
  }
  while ( v14 != "}" );
  v6 = 33;
  *(_WORD *)v13 = *(_WORD *)v14;
  return httpd_cgi_ret(a1, v21, v6, 4);
}
// 4B3110: variable 'v10' is possibly undefined
// 64E318: using guessed type void *off_64E318;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A85C8: using guessed type int __fastcall gbk_to_utf8(_DWORD, _DWORD, _DWORD);
// 6A85D8: using guessed type int __fastcall create_dir(_DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (004B3344) --------------------------------------------------------
int __fastcall sub_4B3344(int a1)
{
  char *v2; // $v0
  const char *v3; // $s5
  unsigned int v4; // $v0
  bool v5; // dc
  char *v6; // $v0
  int v7; // $a1
  int v8; // $a2
  int v9; // $a0
  const char *v10; // $v0
  unsigned int v11; // $a2
  int v12; // $fp
  int v14; // $a2
  _BOOL4 v15; // $s7
  int v16; // $a2
  int v17; // $v0
  char *v18; // $s4
  int v19; // $v0
  int v20; // $s2
  int v21; // $fp
  DIR *v22; // $s3
  struct dirent *v23; // $v0
  const char *v24; // $s1
  int v25; // $v0
  int v26; // $s2
  int v27; // $a2
  int v28; // $a2
  int v29; // $s0
  int v30; // $v0
  const char *v31; // $v0
  char v32[512]; // [sp+28h] [-A58h] BYREF
  char v33[512]; // [sp+228h] [-858h] BYREF
  char v34[512]; // [sp+428h] [-658h] BYREF
  char v35[512]; // [sp+628h] [-458h] BYREF
  char v36[256]; // [sp+828h] [-258h] BYREF
  struct stat v37; // [sp+928h] [-158h] BYREF
  struct stat v38; // [sp+9C8h] [-B8h] BYREF
  char *format; // [sp+A68h] [-18h]
  char *name; // [sp+A6Ch] [-14h]
  char *v41; // [sp+A70h] [-10h]
  char *v42; // [sp+A74h] [-Ch]
  const char *v43; // [sp+A78h] [-8h]

  memset(v35, 0, sizeof(v35));
  memset(v34, 0, sizeof(v34));
  memset(v33, 0, sizeof(v33));
  memset(v32, 0, sizeof(v32));
  memset(v36, 0, sizeof(v36));
  v2 = httpd_get_parm(a1, "path");
  if ( v2 )
  {
    v3 = v2;
    if ( strcmp(v2, "/") )
    {
      if ( *v3 == 47 )
        ++v3;
      v4 = snprintf(v32, 512, "%s", v3);
      v5 = v4 < 0x200;
      v6 = &v32[v4];
      if ( !v5 )
        v6 = &v32[511];
      if ( *(v6 - 1) != 47 )
        *v6 = 47;
    }
  }
  if ( strstr(v32, "..") )
  {
    v7 = *(unsigned __int8 *)(a1 + 210102);
    v8 = (int)"error path";
    v9 = 12;
LABEL_11:
    v10 = (const char *)_GET_LANG_TEXT(v9, v7, v8);
LABEL_12:
    v11 = snprintf(v36, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
    if ( v11 >= 0x100 )
      v11 = 255;
    return httpd_cgi_ret(a1, v36, v11, 4);
  }
  v12 = nvram_match_def("usb_share_enable", "0");
  if ( v12 )
  {
    v10 = (const char *)_GET_LANG_TEXT(192, *(unsigned __int8 *)(a1 + 210102), v14);
    goto LABEL_12;
  }
  format = (char *)usb_acc_check((int *)(a1 + 205460));
  if ( !nvram_match_def("usb_acc_auth", "1") )
    goto LABEL_23;
  if ( usb_httpd_check_user(a1, 1) )
    return v12;
  v15 = v32[0] || *(_DWORD *)(a1 + 205588) >= 2;
  if ( format )
LABEL_23:
    v15 = 0;
  if ( !check_usb_state() )
  {
    v10 = (const char *)_GET_LANG_TEXT(186, *(unsigned __int8 *)(a1 + 210102), v16);
    goto LABEL_12;
  }
  snprintf(v35, 512, "/tmp/mnt/sda1/%s", v32);
  strcpy(v34, "/tmp/mnt/sda1/");
  unescape(v32);
  gbk_to_utf8(v32, &v34[14], 498);
  if ( stat(v35, &v38) )
  {
    if ( stat(v34, &v38) )
    {
      v10 = (const char *)_GET_LANG_TEXT(191, *(unsigned __int8 *)(a1 + 210102), v28);
      goto LABEL_12;
    }
    name = v34;
  }
  else
  {
    name = v35;
  }
  if ( (v38.st_uid & 0xF000) != 0x4000 )
  {
    v29 = *(unsigned __int8 *)(a1 + 210102);
    v30 = _GET_LANG_TEXT(191, v29, 2727);
    v31 = (const char *)_GET_LANG_TEXT(12, v29, v30);
    snprintf(v36, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
    return -1;
  }
  _mem_malloc(0x200000, "usb_list_data", 2727);
  v18 = (char *)v17;
  if ( !v17 )
  {
    v7 = *(unsigned __int8 *)(a1 + 210102);
    v8 = 0x200000;
    v9 = 4;
    goto LABEL_11;
  }
  strcpy((char *)v17, "{\"code\":0,\"error\":\"\",\"data\":{");
  qmemcpy((void *)v17, "{\"code\":0,\"error", 16);
  *(_DWORD *)(v17 + 20) = 1633952300;
  v19 = snprintf((char *)(v17 + 29), 0x200000, "\"upload\":%d,\"list\":[", v15);
  v20 = v19 + 29;
  if ( v19 >= 0x200000 )
  {
    v21 = 2097180;
    if ( format )
    {
      v25 = 2097179;
      v20 = 2097180;
LABEL_48:
      if ( v18[v25] == 44 )
        v21 = --v20;
      goto LABEL_50;
    }
    v20 = 2097180;
  }
  else
  {
    v21 = v19 + 29;
    if ( format )
      goto LABEL_47;
  }
  if ( !v32[0] || !strncmp(v32, "usb/", 4u) || !strncmp(v32, "share/", 6u) )
  {
    v22 = opendir(name);
    if ( v22 )
    {
      format = "%s%s";
      v41 = "1\"";
      v42 = (char *)&off_4CFA50;
      v43 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
      while ( 1 )
      {
        v23 = readdir(v22);
        if ( !v23 )
          break;
        v24 = &v23->d_name[8];
        if ( v20 >= 2096897 )
          break;
        if ( strcmp(&v23->d_name[8], ".")
          && strcmp(v24, "..")
          && (!v15 || v32[0] || *(int *)(a1 + 205588) >= 2 || !strcmp(v24, v42) || !strcmp(v24, v43 - 1452)) )
        {
          sprintf(v33, format, name, v24);
          if ( !stat(v33, &v37) )
            v20 += sprintf(
                     &v18[v20],
                     v41 - 7356,
                     v37.st_atim.tv_sec,
                     v37.st_atim.tv_nsec,
                     v24,
                     v37.st_ctim.tv_sec,
                     (v37.st_uid & 0xF000) == 0x4000);
        }
      }
      closedir(v22);
      v21 = v20;
    }
  }
LABEL_47:
  v25 = v21 - 1;
  if ( v20 > 0 )
    goto LABEL_48;
LABEL_50:
  v26 = v20 + 1;
  *(_WORD *)&v18[v21] = 93;
  v27 = snprintf(&v18[v26], 0x200000 - v26, "}}");
  if ( v27 >= 0x200000 - v26 )
    v27 = 0x1FFFFF - v26;
  *(_DWORD *)(a1 + 36) |= 0x8000u;
  return httpd_cgi_ret(a1, v18, v27 + v26, 8);
}
// 4B35B0: variable 'v14' is possibly undefined
// 4B368C: variable 'v16' is possibly undefined
// 4B3768: variable 'v17' is possibly undefined
// 4B3B60: variable 'v28' is possibly undefined
// 4CFA50: using guessed type void *off_4CFA50;
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A85C8: using guessed type int __fastcall gbk_to_utf8(_DWORD, _DWORD, _DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (004B3BB8) --------------------------------------------------------
int __fastcall sub_4B3BB8(int a1)
{
  char *v2; // $s4
  char *v3; // $s2
  char *v4; // $s1
  char *v5; // $s5
  char *v6; // $s6
  char *v7; // $fp
  char *v8; // $s7
  char *v9; // $s3
  const char *v10; // $v0
  const char *v11; // $s4
  unsigned int v12; // $v0
  int v13; // $s2
  const char *v14; // $v0
  const char *v15; // $v0
  int v16; // $a0
  const char **v17; // $v1
  const char *v18; // $v0
  const char *v19; // $t0
  const char *v20; // $a3
  const char *v21; // $a2
  const char *v22; // $a1
  unsigned int v23; // $a2
  const char *v25; // $v0
  const char *v26; // [sp+28h] [-428h] BYREF
  const char *v27; // [sp+2Ch] [-424h]
  const char *v28; // [sp+30h] [-420h]
  char *v29; // [sp+34h] [-41Ch]
  int v30; // [sp+38h] [-418h]
  char *v31; // [sp+428h] [-28h]
  char *v32; // [sp+42Ch] [-24h]
  char *v33; // [sp+430h] [-20h]
  char *v34; // [sp+434h] [-1Ch]
  char *v35; // [sp+438h] [-18h]
  char *v36; // [sp+43Ch] [-14h]
  char *v37; // [sp+440h] [-10h]
  char *v38; // [sp+444h] [-Ch]
  const char *v39; // [sp+448h] [-8h]

  v2 = httpd_get_parm(a1, "share_enable");
  v3 = httpd_get_parm(a1, "passwd");
  v4 = httpd_get_parm(a1, "name");
  v31 = httpd_get_parm(a1, "hpasswd");
  v32 = httpd_get_parm(a1, "hname");
  v5 = httpd_get_parm(a1, "acc_ip");
  v6 = httpd_get_parm(a1, "acc_mac");
  v33 = httpd_get_parm(a1, "acc_wan");
  v34 = httpd_get_parm(a1, "acc_auth");
  v35 = httpd_get_parm(a1, "device_name");
  v36 = httpd_get_parm(a1, "send_email_en");
  v37 = httpd_get_parm(a1, "send_email_name");
  v7 = httpd_get_parm(a1, "send_email_pwd");
  v38 = "1\"";
  v8 = httpd_get_parm(a1, "printer_enable");
  v9 = httpd_get_parm(a1, "printer_port");
  killall_tk("smbd");
  if ( *v2 == 49 )
    xstart(v38 - 8644, 0);
  if ( v3 )
  {
    if ( !v4 || !*v4 )
      v4 = "login";
    if ( v9 && (v38 = "1\"", !nvram_match_def(&unk_64DE5C, v9)) )
    {
      if ( !J_atoi(v9) )
        v9 = "9100";
      nvram_set(v38 - 8612, v9);
      if ( !v8 || nvram_match_def("usb_printer_en", v8) )
        goto LABEL_47;
    }
    else if ( !v8 || nvram_match_def("usb_printer_en", v8) )
    {
LABEL_10:
      nvram_set("usb_share_enable", v2);
      nvram_set("usb_passwd", v3);
      nvram_set("usb_username", v4);
      v38 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
      if ( v32 )
        nvram_set("usb_husername", v32);
      if ( v31 )
        nvram_set("usb_hpasswd", v31);
      v28 = "smbguest";
      v31 = "smbguest";
      v26 = "smbpasswd";
      v39 = "smbpasswd";
      v27 = "-a";
      v32 = "-a";
      v29 = v3;
      v30 = 0;
      eval(&v26, 0, 0, 0);
      v26 = v39;
      v27 = v32;
      v28 = "smbadmin";
      v29 = (char *)jhl_nv_get_def("usb_hpasswd");
      v30 = 0;
      eval(&v26, 0, 0, 0);
      v11 = (const char *)jhl_nv_get_def("usb_username");
      v10 = (const char *)jhl_nv_get_def(v38 - 4920);
      v12 = snprintf((char *)&v26, 1024, "%s = %s\n%s = %s\n", v31, v11, "smbadmin", v10);
      if ( v12 >= 0x400 )
        v12 = 1023;
      f_write("/etc/smbusers", &v26, v12, 0, 420);
      if ( v5 && !nvram_match_def(&unk_64E3C8, v5) )
      {
        nvram_set(&unk_64E3C8, v5);
        v13 = 1;
      }
      else
      {
        v13 = 0;
      }
      if ( v6 && !nvram_match_def(&unk_64E3D4, v6) )
      {
        nvram_set(&unk_64E3D4, v6);
        ++v13;
      }
      if ( v33 )
        nvram_set("usb_acc_wan", v33);
      if ( v34 )
        nvram_set("usb_acc_auth", v34);
      if ( v35 )
        nvram_set(&unk_64E3E0, v35);
      if ( v36 )
        nvram_set("usb_send_email_en", v36);
      if ( v37 )
        nvram_set(&unk_64E404, v37);
      if ( v7 )
        nvram_set(&unk_64E418, v7);
      v14 = (const char *)jhl_nv_get_def("usb_passwd");
      usb_httpd_passwd_md5(gl_usb_password_md5, v14);
      v15 = (const char *)jhl_nv_get_def("usb_hpasswd");
      usb_httpd_passwd_md5(gl_usb_hpassword_md5, v15);
      if ( v13 )
        set_usb_acc_conf();
      jhl_parm_commit(v16);
      v17 = &v26;
      v18 = "{\"code\":0,\"error\":\"\",\"data\":null}";
      do
      {
        v19 = *(const char **)v18;
        v20 = (const char *)*((_DWORD *)v18 + 1);
        v21 = (const char *)*((_DWORD *)v18 + 2);
        v22 = (const char *)*((_DWORD *)v18 + 3);
        v18 += 16;
        *v17 = v19;
        v17[1] = v20;
        v17[2] = v21;
        v17[3] = v22;
        v17 += 4;
      }
      while ( v18 != "}" );
      v23 = 33;
      *(_WORD *)v17 = *(_WORD *)v18;
      return httpd_cgi_ret(a1, (char *)&v26, v23, 4);
    }
    nvram_set("usb_printer_en", v8);
LABEL_47:
    killall_tk("p910nd");
    if ( nvram_match_def("usb_printer_en", "1") )
    {
      jhl_nv_get_def(&unk_64DE5C);
      xstart("p910nd", "-f");
    }
    goto LABEL_10;
  }
  v25 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_64E388);
  v23 = snprintf((char *)&v26, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v25);
  if ( v23 >= 0x400 )
    v23 = 1023;
  return httpd_cgi_ret(a1, (char *)&v26, v23, 4);
}
// 4B41BC: variable 'v16' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8204: using guessed type int __fastcall f_write(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8534: using guessed type int set_usb_acc_conf(void);
// 6A85AC: using guessed type int __fastcall xstart(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004B445C) --------------------------------------------------------
bool __fastcall f_exists64(const char *a1)
{
  bool v1; // dc
  _BOOL4 result; // $v0
  struct stat v3; // [sp+18h] [-A4h] BYREF

  v1 = stat(a1, &v3) != 0;
  result = 0;
  if ( !v1 )
    result = (v3.st_uid & 0xF000) != 0x4000;
  return result;
}

//----- (004B44B4) --------------------------------------------------------
int __fastcall sub_4B44B4(int a1)
{
  int v2; // $a2
  char *v3; // $v0
  char *v4; // $v0
  int v5; // $a2
  char *v6; // $s5
  const char *v7; // $s7
  unsigned int v8; // $fp
  int v9; // $a2
  int v10; // $a1
  int v11; // $a0
  char *v12; // $v0
  const char *v13; // $a3
  unsigned int v14; // $v0
  char *v16; // $v0
  char v17[512]; // [sp+58h] [-5A8h] BYREF
  char v18[512]; // [sp+258h] [-3A8h] BYREF
  char v19[256]; // [sp+458h] [-1A8h] BYREF
  char v20[104]; // [sp+558h] [-A8h] BYREF
  char v21[64]; // [sp+5C0h] [-40h] BYREF

  memset(v17, 0, sizeof(v17));
  memset(v21, 0, sizeof(v21));
  v3 = (char *)_GET_LANG_TEXT(188, *(unsigned __int8 *)(a1 + 210102), v2);
  strcpy(v19, v3);
  v6 = httpd_get_parm(a1, "filename");
  v4 = httpd_get_parm(a1, "sign");
  if ( !v6 )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = 183;
    goto LABEL_7;
  }
  v7 = v4;
  if ( !v4 )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = 184;
    goto LABEL_7;
  }
  v8 = snprintf(v18, 512, "%s%s", v6, "d1d7855dc37411e387c300163e0c16e5");
  MD5Init(v20);
  v9 = v8;
  if ( v8 >= 0x200 )
    v9 = 511;
  MD5Update(v20, v18, v9);
  MD5Final(v20);
  snprintf(
    v21,
    64,
    "%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
    (unsigned __int8)v20[88],
    (unsigned __int8)v20[89],
    (unsigned __int8)v20[90],
    (unsigned __int8)v20[91],
    (unsigned __int8)v20[92],
    (unsigned __int8)v20[93],
    (unsigned __int8)v20[94],
    (unsigned __int8)v20[95],
    (unsigned __int8)v20[96],
    (unsigned __int8)v20[97],
    (unsigned __int8)v20[98],
    (unsigned __int8)v20[99],
    (unsigned __int8)v20[100],
    (unsigned __int8)v20[101],
    (unsigned __int8)v20[102],
    (unsigned __int8)v20[103]);
  if ( strcmp(v7, v21) )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = 185;
LABEL_7:
    v12 = (char *)_GET_LANG_TEXT(v11, v10, v5);
    strcpy(v19, v12);
    v13 = "false";
    goto LABEL_8;
  }
  snprintf(v17, 512, "/tmp/mnt/sda1/upload/%s", v6);
  if ( !f_exists64(v17) )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = 143;
    goto LABEL_7;
  }
  unlink(v17);
  if ( f_exists64(v17) )
  {
    v10 = *(unsigned __int8 *)(a1 + 210102);
    v11 = 113;
    goto LABEL_7;
  }
  v16 = (char *)_GET_LANG_TEXT(188, *(unsigned __int8 *)(a1 + 210102), v5);
  strcpy(v19, v16);
  v13 = "true";
LABEL_8:
  v14 = snprintf(v18, 512, "{\"success\":%s,\"message\":\"%s\"}", v13, v19);
  if ( v14 >= 0x200 )
    v14 = 511;
  return httpd_cgi_ret(a1, v18, v14, 4);
}
// 4B4540: variable 'v2' is possibly undefined
// 4B46F8: variable 'v5' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8384: using guessed type int __fastcall MD5Init(_DWORD);
// 6A8850: using guessed type int __fastcall MD5Final(_DWORD);
// 6A8928: using guessed type int __fastcall MD5Update(_DWORD, _DWORD, _DWORD);

//----- (004B48CC) --------------------------------------------------------
int __fastcall sub_4B48CC(int a1)
{
  char *v2; // $s4
  int v3; // $a2
  char *v4; // $s1
  char *v5; // $v0
  int v6; // $a1
  int v7; // $a0
  char *v8; // $v0
  unsigned int v9; // $v0
  char v11[1024]; // [sp+20h] [-680h] BYREF
  char v12[512]; // [sp+420h] [-280h] BYREF
  char v13[128]; // [sp+620h] [-80h] BYREF

  memset(v12, 0, sizeof(v12));
  memset(v13, 0, sizeof(v13));
  v2 = httpd_get_parm(a1, "filename");
  v4 = httpd_get_parm(a1, "path");
  usb_httpd_conn_check_user(a1);
  if ( *(_BYTE *)(a1 + 43) != 1 )
  {
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v7 = 2;
    goto LABEL_11;
  }
  if ( v4 )
  {
    v5 = strstr(v4, "/usb/");
    v4 = v5 + 5;
    if ( v5 )
    {
      if ( v5 != (char *)-5 )
      {
        if ( check_usb_state() )
          goto LABEL_6;
LABEL_16:
        v6 = *(unsigned __int8 *)(a1 + 210102);
        v7 = 186;
        goto LABEL_11;
      }
    }
  }
  v4 = "";
  if ( !check_usb_state() )
    goto LABEL_16;
LABEL_6:
  if ( v2 )
  {
    snprintf(v12, 512, "/tmp/mnt/sda1/%s/%s", v4, v2);
    if ( f_exists64(v12) )
    {
      unlink(v12);
      if ( f_exists64(v12) )
      {
        v6 = *(unsigned __int8 *)(a1 + 210102);
        v7 = 113;
      }
      else
      {
        v6 = *(unsigned __int8 *)(a1 + 210102);
        v7 = 188;
      }
    }
    else
    {
      v6 = *(unsigned __int8 *)(a1 + 210102);
      v7 = 143;
    }
  }
  else
  {
    v6 = *(unsigned __int8 *)(a1 + 210102);
    v7 = 183;
  }
LABEL_11:
  v8 = (char *)_GET_LANG_TEXT(v7, v6, v3);
  strcpy(v13, v8);
  sync();
  v9 = snprintf(
         v11,
         1024,
         "<html><head><script type='text/javascript'>function init(){alert('%s');window.parent.location.href='/usb/%s';}<"
         "/script><body onLoad='init();'></body></head></html>",
         v13,
         v4);
  if ( v9 >= 0x400 )
    v9 = 1023;
  return httpd_cgi_ret(a1, v11, v9, 4);
}
// 4B4A80: variable 'v3' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A88E0: using guessed type int check_usb_state(void);

//----- (004B4B98) --------------------------------------------------------
void __fastcall format_usb_email_list_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 4 )
    snprintf(
      a3,
      a4,
      "{\"email_name\":\"%s\",\"email_en\":%s,\"email_url\":\"%s\",\"email_mem\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[3]);
}

//----- (004B4C28) --------------------------------------------------------
int __fastcall usb_get_current_device(int a1)
{
  FILE *v2; // $v0
  FILE *v3; // $s1
  int v4; // $s5
  char v6[256]; // [sp+18h] [-200h] BYREF
  char v7[256]; // [sp+118h] [-100h] BYREF

  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  strcpy(v6, "/tmp/mnt/sda1/");
  if ( *(unsigned __int16 *)"1/" << 16 >> 24 == 47 )
    v6[13] = 0;
  jhl_system("df > /tmp/df_file");
  v2 = fopen("/tmp/df_file", "r");
  v3 = v2;
  if ( v2 )
  {
    fgets(v7, 256, v2);
    memset(v7, 0, sizeof(v7));
    v4 = -1;
    while ( fgets(v7, 256, v3) )
    {
      if ( strstr(v7, v6) )
      {
        sscanf(v7, "%s", a1);
        v4 = 0;
      }
    }
    fclose(v3);
  }
  else
  {
    v4 = -1;
  }
  remove("/tmp/df_file");
  return v4;
}
// 6A8594: using guessed type int __fastcall jhl_system(_DWORD);

//----- (004B4E18) --------------------------------------------------------
int __fastcall sub_4B4E18(int a1)
{
  char *v1; // $v0
  const char *v2; // $v0
  char *v3; // $s7
  const char *v4; // $s0
  const char *v5; // $v0
  const char *v6; // $s1
  int v7; // $s1
  const char *v8; // $s2
  const char *v9; // $s3
  const char *v10; // $s4
  const char *v11; // $s5
  const char *v12; // $s6
  const char *v13; // $fp
  const char *v14; // $v0
  int v15; // $s4
  int v16; // $s1
  char *v17; // $s3
  int v18; // $s5
  int v19; // $s0
  const char **v20; // $s2
  void *v21; // $v0
  char *v22; // $s6
  int v23; // $a1
  void *v24; // $s5
  int v25; // $s5
  int i; // $fp
  int v27; // $v0
  int v28; // $v0
  char *v29; // $a0
  int v30; // $s1
  int v31; // $v0
  int v32; // $s4
  int v33; // $v0
  const char *v34; // $v0
  int v35; // $s0
  int v36; // $v0
  int v37; // $s0
  int v38; // $v0
  int v39; // $a2
  int result; // $v0
  char v41[256]; // [sp+58h] [-228h] BYREF
  char v42[256]; // [sp+158h] [-128h] BYREF
  char *v43; // [sp+258h] [-28h]
  char *v44; // [sp+25Ch] [-24h]
  void *ptr; // [sp+260h] [-20h]
  const char *v46; // [sp+264h] [-1Ch]
  const char *v47; // [sp+268h] [-18h]
  const char *v48; // [sp+26Ch] [-14h]
  const char *v49; // [sp+270h] [-10h]
  const char *v50; // [sp+274h] [-Ch]
  const char *v51; // [sp+278h] [-8h]
  const char *v52; // [sp+27Ch] [-4h]

  v43 = v41;
  memset(v41, 0, sizeof(v41));
  _mem_malloc(10240, "usb_all_data", 90);
  if ( v1 )
  {
    v3 = v1;
    v2 = (const char *)nvram_get("http_lanport");
    v4 = v2;
    if ( !v2 || !*v2 )
      v4 = "80";
    v5 = (const char *)nvram_get("tggl_port");
    v6 = v5;
    if ( v5 && *v5 && (unsigned int)(J_ato10(v5) - 1) < 0xFFFF )
      v4 = v6;
    v7 = usb_get_current_device((int)v43);
    strcpy(v3, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v3, "{\"code\":0,\"error\":\"\"", 20);
    v8 = (const char *)jhl_nv_get_def("usb_share_enable");
    v9 = (const char *)jhl_nv_get_def("usb_printer_en");
    v10 = (const char *)jhl_nv_get_def(&unk_64DE5C);
    v11 = (const char *)nvram_get("lan_ipaddr");
    v12 = (const char *)jhl_nv_get_def("usb_passwd");
    v13 = (const char *)jhl_nv_get_def("usb_username");
    v52 = (const char *)jhl_nv_get_def("usb_hpasswd");
    v51 = (const char *)jhl_nv_get_def("usb_husername");
    v50 = (const char *)jhl_nv_get_def(&unk_64E3C8);
    v49 = (const char *)jhl_nv_get_def(&unk_64E3D4);
    v48 = (const char *)jhl_nv_get_def("usb_acc_wan");
    v47 = (const char *)jhl_nv_get_def("usb_acc_auth");
    v46 = (const char *)jhl_nv_get_def(&unk_64E3E0);
    ptr = (void *)jhl_nv_get_def("usb_send_email_en");
    v44 = (char *)jhl_nv_get_def(&unk_64E404);
    v14 = (const char *)jhl_nv_get_def(&unk_64E418);
    v15 = sprintf(
            v3 + 29,
            "\"status\":%d,\"share_enable\":\"%s\",\"printer_enable\":\"%s\",\"printer_port\":\"%s\",\"lan_ipaddr\":\"%s\""
            ",\"http_lanport\":\"%s\",\"passwd\":\"%s\",\"name\":\"%s\",\"hpasswd\":\"%s\",\"hname\":\"%s\",\"usb_more\":"
            "\"0\",\"acc_ip\":\"%s\",\"acc_mac\":\"%s\",\"acc_wan\":\"%s\",\"acc_auth\":\"%s\",\"device_name\":\"%s\",\"s"
            "end_email_en\":\"%s\",\"send_email_name\":\"%s\",\"send_email_pwd\":\"%s\",\"email_list\":",
            v7 == 0,
            v8,
            v9,
            v10,
            v11,
            v4,
            v12,
            v13,
            v52,
            v51,
            v50,
            v49,
            v48,
            v47,
            v46,
            (const char *)ptr,
            v44,
            v14)
        + 29;
    v16 = 10240 - v15;
    v17 = &v3[v15];
    v18 = nvram_get("usb_send_email_list");
    v19 = snprintf(&v3[v15], 10240 - v15, (char *)&word_642A04);
    if ( v19 >= 10240 - v15 )
      v19 = 10239 - v15;
    if ( v18 )
    {
      v20 = (const char **)malloc(0x18u);
      v44 = (char *)malloc(0x4008u);
      v22 = v44;
      v21 = malloc(0x200000u);
      ptr = v21;
      if ( v21 )
      {
        if ( v20 )
        {
          v23 = v18;
          if ( v22 )
          {
            v24 = v21;
            strlcpy(v21, v23, 0x200000);
            v25 = split_string(v24, 60, v22, 4096);
            if ( v25 > 0 )
            {
              for ( i = 0; i != v25; ++i )
              {
                v27 = split_string(*(_DWORD *)v22, 124, v20, 4);
                format_usb_email_list_data(v20, v27, &v17[v19], v16 - v19);
                v19 += v28;
                v22 += 4;
              }
            }
          }
        }
        free(ptr);
      }
      if ( v20 )
        free(v20);
      if ( v44 )
        free(v44);
    }
    v29 = &v17[v19];
    if ( v19 > 0 && *(v29 - 1) == 44 )
      v29 = &v17[--v19];
    v30 = v16 - v19;
    *v29 = 0;
    v31 = snprintf(v29, v30, &byte_6445A0);
    if ( v31 >= v30 )
      v31 = v30 - 1;
    v32 = v19 + v31 + v15;
    v33 = snprintf(
            &v3[v32],
            10240 - v32,
            ",\"usb_3g\":\"%d\",\"usb_printer\":\"%d\",\"accauth_flag\":\"%d\",\"usb_remove\":\"%d\"",
            1,
            1,
            0,
            1);
    if ( v33 >= 10240 - v32 )
      v33 = 10239 - v32;
    v35 = v33 + v32;
    v34 = (const char *)jhl_nv_get_def("usb_mount_dev");
    v36 = snprintf(&v3[v35], 10240 - v35, ",\"usb_dev\":\"%s\",\"cur_dev\":\"%s\",\"info\":", v34, v43);
    if ( v36 >= 10240 - v35 )
      v36 = 10239 - v35;
    v37 = v36 + v35 + get_all_disk_info(*(unsigned __int8 *)(a1 + 210102), &v3[v36 + v35], 10240 - (v36 + v35));
    v38 = snprintf(&v3[v37], 10240 - v37, "}}");
    if ( v38 >= 10240 - v37 )
      v39 = 10239 - v37;
    else
      v39 = v38;
    result = httpd_cgi_ret(a1, v3, v39 + v37, 8);
  }
  else
  {
    strcpy(v42, "{\"code\":0,\"error\":\"\",\"data\":{");
    result = httpd_cgi_ret(a1, v42, 29, 4);
  }
  return result;
}
// 4B4E94: variable 'v1' is possibly undefined
// 4B52F8: variable 'v28' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A853C: using guessed type int __fastcall J_ato10(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8914: using guessed type int __fastcall get_all_disk_info(_DWORD, _DWORD, _DWORD);

//----- (004B55C0) --------------------------------------------------------
int usb_send_email()
{
  char *v0; // $v0

  if ( nvram_match_def("usb_send_email_en", "0") )
    return -1;
  v0 = (char *)nvram_get("proxy_http_port");
  if ( !v0 )
    v0 = "0";
  if ( !J_atoi(v0) || nvram_match_def("proxy_http_status", "0") || nvram_match_def("usb_share_enable", "0") )
    return -1;
  system("proxy_usb_send_email &");
  return 0;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004B56C8) --------------------------------------------------------
int __fastcall usb_email_asp(int a1)
{
  char *v2; // $s5
  char *v3; // $s6
  char *v4; // $s7
  char *v5; // $s1
  char *v6; // $v0
  char *v7; // $v0
  char *v8; // $s3
  char *v9; // $s4
  int v10; // $v0
  char *v11; // $v0
  int v12; // $a2
  const char *v13; // $v0
  int v14; // $fp
  _DWORD *v16; // $fp
  int v17; // $s7
  int v18; // $v0
  const char *v19; // $v0
  int v20; // $a0
  char *v21; // $v1
  const char *v22; // $v0
  int v23; // $t0
  int v24; // $a3
  int v25; // $a2
  int v26; // $a1
  int v27; // $a1
  int v28; // $a2
  int v29; // $a0
  int v30; // $v0
  int v31; // $a2
  char s[256]; // [sp+28h] [-110h] BYREF
  char *v33; // [sp+128h] [-10h]
  char *v34; // [sp+12Ch] [-Ch]
  char *v35; // [sp+130h] [-8h]

  v34 = httpd_get_parm(a1, "email_name");
  v35 = httpd_get_parm(a1, "old_email_name");
  v2 = httpd_get_parm(a1, "email_en");
  v3 = httpd_get_parm(a1, "email_url");
  v4 = httpd_get_parm(a1, "email_mem");
  v33 = (char *)httpd_get_json_parm(a1, (int)"del_list");
  v5 = httpd_get_parm(a1, "opt");
  _mem_malloc(102400, "usb_email_asp", 344);
  v8 = v7;
  _mem_malloc(102400, "usb_email_asp", 345);
  v9 = v6;
  if ( !v8 || !v6 )
  {
    v27 = *(unsigned __int8 *)(a1 + 210102);
    v28 = 102400;
    v29 = 4;
    goto LABEL_59;
  }
  v10 = a1 + 196608;
  if ( !v5 )
    goto LABEL_57;
  if ( strcmp(v5, (const char *)&off_646D8C) && strcmp(v5, (const char *)&off_648DDC) && strcmp(v5, "del") )
  {
    if ( strcmp(v5, "delall") )
    {
      if ( !strcmp(v5, "send") )
        goto LABEL_9;
      v10 = a1 + 196608;
LABEL_57:
      v27 = *(unsigned __int8 *)(v10 + 13494);
      v28 = (int)"not opt";
LABEL_58:
      v29 = 12;
LABEL_59:
      v13 = (const char *)_GET_LANG_TEXT(v29, v27, v28);
      goto LABEL_15;
    }
    if ( strcmp(v5, "send") )
      goto LABEL_51;
LABEL_9:
    v11 = (char *)nvram_get("usb_send_email_list");
    if ( !v11 )
      v11 = "";
    if ( *v11 && v11[1] && v11[2] )
    {
      if ( !usb_send_email() )
      {
        v19 = (const char *)_GET_LANG_TEXT(57, *(unsigned __int8 *)(a1 + 210102), v31);
        v14 = snprintf(s, 256, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v19);
        if ( (unsigned int)v14 < 0x100 )
          goto LABEL_16;
        goto LABEL_47;
      }
      v13 = (const char *)_GET_LANG_TEXT(56, *(unsigned __int8 *)(a1 + 210102), v31);
    }
    else
    {
      v13 = (const char *)_GET_LANG_TEXT(55, *(unsigned __int8 *)(a1 + 210102), v12);
    }
LABEL_15:
    v14 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
    if ( (unsigned int)v14 < 0x100 )
      goto LABEL_16;
LABEL_47:
    v14 = 255;
    goto LABEL_16;
  }
  if ( !strcmp(v5, "send") )
    goto LABEL_9;
  if ( !strcmp(v5, "delall") )
  {
LABEL_51:
    *v9 = 32;
    v9[1] = 0;
    v33 = "1\"";
LABEL_52:
    jhl_parm_set(v33 - 6712, v9);
    jhl_parm_commit(v20);
    goto LABEL_53;
  }
  if ( !strcmp(v5, "del") && v33 && cJSON_IsArray(v33) )
  {
    v16 = (_DWORD *)*((_DWORD *)v33 + 2);
    if ( !v16 || !v16[4] )
      goto LABEL_53;
    v33 = "1\"";
    v17 = 0;
    v34 = "usb_send_email_list";
    do
    {
      jhl_parm_get("usb_send_email_list", v8, 102400);
      if ( nvparm_del_str(v8, 60, 6, v16[4], 124, 0, v9) )
      {
        jhl_parm_set(v34, v9);
        v17 = 1;
      }
      v16 = (_DWORD *)*v16;
    }
    while ( v16 && v16[4] );
    if ( !v17 )
      goto LABEL_53;
    goto LABEL_52;
  }
  if ( !v34 )
  {
    v27 = *(unsigned __int8 *)(a1 + 210102);
    v28 = (int)&unk_6442E4;
    goto LABEL_58;
  }
  if ( !strcmp(v5, (const char *)&off_646D8C) )
  {
    v18 = strcmp(v5, (const char *)&off_648DDC);
LABEL_32:
    if ( !v2 || !*v2 )
      v2 = "1";
    if ( !v3 || !*v3 )
      v3 = "";
    if ( !v4 || !*v4 )
      v4 = "";
    if ( v18 )
    {
      v33 = "1\"";
    }
    else
    {
      v33 = "1\"";
      jhl_parm_get("usb_send_email_list", v8, 102400);
      if ( v35 )
        v30 = nvparm_del_str(v8, 60, 6, v35, 124, 0, v9);
      else
        v30 = nvparm_del_str(v8, 60, 6, v34, 124, 0, v9);
      if ( v30 )
      {
        v14 = check_rule_num_limit(a1, 36, (int)(v33 - 6712), 60, s, 0x100u);
        if ( v14 > 0 )
          goto LABEL_16;
        sprintf(v8, "%s|%s|%s|%s<", v34, v2, v3, v4);
LABEL_66:
        strcat(v9, v8);
        goto LABEL_52;
      }
    }
    v14 = check_rule_num_limit(a1, 36, (int)(v33 - 6712), 60, s, 0x100u);
    if ( v14 > 0 )
      goto LABEL_16;
    sprintf(v8, "%s|%s|%s|%s<", v34, v2, v3, v4);
    jhl_parm_get(v33 - 6712, v9, 102400);
    if ( !strcmp(v9, " ") )
      *v9 = 0;
    goto LABEL_66;
  }
  v18 = strcmp(v5, (const char *)&off_648DDC);
  if ( !v18 )
    goto LABEL_32;
LABEL_53:
  v21 = s;
  v22 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v23 = *(_DWORD *)v22;
    v24 = *((_DWORD *)v22 + 1);
    v25 = *((_DWORD *)v22 + 2);
    v26 = *((_DWORD *)v22 + 3);
    v22 += 16;
    *(_DWORD *)v21 = v23;
    *((_DWORD *)v21 + 1) = v24;
    *((_DWORD *)v21 + 2) = v25;
    *((_DWORD *)v21 + 3) = v26;
    v21 += 16;
  }
  while ( v22 != "}" );
  v14 = 33;
  *(_WORD *)v21 = *(_WORD *)v22;
LABEL_16:
  _mem_free(v8);
  _mem_free(v9);
  return httpd_cgi_ret(a1, s, v14, 4);
}
// 4B57FC: variable 'v7' is possibly undefined
// 4B5808: variable 'v6' is possibly undefined
// 4B591C: variable 'v12' is possibly undefined
// 4B5CB0: variable 'v31' is possibly undefined
// 4B5D5C: variable 'v20' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (004B5F5C) --------------------------------------------------------
int __fastcall sub_4B5F5C(int a1)
{
  int result; // $v0

  if ( httpd_get_parm(a1, "opt") )
    result = usb_email_asp(a1);
  else
    result = sub_4B3BB8(a1);
  return result;
}

//----- (004B5FD0) --------------------------------------------------------
int __fastcall sub_4B5FD0(int a1)
{
  const char *v2; // $v0
  const char *v3; // $s0
  const char *v4; // $v0
  unsigned int v5; // $v0
  int v6; // $s0
  unsigned int v7; // $v0
  char v9[1024]; // [sp+28h] [-424h] BYREF
  int v10; // [sp+428h] [-24h] BYREF
  int v11; // [sp+42Ch] [-20h]
  int v12[7]; // [sp+430h] [-1Ch] BYREF

  memset(v9, 0, sizeof(v9));
  v10 = 0;
  v11 = 0;
  v12[0] = 0;
  v12[1] = 0;
  v12[2] = 0;
  v12[3] = 0;
  v12[4] = 0;
  v12[5] = 0;
  v2 = (const char *)nvram_get("sj_palce_code_backup");
  if ( !v2 )
    v2 = "";
  snprintf((char *)&v10, 32, "%s", v2);
  strcpy(v9, "{\"code\":0,\"error\":\"\",\"data\":{");
  v3 = (const char *)nvram_get("sj_palce_num_backup");
  if ( v3 )
  {
    v4 = (const char *)nvram_get("sj_palce_num_dst_backup");
    if ( v4 )
      goto LABEL_5;
  }
  else
  {
    v4 = (const char *)nvram_get("sj_palce_num_dst_backup");
    v3 = "";
    if ( v4 )
      goto LABEL_5;
  }
  v4 = "";
LABEL_5:
  v5 = snprintf(
         &v9[29],
         995,
         "\"place_num\":\"%s\",\"place_num_dst\":\"%s\",\"place_type\":\"%c\",\"nowork_type\":\"%c\",\"police_num\":\"%s\"",
         v3,
         v4,
         SBYTE2(v11),
         SHIBYTE(v11),
         (const char *)v12);
  v6 = v5 + 29;
  if ( v5 >= 0x3E3 )
    v6 = 1023;
  v7 = snprintf(&v9[v6], 1024 - v6, "}}");
  if ( v7 >= 1024 - v6 )
    v7 = 1023 - v6;
  return httpd_cgi_ret(a1, v9, v7 + v6, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (004B61F0) --------------------------------------------------------
int __fastcall reset_sj_param(char a1)
{
  int v2; // $v0
  char *v3; // $s4
  char *v4; // $s3
  char *v5; // $s2
  int v6; // $a0
  int v7; // $v0
  int v8; // $s0
  int v10; // $a1
  int v11; // $a1
  int v12; // $a1
  int v13; // $a1
  int v14; // $a1
  int v15; // $a1
  int v16; // $a1
  int v17; // $v0
  int v18; // $v0
  int v19; // $v0
  int v20; // $a1
  int v21; // $a1
  int v22; // $a1
  int v23; // $a1
  int v24; // $a1
  int v25; // $a1
  int v26; // $a1
  int v27; // $a1
  int v28; // $a1
  int v29; // $a1
  int v30; // $a1
  int v31; // $a1
  int v32; // $a1
  int v33; // $a1
  int v34; // $a1
  int v35; // $a1
  int v36; // $a1
  int v37; // $a1
  int v38; // $a1
  int v39; // $a1
  int v40; // $a1
  int v41; // $a1
  int v42; // $a1
  int v43; // $a1
  int v44; // $a1
  int v45; // $a1
  int v46; // $a1
  int v47; // $a1
  int v48; // $a1
  int v49; // $a1
  int v50; // $a1
  int v51; // $a1
  int v52; // $a1
  int v53; // $a1
  int v54; // $a1
  int v55; // $a1
  int v56; // $a1
  int v57; // $a1
  int v58; // $a1
  int v59; // $a1
  int v60; // $a1
  int v61; // $a1
  int v62; // $a1
  int v63; // $a1
  int v64; // $a1
  int v65; // $a1
  int v66; // $a1
  int v67; // $a1
  int v68; // $a1
  int v69; // $a1
  int v70; // $a1
  int v71; // $a1

  v2 = nvram_get("sj_palce_num");
  if ( v2 )
    v3 = (char *)v2;
  else
    v3 = "";
  v4 = (char *)nvram_get("sj_palce_code");
  if ( !v4 )
    v4 = "";
  v5 = (char *)nvram_get("sj_palce_num_dst");
  if ( !v5 )
    v5 = "";
  nvram_set("sj_palce_num_backup", v3);
  nvram_set("sj_palce_code_backup", v4);
  nvram_set("sj_palce_num_dst_backup", v5);
  nvram_set("sj_real_dev_sn", "");
  nvram_set("sj_real_tz_sn", "");
  v7 = a1 & 2;
  if ( (a1 & 1) != 0 )
  {
    v54 = jhl_nv_get_only_def("sj_dev_sn");
    if ( v54 )
      nvram_set("sj_dev_sn", v54);
    else
      nvram_unset("sj_dev_sn");
    v55 = jhl_nv_get_only_def("sj_dev_name");
    if ( v55 )
      nvram_set("sj_dev_name", v55);
    else
      nvram_unset("sj_dev_name");
    v56 = jhl_nv_get_only_def("sj_dev_addr");
    if ( v56 )
      nvram_set("sj_dev_addr", v56);
    else
      nvram_unset("sj_dev_addr");
    v57 = jhl_nv_get_only_def("sj_dev_type");
    if ( v57 )
      nvram_set("sj_dev_type", v57);
    else
      nvram_unset("sj_dev_type");
    v58 = jhl_nv_get_only_def("sj_dev_lable");
    if ( v58 )
      nvram_set("sj_dev_lable", v58);
    else
      nvram_unset("sj_dev_lable");
    v59 = jhl_nv_get_only_def("sj_fixed_type");
    if ( v59 )
      nvram_set("sj_fixed_type", v59);
    else
      nvram_unset("sj_fixed_type");
    v60 = jhl_nv_get_only_def("sj_dev_longitude");
    if ( v60 )
      nvram_set("sj_dev_longitude", v60);
    else
      nvram_unset("sj_dev_longitude");
    v61 = jhl_nv_get_only_def("sj_dev_latitude");
    if ( v61 )
      nvram_set("sj_dev_latitude", v61);
    else
      nvram_unset("sj_dev_latitude");
    v62 = jhl_nv_get_only_def("sj_jwd_type");
    if ( v62 )
      nvram_set("sj_jwd_type", v62);
    else
      nvram_unset("sj_jwd_type");
    v63 = jhl_nv_get_only_def("sj_dev_interval_time");
    if ( v63 )
      nvram_set("sj_dev_interval_time", v63);
    else
      nvram_unset("sj_dev_interval_time");
    v64 = jhl_nv_get_only_def("sj_dev_radius");
    if ( v64 )
      nvram_set("sj_dev_radius", v64);
    else
      nvram_unset("sj_dev_radius");
    v65 = jhl_nv_get_only_def("sj_dev_floor");
    if ( v65 )
      nvram_set("sj_dev_floor", v65);
    else
      nvram_unset("sj_dev_floor");
    v66 = jhl_nv_get_only_def("sj_dev_station");
    if ( v66 )
      nvram_set("sj_dev_station", v66);
    else
      nvram_unset("sj_dev_station");
    v67 = jhl_nv_get_only_def("sj_dev_car_num");
    if ( v67 )
      nvram_set("sj_dev_car_num", v67);
    else
      nvram_unset("sj_dev_car_num");
    v68 = jhl_nv_get_only_def("sj_dev_metro");
    if ( v68 )
      nvram_set("sj_dev_metro", v68);
    else
      nvram_unset("sj_dev_metro");
    v69 = jhl_nv_get_only_def("sj_dev_metro_car");
    if ( v69 )
      nvram_set("sj_dev_metro_car", v69);
    else
      nvram_unset("sj_dev_metro_car");
    v70 = jhl_nv_get_only_def("sj_dev_metro_box");
    if ( v70 )
      nvram_set("sj_dev_metro_box", v70);
    else
      nvram_unset("sj_dev_metro_box");
    v71 = jhl_nv_get_only_def("sj_aps_list");
    if ( v71 )
      nvram_set("sj_aps_list", v71);
    else
      nvram_unset("sj_aps_list");
    v7 = a1 & 2;
  }
  if ( v7 )
  {
    v17 = jhl_nv_get_only_def("sj_palce_num_dst");
    if ( v17 )
      nvram_set("sj_palce_num_dst", v17);
    else
      nvram_unset("sj_palce_num_dst");
    v18 = jhl_nv_get_only_def("sj_palce_num");
    if ( v18 )
      nvram_set("sj_palce_num", v18);
    else
      nvram_unset("sj_palce_num");
    v19 = jhl_nv_get_only_def("sj_palce_code");
    if ( v19 )
      nvram_set("sj_palce_code", v19);
    else
      nvram_unset("sj_palce_code");
    v20 = jhl_nv_get_only_def("sj_palce_name");
    if ( v20 )
      nvram_set("sj_palce_name", v20);
    else
      nvram_unset("sj_palce_name");
    v21 = jhl_nv_get_only_def("sj_place_uscc");
    if ( v21 )
      nvram_set("sj_place_uscc", v21);
    else
      nvram_unset("sj_place_uscc");
    v22 = jhl_nv_get_only_def("sj_palce_addr");
    if ( v22 )
      nvram_set("sj_palce_addr", v22);
    else
      nvram_unset("sj_palce_addr");
    v23 = jhl_nv_get_only_def("sj_palce_state");
    if ( v23 )
      nvram_set("sj_palce_state", v23);
    else
      nvram_unset("sj_palce_state");
    v24 = jhl_nv_get_only_def("sj_palce_longitude");
    if ( v24 )
      nvram_set("sj_palce_longitude", v24);
    else
      nvram_unset("sj_palce_longitude");
    v25 = jhl_nv_get_only_def("sj_palce_latitude");
    if ( v25 )
      nvram_set("sj_palce_latitude", v25);
    else
      nvram_unset("sj_palce_latitude");
    v26 = jhl_nv_get_only_def("sj_palce_nature");
    if ( v26 )
      nvram_set("sj_palce_nature", v26);
    else
      nvram_unset("sj_palce_nature");
    v27 = jhl_nv_get_only_def("sj_palce_worker");
    if ( v27 )
      nvram_set("sj_palce_worker", v27);
    else
      nvram_unset("sj_palce_worker");
    v28 = jhl_nv_get_only_def("sj_palce_worker_cardtype");
    if ( v28 )
      nvram_set("sj_palce_worker_cardtype", v28);
    else
      nvram_unset("sj_palce_worker_cardtype");
    v29 = jhl_nv_get_only_def("sj_palce_worker_cardid");
    if ( v29 )
      nvram_set("sj_palce_worker_cardid", v29);
    else
      nvram_unset("sj_palce_worker_cardid");
    v30 = jhl_nv_get_only_def("sj_palce_phone");
    if ( v30 )
      nvram_set("sj_palce_phone", v30);
    else
      nvram_unset("sj_palce_phone");
    v31 = jhl_nv_get_only_def("sj_palce_start_time");
    if ( v31 )
      nvram_set("sj_palce_start_time", v31);
    else
      nvram_unset("sj_palce_start_time");
    v32 = jhl_nv_get_only_def("sj_palce_end_time");
    if ( v32 )
      nvram_set("sj_palce_end_time", v32);
    else
      nvram_unset("sj_palce_end_time");
    v33 = jhl_nv_get_only_def("sj_dev_sid");
    if ( v33 )
      nvram_set("sj_dev_sid", v33);
    else
      nvram_unset("sj_dev_sid");
    v34 = jhl_nv_get_only_def("sj_network_type");
    if ( v34 )
      nvram_set("sj_network_type", v34);
    else
      nvram_unset("sj_network_type");
    v35 = jhl_nv_get_only_def("sj_debug_log");
    if ( v35 )
      nvram_set("sj_debug_log", v35);
    else
      nvram_unset("sj_debug_log");
    v36 = jhl_nv_get_only_def("sj_netsite_type");
    if ( v36 )
      nvram_set("sj_netsite_type", v36);
    else
      nvram_unset("sj_netsite_type");
    v37 = jhl_nv_get_only_def("sj_business_nature");
    if ( v37 )
      nvram_set("sj_business_nature", v37);
    else
      nvram_unset("sj_business_nature");
    v38 = jhl_nv_get_only_def("sj_access_type");
    if ( v38 )
      nvram_set("sj_access_type", v38);
    else
      nvram_unset("sj_access_type");
    v39 = jhl_nv_get_only_def("sj_operator_net");
    if ( v39 )
      nvram_set("sj_operator_net", v39);
    else
      nvram_unset("sj_operator_net");
    v40 = jhl_nv_get_only_def("sj_terminal_netenv");
    if ( v40 )
      nvram_set("sj_terminal_netenv", v40);
    else
      nvram_unset("sj_terminal_netenv");
    v41 = jhl_nv_get_only_def("sj_acsses_ip_auth_account");
    if ( v41 )
      nvram_set("sj_acsses_ip_auth_account", v41);
    else
      nvram_unset("sj_acsses_ip_auth_account");
    v42 = jhl_nv_get_only_def("sj_data_caiji_type");
    if ( v42 )
      nvram_set("sj_data_caiji_type", v42);
    else
      nvram_unset("sj_data_caiji_type");
    v43 = jhl_nv_get_only_def("sj_caiji_type");
    if ( v43 )
      nvram_set("sj_caiji_type", v43);
    else
      nvram_unset("sj_caiji_type");
    v44 = jhl_nv_get_only_def("sj_ssq_type");
    if ( v44 )
      nvram_set("sj_ssq_type", v44);
    else
      nvram_unset("sj_ssq_type");
    v45 = jhl_nv_get_only_def("sj_province_name");
    if ( v45 )
      nvram_set("sj_province_name", v45);
    else
      nvram_unset("sj_province_name");
    v46 = jhl_nv_get_only_def("sj_city_name");
    if ( v46 )
      nvram_set("sj_city_name", v46);
    else
      nvram_unset("sj_city_name");
    v47 = jhl_nv_get_only_def("sj_area_name");
    if ( v47 )
      nvram_set("sj_area_name", v47);
    else
      nvram_unset("sj_area_name");
    v48 = jhl_nv_get_only_def("sj_police_code");
    if ( v48 )
      nvram_set("sj_police_code", v48);
    else
      nvram_unset("sj_police_code");
    v49 = jhl_nv_get_only_def("sj_fz_name");
    if ( v49 )
      nvram_set("sj_fz_name", v49);
    else
      nvram_unset("sj_fz_name");
    v50 = jhl_nv_get_only_def("sj_fz_cardid");
    if ( v50 )
      nvram_set("sj_fz_cardid", v50);
    else
      nvram_unset("sj_fz_cardid");
    v51 = jhl_nv_get_only_def("sj_fz_phone");
    if ( v51 )
      nvram_set("sj_fz_phone", v51);
    else
      nvram_unset("sj_fz_phone");
    v52 = jhl_nv_get_only_def("sj_dev_caiji_class");
    if ( v52 )
      nvram_set("sj_dev_caiji_class", v52);
    else
      nvram_unset("sj_dev_caiji_class");
    v53 = jhl_nv_get_only_def("sj_caiji_company");
    if ( v53 )
      nvram_set("sj_caiji_company", v53);
    else
      nvram_unset("sj_caiji_company");
    v8 = a1 & 8;
  }
  else
  {
    v8 = a1 & 8;
  }
  if ( v8 )
  {
    v10 = jhl_nv_get_only_def("sj_company_name");
    if ( v10 )
      nvram_set("sj_company_name", v10);
    else
      nvram_unset("sj_company_name");
    v11 = jhl_nv_get_only_def("sj_company_code");
    if ( v11 )
      nvram_set("sj_company_code", v11);
    else
      nvram_unset("sj_company_code");
    v12 = jhl_nv_get_only_def("sj_company_uscc");
    if ( v12 )
      nvram_set("sj_company_uscc", v12);
    else
      nvram_unset("sj_company_uscc");
    v13 = jhl_nv_get_only_def("sj_company_addr");
    if ( v13 )
      nvram_set("sj_company_addr", v13);
    else
      nvram_unset("sj_company_addr");
    v14 = jhl_nv_get_only_def("sj_company_people");
    if ( v14 )
      nvram_set("sj_company_people", v14);
    else
      nvram_unset("sj_company_people");
    v15 = jhl_nv_get_only_def("sj_company_phone");
    if ( v15 )
      nvram_set("sj_company_phone", v15);
    else
      nvram_unset("sj_company_phone");
    v16 = jhl_nv_get_only_def("sj_company_email");
    if ( v16 )
      nvram_set("sj_company_email", v16);
    else
      nvram_unset("sj_company_email");
  }
  jhl_parm_commit(v6);
  return 0;
}
// 4B6340: variable 'v6' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A86F4: using guessed type int __fastcall jhl_nv_get_only_def(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004B7804) --------------------------------------------------------
int __fastcall sj_dev_info_asp(int a1)
{
  int v2; // $s0
  char *v3; // $s1
  char *v4; // $s2
  char *v5; // $s3
  char *v6; // $s5
  char *v7; // $s7
  int v8; // $a2
  int v9; // $v0
  const char *v10; // $v0
  const char *v11; // $v0
  int v12; // $s7
  const char *v13; // $v0
  const char *v14; // $s2
  const char *v15; // $v0
  const char *v16; // $s2
  const char *v17; // $v0
  const char *v18; // $s2
  const char *v19; // $v0
  const char *v20; // $s2
  const char *v21; // $v0
  const char *v22; // $s2
  const char *v23; // $v0
  const char *v24; // $s2
  const char *v25; // $v0
  const char *v26; // $v0
  const char *v27; // $v0
  const char *v28; // $v0
  const char *v29; // $v0
  const char *v30; // $v0
  const char *v31; // $s2
  const char *v32; // $v0
  const char *v33; // $s2
  const char *v34; // $v0
  const char *v35; // $s2
  const char *v36; // $v0
  const char *v37; // $s2
  const char *v38; // $v0
  const char *v39; // $s2
  const char *v40; // $v0
  const char *v41; // $s2
  const char *v42; // $v0
  size_t v43; // $s3
  void *v44; // $v0
  void *v45; // $s1
  const char *v46; // $v0
  char *v47; // $s1
  const char *v48; // $v0
  const char *v49; // $a1
  int v50; // $s1
  const char *v51; // $v0
  const char *v52; // $v0
  const char *v53; // $v0
  const char *v54; // $v0
  const char *v55; // $v0
  const char *v56; // $v0
  int v57; // $a2
  const char *v58; // $s3
  const char *v59; // $v0
  const char *v60; // $s3
  const char *v61; // $v0
  const char *v62; // $s3
  const char *v63; // $v0
  const char *v64; // $s3
  const char *v65; // $v0
  const char *v66; // $s3
  const char *v67; // $v0
  const char *v68; // $s3
  const char *v69; // $v0
  const char *v70; // $s3
  const char *v71; // $v0
  const char *v72; // $s3
  const char *v73; // $v0
  const char *v74; // $s3
  const char *v75; // $v0
  const char *v76; // $s3
  const char *v77; // $v0
  const char *v78; // $s3
  const char *v79; // $v0
  const char *v80; // $s3
  const char *v81; // $v0
  const char *v82; // $s3
  const char *v83; // $v0
  const char *v84; // $s3
  const char *v85; // $v0
  const char *v86; // $s3
  const char *v87; // $v0
  const char *v88; // $s3
  const char *v89; // $v0
  char *v90; // $s3
  const char *v91; // $v0
  const char *v92; // $v0
  const char *v93; // $s3
  const char *v94; // $v0
  const char *v95; // $s3
  const char *v96; // $v0
  const char *v97; // $s3
  const char *v98; // $v0
  const char *v99; // $s3
  const char *v100; // $v0
  const char *v101; // $s3
  const char *v102; // $v0
  const char *v103; // $s3
  const char *v104; // $v0
  const char *v105; // $s3
  const char *v106; // $v0
  const char *v107; // $s3
  const char *v108; // $v0
  const char *v109; // $s3
  const char *v110; // $v0
  const char *v111; // $s3
  const char *v112; // $v0
  const char *v113; // $s3
  const char *v114; // $v0
  const char *v115; // $s3
  const char *v116; // $v0
  const char *v117; // $s3
  const char *v118; // $v0
  const char *v119; // $s3
  const char *v120; // $v0
  const char *v121; // $v0
  const char *v122; // $v0
  const char *v123; // $v0
  unsigned int v124; // $a2
  char *v126; // $s7
  int v127; // $v0
  int v128; // $s0
  char *v129; // $s6
  int v130; // $v0
  int v131; // $v0
  int v132; // $a2
  const char *v133; // $v0
  const char *v134; // $v0
  unsigned int v135; // $v0
  const char *v136; // $v0
  int v137; // $a0
  int v138; // $a2
  int v139[64]; // [sp+20h] [-268h] BYREF
  char v140[128]; // [sp+120h] [-168h] BYREF
  char *v141; // [sp+1A0h] [-E8h]
  void *v142; // [sp+1A4h] [-E4h]
  char *v143; // [sp+1A8h] [-E0h]
  char *v144; // [sp+1ACh] [-DCh]
  char *v145; // [sp+1B0h] [-D8h]
  char *v146; // [sp+1B4h] [-D4h]
  char *v147; // [sp+1B8h] [-D0h]
  char *v148; // [sp+1BCh] [-CCh]
  char *v149; // [sp+1C0h] [-C8h]
  char *v150; // [sp+1C4h] [-C4h]
  char *v151; // [sp+1C8h] [-C0h]
  char *v152; // [sp+1CCh] [-BCh]
  char *v153; // [sp+1D0h] [-B8h]
  char *v154; // [sp+1D4h] [-B4h]
  char *v155; // [sp+1D8h] [-B0h]
  char *v156; // [sp+1DCh] [-ACh]
  char *v157; // [sp+1E0h] [-A8h]
  char *v158; // [sp+1E4h] [-A4h]
  char *v159; // [sp+1E8h] [-A0h]
  char *v160; // [sp+1ECh] [-9Ch]
  char *v161; // [sp+1F0h] [-98h]
  char *v162; // [sp+1F4h] [-94h]
  char *v163; // [sp+1F8h] [-90h]
  char *v164; // [sp+1FCh] [-8Ch]
  char *v165; // [sp+200h] [-88h]
  char *v166; // [sp+204h] [-84h]
  char *v167; // [sp+208h] [-80h]
  char *v168; // [sp+20Ch] [-7Ch]
  char *v169; // [sp+210h] [-78h]
  char *v170; // [sp+214h] [-74h]
  char *v171; // [sp+218h] [-70h]
  char *v172; // [sp+21Ch] [-6Ch]
  char *v173; // [sp+220h] [-68h]
  char *v174; // [sp+224h] [-64h]
  char *v175; // [sp+228h] [-60h]
  char *v176; // [sp+22Ch] [-5Ch]
  char *v177; // [sp+230h] [-58h]
  char *v178; // [sp+234h] [-54h]
  char *v179; // [sp+238h] [-50h]
  char *v180; // [sp+23Ch] [-4Ch]
  char *v181; // [sp+240h] [-48h]
  char *v182; // [sp+244h] [-44h]
  char *v183; // [sp+248h] [-40h]
  char *v184; // [sp+24Ch] [-3Ch]
  char *v185; // [sp+250h] [-38h]
  char *v186; // [sp+254h] [-34h]
  char *v187; // [sp+258h] [-30h]
  char *v188; // [sp+25Ch] [-2Ch]
  char *v189; // [sp+260h] [-28h]
  char *v190; // [sp+264h] [-24h]
  char *v191; // [sp+268h] [-20h]
  char *v192; // [sp+26Ch] [-1Ch]
  char *v193; // [sp+270h] [-18h]
  char *v194; // [sp+274h] [-14h]
  char *v195; // [sp+278h] [-10h]
  char *v196; // [sp+27Ch] [-Ch]
  char *v197; // [sp+280h] [-8h]
  char *v198; // [sp+284h] [-4h]

  v198 = v140;
  memset(v140, 0, sizeof(v140));
  v2 = (int)httpd_get_parm(a1, "dev_sn");
  v3 = httpd_get_parm(a1, "dev_name");
  v4 = httpd_get_parm(a1, "dev_addr");
  v156 = httpd_get_parm(a1, "dev_type");
  v157 = httpd_get_parm(a1, "xt_enable");
  v158 = httpd_get_parm(a1, "xt_wdsz");
  v159 = httpd_get_parm(a1, "xt_trail");
  v160 = httpd_get_parm(a1, "xt_placesn");
  v161 = httpd_get_parm(a1, "dev_lable");
  v150 = httpd_get_parm(a1, "fixed_type");
  v162 = httpd_get_parm(a1, "info_num");
  v5 = httpd_get_parm(a1, "dev_longitude");
  v143 = httpd_get_parm(a1, "dev_latitude");
  v151 = httpd_get_parm(a1, "jwd_type");
  v145 = httpd_get_parm(a1, "dev_radius");
  v163 = httpd_get_parm(a1, "floor_str");
  v164 = httpd_get_parm(a1, "station_info");
  v165 = httpd_get_parm(a1, "dev_car_number");
  v166 = httpd_get_parm(a1, "dev_metro_way");
  v167 = httpd_get_parm(a1, "dev_metro_car");
  v168 = httpd_get_parm(a1, "dev_metro_carriage");
  v142 = httpd_get_parm(a1, "aps_list");
  v144 = httpd_get_parm(a1, "caiji_type");
  v6 = httpd_get_parm(a1, "place_num");
  v155 = httpd_get_parm(a1, "place_type");
  v141 = httpd_get_parm(a1, "place_num_dst");
  v169 = httpd_get_parm(a1, "ssq_type");
  v170 = httpd_get_parm(a1, "province_name");
  v171 = httpd_get_parm(a1, "city_name");
  v172 = httpd_get_parm(a1, "area_name");
  v173 = httpd_get_parm(a1, "police_code");
  v147 = httpd_get_parm(a1, "loc_name");
  v152 = httpd_get_parm(a1, "sj_place_uscc");
  v149 = httpd_get_parm(a1, "loc_addr");
  v174 = httpd_get_parm(a1, "loc_longitude");
  v175 = httpd_get_parm(a1, "loc_latitude");
  v176 = httpd_get_parm(a1, "loc_bussiness_type");
  v177 = httpd_get_parm(a1, "loc_owner");
  v178 = httpd_get_parm(a1, "loc_owner_cer_type");
  v179 = httpd_get_parm(a1, "loc_owner_code");
  v180 = httpd_get_parm(a1, "loc_contact_way");
  v181 = httpd_get_parm(a1, "loc_start");
  v182 = httpd_get_parm(a1, "loc_end");
  v183 = httpd_get_parm(a1, "access_type");
  v184 = httpd_get_parm(a1, "operator_net");
  v185 = httpd_get_parm(a1, "netsite_type");
  v186 = httpd_get_parm(a1, "business_nature");
  v187 = httpd_get_parm(a1, "data_type");
  v188 = httpd_get_parm(a1, "terminal_netenv");
  v189 = httpd_get_parm(a1, "fz_name");
  v190 = httpd_get_parm(a1, "fz_cardid");
  v191 = httpd_get_parm(a1, "fz_phone");
  v192 = httpd_get_parm(a1, "place_state");
  v193 = httpd_get_parm(a1, "dev_caiji_class");
  v194 = httpd_get_parm(a1, "caiji_company");
  v146 = httpd_get_parm(a1, "place_code");
  v153 = httpd_get_parm(a1, "sj_area_num");
  v148 = httpd_get_parm(a1, "auth_servicecode");
  v7 = httpd_get_parm(a1, "opt");
  v195 = httpd_get_parm(a1, "onlinedev_num");
  v196 = httpd_get_parm(a1, "baozhuangdev_num");
  v197 = httpd_get_parm(a1, "dev_detail_id");
  if ( v7 )
  {
    v154 = "1\"";
    if ( !strcmp(v7, "reset") )
    {
      v126 = httpd_get_parm(a1, v154 - 4340);
      if ( !v126 )
        v126 = "all";
      v141 = "address";
      v127 = *v126;
      v128 = 0;
      v142 = "company";
      if ( v127 )
      {
        do
        {
          v129 = strchr(v126, 44);
          if ( !v129 )
            v129 = &v126[strlen(v126)];
          v130 = v129 - v126;
          if ( v129 - v126 == 6 )
          {
            if ( !memcmp("device", v126, 6u) )
              v128 |= 1u;
          }
          else if ( v130 == 5 )
          {
            if ( !memcmp("place", v126, 5u) )
              v128 |= 2u;
          }
          else if ( v130 == 7 )
          {
            if ( !memcmp(v141, v126, 7u) )
            {
              v128 |= 4u;
            }
            else if ( !memcmp(v142, v126, 7u) )
            {
              v128 |= 8u;
            }
          }
          else if ( v130 == 3 && !memcmp("all", v126, 3u) )
          {
            v128 = -1;
          }
          v131 = *v129;
          if ( *v129 )
            v131 = *++v129;
          v126 = v129;
        }
        while ( v131 );
      }
      if ( reset_sj_param(v128) < 0 )
      {
        v136 = (const char *)_GET_LANG_TEXT(63, *(unsigned __int8 *)(a1 + 210102), v132);
        snprintf((char *)v139, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v136);
        v124 = 27;
        v139[0] = 1952805499;
        v139[1] = 1697395002;
        v139[2] = 658141810;
        v139[3] = -37040462;
        v139[4] = -1009329962;
        v139[5] = -592402486;
        v139[6] = 8202017;
        return httpd_cgi_ret(a1, (char *)v139, v124, 4);
      }
      v133 = (const char *)_GET_LANG_TEXT(63, *(unsigned __int8 *)(a1 + 210102), v132);
LABEL_279:
      v124 = snprintf((char *)v139, 256, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v133);
      if ( v124 < 0x100 )
        return httpd_cgi_ret(a1, (char *)v139, v124, 4);
      return httpd_cgi_ret(a1, (char *)v139, 255, 4);
    }
  }
  if ( !v3 || !v4 )
  {
LABEL_282:
    v9 = a1 + 196608;
    goto LABEL_283;
  }
  v9 = a1 + 196608;
  if ( v5 )
  {
    if ( !v143 || !v145 || !v147 || !v149 || (!v6 || !v155 || !v141) && !v146 )
      goto LABEL_282;
    if ( v2 )
    {
      v10 = (const char *)nvram_get("sj_dev_sn");
      if ( v10 && !strcmp(v10, (const char *)v2) )
      {
        v2 = 0;
      }
      else
      {
        nvram_set("sj_dev_sn", v2);
        v2 = 1;
      }
    }
    v11 = (const char *)nvram_get("sj_dev_name");
    if ( v11 && !strcmp(v11, v3) )
    {
      v12 = 0;
    }
    else
    {
      nvram_set("sj_dev_name", v3);
      v12 = 1;
      v2 = 1;
    }
    v13 = (const char *)nvram_get("sj_dev_addr");
    if ( !v13 || strcmp(v13, v4) )
    {
      nvram_set("sj_dev_addr", v4);
      v2 = 1;
    }
    v14 = v156;
    if ( v156 )
    {
      v15 = (const char *)nvram_get("sj_dev_type");
      if ( !v15 || strcmp(v15, v14) )
      {
        nvram_set("sj_dev_type", v156);
        v12 = 1;
        v2 = 1;
      }
    }
    v16 = v158;
    if ( v158 )
    {
      v17 = (const char *)nvram_get("sj_xt_wdsz");
      if ( !v17 || strcmp(v17, v16) )
      {
        nvram_set("sj_xt_wdsz", v158);
        v12 = 1;
        v2 = 1;
      }
    }
    v18 = v157;
    if ( v157 )
    {
      v19 = (const char *)nvram_get("sj_xt_enable");
      if ( !v19 || strcmp(v19, v18) )
      {
        nvram_set("sj_xt_enable", v157);
        v12 = 1;
        v2 = 1;
      }
    }
    v20 = v159;
    if ( v159 )
    {
      v21 = (const char *)nvram_get("sj_xt_trail");
      if ( !v21 || strcmp(v21, v20) )
      {
        nvram_set("sj_xt_trail", v159);
        v12 = 1;
        v2 = 1;
      }
    }
    v22 = v160;
    if ( v160 )
    {
      v23 = (const char *)nvram_get("sj_xt_placesn");
      if ( !v23 || strcmp(v23, v22) )
      {
        nvram_set("sj_xt_placesn", v160);
        v12 = 1;
        v2 = 1;
      }
    }
    v24 = v161;
    if ( v161 )
    {
      v25 = (const char *)nvram_get("sj_dev_lable");
      if ( !v25 || strcmp(v25, v24) )
      {
        nvram_set("sj_dev_lable", v161);
        v12 = 1;
        v2 = 1;
      }
    }
    if ( v150 )
    {
      v26 = (const char *)nvram_get("sj_fixed_type");
      if ( !v26 || strcmp(v26, v150) )
      {
        nvram_set("sj_fixed_type", v150);
        v2 = 1;
      }
    }
    v27 = (const char *)nvram_get("sj_dev_longitude");
    if ( !v27 || strcmp(v27, v5) )
    {
      nvram_set("sj_dev_longitude", v5);
      v12 = 1;
      v2 = 1;
    }
    v28 = (const char *)nvram_get("sj_dev_latitude");
    if ( v28 && !strcmp(v28, v143) )
    {
      if ( !v151 )
        goto LABEL_62;
    }
    else
    {
      nvram_set("sj_dev_latitude", v143);
      v12 = 1;
      if ( !v151 )
        goto LABEL_61;
      v2 = 1;
    }
    v29 = (const char *)nvram_get("sj_jwd_type");
    if ( v29 && !strcmp(v29, v151) )
    {
LABEL_62:
      v30 = (const char *)nvram_get("sj_dev_radius");
      if ( !v30 || strcmp(v30, v145) )
      {
        nvram_set("sj_dev_radius", v145);
        v12 = 1;
        v2 = 1;
      }
      v31 = v163;
      if ( v163 )
      {
        v32 = (const char *)nvram_get("sj_dev_floor");
        if ( !v32 || strcmp(v32, v31) )
        {
          nvram_set("sj_dev_floor", v163);
          v12 = 1;
          v2 = 1;
        }
      }
      v33 = v164;
      if ( v164 )
      {
        v34 = (const char *)nvram_get("sj_dev_station");
        if ( !v34 || strcmp(v34, v33) )
        {
          nvram_set("sj_dev_station", v164);
          v12 = 1;
          v2 = 1;
        }
      }
      v35 = v165;
      if ( v165 )
      {
        v36 = (const char *)nvram_get("sj_dev_car_num");
        if ( !v36 || strcmp(v36, v35) )
        {
          nvram_set("sj_dev_car_num", v165);
          v12 = 1;
          v2 = 1;
        }
      }
      v37 = v166;
      if ( v166 )
      {
        v38 = (const char *)nvram_get("sj_dev_metro");
        if ( !v38 || strcmp(v38, v37) )
        {
          nvram_set("sj_dev_metro", v166);
          v12 = 1;
          v2 = 1;
        }
      }
      v39 = v167;
      if ( v167 )
      {
        v40 = (const char *)nvram_get("sj_dev_metro_car");
        if ( !v40 || strcmp(v40, v39) )
        {
          nvram_set("sj_dev_metro_car", v167);
          v12 = 1;
          v2 = 1;
        }
      }
      v41 = v168;
      if ( v168 )
      {
        v42 = (const char *)nvram_get("sj_dev_metro_box");
        if ( !v42 || strcmp(v42, v41) )
        {
          nvram_set("sj_dev_metro_box", v168);
          v12 = 1;
          v2 = 1;
        }
      }
      if ( v142 )
      {
        v43 = strlen((const char *)v142) + 1;
        _mem_malloc(v43, "sj_dev_info_asp", 338);
        v45 = v44;
        if ( v44 )
        {
          memset(v44, 0, v43);
          if ( jhl_check_and_tran_unicode2312(v142, v45) < 0 )
          {
            _mem_free(v45);
            v45 = v142;
          }
          v46 = (const char *)nvram_get("sj_aps_list");
          if ( !v46 || strcmp(v46, (const char *)v45) )
          {
            nvram_set("sj_aps_list", v45);
            v12 = 1;
            v2 = 1;
          }
          if ( v142 != v45 )
            _mem_free(v45);
        }
      }
      if ( v6 )
      {
        if ( v155 )
        {
          v47 = v198;
          snprintf(v198, 128, "%s%s", v6, v155);
          v48 = (const char *)nvram_get("sj_palce_code");
          v49 = v47;
          if ( !v48 || (v50 = 0, strcmp(v48, v49)) )
          {
            nvram_set("sj_palce_code", v198);
            v50 = 1;
            v2 = 1;
          }
        }
        else
        {
          v50 = 0;
        }
        if ( !v146 )
          goto LABEL_108;
      }
      else
      {
        v50 = 0;
        if ( !v146 )
        {
          v50 = 0;
          goto LABEL_111;
        }
      }
      v51 = (const char *)nvram_get("sj_palce_code");
      if ( !v51 || strcmp(v51, v146) )
      {
        nvram_set("sj_palce_code", v146);
        v50 = 1;
        v2 = 1;
      }
      if ( !v6 )
      {
LABEL_111:
        if ( v141 )
        {
          v53 = (const char *)nvram_get("sj_palce_num_dst");
          if ( !v53 || strcmp(v53, v141) )
          {
            nvram_set("sj_palce_num_dst", v141);
            v2 = 1;
          }
        }
        v54 = (const char *)nvram_get("sj_palce_name");
        if ( v54 && !strcmp(v54, v147) )
        {
          if ( !v152 )
            goto LABEL_123;
        }
        else
        {
          nvram_set("sj_palce_name", v147);
          v50 = 1;
          if ( !v152 )
            goto LABEL_122;
          v2 = 1;
        }
        v55 = (const char *)nvram_get("sj_place_uscc");
        if ( v55 && !strcmp(v55, v152) )
        {
LABEL_123:
          v56 = (const char *)nvram_get("sj_palce_addr");
          if ( !v56 || strcmp(v56, v149) )
          {
            nvram_set("sj_palce_addr", v149);
            v50 = 1;
            v2 = 1;
          }
          v58 = v174;
          if ( v174 )
          {
            v59 = (const char *)nvram_get("sj_palce_longitude");
            if ( !v59 || strcmp(v59, v58) )
            {
              nvram_set("sj_palce_longitude", v174);
              v50 = 1;
              v2 = 1;
            }
          }
          v60 = v175;
          if ( v175 )
          {
            v61 = (const char *)nvram_get("sj_palce_latitude");
            if ( !v61 || strcmp(v61, v60) )
            {
              nvram_set("sj_palce_latitude", v175);
              v50 = 1;
              v2 = 1;
            }
          }
          v62 = v176;
          if ( v176 )
          {
            v63 = (const char *)nvram_get("sj_palce_nature");
            if ( !v63 || strcmp(v63, v62) )
            {
              nvram_set("sj_palce_nature", v176);
              v50 = 1;
              v2 = 1;
            }
          }
          v64 = v177;
          if ( v177 )
          {
            v65 = (const char *)nvram_get("sj_palce_worker");
            if ( !v65 || strcmp(v65, v64) )
            {
              nvram_set("sj_palce_worker", v177);
              v2 = 1;
            }
          }
          v66 = v178;
          if ( v178 )
          {
            v67 = (const char *)nvram_get("sj_palce_worker_cardtype");
            if ( !v67 || strcmp(v67, v66) )
            {
              nvram_set("sj_palce_worker_cardtype", v178);
              v50 = 1;
              v2 = 1;
            }
          }
          v68 = v179;
          if ( v179 )
          {
            v69 = (const char *)nvram_get("sj_palce_worker_cardid");
            if ( !v69 || strcmp(v69, v68) )
            {
              nvram_set("sj_palce_worker_cardid", v179);
              v50 = 1;
              v2 = 1;
            }
          }
          v70 = v180;
          if ( v180 )
          {
            v71 = (const char *)nvram_get("sj_palce_phone");
            if ( !v71 || strcmp(v71, v70) )
            {
              nvram_set("sj_palce_phone", v180);
              v2 = 1;
            }
          }
          v72 = v181;
          if ( v181 )
          {
            v73 = (const char *)nvram_get("sj_palce_start_time");
            if ( !v73 || strcmp(v73, v72) )
            {
              nvram_set("sj_palce_start_time", v181);
              v50 = 1;
              v2 = 1;
            }
          }
          v74 = v182;
          if ( v182 )
          {
            v75 = (const char *)nvram_get("sj_palce_end_time");
            if ( !v75 || strcmp(v75, v74) )
            {
              nvram_set("sj_palce_end_time", v182);
              v50 = 1;
              v2 = 1;
            }
          }
          v76 = v183;
          if ( v183 )
          {
            v77 = (const char *)nvram_get("sj_access_type");
            if ( !v77 || strcmp(v77, v76) )
            {
              nvram_set("sj_access_type", v183);
              v2 = 1;
            }
          }
          v78 = v184;
          if ( v184 )
          {
            v79 = (const char *)nvram_get("sj_operator_net");
            if ( !v79 || strcmp(v79, v78) )
            {
              nvram_set("sj_operator_net", v184);
              v2 = 1;
            }
          }
          v80 = v188;
          if ( v188 )
          {
            v81 = (const char *)nvram_get("sj_terminal_netenv");
            if ( !v81 || strcmp(v81, v80) )
            {
              nvram_set("sj_terminal_netenv", v188);
              v2 = 1;
            }
          }
          v82 = v185;
          if ( v185 )
          {
            v83 = (const char *)nvram_get("sj_netsite_type");
            if ( !v83 || strcmp(v83, v82) )
            {
              nvram_set("sj_netsite_type", v185);
              v2 = 1;
            }
          }
          v84 = v186;
          if ( v186 )
          {
            v85 = (const char *)nvram_get("sj_business_nature");
            if ( !v85 || strcmp(v85, v84) )
            {
              nvram_set("sj_business_nature", v186);
              v2 = 1;
            }
          }
          v86 = v162;
          if ( v162 )
          {
            v87 = (const char *)nvram_get("sj_dev_sid");
            if ( !v87 || strcmp(v87, v86) )
            {
              nvram_set("sj_dev_sid", v162);
              v2 = 1;
            }
          }
          v88 = v187;
          if ( v187 )
          {
            v89 = (const char *)nvram_get("sj_data_caiji_type");
            if ( !v89 || strcmp(v89, v88) )
            {
              nvram_set("sj_data_caiji_type", v187);
              v2 = 1;
            }
          }
          v90 = v144;
          if ( v144 )
          {
            v91 = (const char *)nvram_get("sj_caiji_type");
            if ( !v91 || strcmp(v91, v90) )
            {
              nvram_set("sj_caiji_type", v144);
              v50 = 1;
              v2 = 1;
            }
            v92 = (const char *)nvram_get("sj_caiji_type");
            if ( !v92 || strcmp(v92, v144) )
            {
              nvram_set("sj_caiji_type", v144);
              v2 = 1;
            }
          }
          v93 = v169;
          if ( v169 )
          {
            v94 = (const char *)nvram_get("sj_ssq_type");
            if ( !v94 || strcmp(v94, v93) )
            {
              nvram_set("sj_ssq_type", v169);
              v2 = 1;
            }
          }
          v95 = v170;
          if ( v170 )
          {
            v96 = (const char *)nvram_get("sj_province_name");
            if ( !v96 || strcmp(v96, v95) )
            {
              nvram_set("sj_province_name", v170);
              v2 = 1;
            }
          }
          v97 = v171;
          if ( v171 )
          {
            v98 = (const char *)nvram_get("sj_city_name");
            if ( !v98 || strcmp(v98, v97) )
            {
              nvram_set("sj_city_name", v171);
              v2 = 1;
            }
          }
          v99 = v172;
          if ( v172 )
          {
            v100 = (const char *)nvram_get("sj_area_name");
            if ( !v100 || strcmp(v100, v99) )
            {
              nvram_set("sj_area_name", v172);
              v2 = 1;
            }
          }
          v101 = v173;
          if ( v173 )
          {
            v102 = (const char *)nvram_get("sj_police_code");
            if ( !v102 || strcmp(v102, v101) )
            {
              nvram_set("sj_police_code", v173);
              v2 = 1;
            }
          }
          v103 = v189;
          if ( v189 )
          {
            v104 = (const char *)nvram_get("sj_fz_name");
            if ( !v104 || strcmp(v104, v103) )
            {
              nvram_set("sj_fz_name", v189);
              v2 = 1;
            }
          }
          v105 = v190;
          if ( v190 )
          {
            v106 = (const char *)nvram_get("sj_fz_cardid");
            if ( !v106 || strcmp(v106, v105) )
            {
              nvram_set("sj_fz_cardid", v190);
              v2 = 1;
            }
          }
          v107 = v191;
          if ( v191 )
          {
            v108 = (const char *)nvram_get("sj_fz_phone");
            if ( !v108 || strcmp(v108, v107) )
            {
              nvram_set("sj_fz_phone", v191);
              v2 = 1;
            }
          }
          v109 = v192;
          if ( v192 )
          {
            v110 = (const char *)nvram_get("sj_palce_state");
            if ( !v110 || strcmp(v110, v109) )
            {
              nvram_set("sj_palce_state", v192);
              v2 = 1;
            }
          }
          v111 = v193;
          if ( v193 )
          {
            v112 = (const char *)nvram_get("sj_dev_caiji_class");
            if ( !v112 || strcmp(v112, v111) )
            {
              nvram_set("sj_dev_caiji_class", v193);
              v2 = 1;
            }
          }
          v113 = v194;
          if ( v194 )
          {
            v114 = (const char *)nvram_get("sj_caiji_company");
            if ( !v114 || strcmp(v114, v113) )
            {
              nvram_set("sj_caiji_company", v194);
              v2 = 1;
            }
          }
          v115 = v195;
          if ( v195 )
          {
            v116 = (const char *)nvram_get("sj_onlinedev_num");
            if ( !v116 || strcmp(v116, v115) )
            {
              nvram_set("sj_onlinedev_num", v195);
              v2 = 1;
            }
          }
          v117 = v196;
          if ( v196 )
          {
            v118 = (const char *)nvram_get("sj_baozhuangdev_num");
            if ( !v118 || strcmp(v118, v117) )
            {
              nvram_set("sj_baozhuangdev_num", v196);
              v2 = 1;
            }
          }
          v119 = v197;
          if ( v197 )
          {
            v120 = (const char *)nvram_get("sj_dev_detail_id");
            if ( !v120 || strcmp(v120, v119) )
            {
              nvram_set("sj_dev_detail_id", v197);
              v2 = 1;
            }
          }
          if ( !v153 || (v121 = (const char *)nvram_get("sj_area_num")) != 0 && !strcmp(v121, v153) )
          {
            if ( v148 )
              goto LABEL_257;
            if ( !v2 )
              goto LABEL_261;
          }
          else
          {
            nvram_set("sj_area_num", v153);
            v2 = 1;
            if ( v148 )
            {
LABEL_257:
              v122 = (const char *)nvram_get("sj_auth_servicecode");
              if ( !v122 || strcmp(v122, v148) )
                nvram_set("sj_auth_servicecode", v148);
              if ( !v2 )
              {
LABEL_261:
                v123 = (const char *)_GET_LANG_TEXT(62, *(unsigned __int8 *)(a1 + 210102), v57);
                v124 = snprintf((char *)v139, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v123);
                if ( v124 < 0x100 )
                  return httpd_cgi_ret(a1, (char *)v139, v124, 4);
                return httpd_cgi_ret(a1, (char *)v139, 255, 4);
              }
              goto LABEL_295;
            }
          }
LABEL_295:
          mng_client_restart(0);
          nvram_set("sj_mod_flag", "1");
          if ( v50 )
            nvram_set("sj_place_mod_flag", "1");
          if ( v12 )
            nvram_set("sj_dev_mod_flag", "1");
          jhl_parm_commit(v137);
          v133 = (const char *)_GET_LANG_TEXT(65, *(unsigned __int8 *)(a1 + 210102), v138);
          goto LABEL_279;
        }
        nvram_set("sj_place_uscc", v152);
LABEL_122:
        v50 = 1;
        v2 = 1;
        goto LABEL_123;
      }
LABEL_108:
      v52 = (const char *)nvram_get("sj_palce_num");
      if ( !v52 || strcmp(v52, v6) )
      {
        nvram_set("sj_palce_num", v6);
        v2 = 1;
      }
      goto LABEL_111;
    }
    nvram_set("sj_jwd_type", v151);
LABEL_61:
    v12 = 1;
    v2 = 1;
    goto LABEL_62;
  }
LABEL_283:
  v134 = (const char *)_GET_LANG_TEXT(61, *(unsigned __int8 *)(v9 + 13494), v8);
  v135 = snprintf((char *)v139, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v134);
  if ( v135 >= 0x100 )
    v135 = 255;
  return httpd_cgi_ret(a1, (char *)v139, v135, 4);
}
// 4B87DC: variable 'v44' is possibly undefined
// 4B98BC: variable 'v57' is possibly undefined
// 4B9A24: variable 'v132' is possibly undefined
// 4B9AA4: variable 'v8' is possibly undefined
// 4B9C9C: variable 'v137' is possibly undefined
// 4B9CBC: variable 'v138' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83A0: using guessed type int __fastcall mng_client_restart(_DWORD);
// 6A8550: using guessed type int __fastcall jhl_check_and_tran_unicode2312(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004B9DD8) --------------------------------------------------------
int __fastcall sj_dev_info_data(int a1)
{
  const char *v2; // $v0
  char *v3; // $v0
  char *v4; // $s0
  unsigned int v5; // $v0
  int v6; // $a3
  const char *v8; // $v0
  const char *v9; // $v0
  char v10[256]; // [sp+20h] [-180h] BYREF
  char v11[128]; // [sp+120h] [-80h] BYREF

  memset(v11, 0, sizeof(v11));
  v2 = (const char *)nvram_get("sj_dev_name");
  if ( !v2 )
    v2 = "";
  snprintf(v11, 128, "%s", v2);
  if ( !v11[0] )
  {
    v8 = (const char *)custom_device_name();
    snprintf(v11, 128, "%s", v8);
  }
  _mem_malloc(40960, "sj_dev_info_data", 724);
  v4 = v3;
  if ( v3 )
  {
    v5 = shenji_get_dev_info(v3, 40960);
    v6 = 8;
  }
  else
  {
    v9 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 40960);
    v4 = v10;
    v5 = snprintf(v10, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
    if ( v5 >= 0x100 )
      v5 = 255;
    v6 = 4;
  }
  return httpd_cgi_ret(a1, v4, v5, v6);
}
// 4B9E8C: variable 'v3' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A86E4: using guessed type int custom_device_name(void);
// 6A885C: using guessed type int __fastcall shenji_get_dev_info(_DWORD, _DWORD);

//----- (004B9F7C) --------------------------------------------------------
int __fastcall sub_4B9F7C(int a1)
{
  char *v2; // $v0
  size_t v3; // $v0
  char *v4; // $s2
  int v5; // $v0
  int v6; // $s1
  int v7; // $v0
  char *v8; // $s4
  const char *v9; // $v0
  unsigned int v10; // $s1
  const char *v11; // $v0
  char *v13; // $v0
  char *v14; // $s2
  char *v15; // $s1
  const char *v16; // $s2
  char *v17; // $v0
  const char *v18; // $s1
  char *v19; // $v0
  int v20; // $s1
  unsigned int v21; // $v0
  int v22; // $a1
  const char *v23; // $a2
  int v24; // $a0
  char v25[1024]; // [sp+20h] [-804h] BYREF
  char v26[1028]; // [sp+420h] [-404h] BYREF

  memset(v26, 0, 0x400u);
  memset(v25, 0, sizeof(v25));
  v2 = httpd_get_parm(a1, "url");
  if ( !v2 )
  {
    v22 = *(unsigned __int8 *)(a1 + 210102);
    v23 = "not url";
    v24 = 12;
LABEL_24:
    v11 = (const char *)_GET_LANG_TEXT(v24, v22, v23);
    goto LABEL_12;
  }
  v4 = v2;
  v3 = strlen(v2);
  base64_decode(v4, v25, v3);
  if ( httpd_wget(v25, "/tmp/LatitudeL") <= 0 )
  {
    v11 = "wget error";
    goto LABEL_12;
  }
  if ( access("/tmp/LatitudeL", 0) == -1 )
  {
    v11 = "F_OK error";
    goto LABEL_12;
  }
  v5 = f_size("/tmp/LatitudeL");
  v6 = v5;
  if ( v5 > 0 )
  {
    _mem_malloc(v5, "jsonp_ajax_data", 775);
    v8 = (char *)v7;
    if ( v7 )
    {
      if ( v6 == do_file("/tmp/LatitudeL", v7, v6) )
      {
        v14 = strstr(v8, "<lat>");
        v13 = strstr(v8, "<lng>");
        v15 = v13;
        if ( v14 && (v16 = v14 + 5, v13) )
        {
          v17 = strchr(v16, 60);
          v18 = v15 + 5;
          if ( v17 )
          {
            *v17 = 0;
            v19 = strchr(v18, 60);
            if ( v19 )
            {
              *v19 = 0;
              strcpy(v26, "{\"code\":0,\"error\":\"\",\"data\":{");
              v20 = sprintf(&v26[29], "\"ret\":0,\"lat\":\"%s\",\"lng\":\"%s\"", v16, v18) + 29;
              v21 = snprintf(&v26[v20], 1024 - v20, "}}");
              if ( v21 >= 1024 - v20 )
                v21 = 1023 - v20;
              v10 = v21 + v20;
              goto LABEL_10;
            }
            v9 = "file_info 3 error";
          }
          else
          {
            v9 = "file_info 2 error";
          }
        }
        else
        {
          v9 = "file_info error";
        }
      }
      else
      {
        v9 = "do_file error";
      }
      v10 = snprintf(v26, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
      if ( v10 >= 0x400 )
        v10 = 1023;
LABEL_10:
      _mem_free(v8);
      return httpd_cgi_ret(a1, v26, v10, 4);
    }
    v22 = *(unsigned __int8 *)(a1 + 210102);
    v23 = (const char *)v6;
    v24 = 4;
    goto LABEL_24;
  }
  v11 = "f_size error";
LABEL_12:
  v10 = snprintf(v26, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
  if ( v10 >= 0x400 )
    v10 = 1023;
  return httpd_cgi_ret(a1, v26, v10, 4);
}
// 4BA0B8: variable 'v7' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81CC: using guessed type int __fastcall base64_decode(_DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8718: using guessed type int __fastcall httpd_wget(_DWORD, _DWORD);
// 6A8950: using guessed type int __fastcall f_size(_DWORD);

//----- (004BA388) --------------------------------------------------------
ssize_t __fastcall shenji_send_to_ctrl(const char *a1)
{
  int v2; // $v0
  uint16_t v3; // $v0
  unsigned int v4; // $s1
  int v5; // $v0
  ssize_t result; // $v0
  char v7[1024]; // [sp+20h] [-414h] BYREF
  struct sockaddr addr; // [sp+420h] [-14h] BYREF

  memset(v7, 0, sizeof(v7));
  addr.sa_family = 2;
  v2 = jhl_nv_get_def("sj_udp_port");
  v3 = J_atoi(v2);
  *(_WORD *)addr.sa_data = htons(v3);
  *(_DWORD *)&addr.sa_data[2] = htonl(0);
  v4 = snprintf(v7, 1024, "{\"action\":\"%s\"}", a1);
  if ( v4 >= 0x400 )
    v4 = 1023;
  v5 = socket(2, 1, 0);
  if ( v5 == -1 )
    result = -1;
  else
    result = sendto(v5, v7, v4, 0, &addr, 0x10u);
  return result;
}
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004BA4C8) --------------------------------------------------------
ssize_t shenji_ctrl_set_en()
{
  const char *v0; // $s0

  v0 = (const char *)jhl_nv_get_def("sj_en");
  nvram_set("sj_state_en", v0);
  return shenji_send_to_ctrl(v0);
}
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004BA52C) --------------------------------------------------------
int __fastcall sub_4BA52C(int a1)
{
  const char *v2; // $s1
  const char *v3; // $s3
  const char *v4; // $s4
  const char *v5; // $s5
  const char *v6; // $s6
  const char *v7; // $s7
  _BYTE *v8; // $v0
  const char *v9; // $fp
  const char *v10; // $s0
  const char *v11; // $v0
  int v12; // $s1
  unsigned int v13; // $v0
  char v15[1024]; // [sp+38h] [-400h] BYREF

  strcpy(v15, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("sj_ctrl_en");
  v3 = (const char *)jhl_nv_get_def("sj_ctrl_addr");
  v4 = (const char *)jhl_nv_get_def("sj_ctrl_port");
  v5 = (const char *)jhl_nv_get_def("sj_ctrl_state");
  v6 = (const char *)jhl_nv_get_def("sj_state");
  v7 = (const char *)jhl_nv_get_def("sj_send_data_info");
  v9 = (const char *)jhl_nv_get_def("sj_send_data_tim");
  v8 = (_BYTE *)nvram_get("sj_real_dev_sn");
  if ( !v8 || *v8 )
  {
    v10 = (const char *)nvram_get("sj_real_dev_sn");
    if ( v10 )
      goto LABEL_4;
LABEL_9:
    v11 = (const char *)nvram_get("sj_real_tz_sn");
    v10 = "";
    if ( v11 )
      goto LABEL_5;
    goto LABEL_10;
  }
  v10 = (const char *)nvram_get("sj_palce_code");
  if ( !v10 )
    goto LABEL_9;
LABEL_4:
  v11 = (const char *)nvram_get("sj_real_tz_sn");
  if ( v11 )
    goto LABEL_5;
LABEL_10:
  v11 = "";
LABEL_5:
  v12 = sprintf(
          &v15[29],
          "\"en\":\"%s\",\"addr\":\"%s\",\"port\":\"%s\",\"ctrl_state\":\"%s\",\"sj_state\":\"%s\",\"sj_sendnum\":\"%s\","
          "\"sj_sendtm\":\"%s\",\"sj_code\":\"%s %s\"",
          v2,
          v3,
          v4,
          v5,
          v6,
          v7,
          v9,
          v10,
          v11)
      + 29;
  v13 = snprintf(&v15[v12], 1024 - v12, "}}");
  if ( v13 >= 1024 - v12 )
    v13 = 1023 - v12;
  return httpd_cgi_ret(a1, v15, v13 + v12, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004BA7EC) --------------------------------------------------------
int __fastcall sub_4BA7EC(int a1)
{
  char *v2; // $s3
  char *v3; // $s2
  char *v4; // $s0
  const char *v5; // $v0
  int v6; // $s3
  const char *v7; // $v0
  const char *v8; // $v0
  int v9; // $a0
  const char *v10; // $v0
  char *v11; // $v1
  int v12; // $t1
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  char v17[1024]; // [sp+18h] [-400h] BYREF

  v2 = httpd_get_parm(a1, "en");
  v3 = httpd_get_parm(a1, "addr");
  v4 = httpd_get_parm(a1, "port");
  if ( !v2 || (v5 = (const char *)nvram_get("sj_ctrl_en")) != 0 && !strcmp(v5, v2) )
  {
    v6 = 0;
  }
  else
  {
    nvram_set("sj_ctrl_en", v2);
    v6 = 1;
  }
  if ( !v3 || (v7 = (const char *)nvram_get("sj_ctrl_addr")) != 0 && !strcmp(v7, v3) )
  {
    if ( !v4 )
      goto LABEL_18;
    v8 = (const char *)nvram_get("sj_ctrl_port");
    if ( !v8 )
      goto LABEL_10;
LABEL_17:
    if ( strcmp(v8, v4) )
      goto LABEL_10;
LABEL_18:
    if ( !v6 )
      goto LABEL_12;
    goto LABEL_11;
  }
  nvram_set("sj_ctrl_addr", v3);
  if ( v4 )
  {
    v8 = (const char *)nvram_get("sj_ctrl_port");
    v6 = 1;
    if ( !v8 )
    {
LABEL_10:
      nvram_set("sj_ctrl_port", v4);
      goto LABEL_11;
    }
    goto LABEL_17;
  }
LABEL_11:
  restart_shenji_ctrl();
  jhl_parm_commit(v9);
LABEL_12:
  v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  v11 = v17;
  do
  {
    v12 = *(_DWORD *)v10;
    v13 = *((_DWORD *)v10 + 1);
    v14 = *((_DWORD *)v10 + 2);
    v15 = *((_DWORD *)v10 + 3);
    v10 += 16;
    *(_DWORD *)v11 = v12;
    *((_DWORD *)v11 + 1) = v13;
    *((_DWORD *)v11 + 2) = v14;
    *((_DWORD *)v11 + 3) = v15;
    v11 += 16;
  }
  while ( v10 != "}" );
  *(_WORD *)v11 = *(_WORD *)v10;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 4BA97C: variable 'v9' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A88A8: using guessed type int restart_shenji_ctrl(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004BAA64) --------------------------------------------------------
int __fastcall sub_4BAA64(int a1)
{
  const char *v2; // $s7
  const char *v3; // $s0
  const char *v4; // $s1
  const char *v5; // $s2
  const char *v6; // $s4
  const char *v7; // $s5
  const char *v8; // $s6
  const char *v9; // $v0
  int v10; // $s1
  unsigned int v11; // $v0
  char v13[1028]; // [sp+30h] [-404h] BYREF

  strcpy(v13, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("sj_state_en");
  v3 = (const char *)jhl_nv_get_def("sj_app_id");
  v4 = (const char *)jhl_nv_get_def("sj_app_closeid");
  v5 = (const char *)jhl_nv_get_def("sj_app_remark");
  v6 = (const char *)jhl_nv_get_def("sj_list");
  v7 = (const char *)jhl_nv_get_def("sj_close_list");
  v8 = (const char *)jhl_nv_get_def("sj_state");
  v9 = (const char *)jhl_nv_get_def("sj_ctrl_state");
  v10 = sprintf(
          &v13[29],
          "\"en\":\"%s\",\"appid\":\"%s\",\"closeid\":\"%s\",\"remark\":\"%s\",\"sjlist\":%s,\"close_list\":%s,\"sj_state"
          "\":\"%s\", \"sj_ctrl_state\":\"%s\"",
          v2,
          v3,
          v4,
          v5,
          v6,
          v7,
          v8,
          v9)
      + 29;
  v11 = snprintf(&v13[v10], 1024 - v10, "}}");
  if ( v11 >= 1024 - v10 )
    v11 = 1023 - v10;
  return httpd_cgi_ret(a1, v13, v11 + v10, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004BAC7C) --------------------------------------------------------
int __fastcall sub_4BAC7C(int a1)
{
  char *v2; // $s2
  char *v3; // $s5
  char *v4; // $s4
  char *v5; // $s3
  const char *v6; // $v0
  int v7; // $a2
  int v8; // $a0
  const char *v9; // $v0
  unsigned int v10; // $v0
  const char *v12; // $v0
  int v13; // $s2
  const char *v14; // $v0
  const char *v15; // $v0
  const char *v16; // $v0
  char *v17; // $v1
  const char *v18; // $v0
  int v19; // $t0
  int v20; // $a3
  int v21; // $a2
  int v22; // $a1
  char v23[1024]; // [sp+20h] [-400h] BYREF

  v2 = httpd_get_parm(a1, "en");
  v3 = httpd_get_parm(a1, "appid");
  v4 = httpd_get_parm(a1, "closeid");
  v5 = httpd_get_parm(a1, "remark");
  memset(v23, 0, sizeof(v23));
  v6 = (const char *)nvram_get("sj_ctrl_connect_state");
  if ( v6 && !strcmp(v6, "1") )
  {
    if ( !v2 || (v12 = (const char *)nvram_get("sj_state_en")) != 0 && !strcmp(v12, v2) )
    {
      v13 = 0;
    }
    else
    {
      syslog(7, "%s[%d]:  set sj_en=%s\n", "shenji_asp", 998, v2);
      nvram_set("sj_en", v2);
      nvram_set("sj_ftp_en2", v2);
      nvram_set("sj_state_en", v2);
      v13 = 1;
      exec_service("wys_sj-restart");
    }
    if ( v3 )
    {
      v14 = (const char *)nvram_get("sj_app_id");
      if ( !v14 || strcmp(v14, v3) )
      {
        nvram_set("sj_app_id", v3);
        v13 = 1;
      }
    }
    if ( !v4 || (v15 = (const char *)nvram_get("sj_app_closeid")) != 0 && !strcmp(v15, v4) )
    {
      if ( !v5 )
      {
LABEL_28:
        if ( !v13 )
        {
LABEL_24:
          v17 = v23;
          v18 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          do
          {
            v19 = *(_DWORD *)v18;
            v20 = *((_DWORD *)v18 + 1);
            v21 = *((_DWORD *)v18 + 2);
            v22 = *((_DWORD *)v18 + 3);
            v18 += 16;
            *(_DWORD *)v17 = v19;
            *((_DWORD *)v17 + 1) = v20;
            *((_DWORD *)v17 + 2) = v21;
            *((_DWORD *)v17 + 3) = v22;
            v17 += 16;
          }
          while ( v18 != "}" );
          *(_WORD *)v17 = *(_WORD *)v18;
          return httpd_cgi_ret(a1, v23, 33, 4);
        }
LABEL_23:
        jhl_parm_commit(v8);
        goto LABEL_24;
      }
    }
    else
    {
      nvram_set("sj_app_closeid", v4);
      if ( !v5 )
        goto LABEL_23;
      v13 = 1;
    }
    v16 = (const char *)nvram_get("sj_app_remark");
    if ( !v16 || strcmp(v16, v5) )
    {
      nvram_set("sj_app_remark", v5);
      goto LABEL_23;
    }
    goto LABEL_28;
  }
  v9 = (const char *)_GET_LANG_TEXT(66, *(unsigned __int8 *)(a1 + 210102), v7);
  v10 = snprintf(v23, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v9);
  if ( v10 >= 0x400 )
    v10 = 1023;
  return httpd_cgi_ret(a1, v23, v10, 4);
}
// 4BAD90: variable 'v7' is possibly undefined
// 4BB000: variable 'v8' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004BB09C) --------------------------------------------------------
int __fastcall sub_4BB09C(int a1)
{
  return sj_dev_info_data(a1);
}

//----- (004BB0B8) --------------------------------------------------------
int __fastcall sub_4BB0B8(int a1)
{
  return sj_dev_info_asp(a1);
}

//----- (004BB0D4) --------------------------------------------------------
int __fastcall sub_4BB0D4(int a1)
{
  char *v2; // $s2
  char *v3; // $s4
  int v4; // $a1
  const char *v5; // $a2
  int v6; // $a0
  const char *v7; // $v0
  unsigned int v8; // $a2
  const char *v10; // $v0
  int v11; // $s2
  int v12; // $v0
  const char *v13; // $s6
  void *v14; // $v0
  int v15; // $s5
  void *v16; // $s4
  int v17; // $v0
  int v18; // $a0
  int v19; // $a3
  const char *v20; // $v0
  char *v21; // $v1
  const char *v22; // $v0
  int v23; // $t0
  int v24; // $a3
  int v25; // $a2
  int v26; // $a1
  char v27[128]; // [sp+20h] [-188h] BYREF
  char v28[128]; // [sp+A0h] [-108h] BYREF
  char v29[128]; // [sp+120h] [-88h] BYREF
  int v30; // [sp+1A0h] [-8h]

  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  memset(v27, 0, sizeof(v27));
  v2 = httpd_get_parm(a1, "type");
  v3 = httpd_get_parm(a1, "id");
  if ( !v2 || !*v2 || !v3 || !*v3 )
  {
    v4 = *(unsigned __int8 *)(a1 + 210102);
    v5 = "not type or id";
    v6 = 12;
LABEL_4:
    v7 = (const char *)_GET_LANG_TEXT(v6, v4, v5);
    v8 = snprintf(v29, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x80 )
      v8 = 127;
    return httpd_cgi_ret(a1, v29, v8, 4);
  }
  if ( !strcmp(v3, "param") )
  {
    v20 = (const char *)nvram_get("sj_devparam_type");
    if ( v20 && !strcmp(v20, v2) )
    {
      v11 = 0;
    }
    else
    {
      nvram_set("sj_devparam_type", v2);
      v11 = 1;
    }
    v21 = v27;
    v22 = "/tmp/sj_html/sj_dev_info_hide.htm";
    do
    {
      v23 = *(_DWORD *)v22;
      v24 = *((_DWORD *)v22 + 1);
      v25 = *((_DWORD *)v22 + 2);
      v26 = *((_DWORD *)v22 + 3);
      v22 += 16;
      *(_DWORD *)v21 = v23;
      *((_DWORD *)v21 + 1) = v24;
      *((_DWORD *)v21 + 2) = v25;
      *((_DWORD *)v21 + 3) = v26;
      v21 += 16;
    }
    while ( v22 != "m" );
    *(_WORD *)v21 = *(_WORD *)v22;
  }
  else
  {
    if ( strcmp(v3, "srv") )
    {
      sprintf(v28, "not id: %s", v3);
      v4 = *(unsigned __int8 *)(a1 + 210102);
      v5 = v28;
      v6 = 12;
      goto LABEL_4;
    }
    v10 = (const char *)nvram_get("sj_srv_type");
    if ( v10 && !strcmp(v10, v2) )
    {
      v11 = 0;
    }
    else
    {
      nvram_set("sj_srv_type", v2);
      v11 = 1;
    }
    strcpy(v27, "/tmp/sj_html/sj_state_hide.htm");
  }
  if ( !f_exists(v27) )
  {
    sprintf(v28, "not found path: %s", v27);
    v4 = *(unsigned __int8 *)(a1 + 210102);
    v5 = "not find path";
    v6 = 12;
    goto LABEL_4;
  }
  v12 = f_size(v27);
  v13 = (const char *)(v12 + 1);
  v15 = v12;
  _mem_malloc(v12 + 1, "shenji_info_htm", 1102);
  v16 = v14;
  if ( !v14 )
  {
    v4 = *(unsigned __int8 *)(a1 + 210102);
    v5 = v13;
    v6 = 4;
    goto LABEL_4;
  }
  v17 = f_read(v27, v14, v15);
  v19 = v17;
  if ( v11 )
  {
    v30 = v17;
    jhl_parm_commit(v18);
    v19 = v30;
  }
  return httpd_send_mime_file(a1, "text/html", v16, v19);
}
// 4BB414: variable 'v14' is possibly undefined
// 4BB4FC: variable 'v18' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);
// 6A869C: using guessed type int __fastcall f_read(_DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8950: using guessed type int __fastcall f_size(_DWORD);

//----- (004BB540) --------------------------------------------------------
int __fastcall sub_4BB540(int a1)
{
  int v2; // $v0
  char *v3; // $a0
  int v4; // $v0
  char *v5; // $a0
  int v6; // $v0
  int v7; // $s6
  const char *v8; // $s1
  _BYTE *v9; // $v0
  const char *v10; // $s0
  const char *v11; // $s2
  const char *v12; // $s3
  const char *v13; // $s4
  const char *v14; // $a1
  const char *v15; // $v0
  int v16; // $v0
  int v17; // $s0
  int v18; // $s1
  int v19; // $v0
  int v20; // $a2
  const char *v22; // $v0
  unsigned int v23; // $v0
  char v24[256]; // [sp+90h] [-198h] BYREF
  char v25[32]; // [sp+190h] [-98h] BYREF
  char v26[32]; // [sp+1B0h] [-78h] BYREF
  const char *v27; // [sp+1D0h] [-58h]
  const char *v28; // [sp+1D4h] [-54h]
  const char *v29; // [sp+1D8h] [-50h]
  const char *v30; // [sp+1DCh] [-4Ch]
  const char *v31; // [sp+1E0h] [-48h]
  const char *v32; // [sp+1E4h] [-44h]
  const char *v33; // [sp+1E8h] [-40h]
  const char *v34; // [sp+1ECh] [-3Ch]
  const char *v35; // [sp+1F0h] [-38h]
  const char *v36; // [sp+1F4h] [-34h]
  const char *v37; // [sp+1F8h] [-30h]
  const char *v38; // [sp+1FCh] [-2Ch]
  const char *v39; // [sp+200h] [-28h]
  const char *v40; // [sp+204h] [-24h]
  const char *v41; // [sp+208h] [-20h]
  const char *v42; // [sp+20Ch] [-1Ch]
  const char *v43; // [sp+210h] [-18h]
  const char *v44; // [sp+214h] [-14h]
  const char *v45; // [sp+218h] [-10h]
  const char *v46; // [sp+21Ch] [-Ch]
  const char *v47; // [sp+220h] [-8h]
  const char *v48; // [sp+224h] [-4h]

  v2 = jhl_nv_get_def("sj_des_key");
  if ( v2 )
    v3 = (char *)v2;
  else
    v3 = "";
  jhl_string_encoding_json(v3, v26, 32);
  v4 = jhl_nv_get_def("sj_des_iv");
  if ( v4 )
    v5 = (char *)v4;
  else
    v5 = "";
  jhl_string_encoding_json(v5, v25, 32);
  _mem_malloc(10240, "sj_state_data", 1135);
  v7 = v6;
  if ( v6 )
  {
    strcpy((char *)v6, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy((void *)v6, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v6 + 24) = 975331700;
    v27 = (const char *)jhl_nv_get_def("sj_en");
    v28 = (const char *)jhl_nv_get_def("sj_ftp_srvaddr");
    v29 = (const char *)jhl_nv_get_def("sj_ftp_user");
    v30 = (const char *)jhl_nv_get_def("sj_ftp_pass");
    v31 = (const char *)jhl_nv_get_def("sj_ftp_port");
    v32 = (const char *)jhl_nv_get_def("sj_state");
    v33 = (const char *)jhl_nv_get_def("sj_other_srvaddr");
    v34 = (const char *)jhl_nv_get_def("sj_other_port");
    v35 = (const char *)jhl_nv_get_def("sj_other_udpport");
    v36 = (const char *)jhl_nv_get_def("sj_other_tcpport");
    v37 = (const char *)jhl_nv_get_def("sj_heart_udpport");
    v8 = (const char *)nvram_get("sj_srv_type");
    v38 = (const char *)(v7 + 29);
    if ( !v8 )
      v8 = "";
    v38 = (const char *)jhl_nv_get_def("sj_ftp_srvaddr2");
    v39 = (const char *)jhl_nv_get_def("sj_ftp_user2");
    v40 = (const char *)jhl_nv_get_def("sj_ftp_pass2");
    v41 = (const char *)jhl_nv_get_def("sj_ftp_port2");
    v42 = (const char *)jhl_nv_get_def("sj_send_data_info");
    v43 = (const char *)jhl_nv_get_def("sj_send_data_tim");
    v9 = (_BYTE *)nvram_get("sj_real_dev_sn");
    if ( v9 && !*v9 )
    {
      v10 = (const char *)nvram_get("sj_palce_code");
      if ( v10 )
        goto LABEL_11;
    }
    else
    {
      v10 = (const char *)nvram_get("sj_real_dev_sn");
      if ( v10 )
      {
LABEL_11:
        v11 = (const char *)nvram_get("sj_real_tz_sn");
        if ( !v11 )
          v11 = "";
        v44 = (const char *)jhl_nv_get_def("sj_ftp_en2");
        v45 = (const char *)jhl_nv_get_def("sj_create_time");
        v46 = (const char *)jhl_nv_get_def("sj_ztcp_srvaddr");
        v47 = (const char *)jhl_nv_get_def("sj_ztcp_srvport");
        v12 = (const char *)nvram_get("sj_title");
        if ( !v12 )
          v12 = "";
        v13 = (const char *)nvram_get("sj_subtype");
        if ( !v13 )
          v13 = "";
        v14 = (const char *)nvram_get("yh_platform_addr");
        if ( !v14 )
          v14 = "";
        v48 = v14;
        v15 = (const char *)nvram_get("yh_platform_port");
        if ( !v15 )
          v15 = "";
        v16 = snprintf(
                (char *)(v7 + 29),
                10211,
                "\"enable\":\"%s\",\"srv_addr\":\"%s\",\"srv_user\":\"%s\",\"srv_pwd\":\"%s\",\"srv_port\":\"%s\",\"statu"
                "s\":\"%s\",\"other_srv_addr\":\"%s\",\"other_srv_port\":\"%s\",\"udp_srv_port\":\"%s\",\"tcp_srv_port\":"
                "\"%s\",\"heart_udp_port\":\"%s\",\"srv_type\":\"%s\",\"srv_addr2\":\"%s\",\"srv_user2\":\"%s\",\"srv_pwd"
                "2\":\"%s\",\"srv_port2\":\"%s\",\"senddata_info\":\"%s\",\"senddata_tim\":\"%s\",\"dev_sn\":\"%s\",\"tz_"
                "sn\":\"%s\",\"enable2\":\"%s\",\"create_time\":\"%s\",\"ztcp_srv_addr\":\"%s\",\"ztcp_srv_port\":\"%s\","
                "\"des_key\":\"%s\",\"des_iv\":\"%s\",\"sj_title\":\"%s\",\"sj_subtype\":\"%s\",\"yh_platform_addr\":\"%s"
                "\",\"yh_platform_port\":\"%s\"",
                v27,
                v28,
                v29,
                v30,
                v31,
                v32,
                v33,
                v34,
                v35,
                v36,
                v37,
                v8,
                v38,
                v39,
                v40,
                v41,
                v42,
                v43,
                v10,
                v11,
                v44,
                v45,
                v46,
                v47,
                v26,
                v25,
                v12,
                v13,
                v48,
                v15);
        if ( v16 >= 10211 )
          v16 = 10210;
        v17 = v16 + 29;
        v18 = 10240 - (v16 + 29);
        v19 = snprintf((char *)(v7 + v16 + 29), v18, "}}");
        if ( v19 >= v18 )
          v20 = 10239 - v17;
        else
          v20 = v19;
        return httpd_cgi_ret(a1, (char *)v7, v20 + v17, 8);
      }
    }
    v10 = "";
    goto LABEL_11;
  }
  v22 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
  v23 = snprintf(v24, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v22);
  if ( v23 >= 0x100 )
    v23 = 255;
  return httpd_cgi_ret(a1, v24, v23, 4);
}
// 4BB618: variable 'v6' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A87FC: using guessed type int __fastcall jhl_string_encoding_json(_DWORD, _DWORD, _DWORD);

//----- (004BBC80) --------------------------------------------------------
int __fastcall sub_4BBC80(int a1)
{
  char *v2; // $s1
  char *v3; // $s7
  char *v4; // $s6
  char *v5; // $s5
  char *v6; // $v0
  char *v7; // $s3
  char *v8; // $s4
  const char *v9; // $v0
  int v10; // $s1
  const char *v11; // $v0
  const char *v12; // $v0
  const char *v13; // $v0
  const char *v14; // $s6
  const char *v15; // $v0
  const char *v16; // $s6
  const char *v17; // $v0
  const char *v18; // $s6
  const char *v19; // $v0
  const char *v20; // $s6
  const char *v21; // $v0
  const char *v22; // $s6
  const char *v23; // $v0
  const char *v24; // $s6
  const char *v25; // $v0
  const char *v26; // $s6
  const char *v27; // $v0
  const char *v28; // $s6
  const char *v29; // $v0
  const char *v30; // $s6
  const char *v31; // $v0
  const char *v32; // $s6
  const char *v33; // $v0
  const char *v34; // $s6
  const char *v35; // $v0
  const char *v36; // $s6
  const char *v37; // $v0
  const char *v38; // $s6
  const char *v39; // $v0
  const char *v40; // $s6
  const char *v41; // $v0
  const char *v42; // $s6
  const char *v43; // $v0
  const char *v44; // $s6
  const char *v45; // $v0
  const char *v46; // $v0
  const char *v47; // $v0
  const char *v48; // $v0
  _BYTE *v49; // $v0
  struct tm *v50; // $v0
  char *v51; // $s2
  int v52; // $a0
  char *v53; // $v1
  const char *v54; // $v0
  int v55; // $t0
  int v56; // $a3
  int v57; // $a2
  int v58; // $a1
  char v60[256]; // [sp+30h] [-198h] BYREF
  char v61[64]; // [sp+130h] [-98h] BYREF
  time_t v62; // [sp+170h] [-58h] BYREF
  char *v63; // [sp+178h] [-50h]
  char *v64; // [sp+17Ch] [-4Ch]
  char *v65; // [sp+180h] [-48h]
  char *v66; // [sp+184h] [-44h]
  char *v67; // [sp+188h] [-40h]
  char *v68; // [sp+18Ch] [-3Ch]
  char *v69; // [sp+190h] [-38h]
  char *v70; // [sp+194h] [-34h]
  char *v71; // [sp+198h] [-30h]
  char *v72; // [sp+19Ch] [-2Ch]
  char *v73; // [sp+1A0h] [-28h]
  char *v74; // [sp+1A4h] [-24h]
  char *v75; // [sp+1A8h] [-20h]
  char *v76; // [sp+1ACh] [-1Ch]
  char *v77; // [sp+1B0h] [-18h]
  char *v78; // [sp+1B4h] [-14h]
  char *v79; // [sp+1B8h] [-10h]
  char *v80; // [sp+1BCh] [-Ch]
  char *v81; // [sp+1C0h] [-8h]

  v79 = v60;
  memset(v60, 0, sizeof(v60));
  v81 = v61;
  memset(v61, 0, sizeof(v61));
  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "srv_addr");
  v4 = httpd_get_parm(a1, "srv_user");
  v5 = httpd_get_parm(a1, "srv_pwd");
  v63 = httpd_get_parm(a1, "srv_port");
  v64 = httpd_get_parm(a1, "other_srv_addr");
  v65 = httpd_get_parm(a1, "other_srv_port");
  v66 = httpd_get_parm(a1, "udp_srv_port");
  v67 = httpd_get_parm(a1, "tcp_srv_port");
  v68 = httpd_get_parm(a1, "heart_udp_port");
  v69 = httpd_get_parm(a1, "enable2");
  v70 = httpd_get_parm(a1, "srv_addr2");
  v71 = httpd_get_parm(a1, "srv_user2");
  v72 = httpd_get_parm(a1, "srv_pwd2");
  v73 = httpd_get_parm(a1, "srv_port2");
  v74 = httpd_get_parm(a1, "createtime");
  v75 = httpd_get_parm(a1, "ztcp_srv_addr");
  v76 = httpd_get_parm(a1, "ztcp_srv_port");
  v77 = httpd_get_parm(a1, "des_iv");
  v6 = httpd_get_parm(a1, "des_key");
  v80 = "1\"";
  v78 = v6;
  v7 = httpd_get_parm(a1, "yh_platform_addr");
  v8 = httpd_get_parm(a1, "yh_platform_port");
  if ( !v2 || (v9 = (const char *)nvram_get("sj_en")) != 0 && !strcmp(v9, v2) )
  {
    v10 = 0;
  }
  else
  {
    syslog(7, "%s[%d]:  set sj_en=%s\n", "sj_state_asp", 1228, v2);
    nvram_set("sj_en", v2);
    v10 = 1;
  }
  if ( v3 )
  {
    v11 = (const char *)nvram_get("sj_ftp_srvaddr");
    if ( !v11 || strcmp(v11, v3) )
    {
      nvram_set("sj_ftp_srvaddr", v3);
      v10 = 1;
    }
  }
  if ( v4 )
  {
    v12 = (const char *)nvram_get("sj_ftp_user");
    if ( !v12 || strcmp(v12, v4) )
    {
      nvram_set("sj_ftp_user", v4);
      v10 = 1;
    }
  }
  if ( v5 )
  {
    v13 = (const char *)nvram_get("sj_ftp_pass");
    if ( !v13 || strcmp(v13, v5) )
    {
      nvram_set("sj_ftp_pass", v5);
      v10 = 1;
    }
  }
  v14 = v63;
  if ( v63 )
  {
    v15 = (const char *)nvram_get("sj_ftp_port");
    if ( !v15 || strcmp(v15, v14) )
    {
      nvram_set("sj_ftp_port", v63);
      v10 = 1;
    }
  }
  v16 = v64;
  if ( v64 )
  {
    v17 = (const char *)nvram_get("sj_other_srvaddr");
    if ( !v17 || strcmp(v17, v16) )
    {
      nvram_set("sj_other_srvaddr", v64);
      v10 = 1;
    }
  }
  v18 = v65;
  if ( v65 )
  {
    v19 = (const char *)nvram_get("sj_other_port");
    if ( !v19 || strcmp(v19, v18) )
    {
      nvram_set("sj_other_port", v65);
      v10 = 1;
    }
  }
  v20 = v75;
  if ( v75 )
  {
    v21 = (const char *)nvram_get("sj_ztcp_srvaddr");
    if ( !v21 || strcmp(v21, v20) )
    {
      nvram_set("sj_ztcp_srvaddr", v75);
      v10 = 1;
    }
  }
  v22 = v76;
  if ( v76 )
  {
    v23 = (const char *)nvram_get("sj_ztcp_srvport");
    if ( !v23 || strcmp(v23, v22) )
    {
      nvram_set("sj_ztcp_srvport", v76);
      v10 = 1;
    }
  }
  v24 = v66;
  if ( v66 )
  {
    v25 = (const char *)nvram_get("sj_other_udpport");
    if ( !v25 || strcmp(v25, v24) )
    {
      nvram_set("sj_other_udpport", v66);
      v10 = 1;
    }
  }
  v26 = v68;
  if ( v68 )
  {
    v27 = (const char *)nvram_get("sj_heart_udpport");
    if ( !v27 || strcmp(v27, v26) )
    {
      nvram_set("sj_heart_udpport", v68);
      v10 = 1;
    }
  }
  v28 = v67;
  if ( v67 )
  {
    v29 = (const char *)nvram_get("sj_other_tcpport");
    if ( !v29 || strcmp(v29, v28) )
    {
      nvram_set("sj_other_tcpport", v67);
      v10 = 1;
    }
  }
  v30 = v69;
  if ( v69 )
  {
    v31 = (const char *)nvram_get("sj_ftp_en2");
    if ( !v31 || strcmp(v31, v30) )
    {
      nvram_set("sj_ftp_en2", v69);
      v10 = 1;
    }
  }
  v32 = v70;
  if ( v70 )
  {
    v33 = (const char *)nvram_get("sj_ftp_srvaddr2");
    if ( !v33 || strcmp(v33, v32) )
    {
      nvram_set("sj_ftp_srvaddr2", v70);
      v10 = 1;
    }
  }
  v34 = v71;
  if ( v71 )
  {
    v35 = (const char *)nvram_get("sj_ftp_user2");
    if ( !v35 || strcmp(v35, v34) )
    {
      nvram_set("sj_ftp_user2", v71);
      v10 = 1;
    }
  }
  v36 = v72;
  if ( v72 )
  {
    v37 = (const char *)nvram_get("sj_ftp_pass2");
    if ( !v37 || strcmp(v37, v36) )
    {
      nvram_set("sj_ftp_pass2", v72);
      v10 = 1;
    }
  }
  v38 = v73;
  if ( v73 )
  {
    v39 = (const char *)nvram_get("sj_ftp_port2");
    if ( !v39 || strcmp(v39, v38) )
    {
      nvram_set("sj_ftp_port2", v73);
      v10 = 1;
    }
  }
  v40 = v74;
  if ( v74 )
  {
    v41 = (const char *)nvram_get("sj_create_time");
    if ( !v41 || strcmp(v41, v40) )
    {
      nvram_set("sj_create_time", v74);
      v10 = 1;
    }
  }
  v42 = v78;
  if ( v78 )
  {
    v43 = (const char *)nvram_get("sj_des_key");
    if ( !v43 || strcmp(v43, v42) )
    {
      nvram_set("sj_des_key", v78);
      v10 = 1;
    }
  }
  v44 = v77;
  if ( v77 )
  {
    v45 = (const char *)nvram_get("sj_des_iv");
    if ( !v45 || strcmp(v45, v44) )
    {
      nvram_set("sj_des_iv", v77);
      v10 = 1;
    }
  }
  if ( !v7 )
    goto LABEL_94;
  v46 = (const char *)nvram_get("yh_platform_addr");
  if ( !v46 || strcmp(v46, v7) )
  {
    nvram_set("yh_platform_addr", v7);
    v10 = 1;
  }
  v47 = (const char *)nvram_get("yh_platform_addr");
  if ( v47 )
  {
    if ( !strcmp(v47, v7) )
    {
LABEL_94:
      if ( !v8 )
        goto LABEL_97;
      v48 = (const char *)nvram_get(v80 - 2844);
      if ( !v48 )
        goto LABEL_89;
LABEL_96:
      if ( strcmp(v48, v8) )
        goto LABEL_89;
LABEL_97:
      if ( !v10 )
        goto LABEL_98;
      goto LABEL_90;
    }
  }
  nvram_set("yh_platform_addr", v7);
  if ( !v8 )
    goto LABEL_90;
  v48 = (const char *)nvram_get(v80 - 2844);
  v10 = 1;
  if ( v48 )
    goto LABEL_96;
LABEL_89:
  nvram_set(v80 - 2844, v8);
LABEL_90:
  v49 = (_BYTE *)nvram_get("sj_create_time");
  if ( v49 && !*v49 )
  {
    time(&v62);
    v50 = localtime(&v62);
    v51 = v81;
    snprintf(
      v81,
      63,
      "%04d-%02d-%02d %02d:%02d:%02d",
      v50->tm_year + 1900,
      v50->tm_mon + 1,
      v50->tm_mday,
      v50->tm_hour,
      v50->tm_min,
      v50->tm_sec);
    nvram_set("sj_create_time", v51);
  }
  shenji_ctrl_set_en();
  nvram_set("sj_state", "");
  jhl_parm_commit(v52);
  exec_service("wys_sj-restart");
LABEL_98:
  v53 = v79;
  v54 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v55 = *(_DWORD *)v54;
    v56 = *((_DWORD *)v54 + 1);
    v57 = *((_DWORD *)v54 + 2);
    v58 = *((_DWORD *)v54 + 3);
    v54 += 16;
    *(_DWORD *)v53 = v55;
    *((_DWORD *)v53 + 1) = v56;
    *((_DWORD *)v53 + 2) = v57;
    *((_DWORD *)v53 + 3) = v58;
    v53 += 16;
  }
  while ( v54 != "}" );
  *(_WORD *)v53 = *(_WORD *)v54;
  return httpd_cgi_ret(a1, v79, 33, 4);
}
// 4BC940: variable 'v52' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004BCA50) --------------------------------------------------------
int __fastcall sub_4BCA50(int a1)
{
  const char *v2; // $s4
  const char *v3; // $s1
  const char *v4; // $s3
  int v5; // $v0
  const char *v6; // $v0
  const char *v7; // $s0
  int v8; // $s1
  unsigned int v9; // $v0
  char v11[1024]; // [sp+28h] [-400h] BYREF

  strcpy(v11, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("sj_en");
  v3 = (const char *)jhl_nv_get_def(&unk_64F814);
  v4 = (const char *)jhl_nv_get_def("sj_platform_srv_port");
  v5 = nvram_get("sj_state");
  if ( v5 )
  {
    v7 = (const char *)v5;
    v6 = (const char *)nvram_get("sj_send_last_time");
    if ( v6 )
      goto LABEL_3;
  }
  else
  {
    v6 = (const char *)nvram_get("sj_send_last_time");
    v7 = (const char *)&unk_64F808;
    if ( v6 )
      goto LABEL_3;
  }
  v6 = "";
LABEL_3:
  v8 = sprintf(
         &v11[29],
         "\"enable\":\"%s\",\"srv_addr\":\"%s\",\"srv_port\":\"%s\",\"status\":\"%s\",\"last_time\":\"%s\"",
         v2,
         v3,
         v4,
         v7,
         v6)
     + 29;
  v9 = snprintf(&v11[v8], 1024 - v8, "}}");
  if ( v9 >= 1024 - v8 )
    v9 = 1023 - v8;
  return httpd_cgi_ret(a1, v11, v9 + v8, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004BCC28) --------------------------------------------------------
int __fastcall sub_4BCC28(int a1)
{
  char *v2; // $s4
  char *v3; // $s3
  int v4; // $a0
  char *v5; // $s1
  const char *v6; // $v0
  int v7; // $s4
  const char *v8; // $v0
  const char *v9; // $v0
  char *v10; // $v1
  const char *v11; // $v0
  int v12; // $t0
  int v13; // $a3
  int v14; // $a2
  int v15; // $a1
  char v17[132]; // [sp+18h] [-84h] BYREF

  memset(v17, 0, 0x80u);
  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "srv_addr");
  v5 = httpd_get_parm(a1, "srv_port");
  if ( !v2 || (v6 = (const char *)nvram_get("sj_en")) != 0 && !strcmp(v6, v2) )
  {
    v7 = 0;
  }
  else
  {
    nvram_set("sj_en", v2);
    v7 = 1;
  }
  if ( !v3 || (v8 = (const char *)nvram_get(&unk_64F814)) != 0 && !strcmp(v8, v3) )
  {
    if ( !v5 )
      goto LABEL_18;
    v9 = (const char *)nvram_get("sj_platform_srv_port");
    if ( !v9 )
      goto LABEL_10;
LABEL_17:
    if ( strcmp(v9, v5) )
      goto LABEL_10;
LABEL_18:
    if ( !v7 )
      goto LABEL_12;
    goto LABEL_11;
  }
  nvram_set(&unk_64F814, v3);
  if ( v5 )
  {
    v9 = (const char *)nvram_get("sj_platform_srv_port");
    v7 = 1;
    if ( !v9 )
    {
LABEL_10:
      nvram_set("sj_platform_srv_port", v5);
      goto LABEL_11;
    }
    goto LABEL_17;
  }
LABEL_11:
  jhl_parm_commit(v4);
  exec_service("wys_sj-restart");
LABEL_12:
  v10 = v17;
  v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v12 = *(_DWORD *)v11;
    v13 = *((_DWORD *)v11 + 1);
    v14 = *((_DWORD *)v11 + 2);
    v15 = *((_DWORD *)v11 + 3);
    v11 += 16;
    *(_DWORD *)v10 = v12;
    *((_DWORD *)v10 + 1) = v13;
    *((_DWORD *)v10 + 2) = v14;
    *((_DWORD *)v10 + 3) = v15;
    v10 += 16;
  }
  while ( v11 != "}" );
  *(_WORD *)v10 = *(_WORD *)v11;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 4BCDC8: variable 'v4' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004BCED0) --------------------------------------------------------
int __fastcall sub_4BCED0(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s2
  const char *v5; // $s4
  const char *v6; // $s5
  const char *v7; // $s6
  const char *v8; // $s7
  const char *v9; // $fp
  const char *v10; // $v1
  const char *v11; // $v0
  int v12; // $s1
  const char *v13; // $s4
  const char *v14; // $s2
  const char *v15; // $s5
  const char *v16; // $v0
  int v17; // $s1
  int v18; // $s1
  const char *v19; // $v0
  int v20; // $s1
  int v21; // $v0
  int v22; // $v0
  int v23; // $s1
  int v24; // $s1
  int v25; // $v0
  int v26; // $a2
  int result; // $v0
  const char *v28; // $v0
  unsigned int v29; // $v0
  char v30[1024]; // [sp+38h] [-408h] BYREF
  const char *v31; // [sp+438h] [-8h]
  char *v32; // [sp+43Ch] [-4h]

  _mem_malloc(10240, "wayos_ac_server_data", 23);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\",\"da", 24);
    v4 = (const char *)jhl_nv_get_def("ac_server_enable");
    v5 = (const char *)jhl_nv_get_def("ac_server_mode");
    v6 = (const char *)jhl_nv_get_def("lan_gateway");
    v7 = (const char *)jhl_nv_get_def("lan_get_dns");
    v8 = (const char *)jhl_nv_get_def("lan_ipaddr");
    v9 = (const char *)jhl_nv_get_def("acserver_http_port");
    v10 = (const char *)nvram_get("ac_server_debug");
    if ( !v10 )
      v10 = "0";
    v32 = v3 + 29;
    v31 = v10;
    v11 = (const char *)jhl_nv_get_def("lan_ipaddr");
    v12 = sprintf(
            v3 + 29,
            "\"enable\":\"%s\",\"mode\":\"%s\",\"lan_gateway\":\"%s\",\"lan_dns\":\"%s\",\"server_addr\":\"%s://%s:%s\",\""
            "debug\":\"%s\",\"lan_ipaddr\":\"%s\"",
            v4,
            v5,
            v6,
            v7,
            "http",
            v8,
            v9,
            v31,
            v11)
        + 29;
    v13 = (const char *)nvram_get("proxy_ac_status");
    if ( !v13 )
      v13 = "0";
    v14 = (const char *)nvram_get("proxy_ac_port");
    if ( !v14 )
      v14 = "0";
    v15 = (const char *)nvram_get("proxy_ac_msg");
    if ( !v15 )
    {
      if ( get_web_language_type(a1) )
        v15 = "This function is not enabled";
      else
        v15 = (const char *)&unk_645EF8;
    }
    v16 = (const char *)jhl_nv_get_only_def("proxy_http_srv");
    v17 = v12
        + sprintf(
            &v3[v12],
            ",\"proxy_status\":\"%s\", \"proxy_port\":\"%s\",\"proxy_msg\":\"%s\",\"proxy_server\":\"%s\"",
            v13,
            v14,
            v15,
            v16);
    v18 = v17 + sprintf(&v3[v17], ",\"proxy_en\":\"%d\"", 1);
    v19 = (const char *)nvram_get("ac_server_run");
    if ( !v19 )
      v19 = "0";
    v20 = v18 + sprintf(&v3[v18], ",\"state\":\"%s\"", v19);
    v21 = nvram_get_int("ac_server_type");
    v23 = v20 + sprintf(&v3[v20], ",\"show_merge\":%d,\"server_type\":%d", 0, v21);
    v22 = get_log_data_in_sometime(27, v30, 1024);
    v24 = v23 + sprintf(&v3[v23], ",\"arp_err\":%d", v22 != 0);
    v25 = snprintf(&v3[v24], 10240 - v24, "}}");
    if ( v25 >= 10240 - v24 )
      v26 = 10239 - v24;
    else
      v26 = v25;
    result = httpd_cgi_ret(a1, v3, v26 + v24, 8);
  }
  else
  {
    v28 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 10240);
    v29 = snprintf(v30, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v28);
    if ( v29 >= 0x100 )
      v29 = 255;
    result = httpd_cgi_ret(a1, v30, v29, 4);
  }
  return result;
}
// 4BCF30: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A86F4: using guessed type int __fastcall jhl_nv_get_only_def(_DWORD);
// 6A8730: using guessed type int __fastcall get_log_data_in_sometime(_DWORD, _DWORD, _DWORD);

//----- (004BD3A8) --------------------------------------------------------
int __fastcall sub_4BD3A8(int a1)
{
  char *v2; // $s7
  char *v3; // $s6
  char *v4; // $s5
  char *v5; // $fp
  char *v6; // $s1
  char *v7; // $v0
  char *v8; // $v1
  const char *v9; // $v0
  int v10; // $t0
  int v11; // $a3
  int v12; // $a2
  int v13; // $a1
  char *v15; // $a1
  const char *v16; // $v0
  int v17; // $s4
  const char *v18; // $a1
  const char *v19; // $v0
  const char *v20; // $v0
  const char *v21; // $v0
  int v22; // $fp
  const char *v23; // $v0
  const char *v24; // $v0
  int v25; // $fp
  const char *v26; // $a1
  int v27; // $s7
  const char *v28; // $v0
  const char *v29; // $v0
  const char *v30; // $v0
  const char *v31; // $s4
  const char *v32; // $v0
  const char *v33; // $v0
  const char *v34; // $v0
  int v35; // $a0
  const char *v36; // $v0
  int v37; // $s6
  const char *v38; // $v0
  const char *v39; // $v0
  const char *v40; // $v0
  int v41; // $v0
  char v42[1024]; // [sp+18h] [-550h] BYREF
  char v43[256]; // [sp+418h] [-150h] BYREF
  const char *v44; // [sp+518h] [-50h] BYREF
  const char *v45; // [sp+51Ch] [-4Ch]
  char *v46; // [sp+520h] [-48h]
  int v47; // [sp+524h] [-44h]
  int v48; // [sp+528h] [-40h]
  const char *v49; // [sp+52Ch] [-3Ch]
  const char *v50; // [sp+530h] [-38h]
  const char *v51; // [sp+534h] [-34h]
  int v52; // [sp+538h] [-30h]
  char *v53; // [sp+540h] [-28h]
  char *v54; // [sp+544h] [-24h]
  int v55; // [sp+548h] [-20h]
  char *v56; // [sp+54Ch] [-1Ch]
  char *v57; // [sp+550h] [-18h]
  char *v58; // [sp+554h] [-14h]
  char *v59; // [sp+558h] [-10h]
  char *v60; // [sp+55Ch] [-Ch]
  const char *v61; // [sp+560h] [-8h]
  const char *v62; // [sp+564h] [-4h]

  memset(v43, 0, sizeof(v43));
  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "mode");
  v4 = httpd_get_parm(a1, "lan_gateway");
  v54 = httpd_get_parm(a1, "lan_dns");
  v5 = httpd_get_parm(a1, "debug");
  v6 = httpd_get_parm(a1, "action");
  v53 = httpd_get_parm(a1, "server_type");
  v7 = httpd_get_parm(a1, "opt");
  if ( !v7 || strcmp(v7, "proxy") )
  {
    if ( v6 )
    {
      if ( !strcmp(v6, "restart") )
      {
        exec_service("ac_server-restart");
      }
      else if ( !strcmp(v6, "stop") )
      {
        exec_service("ac_server-stop");
      }
      else if ( !strcmp(v6, "start") )
      {
        exec_service("ac_server-start");
      }
      goto LABEL_8;
    }
    if ( !v5 || (v21 = (const char *)nvram_get("ac_server_debug")) != 0 && !strcmp(v21, v5) )
    {
      v22 = 0;
    }
    else
    {
      nvram_set("ac_server_debug", v5);
      v22 = 1;
    }
    if ( v2 )
    {
      v23 = (const char *)nvram_get("ac_server_enable");
      if ( !v23 || strcmp(v23, v2) )
      {
        nvram_set("ac_server_enable", v2);
        memset(v42, 0, sizeof(v42));
        nvram_set("proxy_ac_status", "0");
        v24 = (const char *)nvram_get("proxy_ac_pid");
        if ( !v24 )
          v24 = "-1";
        v25 = J_atoi(v24);
        if ( v25 > 0 )
        {
          memset(v42, 0, sizeof(v42));
          snprintf(v42, 1024, "kill -9 %d &", v25);
          jhl_system(v42);
          if ( get_web_language_type(a1) )
            v26 = "This function is not enabled";
          else
            v26 = (const char *)&unk_645EF8;
          nvram_set("proxy_ac_msg", v26);
          nvram_set("proxy_ac_pid", "-1");
          nvram_set("proxy_ac_port", "");
        }
        v22 = 1;
      }
    }
    v27 = 0;
    if ( v3 )
    {
      v28 = (const char *)nvram_get("ac_server_mode");
      if ( !v28 || (v27 = 0, strcmp(v28, v3)) )
      {
        nvram_set("ac_server_mode", v3);
        v27 = 1;
        v22 = 1;
      }
      v29 = (const char *)nvram_get("ac_server_enable");
      if ( v29 )
      {
        if ( !strcmp(v29, "1") )
        {
          v36 = (const char *)nvram_get("ac_server_mode");
          if ( v36 )
          {
            if ( !strcmp(v36, "1") )
            {
              nvram_set("rzglType", "0");
              start_rzgl(0);
              v55 = sq_file_get_max_wan();
              if ( v55 > 0 )
              {
                v56 = "a";
                v37 = 0;
                v57 = "1\"";
                v58 = "a";
                v59 = "disable";
                v61 = "wan_conn";
                v62 = "restart";
                do
                {
                  v39 = (const char *)jhl_nvget("wan_proto", v37);
                  if ( strcmp(v56 + 12644, v39) || (v38 = (const char *)nvram_get(v57 - 20284)) == 0 || strcmp(v59, v38) )
                  {
                    v40 = (const char *)jhl_nvget("wan_proto", v37);
                    if ( strcmp(v58 + 12448, v40) )
                    {
                      v41 = jhl_nvget("wan_new_proto", v37);
                      nvram_set(v41, v58 + 12448);
                      v60 = v42;
                      sprintf(v42, "%d", v37);
                      v44 = v61;
                      v45 = v62;
                      v46 = v60;
                      v47 = 0;
                      eval_nowait(&v44, 0, 0, 0);
                    }
                  }
                  ++v37;
                }
                while ( v55 != v37 );
              }
              nvram_set("dhcp_type", &off_63F984);
              v22 = 1;
              start_dhcp_server();
            }
          }
        }
      }
    }
    if ( v4 )
    {
      v30 = (const char *)nvram_get("lan_gateway");
      if ( !v30 || strcmp(v30, v4) )
      {
        nvram_set("lan_gateway", v4);
        v27 = 1;
      }
    }
    v31 = v54;
    if ( v54 )
    {
      v32 = (const char *)nvram_get("lan_get_dns");
      if ( !v32 || strcmp(v32, v31) )
      {
        nvram_set("lan_get_dns", v54);
        v27 = 1;
      }
    }
    v33 = (const char *)nvram_get("ac_server_mode");
    if ( v33 && !strcmp(v33, "1") )
    {
      wan_webset(a1);
      lan_webset(a1);
    }
    if ( !v53 || (v34 = (const char *)nvram_get("server_type")) != 0 && !strcmp(v34, v53) )
    {
      if ( !v22 )
      {
        if ( !v27 )
          goto LABEL_8;
        goto LABEL_62;
      }
    }
    else
    {
      nvram_set("ac_server_type", v53);
    }
    exec_service("ac_server-restart");
    jhl_start_firewall();
LABEL_62:
    lanip_change();
    jhl_parm_commit(v35);
    goto LABEL_8;
  }
  memset(v42, 0, sizeof(v42));
  v15 = httpd_get_parm(a1, "status");
  if ( v15 )
    nvram_set("proxy_ac_status", v15);
  v16 = (const char *)nvram_get("proxy_ac_pid");
  if ( !v16 )
    v16 = "-1";
  v17 = J_atoi(v16);
  if ( v17 > 0 )
  {
    memset(v42, 0, sizeof(v42));
    snprintf(v42, 1024, "kill -9 %d", v17);
    system(v42);
    if ( get_web_language_type(a1) )
      v18 = "This function is not enabled";
    else
      v18 = (const char *)&unk_645EF8;
    nvram_set("proxy_ac_msg", v18);
    nvram_set("proxy_ac_pid", "-1");
    nvram_set("proxy_ac_port", "");
  }
  v19 = (const char *)nvram_get("proxy_ac_status");
  if ( v19 )
  {
    if ( !strcmp(v19, "1") )
    {
      v20 = (const char *)nvram_get("ac_server_enable");
      if ( v20 )
      {
        if ( !strcmp(v20, "1") )
        {
          v44 = "proxy_client";
          v45 = (const char *)jhl_nv_get_only_def("proxy_http_srv");
          v46 = (char *)jhl_nv_get_only_def("proxy_http_srvport");
          v47 = jhl_nv_get_def("lan_ipaddr");
          v48 = jhl_nv_get_def("acserver_http_port");
          v49 = "proxy_ac_port";
          v50 = "proxy_ac_msg";
          v51 = "proxy_ac_pid";
          v52 = 0;
          eval_nowait(&v44, 0, 0, 0);
        }
      }
    }
  }
LABEL_8:
  v8 = v43;
  v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v10 = *(_DWORD *)v9;
    v11 = *((_DWORD *)v9 + 1);
    v12 = *((_DWORD *)v9 + 2);
    v13 = *((_DWORD *)v9 + 3);
    v9 += 16;
    *(_DWORD *)v8 = v10;
    *((_DWORD *)v8 + 1) = v11;
    *((_DWORD *)v8 + 2) = v12;
    *((_DWORD *)v8 + 3) = v13;
    v8 += 16;
  }
  while ( v9 != "}" );
  *(_WORD *)v8 = *(_WORD *)v9;
  return httpd_cgi_ret(a1, v43, 33, 4);
}
// 4BDD84: variable 'v35' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84B8: using guessed type int start_dhcp_server(void);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A858C: using guessed type int jhl_start_firewall(void);
// 6A8594: using guessed type int __fastcall jhl_system(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A86D0: using guessed type int lanip_change(void);
// 6A86F4: using guessed type int __fastcall jhl_nv_get_only_def(_DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8978: using guessed type int __fastcall start_rzgl(_DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004BE060) --------------------------------------------------------
int __fastcall get_rule_num_limit(int a1)
{
  int result; // $v0

  switch ( a1 )
  {
    case 0:
      result = 32;
      break;
    case 1:
      result = sq_file_get_max_wan_no4g();
      break;
    case 2:
    case 3:
    case 5:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 18:
    case 19:
    case 21:
    case 22:
    case 23:
    case 24:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      result = 1024;
      break;
    case 8:
    case 37:
    case 41:
      result = 64;
      break;
    case 25:
      result = 1000;
      break;
    case 26:
    case 35:
    case 38:
    case 39:
      result = 512;
      break;
    case 36:
    case 40:
      result = 128;
      break;
    default:
      result = 256;
      break;
  }
  return result;
}
// 6A86E8: using guessed type int sq_file_get_max_wan_no4g(void);

//----- (004BE0E4) --------------------------------------------------------
int __fastcall sub_4BE0E4(int a1)
{
  int v2; // $fp
  int v3; // $s7
  int v4; // $v0
  unsigned int v5; // $v0
  unsigned int v6; // $v0
  unsigned int v7; // $s7
  unsigned int v8; // $v0
  char v10[4096]; // [sp+18h] [-1000h] BYREF

  memset(v10, 0, sizeof(v10));
  v2 = 0;
  strcpy(v10, "{\"code\":0,\"error\":\"\",\"data\":{\"limit\":[");
  v3 = 38;
  do
  {
    v4 = get_rule_num_limit(v2);
    v5 = snprintf(&v10[v3], 4096 - v3, "%u,", v4);
    ++v2;
    if ( v5 >= 4096 - v3 )
      v5 = 4095 - v3;
    v3 += v5;
  }
  while ( v2 != 42 );
  if ( v3 > 0 && v10[v3 - 1] == 44 )
    --v3;
  v10[v3] = 0;
  v6 = snprintf(&v10[v3], 4096 - v3, &byte_6445A0);
  if ( v6 >= 4096 - v3 )
    v6 = 4095 - v3;
  v7 = v6 + v3;
  v8 = snprintf(&v10[v7], 4096 - v7, "}}");
  if ( v8 >= 4096 - v7 )
    v8 = 4095 - v7;
  return httpd_cgi_ret(a1, v10, v8 + v7, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;

//----- (004BE30C) --------------------------------------------------------
int __fastcall get_rule_num(int a1, int a2)
{
  const char *v2; // $v0
  int v3; // $s1
  const char *v4; // $a0
  int v5; // $s1
  int v6; // $s0
  char *v7; // $v0

  v3 = a2 << 24;
  v2 = (const char *)jhl_nv_get_def(a1);
  if ( !v2 )
    return 0;
  v4 = v2;
  v5 = v3 >> 24;
  if ( !*v2 )
    return 0;
  v6 = 0;
  do
  {
    v7 = strchr(v4, v5);
    v4 = v7 + 1;
    ++v6;
  }
  while ( v7 && v7 != (char *)-1 && v7[1] );
  return v6;
}
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004BE3B8) --------------------------------------------------------
int __fastcall check_rule_num_limit(int a1, int a2, int a3, int a4, char *s, size_t maxlen)
{
  int v8; // $v0
  bool v9; // dc
  int v10; // $a2
  int result; // $v0
  const char *v12; // $v0

  v8 = get_rule_num(a3, (char)a4);
  v9 = v8 >= get_rule_num_limit(a2);
  result = 0;
  if ( v9 )
  {
    v12 = (const char *)_GET_LANG_TEXT(151, *(unsigned __int8 *)(a1 + 210102), v10);
    result = snprintf(s, maxlen, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v12);
    if ( result >= (int)maxlen )
      result = maxlen - 1;
  }
  return result;
}
// 4BE440: variable 'v10' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004BE4A0) --------------------------------------------------------
int __fastcall sub_4BE4A0(int a1)
{
  unsigned int v2; // $v0
  int v3; // $s0
  unsigned int v4; // $v0
  char v6[260]; // [sp+18h] [-104h] BYREF

  strcpy(v6, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = snprintf(&v6[29], 227, "\"total\":%u,\"all\":[]", 0);
  v3 = v2 + 29;
  if ( v2 >= 0xE3 )
    v3 = 255;
  v4 = snprintf(&v6[v3], 256 - v3, "}}");
  if ( v4 >= 256 - v3 )
    v4 = 255 - v3;
  return httpd_cgi_ret(a1, v6, v4 + v3, 4);
}
// 642164: using guessed type __int16 word_642164;

//----- (004BE5C0) --------------------------------------------------------
int __fastcall mr_addr_update_data(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  const char *v4; // $s1
  const char *v5; // $s3
  const char *v6; // $s4
  const char *v7; // $s5
  const char *v8; // $s6
  const char *v9; // $s7
  const char *v10; // $fp
  const char *v11; // $v0
  int v12; // $s3
  int v13; // $v0
  int v14; // $a2
  int result; // $v0
  const char *v16; // $v0
  unsigned int v17; // $v0
  char v18[256]; // [sp+48h] [-110h] BYREF
  const char *v19; // [sp+148h] [-10h]
  const char *v20; // [sp+14Ch] [-Ch]
  const char *v21; // [sp+150h] [-8h]
  const char *v22; // [sp+154h] [-4h]

  _mem_malloc(1024, "mr_addr_update_data", 1353);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\",\"da", 24);
    v4 = (const char *)jhl_nv_get_def("mr_addr_update_en");
    v5 = (const char *)jhl_nv_get_def("dianxin_update_path");
    v6 = (const char *)jhl_nv_get_def("dianxin_modify_time");
    v7 = (const char *)jhl_nv_get_def("wangtong_update_path");
    v8 = (const char *)jhl_nv_get_def("wangtong_modify_time");
    v9 = (const char *)jhl_nv_get_def("yidong_update_path");
    v10 = (const char *)jhl_nv_get_def("yidong_modify_time");
    v22 = (const char *)jhl_nv_get_def("jiaoyu_update_path");
    v21 = (const char *)jhl_nv_get_def("jiaoyu_modify_time");
    v20 = (const char *)jhl_nv_get_def("china_update_path");
    v19 = (const char *)jhl_nv_get_def("china_modify_time");
    v11 = (const char *)jhl_nv_get_def("mr_addr_update_time");
    v12 = sprintf(
            v3 + 29,
            "\"mr_addr_update\":\"%s\",\"enable\":\"%s\",\"dianxin_path\":\"%s\",\"dianxin_mod_time\":\"%s\", \t\t\"wangt"
            "ong_path\":\"%s\",\"wangtong_mod_time\":\"%s\",\"yidong_path\":\"%s\",\"yidong_mod_time\":\"%s\", \t\t\"jiao"
            "yu_path\":\"%s\",\"jiaoyu_mod_time\":\"%s\",\"china_path\":\"%s\",\"china_mod_time\":\"%s\",\"update_time\":\"%s\"",
            "1",
            v4,
            v5,
            v6,
            v7,
            v8,
            v9,
            v10,
            v22,
            v21,
            v20,
            v19,
            v11)
        + 29;
    v13 = snprintf(&v3[v12], 1024 - v12, "}}");
    if ( v13 >= 1024 - v12 )
      v14 = 1023 - v12;
    else
      v14 = v13;
    result = httpd_cgi_ret(a1, v3, v14 + v12, 8);
  }
  else
  {
    v16 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024);
    v17 = snprintf(v18, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v16);
    if ( v17 >= 0x100 )
      v17 = 255;
    result = httpd_cgi_ret(a1, v18, v17, 4);
  }
  return result;
}
// 4BE620: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004BE93C) --------------------------------------------------------
int __fastcall sub_4BE93C(int a1)
{
  const char *v2; // $v0
  unsigned int v3; // $v0
  int v4; // $s0
  unsigned int v5; // $v0
  char v7[132]; // [sp+18h] [-84h] BYREF

  strcpy(v7, "{\"code\":0,\"error\":\"\",\"data\":{");
  v2 = (const char *)jhl_nv_get_def("ping_wan_gw");
  v3 = snprintf(&v7[29], 99, "\"gw_en\":%s", v2);
  v4 = v3 + 29;
  if ( v3 >= 0x63 )
    v4 = 127;
  v5 = snprintf(&v7[v4], 128 - v4, "}}");
  if ( v5 >= 128 - v4 )
    v5 = 127 - v4;
  return httpd_cgi_ret(a1, v7, v5 + v4, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);

//----- (004BEA68) --------------------------------------------------------
int __fastcall sub_4BEA68(int a1)
{
  _BYTE *v1; // $v0
  _BYTE *v2; // $s3
  char *v3; // $v0
  char *v4; // $v0
  char *v5; // $s0
  char *v6; // $s1
  int v7; // $s4
  char *v8; // $v0
  char *v9; // $s0
  char *v10; // $s3
  char *v11; // $s4
  char *v12; // $a1
  char *v13; // $v0
  int v14; // $a0
  int v15; // $v1
  _BOOL4 v16; // $a2
  _BYTE *v17; // $v0
  char *v18; // $s3
  int v19; // $s4
  int v20; // $s0
  const char **v21; // $s5
  int v22; // $fp
  int i; // $s6
  int v24; // $s0
  char *v25; // $s3
  int v26; // $a0
  int v27; // $a2
  const char *v28; // $v0
  unsigned int v29; // $s0
  int v30; // $a2
  int result; // $v0
  const char *v32; // $v0
  unsigned int v33; // $s0
  int v34; // $a2
  const char *v35; // $v0
  unsigned int v36; // $v0
  char v37[5120]; // [sp+20h] [-1E28h] BYREF
  char v38[2048]; // [sp+1420h] [-A28h] BYREF
  int v39[128]; // [sp+1C20h] [-228h] BYREF
  char *s; // [sp+1E20h] [-28h]
  _BYTE *v41; // [sp+1E24h] [-24h]
  int v42; // [sp+1E28h] [-20h]
  char *dest; // [sp+1E2Ch] [-1Ch]
  int v44; // [sp+1E30h] [-18h]
  char *v45; // [sp+1E34h] [-14h]
  int v46; // [sp+1E38h] [-10h]
  char **v47; // [sp+1E3Ch] [-Ch]
  char *v48; // [sp+1E40h] [-8h]
  char *v49; // [sp+1E44h] [-4h]

  v45 = "1\"";
  v46 = get_rule_num_limit(2);
  _mem_malloc(102400, "mrprot_cgi", 639);
  v41 = v1;
  v2 = v1;
  _mem_malloc(102400, "mrprot_cgi", 640);
  dest = v3;
  v5 = v3;
  _mem_malloc(102400, "mrprot_cgi", 641);
  v6 = v4;
  if ( v2 && v5 && v4 )
  {
    v7 = *(_DWORD *)(a1 + 205364);
    find_file_head(a1, *(const char **)(a1 + 205564));
    v9 = v8;
    if ( v8 && (v10 = find_file_end(a1, v8, *(_DWORD *)(a1 + 205564) + v7 - (_DWORD)v8)) != 0 )
    {
      v11 = dest;
      v12 = dest;
      v49 = "a";
      *v10 = 0;
      jhl_parm_get("mrprot2", v12, 102400);
      if ( !strcmp(v11, " ") )
        *v11 = 0;
      if ( v10 - v9 <= 0 )
      {
        v14 = 0;
      }
      else
      {
        v13 = v9;
        v14 = 0;
        do
        {
          v15 = *v13++;
          v16 = v14 + 1 < 102399;
          if ( v15 != 13 && v15 != 10 )
          {
            v41[v14++] = v15;
            if ( !v16 )
              break;
          }
        }
        while ( v10 != v13 );
      }
      v17 = v41;
      v18 = v38;
      v41[v14] = 0;
      v42 = split_string(v17, 60, v38, 512);
      v19 = 0;
      if ( v42 <= 0 )
      {
        s = v37;
      }
      else
      {
        v48 = "1\"";
        s = v37;
        v44 = 0;
        v47 = &off_646D8C;
        do
        {
          strlcpy(s, *(_DWORD *)v18, 5120);
          v20 = split_string(*(_DWORD *)v18, 124, v39, 128);
          if ( v20 >= 10 )
          {
            v21 = (const char **)v39;
            if ( !nvparm_find_str(dest, 60, 18, v39[0], 124, 0) )
            {
              v22 = 0;
              for ( i = 0; i != v20; ++i )
                v22 += sprintf(&v6[v22], "%s|", *v21++);
              set_rule_to_kernel(v48 - 424, v47, v39);
              *(_WORD *)&v6[v22 - 1] = 60;
              v24 = ++v44;
              strcat(dest, v6);
              if ( v24 >= v46 )
                break;
            }
          }
          ++v19;
          v18 += 4;
        }
        while ( v42 != v19 );
      }
      v25 = dest;
      jhl_parm_set(v49 + 27920, dest);
      jhl_parm_commit(v26);
      v28 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v27);
      v29 = snprintf(s, 5120, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v28);
      _mem_free(v41);
      _mem_free(v25);
      _mem_free(v6);
      v30 = v29;
      if ( v29 >= 0x1400 )
        v30 = 5119;
      httpd_cgi_ret(a1, s, v30, 4);
      result = 0;
    }
    else
    {
      v32 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), "Error reading file");
      s = v37;
      v33 = snprintf(v37, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v32);
      _mem_free(v41);
      _mem_free(dest);
      _mem_free(v6);
      v34 = v33;
      if ( v33 >= 0x1400 )
        v34 = 5119;
      httpd_cgi_ret(a1, s, v34, 4);
      result = -1;
    }
  }
  else
  {
    _mem_free(v41);
    _mem_free(dest);
    _mem_free(v6);
    v35 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    s = v37;
    v36 = snprintf(v37, 5120, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v35);
    if ( v36 >= 0x1400 )
      v36 = 5119;
    result = httpd_cgi_ret(a1, s, v36, 4);
  }
  return result;
}
// 4BEAF4: variable 'v1' is possibly undefined
// 4BEB14: variable 'v3' is possibly undefined
// 4BEB28: variable 'v4' is possibly undefined
// 4BEB68: variable 'v8' is possibly undefined
// 4BEDD8: variable 'v26' is possibly undefined
// 4BEDFC: variable 'v27' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A832C: using guessed type int __fastcall set_rule_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004BF098) --------------------------------------------------------
int __fastcall sub_4BF098(int a1)
{
  char *v2; // $s7
  char *v3; // $s1
  int v4; // $s6
  int v5; // $v0
  char *v6; // $v0
  char *v7; // $s4
  int v8; // $s3
  char *v9; // $v1
  const char *v10; // $v0
  int v11; // $t0
  int v12; // $a3
  int v13; // $a2
  int v14; // $a1
  int v15; // $fp
  const char *v17; // $a3
  const char *v18; // $v0
  const char *v19; // $v1
  const char *v20; // $a1
  const char *v21; // $t0
  const char *v22; // $t1
  const char *v23; // $t2
  const char *v24; // $t3
  const char *v25; // $t4
  const char *v26; // $t5
  const char *v27; // $fp
  _BOOL4 v28; // $s7
  _DWORD *v29; // $fp
  int v30; // $v0
  int v31; // $a0
  const char *v32; // $v0
  int v33; // $v0
  char s[256]; // [sp+40h] [-180h] BYREF
  int v35[15]; // [sp+140h] [-80h] BYREF
  int v36[3]; // [sp+17Ch] [-44h] BYREF
  char *v37; // [sp+188h] [-38h]
  char *v38; // [sp+18Ch] [-34h]
  char *v39; // [sp+190h] [-30h]
  char *v40; // [sp+194h] [-2Ch]
  char *v41; // [sp+198h] [-28h]
  char *v42; // [sp+19Ch] [-24h]
  char *v43; // [sp+1A0h] [-20h]
  char *v44; // [sp+1A4h] [-1Ch]
  char *v45; // [sp+1A8h] [-18h]
  char *v46; // [sp+1ACh] [-14h]
  char *v47; // [sp+1B0h] [-10h]
  char *v48; // [sp+1B4h] [-Ch]
  char *v49; // [sp+1B8h] [-8h]

  memset(v35, 0, sizeof(v35));
  v2 = httpd_get_parm(a1, "name");
  v48 = httpd_get_parm(a1, "old_name");
  v37 = httpd_get_parm(a1, "en");
  v38 = httpd_get_parm(a1, "ips");
  v39 = httpd_get_parm(a1, "time");
  v40 = httpd_get_parm(a1, (char *)&off_64E034);
  v41 = httpd_get_parm(a1, "rpri");
  v42 = httpd_get_parm(a1, "wans");
  v43 = httpd_get_parm(a1, "thd_type");
  v44 = httpd_get_parm(a1, (char *)&off_645A5C);
  v45 = httpd_get_parm(a1, "shibie");
  v46 = httpd_get_parm(a1, "ipport");
  v47 = httpd_get_parm(a1, "no_change");
  v3 = httpd_get_parm(a1, "opt");
  v4 = httpd_get_json_parm(a1, (int)"del_list");
  _mem_malloc(102400, "mrprot_asp", 932);
  v7 = v6;
  _mem_malloc(102400, "mrprot_asp", 933);
  v8 = v5;
  if ( !v7 || !v5 )
  {
    v32 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    goto LABEL_77;
  }
  if ( !v3 )
  {
LABEL_76:
    v32 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    goto LABEL_77;
  }
  if ( !strcmp(v3, (const char *)&off_646D8C) || !strcmp(v3, (const char *)&off_648DDC) )
  {
    if ( !strcmp(v3, "delall") )
      goto LABEL_8;
    if ( strcmp(v3, "del") )
      goto LABEL_15;
  }
  else
  {
    if ( strcmp(v3, "del") )
    {
      if ( !strcmp(v3, "delall") )
      {
LABEL_8:
        if ( set_rule_to_kernel("mr", v3, v35) )
          goto LABEL_9;
        *(_BYTE *)v8 = 32;
        *(_BYTE *)(v8 + 1) = 0;
        v49 = "a";
        goto LABEL_65;
      }
      goto LABEL_76;
    }
    if ( !strcmp(v3, "delall") )
      goto LABEL_8;
  }
  if ( v4 && cJSON_IsArray(v4) )
  {
    v29 = *(_DWORD **)(v4 + 8);
    if ( !v29 )
      goto LABEL_9;
    v30 = v29[4];
    if ( !v30 )
      goto LABEL_9;
    v38 = 0;
    v37 = (char *)102400;
    do
    {
      v35[0] = v30;
      if ( !set_rule_to_kernel("mr", v3, v35) )
      {
        jhl_parm_get("mrprot2", v7, v37);
        if ( nvparm_del_str(v7, 60, 15, v29[4], 124, 0, v8) )
        {
          jhl_parm_set("mrprot2", v8);
          v38 = (char *)1;
        }
      }
      v29 = (_DWORD *)*v29;
      if ( !v29 )
        break;
      v30 = v29[4];
    }
    while ( v30 );
    if ( !v38 )
      goto LABEL_9;
    v49 = "a";
    goto LABEL_65;
  }
LABEL_15:
  if ( !v2 )
  {
    v32 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_6442E4);
    goto LABEL_77;
  }
  v35[0] = (int)v2;
  if ( !strcmp(v3, (const char *)&off_646D8C) )
  {
    v49 = "a";
    jhl_parm_get("mrprot2", v8, 102400);
    if ( nvparm_find_str(v8, 60, 15, v2, 124, 0) )
    {
      v32 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "same name");
      goto LABEL_77;
    }
  }
  else
  {
    if ( strcmp(v3, (const char *)&off_648DDC) )
      goto LABEL_9;
    v49 = "a";
  }
  v15 = check_rule_num_limit(a1, 2, (int)(v49 + 27920), 60, s, 0x100u);
  if ( v15 > 0 )
    goto LABEL_12;
  if ( v37 )
  {
    if ( !*v37 )
      v37 = "1";
  }
  else
  {
    v37 = "1";
  }
  v35[1] = (int)v37;
  if ( !v38 || !*v38 )
    v38 = "";
  v35[2] = (int)v38;
  if ( !v39 || !*v39 )
    v39 = "OFF";
  v35[3] = (int)v39;
  if ( !v40 || !*v40 )
    v40 = "0";
  v35[4] = (int)v40;
  if ( !v41 || !*v41 )
    v41 = "1";
  v35[5] = (int)v41;
  if ( !v42 || !*v42 )
    v42 = "";
  v35[6] = (int)v42;
  if ( !v43 || !*v43 )
    v43 = "0";
  v35[7] = (int)v43;
  if ( !v44 || !*v44 )
    v44 = "";
  v35[8] = (int)v44;
  if ( !v45 || !*v45 )
    v45 = "00000000";
  v35[9] = (int)v45;
  if ( !v46 || !*v46 )
    v46 = "";
  v35[10] = (int)v46;
  if ( !v47 || !*v47 )
    v47 = "0";
  v35[11] = (int)v47;
  if ( !v48 )
  {
    if ( strcmp(v3, (const char *)&off_648DDC) )
    {
      v27 = v47;
      v26 = v46;
      v25 = v45;
      v24 = v44;
      v23 = v43;
      v22 = v42;
      v21 = v41;
      v20 = v40;
      v19 = v39;
      v18 = v38;
      v17 = v37;
      v28 = 0;
      goto LABEL_45;
    }
    jhl_parm_get(v49 + 27920, v7, 102400);
    v33 = nvparm_del_str(v7, 60, 15, v2, 124, 0, v8);
LABEL_84:
    v28 = v33 != 0;
    sprintf(
      v7,
      "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<",
      (const char *)v35[0],
      (const char *)v35[1],
      (const char *)v35[2],
      (const char *)v35[3],
      (const char *)v35[4],
      (const char *)v35[5],
      (const char *)v35[6],
      (const char *)v35[7],
      (const char *)v35[8],
      (const char *)v35[9],
      (const char *)v35[10],
      (const char *)v35[11]);
    goto LABEL_46;
  }
  v36[1] = (int)v48;
  v36[0] = (int)"mr_del.sh";
  v36[2] = 0;
  eval(v36, 0, 0, 0);
  if ( !strcmp(v3, (const char *)&off_648DDC) )
  {
    jhl_parm_get(v49 + 27920, v7, 102400);
    v33 = nvparm_del_str(v7, 60, 15, v48, 124, 0, v8);
    goto LABEL_84;
  }
  v17 = (const char *)v35[1];
  v18 = (const char *)v35[2];
  v19 = (const char *)v35[3];
  v20 = (const char *)v35[4];
  v21 = (const char *)v35[5];
  v22 = (const char *)v35[6];
  v23 = (const char *)v35[7];
  v24 = (const char *)v35[8];
  v25 = (const char *)v35[9];
  v26 = (const char *)v35[10];
  v27 = (const char *)v35[11];
  v28 = 0;
LABEL_45:
  sprintf(
    v7,
    "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s<",
    (const char *)v35[0],
    v17,
    v18,
    v19,
    v20,
    v21,
    v22,
    v23,
    v24,
    v25,
    v26,
    v27);
LABEL_46:
  if ( !set_rule_to_kernel("mr", v3, v35) )
  {
    if ( !v28 )
    {
      jhl_parm_get(v49 + 27920, v8, 102400);
      if ( !strcmp((const char *)v8, " ") )
        *(_BYTE *)v8 = 0;
    }
    strcat((char *)v8, v7);
LABEL_65:
    jhl_parm_set(v49 + 27920, v8);
    jhl_parm_commit(v31);
LABEL_9:
    v9 = s;
    v10 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v11 = *(_DWORD *)v10;
      v12 = *((_DWORD *)v10 + 1);
      v13 = *((_DWORD *)v10 + 2);
      v14 = *((_DWORD *)v10 + 3);
      v10 += 16;
      *(_DWORD *)v9 = v11;
      *((_DWORD *)v9 + 1) = v12;
      *((_DWORD *)v9 + 2) = v13;
      *((_DWORD *)v9 + 3) = v14;
      v9 += 16;
    }
    while ( v10 != "}" );
    v15 = 33;
    *(_WORD *)v9 = *(_WORD *)v10;
    goto LABEL_12;
  }
  v32 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), v3);
LABEL_77:
  v15 = snprintf(s, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v32);
  if ( (unsigned int)v15 >= 0x100 )
    v15 = 255;
LABEL_12:
  _mem_free(v7);
  _mem_free((void *)v8);
  return httpd_cgi_ret(a1, s, v15, 4);
}
// 4BF2D0: variable 'v6' is possibly undefined
// 4BF2DC: variable 'v5' is possibly undefined
// 4BFA10: variable 'v31' is possibly undefined
// 645A5C: using guessed type char *off_645A5C;
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 64E034: using guessed type int (**off_64E034)();
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8308: using guessed type int __fastcall jhl_parm_set(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A832C: using guessed type int __fastcall set_rule_to_kernel(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);

//----- (004BFD3C) --------------------------------------------------------
int __fastcall mr_list_get(int a1, int a2, int a3)
{
  int v5; // $v0
  int v7; // $v1
  int v8; // $s0
  int v9; // $s3
  int v10; // $s4
  int v11; // $v0
  int v12; // $v0
  int v13; // $v0
  int v14; // $a1
  int (__fastcall *v15)(const char *, int); // $t9
  const char *v16; // $a0
  int v17; // $v0
  int v18; // $s2
  int v19; // $v0
  int v20; // $v0
  int v21; // $v0
  unsigned int v22; // $a0
  int v23; // $s2
  unsigned int v24; // $s2
  int v25; // $v0
  int v26; // $v0
  int v27; // $v0
  int v28; // $v0
  char v30[32]; // [sp+58h] [-60h] BYREF
  _DWORD v31[8]; // [sp+78h] [-40h] BYREF
  int v32; // [sp+98h] [-20h]
  char *v33; // [sp+9Ch] [-1Ch]
  char *v34; // [sp+A0h] [-18h]
  const char *v35; // [sp+A4h] [-14h]
  char *v36; // [sp+A8h] [-10h]
  const char *v37; // [sp+ACh] [-Ch]
  char *v38; // [sp+B0h] [-8h]
  char *format; // [sp+B4h] [-4h]

  v5 = nvram_match_def("ping_wan_gw", "1");
  v7 = *(_DWORD *)(a1 + 4);
  v32 = v5;
  if ( v7 <= 0 || (v8 = a1 + 8, a3 < 100) )
  {
    v28 = 0;
    v9 = 0;
    goto LABEL_22;
  }
  v34 = "1\"";
  v9 = 0;
  v33 = "1\"";
  v10 = 0;
  format = "%lu/200";
  v35 = "vpn_flow_all";
  v36 = "1\"";
  v38 = "a";
  v37 = "wan_flow_all";
  do
  {
    v31[0] = 0;
    v31[1] = 0;
    v31[2] = 0;
    v31[3] = 0;
    v31[4] = 0;
    v31[5] = 0;
    v31[6] = 0;
    v31[7] = 0;
    v22 = *(unsigned __int16 *)(v8 + 8);
    v23 = v22 - 1;
    if ( v32 && v22 < 0x65 )
    {
      v27 = ping_wan_gw_get_state(v22 - 1);
      sprintf((char *)v31, format, v27);
      v22 = *(unsigned __int16 *)(v8 + 8);
      v23 = v22 - 1;
    }
    if ( v23 < 101 )
    {
      v11 = jhl_nvget(v37, v23);
      v12 = nvram_get(v11);
      if ( !v12 )
        v12 = (int)(v38 + 14076);
      v13 = J_atoi(v12);
      v14 = v23;
      v15 = (int (__fastcall *)(const char *, int))&jhl_nvget;
      v16 = "wan_flow_use";
    }
    else
    {
      v24 = v22 - 102;
      v25 = jhl_vpnget(v35, v22 - 102);
      v26 = nvram_get(v25);
      if ( !v26 )
        v26 = (int)(v38 + 14076);
      v13 = J_atoi(v26);
      v14 = v24;
      v15 = (int (__fastcall *)(const char *, int))&jhl_vpnget;
      v16 = v36 - 292;
    }
    v18 = v13;
    v17 = v15(v16, v14);
    v19 = nvram_get(v17);
    if ( !v19 )
      v19 = (int)(v38 + 14076);
    v20 = J_atoi(v19);
    sprintf(v30, v34 - 276, v20, v18 << 10, *(unsigned __int8 *)(v8 + 10));
    v21 = snprintf(
            (char *)(a2 + v9),
            a3,
            v33 - 264,
            *(unsigned __int16 *)(v8 + 8),
            *(unsigned __int8 *)(v8 + 2),
            *(unsigned __int8 *)(v8 + 7),
            *(unsigned __int8 *)(v8 + 1),
            *(_DWORD *)(v8 + 20),
            *(unsigned __int8 *)(v8 + 132),
            *(_DWORD *)(v8 + 12),
            *(_DWORD *)(v8 + 16),
            *(_DWORD *)(v8 + 24),
            *(_DWORD *)(v8 + 28),
            *(_DWORD *)(v8 + 32),
            *(_DWORD *)(v8 + 36),
            *(_DWORD *)(v8 + 40),
            v31,
            *(_DWORD *)(v8 + 120),
            v30,
            101);
    if ( v21 >= a3 )
      v21 = a3 - 1;
    ++v10;
    v9 += v21;
    a3 -= v21;
    v8 += 352;
  }
  while ( v10 < *(_DWORD *)(a1 + 4) && a3 >= 100 );
  if ( v9 <= 0 )
    goto LABEL_24;
  v28 = v9;
  if ( *(_BYTE *)(a2 + v9 - 1) == 44 )
  {
    --v9;
LABEL_24:
    v28 = v9;
  }
LABEL_22:
  *(_BYTE *)(a2 + v28) = 0;
  return v9;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A88C0: using guessed type int __fastcall ping_wan_gw_get_state(_DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004C0120) --------------------------------------------------------
int __fastcall sub_4C0120(int a1)
{
  char *v2; // $v0
  char *v3; // $s0
  int v4; // $v0
  int v5; // $s2
  int v6; // $s4
  int v7; // $v0
  int v8; // $a2
  int result; // $v0
  const char *v10; // $v0
  unsigned int v11; // $v0
  char v12[256]; // [sp+28h] [-100h] BYREF

  _mem_malloc(1024000, "mr_list_data", 1163);
  v3 = v2;
  if ( v2 )
  {
    strcpy(v2, "{\"code\":0,\"error\":\"\",\"data\":[");
    qmemcpy(v2, "{\"code\":0,\"error\":\"\"", 20);
    v4 = cgi_signal_to_kernel(10, 23, 1024000);
    v5 = 1023971 - v4;
    v6 = v4 + 29;
    v7 = snprintf(&v3[v4 + 29], 1023971 - v4, "]}");
    if ( v7 >= v5 )
      v8 = 1023999 - v6;
    else
      v8 = v7;
    result = httpd_cgi_ret(a1, v3, v8 + v6, 8);
  }
  else
  {
    v10 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 1024000);
    v11 = snprintf(v12, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
    if ( v11 >= 0x100 )
      v11 = 255;
    result = httpd_cgi_ret(a1, v12, v11, 4);
  }
  return result;
}
// 4C0174: variable 'v2' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8764: using guessed type int __fastcall cgi_signal_to_kernel(_DWORD, _DWORD, _DWORD);

//----- (004C031C) --------------------------------------------------------
int __fastcall sub_4C031C(int a1)
{
  char **v1; // $v0
  const char **v3; // $v1
  char *v4; // $t0
  const char *v5; // $a3
  const char *v6; // $a2
  const char *v7; // $a1
  char *v8; // $a0
  const char *v9; // $v0
  char *v10; // $v0
  char *v11; // $s0
  int v12; // $v0
  int v13; // $s3
  char *v14; // $s1
  const char *v15; // $v0
  int v16; // $s3
  int *v17; // $v0
  int v18; // $v1
  int v19; // $a0
  int v20; // $v1
  char v21; // $a1
  char v22; // $v0
  const char *v23; // $v0
  bool v24; // dc
  char *v25; // $v0
  int *v26; // $v1
  int v27; // $a0
  int v28; // $a1
  int v29; // $a0
  int v30; // $v1
  const char *v31; // $v0
  int v32; // $s1
  char *v33; // $v0
  int *v34; // $v1
  int v35; // $a0
  int v36; // $a1
  int v37; // $a0
  char v38; // $v1
  const char *v39; // $v0
  int v40; // $s1
  char *v41; // $v0
  int *v42; // $v1
  int v43; // $a0
  int v44; // $a1
  int v45; // $a0
  char v46; // $v1
  const char *v47; // $v0
  int v48; // $s1
  char *v49; // $v0
  int *v50; // $v1
  int v51; // $a1
  int v52; // $a0
  int v53; // $a1
  int v54; // $a0
  char v55; // $v1
  const char *v56; // $v0
  int v57; // $s1
  char *v58; // $v0
  int *v59; // $v1
  int v60; // $a0
  int v61; // $a1
  int v62; // $a0
  char v63; // $v1
  int v64; // $s1
  int v65; // $a2
  int result; // $v0
  const char *v67; // $v0
  unsigned int v68; // $v0
  char v69[256]; // [sp+20h] [-12Ch] BYREF
  const char *v70[11]; // [sp+120h] [-2Ch] BYREF

  v1 = off_678AF0;
  v3 = v70;
  do
  {
    v4 = *v1;
    v5 = v1[1];
    v6 = v1[2];
    v7 = v1[3];
    v1 += 4;
    *v3 = v4;
    v3[1] = v5;
    v3[2] = v6;
    v3[3] = v7;
    v3 += 4;
  }
  while ( v1 != (char **)&off_678B10 );
  v8 = *v1;
  v9 = v1[1];
  *v3 = v8;
  v3[1] = v9;
  _mem_malloc(5000, "mr_clips_data", 1192);
  v11 = v10;
  if ( v10 )
  {
    strcpy(v10, "{\"code\":0,\"error\":\"\",\"data\":{");
    qmemcpy(v10, "{\"code\":0,\"error", 16);
    v12 = get_nvarms(v70, (int)(v10 + 29), 4971);
    v13 = v12 + 29;
    v14 = &v11[v12 + 29];
    if ( v12 + 29 > 0 && *(v14 - 1) == 44 )
    {
      v13 = v12 + 28;
      v14 = &v11[v12 + 28];
    }
    *v14 = 0;
    v15 = (const char *)nvram_get("mrcl_dianxin");
    if ( v15 && *v15 && strlen(v15) >= 5 )
    {
      v16 = v13 + 18;
      v17 = &dword_64FFDC;
    }
    else
    {
      v16 = v13 + 18;
      v17 = &dword_64FFF0;
    }
    *(_DWORD *)v14 = 1768170028;
    v18 = v17[1];
    *(_DWORD *)v14 = 1768170028;
    *((_DWORD *)v14 + 1) = v18;
    v19 = v17[2];
    *((_DWORD *)v14 + 1) = v18;
    *((_DWORD *)v14 + 2) = v19;
    v20 = v17[3];
    *((_DWORD *)v14 + 2) = v19;
    LOBYTE(v19) = *((_BYTE *)v17 + 17);
    *((_DWORD *)v14 + 3) = v20;
    v21 = *((_BYTE *)v17 + 16);
    v14[17] = v19;
    v22 = *((_BYTE *)v17 + 18);
    v14[16] = v21;
    v14[18] = v22;
    v23 = (const char *)nvram_get("mrcl_wangtong");
    if ( v23 && *v23 && (v24 = strlen(v23) >= 5, v25 = &v11[v16], v24) )
    {
      v26 = &dword_650014;
    }
    else
    {
      v25 = &v11[v16];
      v26 = &dword_650028;
    }
    *(_DWORD *)v25 = 1635197484;
    v27 = v26[1];
    *(_DWORD *)v25 = 1635197484;
    *((_DWORD *)v25 + 1) = v27;
    v28 = v26[2];
    *((_DWORD *)v25 + 1) = v27;
    *((_DWORD *)v25 + 2) = v28;
    v29 = v26[3];
    *((_DWORD *)v25 + 2) = v28;
    *((_DWORD *)v25 + 3) = v29;
    v30 = v26[4];
    *((_DWORD *)v25 + 3) = v29;
    *((_DWORD *)v25 + 4) = v30;
    v31 = (const char *)nvram_get("mrcl_yidong");
    v32 = v16 + 19;
    if ( v31 && *v31 && (v24 = strlen(v31) >= 5, v33 = &v11[v32], v24) )
    {
      v34 = &dword_650048;
    }
    else
    {
      v33 = &v11[v32];
      v34 = &dword_65005C;
    }
    *(_DWORD *)v33 = 1769546284;
    v35 = v34[1];
    *(_DWORD *)v33 = 1769546284;
    *((_DWORD *)v33 + 1) = v35;
    v36 = v34[2];
    *((_DWORD *)v33 + 1) = v35;
    *((_DWORD *)v33 + 2) = v36;
    v37 = v34[3];
    *((_DWORD *)v33 + 2) = v36;
    *((_DWORD *)v33 + 3) = v37;
    LOBYTE(v36) = *((_BYTE *)v34 + 16);
    v38 = *((_BYTE *)v34 + 17);
    v33[16] = v36;
    v33[17] = v38;
    v39 = (const char *)nvram_get("mrcl_jiaoyu");
    v40 = v16 + 36;
    if ( v39 && *v39 && (v24 = strlen(v39) >= 5, v41 = &v11[v40], v24) )
    {
      v42 = &dword_65007C;
    }
    else
    {
      v41 = &v11[v40];
      v42 = &dword_650090;
    }
    *(_DWORD *)v41 = 1768563244;
    v43 = v42[1];
    *(_DWORD *)v41 = 1768563244;
    *((_DWORD *)v41 + 1) = v43;
    v44 = v42[2];
    *((_DWORD *)v41 + 1) = v43;
    *((_DWORD *)v41 + 2) = v44;
    v45 = v42[3];
    *((_DWORD *)v41 + 2) = v44;
    *((_DWORD *)v41 + 3) = v45;
    LOBYTE(v44) = *((_BYTE *)v42 + 16);
    v46 = *((_BYTE *)v42 + 17);
    v41[16] = v44;
    v41[17] = v46;
    v47 = (const char *)nvram_get("mrcl_changcheng");
    v48 = v16 + 53;
    if ( v47 && *v47 && (v24 = strlen(v47) >= 5, v49 = &v11[v48], v24) )
    {
      v50 = &dword_6500B4;
    }
    else
    {
      v49 = &v11[v48];
      v50 = &dword_6500CC;
    }
    *(_DWORD *)v49 = 1751327276;
    v51 = v50[1];
    *(_DWORD *)v49 = 1751327276;
    *((_DWORD *)v49 + 1) = v51;
    v52 = v50[2];
    *((_DWORD *)v49 + 1) = v51;
    *((_DWORD *)v49 + 2) = v52;
    v53 = v50[3];
    *((_DWORD *)v49 + 2) = v52;
    *((_DWORD *)v49 + 3) = v53;
    v54 = v50[4];
    *((_DWORD *)v49 + 3) = v53;
    *((_DWORD *)v49 + 4) = v54;
    LOBYTE(v53) = *((_BYTE *)v50 + 20);
    v55 = *((_BYTE *)v50 + 21);
    v49[20] = v53;
    v49[21] = v55;
    v56 = (const char *)nvram_get("mrcl_china");
    v57 = v16 + 74;
    if ( v56 && *v56 && (v24 = strlen(v56) >= 5, v58 = &v11[v57], v24) )
    {
      v59 = &dword_6500F0;
    }
    else
    {
      v58 = &v11[v57];
      v59 = &dword_650104;
    }
    *(_DWORD *)v58 = 1751327276;
    v60 = v59[1];
    *(_DWORD *)v58 = 1751327276;
    *((_DWORD *)v58 + 1) = v60;
    v61 = v59[2];
    *((_DWORD *)v58 + 1) = v60;
    *((_DWORD *)v58 + 2) = v61;
    v62 = v59[3];
    *((_DWORD *)v58 + 2) = v61;
    v63 = *((_BYTE *)v59 + 16);
    v64 = v16 + 90;
    *((_DWORD *)v58 + 3) = v62;
    *((_DWORD *)v58 + 3) = v62;
    v58[16] = v63;
    v65 = snprintf(&v11[v64], 5000 - v64, "}}");
    if ( v65 >= 5000 - (v16 + 90) )
      v65 = 4999 - v64;
    result = httpd_cgi_ret(a1, v11, v64 + v65, 8);
  }
  else
  {
    v67 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 5000);
    v68 = snprintf(v69, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v67);
    if ( v68 >= 0x100 )
      v68 = 255;
    result = httpd_cgi_ret(a1, v69, v68, 4);
  }
  return result;
}
// 4C03B8: variable 'v10' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 64FFDC: using guessed type int dword_64FFDC;
// 64FFF0: using guessed type int dword_64FFF0;
// 650014: using guessed type int dword_650014;
// 650028: using guessed type int dword_650028;
// 650048: using guessed type int dword_650048;
// 65005C: using guessed type int dword_65005C;
// 65007C: using guessed type int dword_65007C;
// 650090: using guessed type int dword_650090;
// 6500B4: using guessed type int dword_6500B4;
// 6500CC: using guessed type int dword_6500CC;
// 6500F0: using guessed type int dword_6500F0;
// 650104: using guessed type int dword_650104;
// 678AF0: using guessed type char *off_678AF0[8];
// 678B10: using guessed type void *off_678B10;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004C0978) --------------------------------------------------------
int __fastcall sub_4C0978(int a1)
{
  char *v1; // $v0
  const char *v3; // $a1
  const char *v4; // $s2
  char **v5; // $s0
  int v6; // $s1
  int v7; // $a0
  char **v8; // $v1
  const char *v9; // $v0
  char *v10; // $t0
  char *v11; // $a3
  char *v12; // $a2
  char *v13; // $a1
  char *v15; // $v1
  char *v16; // [sp+18h] [-704h] BYREF
  const char *v17; // [sp+1Ch] [-700h]
  char *v18; // [sp+20h] [-6FCh]
  char *v19; // [sp+24h] [-6F8h]
  char *v20; // [sp+28h] [-6F4h]
  int v21; // [sp+2Ch] [-6F0h]
  char v22[256]; // [sp+418h] [-304h] BYREF
  char v23[256]; // [sp+518h] [-204h] BYREF
  char v24[260]; // [sp+618h] [-104h] BYREF

  v1 = httpd_get_parm(a1, "n");
  if ( v1 )
  {
    v3 = ll_ssstt;
    if ( ll_ssstt )
    {
      v4 = v1;
      v5 = &off_679810;
      v6 = 0;
      while ( 1 )
      {
        v5 += 2;
        if ( !strcmp(v4, v3) )
          break;
        v3 = *(v5 - 2);
        ++v6;
        if ( !v3 )
          goto LABEL_9;
      }
      sprintf(v23, "/etc/def_mrcl/%s.txt", v4);
      sprintf(v24, "/etc/mrcl/%s.txt", v4);
      sprintf(v22, "mrcl_%s", v4);
      if ( f_exists(v23) )
      {
        v16 = "cp";
        v17 = "-f";
        v18 = v23;
        v19 = v24;
        v20 = 0;
        eval(&v16, 0, 0, 0);
        v16 = "wys";
        v15 = (&ll_ssstt)[2 * v6 + 1];
        v17 = "mrcl_ips";
        v18 = v15;
        v19 = (char *)v4;
        v20 = v24;
        v21 = 0;
        eval(&v16, 0, 0, 0);
      }
      nvram_unset(v22);
      jhl_parm_commit(v7);
    }
  }
LABEL_9:
  v8 = &v16;
  v9 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v10 = *(char **)v9;
    v11 = (char *)*((_DWORD *)v9 + 1);
    v12 = (char *)*((_DWORD *)v9 + 2);
    v13 = (char *)*((_DWORD *)v9 + 3);
    v9 += 16;
    *v8 = v10;
    v8[1] = v11;
    v8[2] = v12;
    v8[3] = v13;
    v8 += 4;
  }
  while ( v9 != "}" );
  *(_WORD *)v8 = *(_WORD *)v9;
  return httpd_cgi_ret(a1, (char *)&v16, 33, 4);
}
// 4C0AC4: variable 'v7' is possibly undefined
// 679808: using guessed type char *ll_ssstt;
// 679810: using guessed type char *off_679810;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);

//----- (004C0BFC) --------------------------------------------------------
int __fastcall sub_4C0BFC(int a1)
{
  char *v2; // $v0
  int v3; // $a2
  const char *v4; // $a2
  const char *v5; // $v0
  unsigned int v6; // $a2
  int v8; // $a1
  char *v9; // $a2
  int v10; // $a0
  const char *v11; // $v0
  unsigned int v12; // $v0
  int v13; // $s3
  unsigned int v14; // $v0
  int v15[256]; // [sp+20h] [-504h] BYREF
  char v16[260]; // [sp+420h] [-104h] BYREF

  memset(v15, 0, sizeof(v15));
  v2 = httpd_get_parm(a1, "ip");
  if ( v2 )
  {
    v15[0] = 10;
    v15[3] = 11;
    v15[1] = 1024;
    v15[4] = get_ip_from_str(v2);
    if ( v15[4] )
    {
      if ( !jianhl_order_opt_fun(v15, v15[1], v3) )
      {
        if ( v15[2] )
        {
          if ( v15[2] >= 0x33u || (v4 = (const char *)jhlret_err_str[v15[2]]) == 0 )
            v4 = "not find err!";
          v5 = (const char *)_GET_LANG_TEXT(3, *(unsigned __int8 *)(a1 + 210102), v4);
          v6 = snprintf(v16, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v5);
          if ( v6 >= 0x100 )
            v6 = 255;
        }
        else
        {
          strcpy(v16, "{\"code\":0,\"error\":\"\",\"data\":{");
          v13 = sprintf(&v16[29], "\"type\":%d", LOBYTE(v15[5])) + 29;
          v14 = snprintf(&v16[v13], 256 - v13, "}}");
          if ( v14 >= 256 - v13 )
            v14 = 255 - v13;
          v6 = v14 + v13;
        }
        return httpd_cgi_ret(a1, v16, v6, 4);
      }
      v8 = *(unsigned __int8 *)(a1 + 210102);
      v9 = "";
      v10 = 3;
    }
    else
    {
      v8 = *(unsigned __int8 *)(a1 + 210102);
      v9 = "ip error";
      v10 = 12;
    }
  }
  else
  {
    v8 = *(unsigned __int8 *)(a1 + 210102);
    v9 = "not ip";
    v10 = 12;
  }
  v11 = (const char *)_GET_LANG_TEXT(v10, v8, v9);
  v12 = snprintf(v16, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
  if ( v12 >= 0x100 )
    v12 = 255;
  return httpd_cgi_ret(a1, v16, v12, 4);
}
// 4C0CA0: variable 'v3' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8748: using guessed type int __fastcall get_ip_from_str(_DWORD);
// 6A8900: using guessed type int __fastcall jianhl_order_opt_fun(_DWORD, _DWORD, _DWORD);

//----- (004C0F00) --------------------------------------------------------
int __fastcall sub_4C0F00(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/dianxin.txt", 0);
}

//----- (004C0F20) --------------------------------------------------------
int __fastcall sub_4C0F20(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/wangtong.txt", 0);
}

//----- (004C0F40) --------------------------------------------------------
int __fastcall sub_4C0F40(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/yidong.txt", 0);
}

//----- (004C0F60) --------------------------------------------------------
int __fastcall sub_4C0F60(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/jiaoyu.txt", 0);
}

//----- (004C0F80) --------------------------------------------------------
int __fastcall sub_4C0F80(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/china.txt", 0);
}

//----- (004C0FA0) --------------------------------------------------------
int __fastcall sub_4C0FA0(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/changcheng.txt", 0);
}

//----- (004C0FC0) --------------------------------------------------------
int __fastcall sub_4C0FC0(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/other.txt", 0);
}

//----- (004C0FE0) --------------------------------------------------------
int __fastcall sub_4C0FE0(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/ziding1.txt", 0);
}

//----- (004C1000) --------------------------------------------------------
int __fastcall sub_4C1000(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/ziding2.txt", 0);
}

//----- (004C1020) --------------------------------------------------------
int __fastcall sub_4C1020(int a1)
{
  return read_file_asp(a1, (int)"/etc/mrcl/ziding3.txt", 0);
}

//----- (004C1040) --------------------------------------------------------
int __fastcall sub_4C1040(int a1)
{
  char *v1; // $v0
  char *v3; // $s0
  const char **v4; // $v1
  const char *v5; // $v0
  const char *v6; // $t0
  const char *v7; // $a3
  const char *v8; // $a2
  const char *v9; // $a1
  int v11; // $a0
  const char *v12; // [sp+18h] [-80h] BYREF
  int v13; // [sp+1Ch] [-7Ch]

  v1 = httpd_get_parm(a1, "gw_en");
  if ( v1 )
  {
    v3 = v1;
    if ( !nvram_match_def("ping_wan_gw", v1) )
    {
      nvram_set("ping_wan_gw", v3);
      killall_tk("ping_wangw_ck");
      killall_tk("ping_wangw_run");
      if ( nvram_match_def("ping_wan_gw", "1") )
      {
        v12 = "ping_wangw_ck";
        v13 = 0;
        eval_nowait(&v12, 0, 0, 0);
      }
      v12 = "ping_wangw_run";
      v13 = 0;
      eval_nowait(&v12, 0, 0, 0);
      jhl_parm_commit(v11);
    }
  }
  v4 = &v12;
  v5 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v6 = *(const char **)v5;
    v7 = (const char *)*((_DWORD *)v5 + 1);
    v8 = (const char *)*((_DWORD *)v5 + 2);
    v9 = (const char *)*((_DWORD *)v5 + 3);
    v5 += 16;
    *v4 = v6;
    v4[1] = v7;
    v4[2] = v8;
    v4[3] = v9;
    v4 += 4;
  }
  while ( v5 != "}" );
  *(_WORD *)v4 = *(_WORD *)v5;
  return httpd_cgi_ret(a1, (char *)&v12, 33, 4);
}
// 4C11CC: variable 'v11' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A82E4: using guessed type int __fastcall killall_tk(_DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C1210) --------------------------------------------------------
int __fastcall sub_4C1210(int a1)
{
  char *v2; // $v0
  const char *v3; // $v0
  char *v4; // $s1
  int v5; // $v0
  int result; // $v0
  const char *v7; // $v0
  unsigned int v8; // $v0
  char v9[260]; // [sp+20h] [-104h] BYREF

  _mem_malloc(0x200000, "mrprot_txt", 577);
  if ( v2 )
  {
    v4 = v2;
    v3 = (const char *)nvram_get("mrprot2");
    if ( !v3 )
      v3 = " ";
    v5 = sprintf(v4, "%s", v3);
    *(_DWORD *)(a1 + 32) &= 0xFFFFFFFD;
    result = httpd_send_mime_file(a1, "application/binary-file", v4, v5);
  }
  else
  {
    v7 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v8 = snprintf(v9, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v7);
    if ( v8 >= 0x100 )
      v8 = 255;
    result = httpd_cgi_ret(a1, v9, v8, 4);
  }
  return result;
}
// 4C1250: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004C1360) --------------------------------------------------------
int __fastcall sub_4C1360(int a1)
{
  int v1; // $v0
  int v2; // $s4
  char *v3; // $s1
  int v4; // $s3
  int v5; // $s0
  int v6; // $v0
  char *v7; // $s2
  int v8; // $v0
  const char *v9; // $v0
  int v10; // $v0
  const char *v11; // $v0
  const char *v12; // $s7
  int v13; // $s3
  int v14; // $v0
  int v15; // $s3
  char *v16; // $v0
  int v17; // $s7
  int v18; // $v0
  const char *v19; // $s2
  const char *v20; // $s7
  const char *v21; // $fp
  int v22; // $v0
  const char *v23; // $v0
  int v24; // $s0
  int v25; // $v0
  const char *v26; // $v0
  int v27; // $v0
  int v28; // $s2
  char *v29; // $v0
  int v30; // $v0
  int v31; // $s6
  int v32; // $s7
  int v33; // $v0
  int v34; // $v0
  int v35; // $s3
  char *v36; // $v0
  const char *v37; // $v0
  int v38; // $s0
  const char *v39; // $v0
  int v40; // $s0
  const char *v41; // $s3
  const char *v42; // $s2
  const char *v43; // $v0
  int v44; // $s0
  int v45; // $v0
  int v46; // $a2
  const char *v48; // $a1
  const char *v49; // $v0
  unsigned int v50; // $a2
  char v51[512]; // [sp+50h] [-288h] BYREF
  int v52[16]; // [sp+250h] [-88h] BYREF
  int *v53; // [sp+290h] [-48h]
  char *v54; // [sp+294h] [-44h]
  const char *v55; // [sp+298h] [-40h]
  char *format; // [sp+29Ch] [-3Ch]
  char *v57; // [sp+2A0h] [-38h]
  const char *v58; // [sp+2A4h] [-34h]
  const char *v59; // [sp+2A8h] [-30h]
  const char *v60; // [sp+2ACh] [-2Ch]
  const char *v61; // [sp+2B0h] [-28h]
  const char *v62; // [sp+2B4h] [-24h]
  const char *v63; // [sp+2B8h] [-20h]
  const char *v64; // [sp+2BCh] [-1Ch]
  const char *v65; // [sp+2C0h] [-18h]
  const char *v66; // [sp+2C4h] [-14h]
  char *v67; // [sp+2C8h] [-10h]
  char *v68; // [sp+2CCh] [-Ch]
  char *v69; // [sp+2D0h] [-8h]

  v53 = v52;
  memset(v52, 0, sizeof(v52));
  v2 = sq_file_get_max_wan();
  _mem_malloc(0x200000, "mr_data", 75);
  v3 = (char *)v1;
  if ( !v1 )
  {
    v49 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v50 = snprintf(v51, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v49);
    if ( v50 >= 0x100 )
      v50 = 255;
    return httpd_cgi_ret(a1, v51, v50, 4);
  }
  strcpy((char *)v1, "{\"code\":0,\"error\":\"\",\"data\":{");
  qmemcpy((void *)v1, "{\"code\":0,\"error", 16);
  *(_DWORD *)(v1 + 20) = 1633952300;
  v4 = sprintf((char *)(v1 + 29), "\"pppoe_br\":\"%d\",\"igmp\":\"%d\",\"mr_qos\":%d,\"wans\":[", 1, 1, 0) + 29;
  if ( v2 <= 0 )
    goto LABEL_30;
  v54 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
  v57 = "1\"";
  v5 = 0;
  v55 = "wan_proto";
  format = "{\"iface\":%d,\"wan_ifname\":\"%s\",";
  while ( 1 )
  {
    v6 = jhl_nvget("wan_ifname", v5);
    v7 = (char *)nvram_get(v6);
    if ( !v7 )
      v7 = v54 - 1556;
    if ( !*v7 )
      break;
    v8 = jhl_nvget("wan_down", v5);
    v9 = (const char *)nvram_get(v8);
    if ( v9 && !strcmp(v9, "1") || jhl_iface_link_up_check(v7, v5) )
      goto LABEL_4;
    v10 = jhl_nvget(v55, v5);
    v11 = (const char *)nvram_get(v10);
    v12 = v11;
    if ( v11 )
    {
      if ( strcmp("3G", v11) || (v48 = (const char *)nvram_get("wan_3g_enable")) == 0 || strcmp("disable", v48) )
      {
        if ( !strncmp(v12, "3G", 2u) )
          v12 = "4G";
        goto LABEL_15;
      }
LABEL_4:
      if ( v2 == ++v5 )
        break;
    }
    else
    {
      v12 = v54 - 1556;
LABEL_15:
      v13 = sprintf(&v3[v4], format, v5, v7) + v4;
      v15 = v13 + sprintf(&v3[v13], v57 + 824, v12);
      v14 = jhl_nvget("mr_parm", v5);
      v16 = (char *)nvram_get(v14);
      if ( !v16 || !*v16 )
        v16 = " ";
      strlcpy(v51, v16, 512);
      v17 = (int)v53;
      v18 = split_string(v51, 60, v53, 14);
      mr_parm_default(v18, v17, v5);
      v68 = (char *)v52[3];
      v67 = (char *)v52[4];
      v66 = (const char *)v52[5];
      v65 = (const char *)v52[6];
      v64 = (const char *)v52[7];
      v63 = (const char *)v52[8];
      v62 = (const char *)v52[9];
      v61 = (const char *)v52[10];
      v60 = (const char *)v52[11];
      v59 = (const char *)v52[12];
      v58 = (const char *)v52[13];
      v19 = (const char *)v52[0];
      v20 = (const char *)v52[1];
      v21 = (const char *)v52[2];
      v22 = jhl_nvget("wan_flow_all", v5);
      v23 = (const char *)nvram_get(v22);
      if ( !v23 )
        v23 = "0";
      ++v5;
      v4 = v15
         + sprintf(
             &v3[v15],
             "\"jh_en\":\"%s\",\"qz\":\"%s\",\"zc_en\":\"%s\",\"tm\":\"%s\",\"times\":\"%s\",\"act\":\"%s\",\"su\":\"%s\""
             ",\"gw_en\":\"%s\",\"srv_en\":\"%s\",\"srv_ip\":\"%s\",\"gw_ip\":\"%s\",\"qz_t\":\"%s\",\"host\":\"%s\",\"ct"
             "\":\"%s\",\"flow\":\"%s\"},",
             v19,
             v20,
             v21,
             v68,
             v67,
             v66,
             v65,
             v64,
             v63,
             v62,
             v61,
             v60,
             v59,
             v58,
             v23);
      if ( v2 == v5 )
        break;
    }
  }
  v54 = "{\"iface\":%d,";
  v24 = 0;
  v67 = "1\"";
  v68 = "\"jh_en\":\"%s\",\"qz\":\"%s\",\"zc_en\":\"%s\",\"tm\":\"%s\",\"times\":\"%s\",\"act\":\"%s\",\"su\":\"%s\",\"gw"
        "_en\":\"%s\",\"srv_en\":\"%s\",\"srv_ip\":\"%s\",\"gw_ip\":\"%s\",\"qz_t\":\"%s\",\"host\":\"%s\",\"ct\":\"%s\","
        "\"flow\":\"%s\",\"vpn_port\":\"%d\"},";
  v69 = "a";
  do
  {
    v25 = jhl_vpnget("vpn_proto", v24);
    v26 = (const char *)nvram_get(v25);
    if ( !v26 || strcmp(v26, (const char *)&off_63F984) )
    {
      v28 = sprintf(&v3[v4], v54, v24 + 101);
      v27 = jhl_vpnget("vpnmr_parm", v24);
      v29 = (char *)nvram_get(v27);
      if ( !v29 || !*v29 )
        v29 = " ";
      strlcpy(v51, v29, 512);
      v30 = split_string(v51, 60, v53, 14);
      mr_parm_default(v30, v53, v24 + 101);
      v66 = (const char *)v52[0];
      v65 = (const char *)v52[3];
      v64 = (const char *)v52[4];
      v63 = (const char *)v52[5];
      v62 = (const char *)v52[6];
      v61 = (const char *)v52[7];
      v60 = (const char *)v52[8];
      v59 = (const char *)v52[9];
      v58 = (const char *)v52[10];
      v57 = (char *)v52[11];
      format = (char *)v52[12];
      v55 = (const char *)v52[13];
      v31 = v52[1];
      v32 = v52[2];
      v33 = jhl_vpnget(v67 - 308, v24);
      v35 = v28 + v4;
      v34 = nvram_get(v33);
      if ( !v34 )
        v34 = (int)(v69 + 14076);
      v4 = v35
         + sprintf(&v3[v35], v68, v66, v31, v32, v65, v64, v63, v62, v61, v60, v59, v58, v57, format, v55, v34, 101);
    }
    ++v24;
  }
  while ( v24 != 5 && v2 != v24 );
LABEL_30:
  v36 = &v3[v4];
  if ( v4 > 0 && *(v36 - 1) == 44 )
    v36 = &v3[--v4];
  *v36 = 93;
  v36[1] = 44;
  v36[2] = 0;
  v37 = (const char *)jhl_nv_get_def("mr_mode");
  v38 = v4 + 2 + sprintf(&v3[v4 + 2], "\"mode\":\"%s\",", v37);
  v39 = (const char *)jhl_nv_get_def("mr_onlywan_tcp");
  v40 = v38 + sprintf(&v3[v38], "\"onlywan_tcp\":\"%s\",", v39);
  v41 = (const char *)jhl_nv_get_def("mr_onlywan");
  v42 = (const char *)jhl_nv_get_def("mr_zn_val");
  v43 = (const char *)jhl_nv_get_def("mr_ct_rule_name");
  v44 = v40
      + sprintf(
          &v3[v40],
          "\"onlywan\":\"%s\",\"zn_val\":\"%s\",\"ct_rule_name\":\"%s\",\"flag\":\"%d\"",
          v41,
          v42,
          v43,
          1);
  v45 = snprintf(&v3[v44], 0x200000 - v44, "}}");
  if ( v45 >= 0x200000 - v44 )
    v46 = 0x1FFFFF - v44;
  else
    v46 = v45;
  return httpd_cgi_ret(a1, v3, v46 + v44, 8);
}
// 4C13FC: variable 'v1' is possibly undefined
// 63F984: using guessed type void *off_63F984;
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8270: using guessed type int __fastcall mr_parm_default(_DWORD, _DWORD, _DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);

//----- (004C1D58) --------------------------------------------------------
int __fastcall sub_4C1D58(int a1)
{
  char *v2; // $s1
  char *v3; // $s6
  char *v4; // $s5
  char *v5; // $s4
  char *v6; // $s3
  char *v7; // $s2
  const char *v8; // $v0
  int v9; // $s1
  const char *v10; // $v0
  const char *v11; // $v0
  const char *v12; // $v0
  const char *v13; // $v0
  const char *v14; // $v0
  int v15; // $a0

  v2 = httpd_get_parm(a1, "enable");
  v3 = httpd_get_parm(a1, "dianxin_path");
  v4 = httpd_get_parm(a1, "wangtong_path");
  v5 = httpd_get_parm(a1, "yidong_path");
  v6 = httpd_get_parm(a1, "jiaoyu_path");
  v7 = httpd_get_parm(a1, "china_path");
  if ( !v2 || (v8 = (const char *)nvram_get("mr_addr_update_en")) != 0 && !strcmp(v8, v2) )
  {
    v9 = 0;
  }
  else
  {
    nvram_set("mr_addr_update_en", v2);
    v9 = 1;
  }
  if ( v3 )
  {
    v10 = (const char *)nvram_get("dianxin_update_path");
    if ( !v10 || strcmp(v10, v3) )
    {
      nvram_set("dianxin_update_path", v3);
      v9 = 1;
    }
  }
  if ( v4 )
  {
    v11 = (const char *)nvram_get("wangtong_update_path");
    if ( !v11 || strcmp(v11, v4) )
    {
      nvram_set("wangtong_update_path", v4);
      v9 = 1;
    }
  }
  if ( v5 )
  {
    v12 = (const char *)nvram_get("yidong_update_path");
    if ( !v12 || strcmp(v12, v5) )
    {
      nvram_set("yidong_update_path", v5);
      v9 = 1;
    }
  }
  if ( !v6 || (v13 = (const char *)nvram_get("jiaoyu_update_path")) != 0 && !strcmp(v13, v6) )
  {
    if ( !v7 )
      goto LABEL_28;
    v14 = (const char *)nvram_get("china_update_path");
    if ( !v14 )
      goto LABEL_22;
LABEL_27:
    if ( strcmp(v14, v7) )
      goto LABEL_22;
LABEL_28:
    if ( !v9 )
      return mr_addr_update_data(a1);
    goto LABEL_23;
  }
  nvram_set("jiaoyu_update_path", v6);
  if ( v7 )
  {
    v14 = (const char *)nvram_get("china_update_path");
    v9 = 1;
    if ( !v14 )
    {
LABEL_22:
      nvram_set("china_update_path", v7);
      goto LABEL_23;
    }
    goto LABEL_27;
  }
LABEL_23:
  nvram_unset("mr_addr_update_time");
  exec_service("mr_addr_update-restart");
  jhl_parm_commit(v15);
  return mr_addr_update_data(a1);
}
// 4C207C: variable 'v15' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8540: using guessed type int __fastcall nvram_unset(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C2118) --------------------------------------------------------
int __fastcall sub_4C2118(int a1)
{
  char *v1; // $s5
  char *v2; // $s0
  char *v3; // $s2
  char *v4; // $s6
  int v5; // $a0
  int v6; // $s0
  int v7; // $v0
  int v8; // $v0
  _BOOL4 v9; // $s4
  int v10; // $s2
  int v11; // $v0
  int v12; // $a1
  char *v13; // $a1
  int v14; // $s3
  int v15; // $s1
  int v16; // $v0
  _DWORD *v17; // $s7
  const char *v18; // $s0
  char *v19; // $s1
  char *v20; // $v0
  char *v21; // $s0
  int v22; // $v0
  const char *v23; // $s0
  int v24; // $a2
  int v25; // $v0
  const char *v26; // $a1
  char *v27; // $s1
  char *v28; // $s1
  char *v29; // $v0
  const char *v30; // $s3
  const char *v31; // $s7
  int v32; // $s3
  int v33; // $v0
  int v34; // $v0
  char *v35; // $v0
  int v36; // $v0
  int v37; // $a1
  int (__fastcall *v38)(const char *, int); // $t9
  const char *v39; // $a0
  int v40; // $v0
  int v41; // $s0
  char *v42; // $v0
  unsigned int v43; // $v0
  bool v44; // dc
  unsigned int v45; // $s0
  char *v46; // $v1
  char *v47; // $s0
  int v48; // $v0
  int v49; // $v0
  int v50; // $v0
  int v51; // $v0
  int v52; // $v0
  int v53; // $s0
  char *v54; // $v1
  const char *v55; // $v0
  int v56; // $t0
  int v57; // $a3
  int v58; // $a2
  int v59; // $a1
  int v61; // $v0
  int v62; // $v0
  int v63; // $s1
  int v64; // $v0
  const char *v65; // $s1
  int v66; // $v0
  const char *v67; // $v0
  int v68; // $v0
  int v69; // $v0
  const char *v70; // $s3
  int v71; // $v0
  const char *v72; // $s1
  int v73; // $v0
  const char *v74; // $v0
  int v75; // $v0
  int v76; // $v0
  int v77; // $v0
  char *v78; // $v0
  const char *v79; // [sp+48h] [-490h] BYREF
  const char *v80; // [sp+4Ch] [-48Ch]
  const char *v81; // [sp+50h] [-488h]
  char *v82; // [sp+54h] [-484h]
  char *v83; // [sp+58h] [-480h]
  int v84; // [sp+5Ch] [-47Ch]
  char v85[200]; // [sp+248h] [-290h] BYREF
  const char *v86; // [sp+310h] [-1C8h] BYREF
  const char *v87; // [sp+314h] [-1C4h]
  const char *v88; // [sp+318h] [-1C0h]
  int *v89; // [sp+31Ch] [-1BCh]
  void *v90; // [sp+320h] [-1B8h]
  int v91; // [sp+324h] [-1B4h]
  const char *v92; // [sp+328h] [-1B0h]
  char *v93; // [sp+32Ch] [-1ACh]
  int v94; // [sp+330h] [-1A8h]
  int *v95; // [sp+334h] [-1A4h]
  char *v96; // [sp+338h] [-1A0h]
  char *v97; // [sp+33Ch] [-19Ch]
  char *v98; // [sp+340h] [-198h]
  int v99; // [sp+344h] [-194h]
  int v100; // [sp+348h] [-190h]
  int v101; // [sp+34Ch] [-18Ch]
  int v102; // [sp+350h] [-188h]
  int v103[16]; // [sp+354h] [-184h] BYREF
  char v104[64]; // [sp+394h] [-144h] BYREF
  int v105; // [sp+3D4h] [-104h] BYREF
  int v106; // [sp+3D8h] [-100h]
  int v107; // [sp+3DCh] [-FCh]
  int v108; // [sp+3E0h] [-F8h]
  int v109; // [sp+3E4h] [-F4h]
  int v110; // [sp+3E8h] [-F0h]
  int v111; // [sp+3ECh] [-ECh]
  int v112; // [sp+3F0h] [-E8h]
  char v113; // [sp+3F4h] [-E4h] BYREF
  int v114; // [sp+414h] [-C4h] BYREF
  int v115; // [sp+418h] [-C0h]
  int v116; // [sp+41Ch] [-BCh]
  int v117; // [sp+420h] [-B8h]
  int v118; // [sp+424h] [-B4h]
  int v119; // [sp+428h] [-B0h]
  char v120; // [sp+42Ch] [-ACh] BYREF
  char *v121; // [sp+440h] [-98h]
  const char *v122; // [sp+444h] [-94h]
  int v123; // [sp+448h] [-90h]
  const char *v124; // [sp+44Ch] [-8Ch]
  char *v125; // [sp+450h] [-88h]
  char *v126; // [sp+454h] [-84h]
  char *v127; // [sp+458h] [-80h]
  char *v128; // [sp+45Ch] [-7Ch]
  int v129; // [sp+460h] [-78h]
  unsigned int v130; // [sp+464h] [-74h]
  char *v131; // [sp+468h] [-70h]
  char *v132; // [sp+46Ch] [-6Ch]
  char *v133; // [sp+470h] [-68h]
  int v134; // [sp+474h] [-64h]
  const char **v135; // [sp+478h] [-60h]
  char *v136; // [sp+47Ch] [-5Ch]
  int *v137; // [sp+480h] [-58h]
  char *v138; // [sp+484h] [-54h]
  int v139; // [sp+488h] [-50h]
  char *v140; // [sp+48Ch] [-4Ch]
  char *v141; // [sp+490h] [-48h]
  char *v142; // [sp+494h] [-44h]
  const char *v143; // [sp+498h] [-40h]
  const char *v144; // [sp+49Ch] [-3Ch]
  const char *v145; // [sp+4A0h] [-38h]
  char *v146; // [sp+4A4h] [-34h]
  char *v147; // [sp+4A8h] [-30h]
  char *v148; // [sp+4ACh] [-2Ch]
  char *v149; // [sp+4B0h] [-28h]
  char *v150; // [sp+4B4h] [-24h]
  char *v151; // [sp+4B8h] [-20h]
  char *v152; // [sp+4BCh] [-1Ch]
  char *v153; // [sp+4C0h] [-18h]
  char *v154; // [sp+4C4h] [-14h]
  char *v155; // [sp+4C8h] [-10h]
  char *v156; // [sp+4CCh] [-Ch]
  const char *v157; // [sp+4D0h] [-8h]

  v1 = httpd_get_parm(a1, "mode");
  v2 = httpd_get_parm(a1, "onlywan");
  v3 = httpd_get_parm(a1, "onlywan_tcp");
  v4 = httpd_get_parm(a1, "ct_rule_name");
  v126 = v104;
  v134 = httpd_get_json_parm(a1, (int)"wans");
  v114 = 0;
  v115 = 0;
  v116 = 0;
  v117 = 0;
  v118 = 0;
  v119 = 0;
  v105 = 0;
  v106 = 0;
  v107 = 0;
  v108 = 0;
  v109 = 0;
  v110 = 0;
  v111 = 0;
  v112 = 0;
  v137 = v103;
  memset(v104, 0, sizeof(v104));
  memset(v103, 0, sizeof(v103));
  if ( v4 )
    nvram_set("mr_ct_rule_name", v4);
  if ( v1 && (!strcmp(v1, "hi") || !strcmp(v1, "ct")) )
    nvram_set("mr_mode", v1);
  v124 = "wys";
  v79 = "wys";
  v80 = "mr";
  v81 = "mode";
  v122 = "mr";
  v82 = (char *)jhl_nv_get_def("mr_mode");
  v135 = &v79;
  v83 = (char *)jhl_nv_get_def("mr_ct_rule_name");
  v84 = 0;
  eval(&v79, 0, 0, 0);
  if ( v2 && (!strcmp(v2, "1") || !strcmp(v2, "0")) )
  {
    if ( !v3 )
      v3 = (char *)jhl_nv_get_def("mr_onlywan_tcp");
    goto LABEL_10;
  }
  if ( !v3 )
    goto LABEL_11;
  if ( !strcmp(v3, "1") )
  {
    if ( v2 )
      goto LABEL_10;
  }
  else
  {
    if ( strcmp(v3, "0") )
      goto LABEL_11;
    if ( v2 )
      goto LABEL_10;
  }
  v2 = (char *)jhl_nv_get_def("mr_onlywan");
LABEL_10:
  nvram_set("mr_onlywan_tcp", v3);
  nvram_set("mr_onlywan", v2);
  v79 = v124;
  v80 = v122;
  v81 = "onlywan";
  v82 = v2;
  v83 = v3;
  v84 = 0;
  eval(v135, 0, 0, 0);
LABEL_11:
  if ( v134 )
  {
    v139 = cJSON_GetArraySize(v134);
    if ( v139 > 0 )
    {
      v125 = "a";
      v142 = "a";
      v123 = 0;
      v146 = "1\"";
      v147 = "a";
      v138 = "a";
      v140 = "1\"";
      v149 = &v113;
      v141 = "a";
      v150 = &v120;
      v148 = "1\"";
      v157 = "a: no-cache\r\nCache-Control: no-cache\r\nSec-WebSocket-Accept: %s\r\n\r\n";
      v131 = v85;
      v143 = "jh";
      v144 = "val";
      v145 = "zc";
      v121 = "qz";
      v127 = "zc_en";
      v133 = "tm";
      while ( 1 )
      {
        v6 = cJSON_GetArrayItem(v134, v123);
        v7 = cJSON_GetObjectItem(v6, v142 + 13148);
        v8 = cJSON_GetIntvalue(v7);
        v9 = v8 < 101;
        v10 = v8;
        if ( v8 >= 101 )
        {
          v63 = v8 - 101;
          jhl_vpnclient_route_id(v8 - 101, v150);
          v64 = jhl_vpnget(v148 + 1368, v63);
          v13 = (char *)nvram_get(v64);
          v130 = -10;
          v129 = 0;
          if ( !v13 )
            v13 = (char *)(v157 - 1556);
        }
        else
        {
          jhl_wan_route_id(v8, v150);
          v11 = jhl_nvget("mr_parm", v10);
          v12 = nvram_get(v11);
          if ( !v12 )
            v12 = (int)(v157 - 1556);
          v128 = (char *)v12;
          v129 = jhl_get_wan_proto(v10);
          v13 = v128;
          v130 = v129 - 10;
        }
        if ( !*v13 )
          v13 = " ";
        v14 = (int)v135;
        strlcpy(v135, v13, 512);
        v15 = (int)v137;
        v16 = split_string(v14, 60, v137, 14);
        mr_parm_default(v16, v15, v10);
        v17 = *(_DWORD **)(v6 + 8);
        if ( v17 )
        {
          v156 = "1\"";
          v128 = 0;
          v132 = "times";
          v136 = "act";
          v151 = "su";
          v152 = "gw_en";
          v153 = "srv_en";
          v154 = "srv_ip";
          v155 = "gw_ip";
          while ( 1 )
          {
            v18 = (const char *)v17[8];
            v19 = (char *)v17[4];
            v17 = (_DWORD *)*v17;
            if ( !strcmp(v18, "jh_en") )
            {
              v103[0] = (int)v19;
LABEL_24:
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v121) )
            {
              if ( !*v19 )
                goto LABEL_24;
              v103[1] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v127) )
            {
              v103[2] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v133) )
            {
              v103[3] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v132) )
            {
              v103[4] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v136) )
            {
              v103[5] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v151) )
            {
              v103[6] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v152) )
            {
              v103[7] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v153) )
            {
              v103[8] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v154) )
            {
              v103[9] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v155) )
            {
              v103[10] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, v156 + 1556) )
            {
              v103[11] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, "host") )
            {
              v103[12] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else if ( !strcmp(v18, "ct") )
            {
              v103[13] = (int)v19;
              if ( !v17 )
                goto LABEL_25;
            }
            else
            {
              if ( strcmp(v18, "flow") )
                goto LABEL_24;
              v128 = v19;
              if ( !v17 )
                goto LABEL_25;
            }
          }
        }
        v128 = 0;
LABEL_25:
        if ( sq_file_get_state() == 1 )
        {
          v20 = (char *)v103[2];
        }
        else
        {
          v20 = "0";
          v103[2] = (int)"0";
        }
        v21 = v131;
        sprintf(
          v131,
          v146 + 1572,
          v103[0],
          v103[1],
          v20,
          v103[3],
          v103[4],
          v103[5],
          v103[6],
          v103[7],
          v103[8],
          v103[9],
          v103[10],
          v103[11],
          v103[12],
          v103[13]);
        if ( v9 )
        {
          v22 = jhl_nvget("mr_parm", v10);
          nvram_set(v22, v21);
          if ( J_atoi(v103[1]) )
          {
            v23 = (const char *)v103[1];
            v114 = 0;
            v115 = 0;
            v116 = 0;
            v117 = 0;
            v118 = 0;
            v119 = 0;
          }
          else
          {
            v114 = 0;
            v115 = 0;
            v116 = 0;
            v117 = 0;
            v118 = 0;
            v119 = 0;
            v23 = "100000";
          }
          v24 = v10 + 1;
        }
        else
        {
          v75 = jhl_vpnget(v148 + 1368, v10 - 101);
          nvram_set(v75, v131);
          if ( J_atoi(v103[1]) )
          {
            v23 = (const char *)v103[1];
            v114 = 0;
            v115 = 0;
            v116 = 0;
            v117 = 0;
            v118 = 0;
            v119 = 0;
          }
          else
          {
            v114 = 0;
            v115 = 0;
            v116 = 0;
            v117 = 0;
            v118 = 0;
            v119 = 0;
            v23 = "100000";
          }
          v24 = v10;
        }
        sprintf((char *)&v114, v147 + 24872, v24);
        v105 = 0;
        v106 = 0;
        v107 = 0;
        v108 = 0;
        v109 = 0;
        v110 = 0;
        v111 = 0;
        v112 = 0;
        if ( strcmp((const char *)v103[7], v125 + 9340) )
          break;
        if ( StrToIp(v103[10]) )
        {
          v26 = (const char *)v103[10];
        }
        else if ( v9 )
        {
          v26 = (const char *)jhl_get_wangw(v10);
        }
        else
        {
          v25 = jhl_vpnget("vpn_peerip", v10);
          v26 = (const char *)nvram_get(v25);
          if ( !v26 )
            v26 = "0.0.0.0";
        }
        strlcpy(&v105, v26, 32);
        if ( v9 )
          goto LABEL_84;
LABEL_37:
        v27 = v126;
        memset(v126, 0, 0x40u);
        if ( !strcmp((const char *)v103[8], v125 + 9340) )
        {
          snprintf(v27, 64, "%s", (const char *)v103[9]);
          if ( v130 >= 3 )
            goto LABEL_39;
        }
        else
        {
          *(_WORD *)v126 = 48;
          if ( v130 >= 3 )
          {
LABEL_39:
            v28 = "0";
            if ( v9 )
              goto LABEL_77;
            goto LABEL_40;
          }
        }
        v28 = v125 + 9340;
        if ( v9 )
        {
LABEL_77:
          v61 = jhl_nvget("wan_proto", v10);
          v30 = (const char *)nvram_get(v61);
          if ( !v30 )
            v30 = v157 - 1556;
          v62 = jhl_nvget("ppp_demand_run", v10);
          v29 = (char *)nvram_get(v62);
          if ( !v29 )
            v29 = (char *)(v157 - 1556);
          goto LABEL_41;
        }
LABEL_40:
        v29 = "0";
        v30 = "vpn";
LABEL_41:
        v31 = v124;
        v87 = v122;
        v90 = (void *)v103[0];
        v93 = v29;
        v88 = v143;
        v91 = v103[12];
        v92 = v30;
        v86 = v124;
        v89 = &v114;
        v94 = v103[13];
        v95 = 0;
        eval(&v86, 0, 0, 0);
        v88 = v144;
        v86 = v31;
        v87 = v122;
        v89 = &v114;
        v90 = (void *)v23;
        v91 = v103[11];
        v92 = 0;
        eval(&v86, 0, 0, 0);
        v32 = (int)v128;
        if ( v128 )
        {
          if ( v9 )
          {
            v33 = jhl_nvget("wan_flow_all", v10);
            nvram_set(v33, v32);
            v34 = jhl_nvget("wan_flow_all", v10);
            v35 = (char *)nvram_get(v34);
            if ( !v35 )
              v35 = "0";
            v36 = J_atoi(v35);
            v37 = v10;
            v38 = (int (__fastcall *)(const char *, int))&jhl_nvget;
            v39 = "wan_flow_use";
          }
          else
          {
            v76 = jhl_vpnget("vpn_flow_all", v10 - 101);
            nvram_set(v76, v128);
            v77 = jhl_vpnget("vpn_flow_all", v10 - 101);
            v78 = (char *)nvram_get(v77);
            if ( !v78 )
              v78 = "0";
            v36 = J_atoi(v78);
            v37 = v10 - 101;
            v38 = (int (__fastcall *)(const char *, int))&jhl_vpnget;
            v39 = "vpn_flow_use";
          }
          v41 = v36;
          v40 = v38(v39, v37);
          v42 = (char *)nvram_get(v40);
          if ( !v42 )
            v42 = "0";
          v43 = J_atoi(v42);
          v44 = v41 == 0;
          v45 = v41 << 10;
          if ( v44 || v43 < v45 )
            v46 = "0";
          else
            v46 = v125 + 9340;
          v86 = v124;
          v87 = v122;
          v88 = "flow";
          v89 = &v114;
          v90 = v46;
          v91 = 0;
          eval(&v86, 0, 0, 0);
        }
        v47 = v149;
        snprintf(v149, 32, v140 - 15580, v129);
        v86 = v124;
        v87 = v122;
        v89 = &v114;
        v88 = v145;
        v95 = &v105;
        v90 = (void *)v103[2];
        v97 = v28;
        v91 = v103[5];
        v98 = v47;
        v92 = (const char *)v103[3];
        v93 = (char *)v103[4];
        v94 = v103[6];
        v96 = v126;
        v48 = jhl_nvget(v138 + 12484, v10);
        v49 = nvram_get(v48);
        if ( !v49 )
          v49 = (int)(v157 - 1556);
        v99 = v49;
        v50 = jhl_nvget(v141 + 6804, v10);
        v51 = nvram_get(v50);
        if ( !v51 )
          v51 = (int)(v157 - 1556);
        v100 = v51;
        v52 = jhl_get_wanip(v10);
        ++v123;
        v101 = v52;
        v102 = 0;
        v53 = v123;
        eval(&v86, 0, 0, 0);
        if ( v139 == v53 )
          goto LABEL_57;
      }
      LOWORD(v105) = 48;
      if ( !v9 )
        goto LABEL_37;
LABEL_84:
      if ( StrToIp(v103[10]) )
        v65 = (const char *)v103[10];
      else
        v65 = (const char *)jhl_get_wangw(v10);
      v66 = jhl_nvget("wan_pinggw", v10);
      v67 = (const char *)nvram_get(v66);
      if ( !v67 || !v65 || strcmp(v67, v65) )
      {
        v68 = jhl_nvget("wan_pinggw", v10);
        nvram_set(v68, v65);
        if ( nvram_match_def("ping_wan_gw", v125 + 9340) )
        {
          ping_wan_gw_stop(v10);
          v69 = jhl_nvget(v138 + 12484, v10);
          v70 = (const char *)nvram_get(v69);
          if ( !v70 )
            v70 = v157 - 1556;
          if ( *v70 )
          {
            v71 = jhl_nvget("wan_name", v10);
            v72 = (const char *)nvram_get(v71);
            if ( !v72 )
              v72 = v157 - 1556;
            if ( *v72 )
            {
              v73 = jhl_nvget("wan_down", v10);
              v74 = (const char *)nvram_get(v73);
              if ( (!v74 || strcmp(v74, v125 + 9340)) && !jhl_iface_link_up_check(v70, v10) && jhl_check_wanup(v10) )
                ping_wan_gw_start(v10, v72);
            }
          }
        }
      }
      goto LABEL_37;
    }
  }
  v131 = v85;
LABEL_57:
  jhl_parm_commit(v5);
  v54 = v131;
  v55 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v56 = *(_DWORD *)v55;
    v57 = *((_DWORD *)v55 + 1);
    v58 = *((_DWORD *)v55 + 2);
    v59 = *((_DWORD *)v55 + 3);
    v55 += 16;
    *(_DWORD *)v54 = v56;
    *((_DWORD *)v54 + 1) = v57;
    *((_DWORD *)v54 + 2) = v58;
    *((_DWORD *)v54 + 3) = v59;
    v54 += 16;
  }
  while ( v55 != "}" );
  *(_WORD *)v54 = *(_WORD *)v55;
  return httpd_cgi_ret(a1, v131, 33, 4);
}
// 4C2CBC: variable 'v5' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8270: using guessed type int __fastcall mr_parm_default(_DWORD, _DWORD, _DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A8388: using guessed type int __fastcall ping_wan_gw_start(_DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8460: using guessed type int __fastcall jhl_get_wan_proto(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8518: using guessed type int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD);
// 6A8538: using guessed type int __fastcall jhl_check_wanup(_DWORD);
// 6A862C: using guessed type int __fastcall StrToIp(_DWORD);
// 6A86FC: using guessed type int __fastcall cJSON_GetArraySize(_DWORD);
// 6A8700: using guessed type int sq_file_get_state(void);
// 6A8710: using guessed type int __fastcall jhl_get_wanip(_DWORD);
// 6A8744: using guessed type int __fastcall cJSON_GetIntvalue(_DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8864: using guessed type int __fastcall jhl_vpnclient_route_id(_DWORD, _DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8920: using guessed type int __fastcall jhl_get_wangw(_DWORD);
// 6A8948: using guessed type int __fastcall jhl_vpnget(_DWORD, _DWORD);
// 6A89A4: using guessed type int __fastcall ping_wan_gw_stop(_DWORD);
// 6A89B0: using guessed type int __fastcall jhl_wan_route_id(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004C364C) --------------------------------------------------------
void __fastcall format_mrprot_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 12 )
    snprintf(
      a3,
      a4,
      "{\"name\":\"%s\",\"en\":%s,\"ips\":\"%s\",\"thd\":\"%s\",\"thd_type\":\"%s\",\"time\":\"%s\",\"rpri\":%s,\"log\":%"
      "s,\"wans\":\"%s\",\"no_change\":\"%s\",\"shibie\":\"%s\",\"ipport\":\"%s\"},",
      *a1,
      a1[1],
      a1[2],
      a1[8],
      a1[7],
      a1[3],
      a1[5],
      a1[4],
      a1[6],
      a1[11],
      a1[9],
      a1[10]);
}

//----- (004C371C) --------------------------------------------------------
int __fastcall get_mrcl_type_data(int a1)
{
  const char *v2; // $v0
  int v3; // $s2
  bool v4; // dc
  _DWORD *v5; // $v0
  int v6; // $s0
  const char *v7; // $v0
  int v8; // $v0
  _DWORD *v9; // $v1
  const char *v10; // $v0
  int v11; // $v0
  _DWORD *v12; // $v1
  const char *v13; // $v0
  int v14; // $v0
  int v15; // $v1
  const char *v16; // $v0
  int v17; // $v0
  _DWORD *v18; // $v1
  const char *v19; // $v0
  int v20; // $v0
  int v21; // $v1
  const char *v22; // $v0
  int v23; // $v0
  int v24; // $v1
  const char *v25; // $v0
  int v26; // $v0
  int v27; // $v1

  *(_WORD *)a1 = 91;
  v2 = (const char *)nvram_get("mrcl_1_en");
  v3 = 1;
  if ( v2 )
  {
    v4 = strcmp(v2, "1") == 0;
    v5 = (_DWORD *)(a1 + 1);
    if ( v4 )
    {
      *v5 = 578036347;
      *v5 = 578036347;
      *(_DWORD *)(a1 + 5) = 573321530;
      *(_DWORD *)(a1 + 5) = 573321530;
      *(_DWORD *)(a1 + 9) = 574235246;
      *(_DWORD *)(a1 + 9) = 574235246;
      *(_DWORD *)(a1 + 13) = -976164939;
      *(_DWORD *)(a1 + 13) = -976164939;
      *(_DWORD *)(a1 + 17) = 2915618;
      v3 = 20;
      v6 = 20;
      goto LABEL_5;
    }
    v3 = 1;
  }
  v6 = 1;
LABEL_5:
  v7 = (const char *)nvram_get("mrcl_2_en");
  if ( v7 )
  {
    v8 = strcmp(v7, "1");
    v9 = (_DWORD *)(a1 + v3);
    if ( !v8 )
    {
      *v9 = 578036347;
      *v9 = 578036347;
      v9[1] = 573321786;
      v9[1] = 573321786;
      v9[2] = 574235246;
      v9[2] = 574235246;
      v9[3] = -1462896435;
      v9[3] = -1462896435;
      v9[4] = 2915618;
      v6 += 19;
      v9[4] = 2915618;
      v3 = v6;
    }
  }
  v10 = (const char *)nvram_get("mrcl_3_en");
  if ( v10 )
  {
    v11 = strcmp(v10, "1");
    v12 = (_DWORD *)(a1 + v3);
    if ( !v11 )
    {
      *v12 = 578036347;
      *v12 = 578036347;
      v12[1] = 573322042;
      v12[1] = 573322042;
      v12[2] = 574235246;
      v12[2] = 574235246;
      v12[3] = -1346976046;
      v12[3] = -1346976046;
      v12[4] = 2915618;
      v6 += 19;
      v12[4] = 2915618;
      v3 = v6;
    }
  }
  v13 = (const char *)nvram_get("mrcl_4_en");
  if ( v13 )
  {
    v14 = strcmp(v13, "1");
    v15 = a1 + v3;
    if ( !v14 )
    {
      *(_DWORD *)v15 = 578036347;
      *(_DWORD *)v15 = 578036347;
      *(_DWORD *)(v15 + 4) = 573322298;
      *(_DWORD *)(v15 + 4) = 573322298;
      *(_DWORD *)(v15 + 8) = 574235246;
      *(_DWORD *)(v15 + 8) = 574235246;
      *(_DWORD *)(v15 + 12) = -36451139;
      *(_DWORD *)(v15 + 12) = -36451139;
      *(_DWORD *)(v15 + 16) = 2099443917;
      *(_BYTE *)(v15 + 20) = 44;
      v6 += 21;
      *(_BYTE *)(v15 + 21) = 0;
      v3 = v6;
    }
  }
  v16 = (const char *)nvram_get("mrcl_5_en");
  if ( v16 )
  {
    v17 = strcmp(v16, "1");
    v18 = (_DWORD *)(a1 + v3);
    if ( !v17 )
    {
      *v18 = 578036347;
      *v18 = 578036347;
      v18[1] = 573322554;
      v18[1] = 573322554;
      v18[2] = 574235246;
      v18[2] = 574235246;
      v18[3] = -53746490;
      v18[3] = -53746490;
      v18[4] = 2915618;
      v6 += 19;
      v18[4] = 2915618;
      v3 = v6;
    }
  }
  v19 = (const char *)nvram_get("mrcl_6_en");
  if ( v19 )
  {
    v20 = strcmp(v19, "1");
    v21 = a1 + v3;
    if ( !v20 )
    {
      *(_DWORD *)v21 = 578036347;
      *(_DWORD *)v21 = 578036347;
      *(_DWORD *)(v21 + 4) = 573322810;
      *(_DWORD *)(v21 + 4) = 573322810;
      *(_DWORD *)(v21 + 8) = 574235246;
      *(_DWORD *)(v21 + 8) = 574235246;
      *(_DWORD *)(v21 + 12) = -1464412969;
      *(_DWORD *)(v21 + 12) = -1464412969;
      *(_DWORD *)(v21 + 16) = 573695442;
      *(_BYTE *)(v21 + 20) = 125;
      v6 += 22;
      *(_BYTE *)(v21 + 21) = 44;
      *(_BYTE *)(v21 + 22) = 0;
      v3 = v6;
    }
  }
  v22 = (const char *)nvram_get("mrcl_7_en");
  if ( v22 )
  {
    v23 = strcmp(v22, "1");
    v24 = a1 + v3;
    if ( !v23 )
    {
      *(_DWORD *)v24 = 578036347;
      *(_DWORD *)v24 = 578036347;
      *(_DWORD *)(v24 + 4) = 573323066;
      *(_DWORD *)(v24 + 4) = 573323066;
      *(_DWORD *)(v24 + 8) = 574235246;
      *(_DWORD *)(v24 + 8) = 574235246;
      *(_DWORD *)(v24 + 12) = -1464412969;
      *(_DWORD *)(v24 + 12) = -1464412969;
      *(_DWORD *)(v24 + 16) = 573760978;
      *(_BYTE *)(v24 + 20) = 125;
      v6 += 22;
      *(_BYTE *)(v24 + 21) = 44;
      *(_BYTE *)(v24 + 22) = 0;
      v3 = v6;
    }
  }
  v25 = (const char *)nvram_get("mrcl_10_en");
  if ( v25 )
  {
    v4 = strcmp(v25, "1") != 0;
    v26 = a1 + v3;
    if ( !v4 )
    {
      *(_DWORD *)v26 = 578036347;
      *(_DWORD *)v26 = 578036347;
      *(_DWORD *)(v26 + 4) = 741355834;
      *(_DWORD *)(v26 + 4) = 741355834;
      *(_DWORD *)(v26 + 8) = 975334946;
      *(_DWORD *)(v26 + 8) = 975334946;
      *(_DWORD *)(v26 + 12) = -990201566;
      *(_DWORD *)(v26 + 12) = -990201566;
      *(_DWORD *)(v26 + 16) = 746398426;
      v6 += 20;
      *(_DWORD *)(v26 + 16) = 746398426;
      v3 = v6;
      *(_BYTE *)(v26 + 20) = 0;
    }
  }
  v27 = a1 + v3;
  *(_DWORD *)v27 = 578036347;
  *(_DWORD *)v27 = 578036347;
  *(_DWORD *)(v27 + 4) = 892678714;
  *(_DWORD *)(v27 + 4) = 892678714;
  *(_DWORD *)(v27 + 8) = 577643052;
  *(_DWORD *)(v27 + 8) = 577643052;
  *(_DWORD *)(v27 + 12) = -1261559238;
  *(_DWORD *)(v27 + 12) = -1261559238;
  *(_DWORD *)(v27 + 16) = -256788790;
  *(_DWORD *)(v27 + 16) = -256788790;
  *(_DWORD *)(v27 + 20) = 2099430581;
  *(_DWORD *)(v27 + 20) = 2099430581;
  *(_BYTE *)(v27 + 24) = 0;
  *(_WORD *)(a1 + v6 + 24) = 93;
  return v6 + 25;
}
// 65078C: using guessed type char byte_65078C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);

//----- (004C3CB0) --------------------------------------------------------
int __fastcall sub_4C3CB0(int a1)
{
  char *v1; // $v1
  char **v2; // $v0
  char *v3; // $t0
  char *v4; // $a3
  char *v5; // $a2
  char *v6; // $a1
  char *v7; // $a0
  char *v8; // $v0
  int v9; // $v0
  char *v10; // $s6
  _BYTE *v11; // $s2
  int v12; // $s0
  void *v13; // $s1
  void *v14; // $v0
  void *v15; // $s5
  int v16; // $s3
  int v17; // $a1
  void *v18; // $s0
  int v19; // $s4
  _DWORD *v20; // $s7
  int v21; // $s0
  int i; // $fp
  int v23; // $v0
  int v24; // $v0
  char *v25; // $a0
  int v26; // $v0
  int v27; // $s0
  char *v28; // $v0
  int v29; // $s0
  char *v30; // $v0
  int v31; // $s0
  char *v32; // $v0
  int v33; // $v0
  int v34; // $s0
  char *v35; // $v0
  const char **v36; // $a0
  int v37; // $s0
  int v38; // $a2
  const char *v40; // $v0
  unsigned int v41; // $v0
  char v42[256]; // [sp+20h] [-130h] BYREF
  char v43[40]; // [sp+120h] [-30h] BYREF
  char *v44; // [sp+148h] [-8h]
  void *ptr; // [sp+14Ch] [-4h]

  v1 = v43;
  v44 = v43;
  v2 = off_678AF0;
  do
  {
    v3 = *v2;
    v4 = v2[1];
    v5 = v2[2];
    v6 = v2[3];
    v2 += 4;
    *(_DWORD *)v1 = v3;
    *((_DWORD *)v1 + 1) = v4;
    *((_DWORD *)v1 + 2) = v5;
    *((_DWORD *)v1 + 3) = v6;
    v1 += 16;
  }
  while ( v2 != (char **)&off_678B10 );
  v7 = *v2;
  v8 = v2[1];
  *(_DWORD *)v1 = v7;
  *((_DWORD *)v1 + 1) = v8;
  _mem_malloc(0x200000, "mrprot_data", 851);
  v10 = (char *)v9;
  if ( v9 )
  {
    strcpy((char *)v9, "{\"code\":0,\"error\":\"\",\"data\":{\"all\":");
    qmemcpy((void *)v9, "{\"code\":0,\"e", 12);
    *(_DWORD *)(v9 + 24) = 975331700;
    *(_BYTE *)(v9 + 32) = 108;
    v11 = (_BYTE *)(v9 + 35);
    v12 = nvram_get("mrprot2");
    v10[35] = 91;
    v10[36] = 0;
    if ( !v12 )
    {
      v25 = v10 + 36;
      v21 = 1;
      if ( *v11 != 44 )
        goto LABEL_19;
      goto LABEL_26;
    }
    v13 = malloc(0x38u);
    v15 = malloc(0x4008u);
    v14 = malloc(0x200000u);
    ptr = v14;
    v16 = 1;
    if ( !v14 )
    {
      v21 = 1;
LABEL_13:
      if ( v13 )
        free(v13);
      if ( v15 )
        free(v15);
      if ( v21 <= 0 )
      {
        v25 = &v11[v16];
        goto LABEL_19;
      }
      v25 = &v11[v16];
      if ( v11[v16 - 1] != 44 )
      {
LABEL_19:
        *v25 = 0;
        v26 = snprintf(v25, 2097117 - v21, &byte_6445A0);
        if ( v26 >= 2097117 - v21 )
          v26 = 2097116 - v21;
        v27 = v21 + v26;
        v28 = &v10[v27 + 35];
        strcpy(v28, ",\"wans\":");
        *(_DWORD *)v28 = 1635197484;
        *((_DWORD *)v28 + 1) = 975336302;
        v29 = v27 + 43 + get_wans_data(&v10[v27 + 43], 0x200000 - (v27 + 43));
        v30 = &v10[v29];
        strcpy(&v10[v29], ",\"vpns\":");
        *(_DWORD *)v30 = 1886790188;
        *((_DWORD *)v30 + 1) = 975336302;
        v31 = v29 + 8 + get_vpns_iface(&v10[v29 + 8]);
        v32 = &v10[v31];
        strcpy(&v10[v31], ",\"type\":");
        *(_DWORD *)v32 = 2037654060;
        *((_DWORD *)v32 + 1) = 975332720;
        v33 = v31 + 8 + get_mrcl_type_data((int)&v10[v31 + 8]);
        v34 = v33 + 1;
        v35 = &v10[v33];
        v36 = (const char **)v44;
        *v35 = 44;
        v35[1] = 0;
        v37 = v34 + get_nvarms(v36, (int)&v10[v34], 0x200000 - v34) - 1;
        v38 = snprintf(&v10[v37], 0x200000 - v37, "}}");
        if ( v38 >= 0x200000 - v37 )
          v38 = 0x1FFFFF - v37;
        return httpd_cgi_ret(a1, v10, v38 + v37, 8);
      }
LABEL_26:
      v25 = &v11[--v21];
      goto LABEL_19;
    }
    if ( v13 )
    {
      v17 = v12;
      if ( v15 )
      {
        v18 = v14;
        strlcpy(v14, v17, 0x200000);
        v19 = split_string(v18, 60, v15, 4096);
        if ( v19 > 0 )
        {
          v20 = v15;
          v21 = 1;
          for ( i = 0; i != v19; ++i )
          {
            v23 = split_string(*v20, 124, v13, 12);
            format_mrprot_data((const char **)v13, v23, &v11[v21], 2097117 - v21);
            v21 += v24;
            ++v20;
          }
          v16 = v21;
          goto LABEL_12;
        }
        v16 = 1;
      }
    }
    v21 = 1;
LABEL_12:
    free(ptr);
    goto LABEL_13;
  }
  v40 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
  v41 = snprintf(v42, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v40);
  if ( v41 >= 0x100 )
    v41 = 255;
  return httpd_cgi_ret(a1, v42, v41, 4);
}
// 4C3D64: variable 'v9' is possibly undefined
// 4C3F14: variable 'v24' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 64331C: using guessed type int dword_64331C;
// 6445A0: using guessed type char byte_6445A0;
// 6448E0: using guessed type int dword_6448E0;
// 6459A8: using guessed type int dword_6459A8;
// 678AF0: using guessed type char *off_678AF0[8];
// 678B10: using guessed type void *off_678B10;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C4218) --------------------------------------------------------
int __fastcall mrcl_ips_get_type(const char *a1)
{
  char *v1; // $s0
  const char *v3; // $a0

  v1 = (char *)&cl_ips_types;
  v3 = off_679864;
  if ( !off_679864 )
    return 0;
  while ( 1 )
  {
    v1 += 8;
    if ( !strcmp(v3, a1) )
      break;
    v3 = (const char *)*((_DWORD *)v1 + 1);
    if ( !v3 )
      return 0;
  }
  return *((_DWORD *)v1 - 2);
}
// 679864: using guessed type char *off_679864;

//----- (004C42B4) --------------------------------------------------------
int __fastcall sub_4C42B4(int a1)
{
  char *v2; // $v0
  char *v3; // $s1
  char *v4; // $s5
  int v5; // $s0
  int v6; // $a0
  int *v7; // $v1
  const char *v8; // $v0
  int v9; // $t0
  int v10; // $a3
  int v11; // $a2
  int v12; // $a1
  unsigned int v13; // $a2
  const char *v15; // $v0
  char v16[256]; // [sp+20h] [-19Ch] BYREF
  int v17[32]; // [sp+120h] [-9Ch] BYREF
  char v18[28]; // [sp+1A0h] [-1Ch] BYREF

  v3 = httpd_get_parm(a1, "n");
  v2 = httpd_get_parm(a1, "en");
  if ( v3 && (v4 = v2, (v5 = mrcl_ips_get_type(v3)) != 0) )
  {
    if ( v5 == 10 && nvram_match_def("drop_foreign_ip", "1") )
      v4 = "1";
    sprintf(v18, "%d", v5);
    sprintf(v16, "mrcl_%d_en", v5);
    v17[0] = (int)"wys";
    v17[1] = (int)"mrcl_en";
    v17[2] = (int)v18;
    v17[3] = (int)v3;
    v17[4] = (int)v4;
    v17[5] = 0;
    eval(v17, 0, 0, 0);
    nvram_set(v16, v4);
    jhl_parm_commit(v6);
    v7 = v17;
    v8 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v9 = *(_DWORD *)v8;
      v10 = *((_DWORD *)v8 + 1);
      v11 = *((_DWORD *)v8 + 2);
      v12 = *((_DWORD *)v8 + 3);
      v8 += 16;
      *v7 = v9;
      v7[1] = v10;
      v7[2] = v11;
      v7[3] = v12;
      v7 += 4;
    }
    while ( v8 != "}" );
    v13 = 33;
    *(_WORD *)v7 = *(_WORD *)v8;
  }
  else
  {
    v15 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_6442E4);
    v13 = snprintf((char *)v17, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v15);
    if ( v13 >= 0x80 )
      v13 = 127;
  }
  return httpd_cgi_ret(a1, (char *)v17, v13, 4);
}
// 4C43F4: variable 'v6' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83E4: using guessed type int __fastcall nvram_match_def(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C4514) --------------------------------------------------------
int __fastcall mrclfile_cgi(int a1, int a2, const char *a3)
{
  int v3; // $s3
  int v4; // $s6
  char *v7; // $v0
  char *v9; // $v0
  const char *v10; // $s0
  int v11; // $s6
  signed int v12; // $v0
  int v13; // $s1
  const char *v14; // $a2
  const char *v15; // $v0
  unsigned int v16; // $a2
  int v18; // $a0
  const char *v19; // $v0
  int v20[256]; // [sp+20h] [-60Ch] BYREF
  char v21[256]; // [sp+420h] [-20Ch] BYREF
  char v22[256]; // [sp+520h] [-10Ch] BYREF
  const char *v23; // [sp+620h] [-Ch]

  v3 = a1 + 196608;
  v4 = *(_DWORD *)(a1 + 205364);
  find_file_head(a1, *(const char **)(a1 + 205564));
  if ( v7 )
  {
    v10 = v7;
    v9 = find_file_end(a1, v7, *(_DWORD *)(v3 + 8956) + v4 - (_DWORD)v7);
    v11 = v9 - v10;
    if ( v9 )
    {
      if ( v11 >= 204801 )
      {
        v14 = (const char *)_GET_LANG_TEXT(40, *(unsigned __int8 *)(v3 + 13494), "200K");
      }
      else
      {
        *v9 = 0;
        v12 = strlen(v10);
        v13 = v11;
        if ( v12 < v11 )
          v13 = v12;
        sprintf(v22, "/etc/mrcl/%s_tmp.txt", a3);
        f_write(v22, v10, v13, 0, 448);
        if ( judge_ipaddr_file_valid(v22) )
        {
          unlink(v22);
          sprintf(v22, "/etc/mrcl/%s.txt", a3);
          sprintf(v21, "mrcl_%s", a3);
          f_write(v22, v10, v13, 0, 448);
          v20[0] = (int)"wys";
          v20[1] = (int)"mrcl_ips";
          v20[2] = a2;
          v20[3] = (int)a3;
          v20[4] = (int)v22;
          v20[5] = 0;
          eval(v20, 0, 0, 0);
          nvram_set_zipfile(v21, v22, 204800);
          jhl_parm_commit(v18);
          goto LABEL_12;
        }
        v23 = (const char *)_GET_LANG_TEXT(42, *(unsigned __int8 *)(a1 + 210102), "");
        unlink(v22);
        v14 = v23;
      }
      if ( v14 )
        goto LABEL_9;
LABEL_12:
      v19 = (const char *)_GET_LANG_TEXT(34, *(unsigned __int8 *)(a1 + 210102), v14);
      v16 = snprintf((char *)v20, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", v19);
      if ( v16 < 0x400 )
        return httpd_cgi_ret(a1, (char *)v20, v16, 4);
LABEL_13:
      v16 = 1023;
      return httpd_cgi_ret(a1, (char *)v20, v16, 4);
    }
  }
  v14 = "Error reading file";
LABEL_9:
  v15 = (const char *)_GET_LANG_TEXT(33, *(unsigned __int8 *)(a1 + 210102), v14);
  v16 = snprintf((char *)v20, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v15);
  if ( v16 >= 0x400 )
    goto LABEL_13;
  return httpd_cgi_ret(a1, (char *)v20, v16, 4);
}
// 4C4578: variable 'v7' is possibly undefined
// 4C47FC: variable 'v18' is possibly undefined
// 4C4818: variable 'v14' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A8204: using guessed type int __fastcall f_write(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A84F8: using guessed type int __fastcall judge_ipaddr_file_valid(_DWORD);
// 6A861C: using guessed type int __fastcall nvram_set_zipfile(_DWORD, _DWORD, _DWORD);

//----- (004C488C) --------------------------------------------------------
int __fastcall sub_4C488C(int a1)
{
  return mrclfile_cgi(a1, (int)"1", "dianxin");
}

//----- (004C48B0) --------------------------------------------------------
int __fastcall sub_4C48B0(int a1)
{
  return mrclfile_cgi(a1, (int)"2", "wangtong");
}

//----- (004C48D4) --------------------------------------------------------
int __fastcall sub_4C48D4(int a1)
{
  return mrclfile_cgi(a1, (int)"3", "yidong");
}

//----- (004C48F8) --------------------------------------------------------
int __fastcall sub_4C48F8(int a1)
{
  return mrclfile_cgi(a1, (int)"4", "jiaoyu");
}

//----- (004C491C) --------------------------------------------------------
int __fastcall sub_4C491C(int a1)
{
  return mrclfile_cgi(a1, (int)&unk_4D15F8, "other");
}

//----- (004C4940) --------------------------------------------------------
int __fastcall sub_4C4940(int a1)
{
  return mrclfile_cgi(a1, (int)"6", "ziding1");
}

//----- (004C4964) --------------------------------------------------------
int __fastcall sub_4C4964(int a1)
{
  return mrclfile_cgi(a1, (int)"9", "changcheng");
}

//----- (004C4988) --------------------------------------------------------
int __fastcall sub_4C4988(int a1)
{
  return mrclfile_cgi(a1, (int)"10", "china");
}

//----- (004C49AC) --------------------------------------------------------
int __fastcall sub_4C49AC(int a1)
{
  return mrclfile_cgi(a1, (int)"7", "ziding2");
}

//----- (004C49D0) --------------------------------------------------------
int __fastcall sub_4C49D0(int a1)
{
  return mrclfile_cgi(a1, (int)"8", "ziding3");
}

//----- (004C4A00) --------------------------------------------------------
int __fastcall sub_4C4A00(int a1)
{
  int v2; // $v0
  int v3; // $v0
  bool v4; // dc
  int v5; // $v0
  char v7[4096]; // [sp+18h] [-101Ch] BYREF
  char *v8; // [sp+1018h] [-1Ch] BYREF
  int v9; // [sp+101Ch] [-18h]
  int v10; // [sp+1020h] [-14h]
  int v11; // [sp+1024h] [-10h]
  int v12; // [sp+1028h] [-Ch]

  v8 = v7;
  v9 = 4096;
  strcpy(v7, "{\"code\":0,\"error\":\"\",\"data\":{");
  v10 = 29;
  v11 = 0;
  v12 = 0;
  mcl_bytearray_printf(&v8, "\"lan\":[");
  lan_iface_foreach(&v8, sub_4C4B88);
  v2 = v10;
  if ( v10 > 0 && v8[v10 - 1] == 44 )
    v2 = --v10;
  v8[v2] = 0;
  mcl_bytearray_printf(&v8, &byte_6445A0);
  v3 = snprintf(&v8[v10], v9 - v10, "}}");
  v4 = v3 < v9 - v10;
  v5 = v3 + v10;
  if ( !v4 )
    v5 = v9 - 1;
  v10 = v5;
  return httpd_cgi_ret(a1, v8, v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6A8414: using guessed type int mcl_bytearray_printf(_DWORD, const char *, ...);
// 6A84EC: using guessed type int __fastcall lan_iface_foreach(_DWORD, _DWORD);

//----- (004C4B88) --------------------------------------------------------
int __fastcall sub_4C4B88(int a1, int a2, const char *a3)
{
  int v6; // $v0
  int v7; // $v0
  const char *v8; // $s2
  int v9; // $v0
  const char *v10; // $s3
  int v11; // $v0
  const char *v12; // $s4
  int v13; // $v0
  const char *v14; // $s5
  int v15; // $v0
  const char *v16; // $v1
  int v17; // $v0
  const char *v18; // $v0
  char v20[32]; // [sp+38h] [-28h] BYREF
  const char *v21; // [sp+58h] [-8h]

  snprintf(v20, 32, "LAN%u", a2 + 1);
  v6 = lan_name_get2("ipv6.lan", a2, "ip", 0);
  v7 = nvram_get(v6);
  if ( v7 )
    v8 = (const char *)v7;
  else
    v8 = "";
  v9 = lan_name_get2("ipv6.lan", a2, &unk_4D0FF8, 0);
  v10 = (const char *)nvram_get(v9);
  if ( !v10 )
    v10 = "";
  v11 = lan_name_get2("ipv6.lan", a2, "dhcp", 0);
  v12 = (const char *)nvram_get(v11);
  if ( !v12 )
    v12 = "";
  v13 = lan_name_get2("ipv6.lan", a2, "ndp", 0);
  v14 = (const char *)nvram_get(v13);
  if ( !v14 )
    v14 = "";
  v15 = lan_name_get2("ipv6.lan", a2, &off_6508E4, 0);
  v16 = (const char *)nvram_get(v15);
  if ( !v16 )
    v16 = "";
  v21 = v16;
  v17 = lan_name_get2("ipv6.lan", a2, "dns", 0);
  v18 = (const char *)nvram_get(v17);
  if ( !v18 )
    v18 = "";
  mcl_bytearray_printf(
    a1,
    "{\"iface\":\"%u\",\"ifname\":\"%s\",\"showname\":\"%s\",\"ip\":\"%s\",\"ra_type\":\"%s\",\"dhcp_type\":\"%s\",\"ndp_"
    "type\":\"%s\",\"ula\":\"%s\",\"dns\":\"%s\"},",
    a2,
    a3,
    v20,
    v8,
    v10,
    v12,
    v14,
    v21,
    v18);
  return -1;
}
// 6508E4: using guessed type void *off_6508E4;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8414: using guessed type int mcl_bytearray_printf(_DWORD, const char *, ...);
// 6A84C4: using guessed type int __fastcall lan_name_get2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C4E38) --------------------------------------------------------
int __fastcall sub_4C4E38(int a1)
{
  const char *v2; // $v0
  int v3; // $v0
  bool v4; // dc
  int v5; // $v0
  char v7[8192]; // [sp+18h] [-2018h] BYREF
  char *v8; // [sp+2018h] [-18h] BYREF
  int v9; // [sp+201Ch] [-14h]
  int v10; // [sp+2020h] [-10h]
  int v11; // [sp+2024h] [-Ch]
  int v12; // [sp+2028h] [-8h]

  v8 = v7;
  v9 = 0x2000;
  strcpy(v7, "{\"code\":0,\"error\":\"\",\"data\":{");
  v10 = 29;
  v11 = 0;
  v12 = 0;
  v2 = (const char *)nvram_get("ipv6in4_all");
  if ( !v2 )
    v2 = "";
  mcl_bytearray_printf(&v8, "\"list\":\"%s\"", v2);
  v3 = snprintf(&v8[v10], v9 - v10, "}}");
  v4 = v3 < v9 - v10;
  v5 = v3 + v10;
  if ( !v4 )
    v5 = v9 - 1;
  v10 = v5;
  return httpd_cgi_ret(a1, v8, v5, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8414: using guessed type int mcl_bytearray_printf(_DWORD, const char *, ...);

//----- (004C4F78) --------------------------------------------------------
int __fastcall sub_4C4F78(int a1, int a2, const char *a3)
{
  int v5; // $v0
  const char *v7; // $v0
  const char *v8; // $s0
  char v10[36]; // [sp+20h] [-24h] BYREF

  v5 = lan_name_get2("wan", a2, "proto", 0);
  v7 = (const char *)nvram_get(v5);
  if ( v7 && ((v8 = v7, !strcmp(v7, "3G")) || !strcmp(v8, "4G")) )
    strcpy(v10, "4G");
  else
    snprintf(v10, 32, "WAN%u", a2 + 1);
  return -(mcl_bytearray_printf(a1, "{\"iface\":\"%u\",\"ifname\":\"%s\",\"showname\":\"%s\"},", a2, a3, v10) < 1);
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8414: using guessed type int mcl_bytearray_printf(_DWORD, const char *, ...);
// 6A84C4: using guessed type int __fastcall lan_name_get2(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C50A8) --------------------------------------------------------
int __fastcall sub_4C50A8(int a1)
{
  const char *v2; // $v0
  int v3; // $a0
  char v5[8192]; // [sp+28h] [-4000h] BYREF
  char v6[8192]; // [sp+2028h] [-2000h] BYREF

  v5[0] = 0;
  v2 = (const char *)nvram_get("ipv6in4_all");
  if ( !v2 )
    v2 = "";
  snprintf(v6, 0x2000, "%s", v2);
  nvparm_del_str(v6, 60, 0, a1, 124, 0, v5);
  ipv6in4_stop(a1);
  nvram_set("ipv6in4_all", v5);
  jhl_parm_commit(v3);
  return 0;
}
// 4C5180: variable 'v3' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A850C: using guessed type int __fastcall ipv6in4_stop(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C51B0) --------------------------------------------------------
int __fastcall sub_4C51B0(int a1, int a2, int a3, int a4, char *nptr)
{
  const char *v9; // $v0
  int v10; // $s3
  bool v11; // dc
  int result; // $v0
  int v13; // $a0
  char v14[8192]; // [sp+28h] [-401Ch] BYREF
  char v15[8192]; // [sp+2028h] [-201Ch] BYREF
  int v16[7]; // [sp+4028h] [-1Ch] BYREF

  v10 = atoi(nptr);
  v9 = (const char *)nvram_get("ipv6in4_all");
  if ( !v9 )
    v9 = "";
  snprintf(v15, 0x2000, "%s", v9);
  v14[0] = 0;
  nvparm_del_str(v15, 60, 0, a1, 124, 0, v14);
  v16[0] = (int)v14;
  v16[1] = 0x2000;
  v16[2] = strlen(v14);
  v16[3] = 0;
  v16[4] = 0;
  v11 = mcl_bytearray_printf(
          v16,
          "<%s|%s|%s|%s|%d",
          (const char *)a1,
          (const char *)a2,
          (const char *)a3,
          (const char *)a4,
          v10 != 0) <= 0;
  result = -1;
  if ( !v11 )
  {
    ipv6in4_stop(a1);
    if ( v10 )
      ipv6in4_start(a1, a2, a3, a4);
    nvram_set("ipv6in4_all", v16[0]);
    jhl_parm_commit(v13);
    result = 0;
  }
  return result;
}
// 4C531C: variable 'v13' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8414: using guessed type int mcl_bytearray_printf(_DWORD, const char *, ...);
// 6A850C: using guessed type int __fastcall ipv6in4_stop(_DWORD);
// 6A8510: using guessed type int __fastcall ipv6in4_start(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C5380) --------------------------------------------------------
int __fastcall sub_4C5380(int a1)
{
  char *v2; // $s1
  char *v3; // $s2
  char *v4; // $s4
  char *v5; // $s6
  char *v6; // $v0
  char *v7; // $fp
  char *nptr; // $s7
  int v9; // $s3
  int v10; // $a0
  char *v11; // $a1
  int v12; // $a2
  char v13; // $v0
  char *v14; // $v1
  int v15; // $v0
  int v16; // $v0
  int v17; // $a1
  int v18; // $a0
  const char *v19; // $v0
  unsigned int v20; // $a2
  char *v22; // $v1
  int v23; // $v0
  int v24; // $v0
  char *v25; // $v1
  const char *v26; // $v0
  int v27; // $t0
  int v28; // $a3
  int v29; // $a2
  int v30; // $a1
  char *v31; // $v0
  char *v32; // $fp
  int v33; // $a3
  char *v34; // $fp
  char v35[256]; // [sp+28h] [-150h] BYREF
  char v36[64]; // [sp+128h] [-50h] BYREF
  int v37[2]; // [sp+168h] [-10h] BYREF
  char *s; // [sp+170h] [-8h]

  v2 = httpd_get_parm(a1, "opt");
  v3 = httpd_get_parm(a1, "name");
  v4 = httpd_get_parm(a1, "remote_ipv4");
  v5 = httpd_get_parm(a1, "local_ipv4");
  v7 = httpd_get_parm(a1, "local_ipv6");
  v6 = httpd_get_parm(a1, "tunnel_enable");
  v37[0] = 0;
  v37[1] = 0;
  if ( !v2
    || (nptr = v6, (v9 = strcmp(v2, (const char *)&off_648DDC)) != 0)
    && strcmp(v2, (const char *)&off_646D8C)
    && strcmp(v2, "del") )
  {
    v19 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not opt");
    goto LABEL_23;
  }
  if ( !v3 || (v10 = *v3, v11 = v3 + 1, !*v3) )
  {
    v19 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_6442E4);
    goto LABEL_23;
  }
  v12 = 95;
  v13 = v10 | 0x20;
  do
  {
    ++v11;
    if ( (unsigned __int8)(v13 - 97) >= 0x1Au && (unsigned __int8)(v10 - 48) >= 0xAu && v10 != 95 && v10 != 46 )
    {
      v19 = (const char *)_GET_LANG_TEXT(159, *(unsigned __int8 *)(a1 + 210102), 95);
LABEL_23:
      v20 = snprintf(v35, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
      if ( v20 >= 0x100 )
        v20 = 255;
      return httpd_cgi_ret(a1, v35, v20, 4);
    }
    v10 = *(v11 - 1);
    v13 = v10 | 0x20;
  }
  while ( *(v11 - 1) );
  if ( !v9 || (s = "a", !strcmp(v2, (const char *)&off_646D8C)) )
  {
    if ( v4 )
    {
      v14 = "1\"";
      if ( *v4 )
      {
        s = "1\"";
        v15 = strcmp(v4, "any");
        v14 = "1\"";
        if ( v15 )
        {
          v16 = uv_inet_pton4(v4, v35);
          v14 = s;
          if ( v16 )
          {
            v17 = *(unsigned __int8 *)(a1 + 210102);
            v18 = 160;
            goto LABEL_21;
          }
        }
      }
      else
      {
        v4 = "any";
      }
    }
    else
    {
      v14 = "1\"";
      v4 = "any";
    }
    if ( v5 && *v5 && (s = v14, !uv_inet_pton4(v5, v35)) )
    {
      if ( !v7 || !*v7 )
      {
        uv_inet_pton4(v5, v37);
        v23 = strcmp(v4, s - 4312);
        s = v36;
        if ( v23 )
          snprintf(
            v36,
            64,
            "2002:%02x%02x:%02x%02x::1/48",
            LOBYTE(v37[0]),
            BYTE1(v37[0]),
            BYTE2(v37[0]),
            HIBYTE(v37[0]));
        else
          snprintf(
            v36,
            64,
            "2002:%02x%02x:%02x%02x::1/16",
            LOBYTE(v37[0]),
            BYTE1(v37[0]),
            BYTE2(v37[0]),
            HIBYTE(v37[0]));
        goto LABEL_36;
      }
      s = v36;
      snprintf(v36, 64, "%s", v7);
      v31 = strchr(s, 47);
      v32 = v31;
      if ( v31 )
        *v31 = 0;
      if ( v36[0] && !uv_inet_pton6(s, v35) )
      {
        if ( v32 )
        {
          v33 = atoi(v32 + 1);
          if ( (unsigned int)(v33 - 8) >= 0x79 )
            v33 = 64;
        }
        else
        {
          v34 = s;
          v32 = &v34[strlen(s)];
          v33 = 64;
        }
        snprintf(v32, (char *)v37 - v32, (char *)&off_650A30, v33);
LABEL_36:
        v24 = strcmp(v2, "del");
        v7 = s;
        if ( !v24 )
          goto LABEL_46;
        goto LABEL_37;
      }
      v17 = *(unsigned __int8 *)(a1 + 210102);
      v18 = 162;
    }
    else
    {
      v17 = *(unsigned __int8 *)(a1 + 210102);
      v18 = 161;
    }
LABEL_21:
    v19 = (const char *)_GET_LANG_TEXT(v18, v17, v12);
    goto LABEL_23;
  }
  if ( strcmp(v2, "del") )
  {
    v22 = s;
    goto LABEL_39;
  }
LABEL_46:
  sub_4C50A8((int)v3);
LABEL_37:
  if ( !strcmp(v2, (const char *)&off_648DDC) )
    goto LABEL_40;
  v22 = "a";
LABEL_39:
  if ( !strcmp(v2, v22 + 28044) )
  {
LABEL_40:
    if ( !nptr )
      nptr = "0";
    sub_4C51B0((int)v3, (int)v4, (int)v5, (int)v7, nptr);
  }
  v25 = v35;
  v26 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v27 = *(_DWORD *)v26;
    v28 = *((_DWORD *)v26 + 1);
    v29 = *((_DWORD *)v26 + 2);
    v30 = *((_DWORD *)v26 + 3);
    v26 += 16;
    *(_DWORD *)v25 = v27;
    *((_DWORD *)v25 + 1) = v28;
    *((_DWORD *)v25 + 2) = v29;
    *((_DWORD *)v25 + 3) = v30;
    v25 += 16;
  }
  while ( v26 != "}" );
  v20 = 33;
  *(_WORD *)v25 = *(_WORD *)v26;
  return httpd_cgi_ret(a1, v35, v20, 4);
}
// 4C55CC: variable 'v12' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 650A30: using guessed type void *off_650A30;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A870C: using guessed type int __fastcall uv_inet_pton6(_DWORD, _DWORD);
// 6A8714: using guessed type int __fastcall uv_inet_pton4(_DWORD, _DWORD);

//----- (004C5A3C) --------------------------------------------------------
int __fastcall sub_4C5A3C(int a1, int a2, const char *a3)
{
  const char *v6; // $v0
  char v8[32]; // [sp+20h] [-20h] BYREF

  v6 = (const char *)lan_showname_guess(a2, a3, v8);
  return -(mcl_bytearray_printf(a1, "{\"iface\":\"%u\",\"ifname\":\"%s\",\"showname\":\"%s\"},", a2, a3, v6) < 1);
}
// 6A8414: using guessed type int mcl_bytearray_printf(_DWORD, const char *, ...);
// 6A8954: using guessed type int __fastcall lan_showname_guess(_DWORD, _DWORD, _DWORD);

//----- (004C5AC4) --------------------------------------------------------
int __fastcall sub_4C5AC4(int a1)
{
  char *v2; // $s2
  char *v3; // $s6
  char *v4; // $s7
  char *v5; // $v0
  char *v6; // $s4
  int v7; // $fp
  void *v8; // $v0
  void *v9; // $s1
  void *v10; // $v0
  _DWORD *v11; // $s4
  int v12; // $s6
  int v13; // $a0
  unsigned int v14; // $s5
  int v16; // $a1
  int v17; // $a2
  int v18; // $a0
  const char *v19; // $v0
  int v20; // $a1
  const char *v21; // $a2
  int v22; // $a0
  const char *v23; // $v0
  char *v24; // $v1
  const char *v25; // $v0
  int v26; // $t0
  int v27; // $a3
  int v28; // $a2
  int v29; // $a1
  char *v30; // $s4
  const char *v31; // $v0
  char v32[1024]; // [sp+28h] [-430h] BYREF
  char *v33; // [sp+428h] [-30h] BYREF
  char *v34; // [sp+42Ch] [-2Ch]
  char *v35; // [sp+430h] [-28h]
  char *v36; // [sp+434h] [-24h]
  int v37; // [sp+438h] [-20h]
  int v38; // [sp+43Ch] [-1Ch]
  char *s; // [sp+440h] [-18h]
  void *v40; // [sp+444h] [-14h]
  char *v41; // [sp+448h] [-10h]
  char *v42; // [sp+44Ch] [-Ch]
  char *v43; // [sp+450h] [-8h]
  int v44; // [sp+454h] [-4h]

  s = v32;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  memset(v32, 0, sizeof(v32));
  v2 = httpd_get_parm(a1, "opt");
  v3 = httpd_get_parm(a1, "name");
  v4 = httpd_get_parm(a1, "dst");
  v41 = httpd_get_parm(a1, "gw");
  v42 = httpd_get_parm(a1, "dev");
  v5 = httpd_get_parm(a1, "old_name");
  v43 = "a";
  v6 = v5;
  v7 = httpd_get_json_parm(a1, (int)"del_list");
  if ( strcmp((const char *)&off_646D8C, v2) && strcmp("del", v2) && strcmp((const char *)&off_648DDC, v2) )
  {
    v16 = *(unsigned __int8 *)(a1 + 210102);
    v17 = (int)"not opt";
    v18 = 12;
    goto LABEL_28;
  }
  _mem_malloc(102400, "ipv6_router_asp", 630);
  v9 = v8;
  if ( !v8 )
  {
    v16 = *(unsigned __int8 *)(a1 + 210102);
    v17 = 102400;
    v18 = 4;
LABEL_28:
    v19 = (const char *)_GET_LANG_TEXT(v18, v16, v17);
    v14 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v19);
    if ( v14 >= 0x400 )
      v14 = 1023;
    return httpd_cgi_ret(a1, s, v14, 4);
  }
  _mem_malloc(102400, "ipv6_router_asp", 637);
  v40 = v10;
  if ( v10 )
  {
    v44 = (int)"1\"";
    if ( !strcmp("del", v2) && v7 && cJSON_IsArray(v7) )
    {
      v11 = *(_DWORD **)(v7 + 8);
      if ( !v11 )
        goto LABEL_48;
      v12 = v11[4];
      if ( !v12 )
        goto LABEL_48;
      v44 = 0;
      v42 = "ipv6_router_static";
      v41 = (char *)102400;
      v43 = "ipv6_router_static";
      do
      {
        jhl_parm_get(v42, v9, v41);
        if ( nvparm_get_str(v9, 60, 6, v12, 124, 3, &v33) )
        {
          if ( !ipv6_router_set_to_server(v2, &v33) )
          {
            jhl_parm_get(v43, v9, v41);
            if ( nvparm_del_str(v9, 60, 6, v12, 124, 3, v40) )
            {
              nvram_set(v42, v40);
              v44 = 1;
            }
          }
        }
        v11 = (_DWORD *)*v11;
        if ( !v11 )
          break;
        v12 = v11[4];
      }
      while ( v12 );
LABEL_47:
      if ( !v44 )
        goto LABEL_48;
      goto LABEL_56;
    }
    if ( v3 )
    {
      if ( strcmp(v2, (const char *)&off_648DDC) )
        goto LABEL_21;
      if ( !v6 )
      {
        v20 = *(unsigned __int8 *)(a1 + 210102);
        v21 = (const char *)&unk_650A48;
        v22 = 12;
        goto LABEL_45;
      }
      jhl_parm_get("ipv6_router_static", v9, 102400);
      if ( nvparm_get_str(v9, 60, 6, v3, 124, 3, &v33)
        && !ipv6_router_set_to_server(v44 - 15196, &v33)
        && (jhl_parm_get("ipv6_router_static", v9, 102400), nvparm_del_str(v9, 60, 6, v3, 124, 3, v40)) )
      {
        nvram_set("ipv6_router_static", v40);
        v44 = 1;
      }
      else
      {
LABEL_21:
        v44 = 0;
      }
      if ( !strcmp(v43 + 28044, v2) )
      {
        v14 = check_rule_num_limit(a1, 33, (int)"ipv6_router_static", 62, s, 0x400u);
        if ( (int)v14 > 0 )
        {
LABEL_24:
          _mem_free(v9);
          _mem_free(v40);
          return httpd_cgi_ret(a1, s, v14, 4);
        }
      }
      else if ( strcmp((const char *)&off_648DDC, v2) )
      {
        goto LABEL_47;
      }
      jhl_parm_get("ipv6_router_static", v9, 102400);
      if ( nvparm_find_str(v9, 60, 6, v3, 124, 3) )
      {
        v20 = *(unsigned __int8 *)(a1 + 210102);
        v21 = "same name";
        v22 = 12;
      }
      else
      {
        if ( !*v3 )
          v3 = "";
        v36 = v3;
        if ( !v4 || !*v4 )
          v4 = "";
        v33 = v4;
        if ( !v41 || !*v41 )
          v41 = "";
        v34 = v41;
        if ( !v42 || !*v42 )
          v42 = "";
        v35 = v42;
        if ( !ipv6_router_set_to_server(v2, &v33) )
        {
          v30 = (char *)v40;
          snprintf((char *)v40, 102400, "%s|%s|%s|%s<", v4, v41, v42, v3);
          jhl_parm_get("ipv6_router_static", v9, 102400);
          strcat((char *)v9, v30);
          nvram_set("ipv6_router_static", v9);
LABEL_56:
          jhl_parm_commit(v13);
LABEL_48:
          v24 = s;
          v25 = "{\"code\":0,\"error\":\"\",\"data\":null}";
          do
          {
            v26 = *(_DWORD *)v25;
            v27 = *((_DWORD *)v25 + 1);
            v28 = *((_DWORD *)v25 + 2);
            v29 = *((_DWORD *)v25 + 3);
            v25 += 16;
            *(_DWORD *)v24 = v26;
            *((_DWORD *)v24 + 1) = v27;
            *((_DWORD *)v24 + 2) = v28;
            *((_DWORD *)v24 + 3) = v29;
            v24 += 16;
          }
          while ( v25 != "}" );
          v14 = 33;
          *(_WORD *)v24 = *(_WORD *)v25;
          goto LABEL_24;
        }
        v20 = *(unsigned __int8 *)(a1 + 210102);
        v21 = v2;
        v22 = 166;
      }
    }
    else
    {
      v20 = *(unsigned __int8 *)(a1 + 210102);
      v21 = (const char *)&unk_6442E4;
      v22 = 12;
    }
LABEL_45:
    v23 = (const char *)_GET_LANG_TEXT(v22, v20, v21);
    v14 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v23);
    if ( v14 >= 0x400 )
      v14 = 1023;
    goto LABEL_24;
  }
  v31 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
  v14 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
  if ( v14 >= 0x400 )
    v14 = 1023;
  _mem_free(v9);
  return httpd_cgi_ret(a1, s, v14, 4);
}
// 4C5C70: variable 'v8' is possibly undefined
// 4C5C88: variable 'v10' is possibly undefined
// 4C6338: variable 'v13' is possibly undefined
// 646D8C: using guessed type char *off_646D8C;
// 648DDC: using guessed type char *off_648DDC;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81F4: using guessed type int __fastcall nvparm_find_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83C8: using guessed type int __fastcall nvparm_del_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8568: using guessed type int __fastcall ipv6_router_set_to_server(_DWORD, _DWORD);
// 6A8600: using guessed type int __fastcall jhl_parm_get(_DWORD, _DWORD, _DWORD);
// 6A86B0: using guessed type int __fastcall nvparm_get_str(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C641C) --------------------------------------------------------
int __fastcall sub_4C641C(int a1)
{
  int v1; // $v0
  int v2; // $s5
  int v3; // $s7
  int v4; // $s4
  int v5; // $v0
  _DWORD *v6; // $s6
  int v7; // $v0
  int v8; // $a0
  int v9; // $s1
  int v10; // $s3
  const char *v11; // $a2
  const char *v12; // $s0
  int v13; // $v0
  const char *v14; // $v0
  int v15; // $v0
  char *v16; // $v1
  const char *v17; // $v0
  int v18; // $t0
  int v19; // $a3
  int v20; // $a2
  int v21; // $a1
  unsigned int v22; // $a2
  const char *v24; // $v0
  char v25[1024]; // [sp+20h] [-430h] BYREF
  int v26[8]; // [sp+420h] [-30h] BYREF
  const char *v27; // [sp+440h] [-10h]
  int v28; // [sp+444h] [-Ch]
  char *s; // [sp+448h] [-8h]

  s = v25;
  memset(v25, 0, sizeof(v25));
  v1 = httpd_get_json_parm(a1, (int)"wans");
  if ( v1 )
  {
    v2 = v1;
    v3 = cJSON_GetArraySize(v1);
    if ( v3 > 0 )
    {
      v4 = 0;
      v28 = 0;
      v27 = "iface";
      do
      {
        v26[0] = 0;
        v26[1] = 0;
        v26[2] = 0;
        v26[3] = 0;
        v26[4] = 0;
        v26[5] = 0;
        v26[6] = 0;
        v26[7] = 0;
        v5 = cJSON_GetArrayItem(v2, v4);
        v6 = *(_DWORD **)(v5 + 8);
        v7 = cJSON_GetObjectItem(v5, v27);
        v9 = cJSON_GetIntvalue(v7);
        if ( !v6 )
          goto LABEL_12;
        v10 = 0;
        do
        {
          v11 = (const char *)v6[8];
          v12 = (const char *)v6[4];
          v6 = (_DWORD *)*v6;
          sprintf((char *)v26, "ipv6.wan_%s", v11);
          v13 = jhl_nvget(v26, v9);
          v14 = (const char *)nvram_get(v13);
          if ( !v14 || !v12 || strcmp(v14, v12) )
          {
            v15 = jhl_nvget(v26, v9);
            nvram_set(v15, v12);
            v10 = 1;
          }
        }
        while ( v6 );
        if ( v10 )
        {
          ++v28;
          ipv6wan_start(v9, 0, 0);
          ++v4;
        }
        else
        {
LABEL_12:
          ++v4;
        }
      }
      while ( v3 != v4 );
      if ( v28 )
        jhl_parm_commit(v8);
    }
    v16 = s;
    v17 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    do
    {
      v18 = *(_DWORD *)v17;
      v19 = *((_DWORD *)v17 + 1);
      v20 = *((_DWORD *)v17 + 2);
      v21 = *((_DWORD *)v17 + 3);
      v17 += 16;
      *(_DWORD *)v16 = v18;
      *((_DWORD *)v16 + 1) = v19;
      *((_DWORD *)v16 + 2) = v20;
      *((_DWORD *)v16 + 3) = v21;
      v16 += 16;
    }
    while ( v17 != "}" );
    v22 = 33;
    *(_WORD *)v16 = *(_WORD *)v17;
  }
  else
  {
    v24 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), &unk_650A58);
    v22 = snprintf(s, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v24);
    if ( v22 >= 0x400 )
      v22 = 1023;
  }
  return httpd_cgi_ret(a1, s, v22, 4);
}
// 4C66E0: variable 'v8' is possibly undefined
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8518: using guessed type int __fastcall cJSON_GetArrayItem(_DWORD, _DWORD);
// 6A86FC: using guessed type int __fastcall cJSON_GetArraySize(_DWORD);
// 6A8744: using guessed type int __fastcall cJSON_GetIntvalue(_DWORD);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A8998: using guessed type int __fastcall ipv6wan_start(_DWORD, _DWORD, _DWORD);

//----- (004C6758) --------------------------------------------------------
int __fastcall sub_4C6758(int a1)
{
  char *v2; // $fp
  char *v3; // $s7
  char *v4; // $s6
  int v5; // $a0
  char *v6; // $s2
  int v7; // $v0
  const char *v8; // $v0
  int v9; // $v0
  int v10; // $s3
  int v11; // $v0
  const char *v12; // $v0
  int v13; // $v0
  int v14; // $v0
  const char *v15; // $v0
  int v16; // $v0
  const char *v17; // $s7
  int v18; // $v0
  const char *v19; // $v0
  int v20; // $v0
  int v21; // $v0
  const char *v22; // $v0
  int v23; // $v0
  int v24; // $v0
  const char *v25; // $v0
  int v26; // $v0
  char *v27; // $v1
  const char *v28; // $v0
  int v29; // $t0
  int v30; // $a3
  int v31; // $a2
  int v32; // $a1
  char v34[128]; // [sp+18h] [-90h] BYREF
  char *v35; // [sp+98h] [-10h]
  char *v36; // [sp+9Ch] [-Ch]
  char *v37; // [sp+A0h] [-8h]

  v37 = v34;
  memset(v34, 0, sizeof(v34));
  v2 = httpd_get_parm(a1, "ip");
  v3 = httpd_get_parm(a1, "ra_type");
  v4 = httpd_get_parm(a1, "dhcp_type");
  v36 = httpd_get_parm(a1, "ndp_type");
  v35 = httpd_get_parm(a1, (char *)&off_6508E4);
  v6 = httpd_get_parm(a1, "dns");
  if ( !v2 || (v7 = lan_name_get2("ipv6.lan", 0, "ip", 0), (v8 = (const char *)nvram_get(v7)) != 0) && !strcmp(v8, v2) )
  {
    v10 = 0;
  }
  else
  {
    v9 = lan_name_get2("ipv6.lan", 0, "ip", 0);
    nvram_set(v9, v2);
    v10 = 1;
  }
  if ( v3 )
  {
    v11 = lan_name_get2("ipv6.lan", 0, &unk_4D0FF8, 0);
    v12 = (const char *)nvram_get(v11);
    if ( !v12 || strcmp(v12, v3) )
    {
      v13 = lan_name_get2("ipv6.lan", 0, &unk_4D0FF8, 0);
      nvram_set(v13, v3);
      v10 = 1;
    }
  }
  if ( v4 )
  {
    v14 = lan_name_get2("ipv6.lan", 0, "dhcp", 0);
    v15 = (const char *)nvram_get(v14);
    if ( !v15 || strcmp(v15, v4) )
    {
      v16 = lan_name_get2("ipv6.lan", 0, "dhcp", 0);
      nvram_set(v16, v4);
      v10 = 1;
    }
  }
  v17 = v36;
  if ( v36 )
  {
    v18 = lan_name_get2("ipv6.lan", 0, "ndp", 0);
    v19 = (const char *)nvram_get(v18);
    if ( !v19 || strcmp(v19, v17) )
    {
      v20 = lan_name_get2("ipv6.lan", 0, "ndp", 0);
      nvram_set(v20, v36);
      v10 = 1;
    }
  }
  if ( !v35
    || (v21 = lan_name_get2("ipv6.lan", 0, &off_6508E4, 0), (v22 = (const char *)nvram_get(v21)) != 0)
    && !strcmp(v22, v35) )
  {
    if ( !v6 )
      goto LABEL_30;
    goto LABEL_23;
  }
  v23 = lan_name_get2("ipv6.lan", 0, &off_6508E4, 0);
  nvram_set(v23, v35);
  if ( v6 )
  {
    v10 = 1;
LABEL_23:
    v24 = lan_name_get2("ipv6.lan", 0, "dns", 0);
    v25 = (const char *)nvram_get(v24);
    if ( !v25 || strcmp(v25, v6) )
    {
      v26 = lan_name_get2("ipv6.lan", 0, "dns", 0);
      nvram_set(v26, v6);
      goto LABEL_26;
    }
LABEL_30:
    if ( !v10 )
      goto LABEL_27;
  }
LABEL_26:
  jhl_parm_commit(v5);
  ipv6lan_set_all();
  dhcp6s_restart();
LABEL_27:
  v27 = v37;
  v28 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v29 = *(_DWORD *)v28;
    v30 = *((_DWORD *)v28 + 1);
    v31 = *((_DWORD *)v28 + 2);
    v32 = *((_DWORD *)v28 + 3);
    v28 += 16;
    *(_DWORD *)v27 = v29;
    *((_DWORD *)v27 + 1) = v30;
    *((_DWORD *)v27 + 2) = v31;
    *((_DWORD *)v27 + 3) = v32;
    v27 += 16;
  }
  while ( v28 != "}" );
  *(_WORD *)v27 = *(_WORD *)v28;
  return httpd_cgi_ret(a1, v37, 33, 4);
}
// 4C6C28: variable 'v5' is possibly undefined
// 6508E4: using guessed type void *off_6508E4;
// 6A8180: using guessed type int __fastcall jhl_parm_commit(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A84C4: using guessed type int __fastcall lan_name_get2(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A85FC: using guessed type int dhcp6s_restart(void);
// 6A8630: using guessed type int ipv6lan_set_all(void);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C6D0C) --------------------------------------------------------
int __fastcall get_ipv6_wans_data(char *a1, int a2)
{
  int v3; // $s5
  int v4; // $s2
  int v5; // $s0
  int v6; // $v0
  char *v7; // $s1
  int v8; // $v0
  int v9; // $v0
  const char *v10; // $v0
  int v11; // $v0
  const char *v12; // $v0
  int v13; // $v0
  int v14; // $v0
  int v15; // $s2
  const char *v16; // $v0
  int v17; // $v0
  int v18; // $v0
  int v19; // $s1
  int v20; // $s2
  int v21; // $v0
  int v22; // $v0
  int v23; // $v0
  int v24; // $v0
  int v25; // $v0
  char *v26; // $v1
  int v27; // $v0
  const char *v28; // $v0
  int v29; // $v0
  int v30; // $s1
  int v31; // $v0
  char *v32; // $a0
  int v33; // $s4
  int v34; // $v0
  char *v36; // [sp+30h] [-30h]
  char *v37; // [sp+30h] [-30h]
  const char *v38; // [sp+38h] [-28h]
  const char *v39; // [sp+3Ch] [-24h]
  const char *v40; // [sp+40h] [-20h]
  const char *v41; // [sp+44h] [-1Ch]
  const char *v42; // [sp+58h] [-8h]

  v3 = sq_file_get_max_wan();
  v4 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v4 >= a2 )
    v4 = a2 - 1;
  if ( v3 > 0 && v4 < a2 - 99 )
  {
    v5 = 0;
    do
    {
      v6 = jhl_nvget("wan_ifname", v5);
      v7 = (char *)nvram_get(v6);
      if ( !v7 )
        v7 = "";
      v8 = jhl_nvget("wan_orgifname", v5);
      nvram_get(v8);
      if ( !*v7 )
        break;
      v9 = jhl_nvget("wan_down", v5);
      v10 = (const char *)nvram_get(v9);
      if ( v10 && !strcmp(v10, "1") || jhl_iface_link_up_check(v7, v5) )
      {
        if ( v3 == ++v5 )
          break;
      }
      else
      {
        v11 = jhl_nvget("wan_proto", v5);
        v12 = (const char *)nvram_get(v11);
        v36 = (char *)v12;
        if ( v12 )
        {
          if ( !strncmp(v12, "3G", 2u) )
          {
            v36 = "4G";
          }
          else if ( !strncmp(v36, "4G", 2u) )
          {
            v36 = "4G";
          }
        }
        else
        {
          v36 = "disabled";
        }
        v13 = snprintf(&a1[v4], a2 - v4, (char *)&word_642164);
        if ( v13 >= a2 - v4 )
          v13 = a2 - v4 - 1;
        v15 = v13 + v4;
        v14 = jhl_nvget("wan_name", v5);
        v16 = (const char *)nvram_get(v14);
        if ( !v16 )
          v16 = "";
        v17 = snprintf(
                &a1[v15],
                a2 - v15,
                "\"iface\":\"%d\",\"wan_ifname\":\"%s\",\"wan_type\":\"%s\",\"wan_name\":\"%s\",",
                v5,
                v7,
                v36,
                v16);
        if ( v17 >= a2 - v15 )
          v17 = a2 - v15 - 1;
        v19 = v17 + v15;
        v18 = jhl_nvget("ipv6.wan_proto", v5);
        v20 = a2 - v19;
        v37 = (char *)nvram_get(v18);
        if ( !v37 )
          v37 = "OFF";
        v21 = jhl_nvget("ipv6.wan_mode", v5);
        v38 = (const char *)nvram_get(v21);
        if ( !v38 )
          v38 = "router";
        v22 = jhl_nvget("ipv6.wan_local_ip", v5);
        v39 = (const char *)jhl_nv_get_def(v22);
        if ( !v39 )
          v39 = "";
        v23 = jhl_nvget("ipv6.wan_peer_ip", v5);
        v40 = (const char *)jhl_nv_get_def(v23);
        if ( !v40 )
          v40 = "";
        v24 = jhl_nvget("ipv6.wan_local_ip6", v5);
        v41 = (const char *)jhl_nv_get_def(v24);
        if ( !v41 )
          v41 = "";
        v25 = jhl_nvget("ipv6.wan_static_ip6", v5);
        v26 = (char *)jhl_nv_get_def(v25);
        if ( !v26 )
          v26 = "";
        v42 = v26;
        v27 = jhl_nvget("ipv6.wan_static_gw6", v5);
        v28 = (const char *)jhl_nv_get_def(v27);
        if ( !v28 )
          v28 = "";
        v29 = snprintf(
                &a1[v19],
                a2 - v19,
                "\"proto\":\"%s\",\"mode\":\"%s\",\"local_ip\":\"%s\",\"peer_ip\":\"%s\",\"local_ip6\":\"%s\",\"static_ip"
                "6\":\"%s\",\"static_gw6\":\"%s\"",
                v37,
                v38,
                v39,
                v40,
                v41,
                v42,
                v28);
        if ( v29 >= v20 )
          v29 = v20 - 1;
        v30 = v29 + v19;
        v31 = snprintf(&a1[v30], a2 - v30, &byte_65078C);
        if ( v31 >= a2 - v30 )
          v31 = a2 - v30 - 1;
        ++v5;
        v4 = v31 + v30;
        if ( v3 == v5 )
          break;
      }
    }
    while ( v4 < a2 - 99 );
  }
  v32 = &a1[v4];
  if ( v4 > 0 && *(v32 - 1) == 44 )
    v32 = &a1[--v4];
  v33 = a2 - v4;
  *v32 = 0;
  v34 = snprintf(v32, v33, &byte_6445A0);
  if ( v34 >= v33 )
    v34 = v33 - 1;
  return v4 + v34;
}
// 642164: using guessed type __int16 word_642164;
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 65078C: using guessed type char byte_65078C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A82F4: using guessed type int __fastcall jhl_iface_link_up_check(_DWORD, _DWORD);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A85E0: using guessed type int sq_file_get_max_wan(void);
// 6A890C: using guessed type int __fastcall jhl_nvget(_DWORD, _DWORD);

//----- (004C73B8) --------------------------------------------------------
int __fastcall sub_4C73B8(int a1)
{
  int v2; // $v0
  char *v3; // $s0
  int v4; // $s3
  int v5; // $v0
  int v6; // $a2
  int result; // $v0
  const char *v8; // $v0
  unsigned int v9; // $v0
  char v10[256]; // [sp+20h] [-100h] BYREF

  _mem_malloc(0x200000, "wan_conf_ipv6_data", 211);
  v3 = (char *)v2;
  if ( v2 )
  {
    strcpy((char *)v2, "{\"code\":0,\"error\":\"\",\"data\":{\"wans\":");
    qmemcpy((void *)v2, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v2 + 24) = 975331700;
    strcpy((char *)(v2 + 32), "ns\":");
    v4 = get_ipv6_wans_data((char *)(v2 + 36), 2097116) + 36;
    v5 = snprintf(&v3[v4], 0x200000 - v4, "}}");
    if ( v5 >= 0x200000 - v4 )
      v6 = 0x1FFFFF - v4;
    else
      v6 = v5;
    result = httpd_cgi_ret(a1, v3, v6 + v4, 8);
  }
  else
  {
    v8 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v9 = snprintf(v10, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v8);
    if ( v9 >= 0x100 )
      v9 = 255;
    result = httpd_cgi_ret(a1, v10, v9, 4);
  }
  return result;
}
// 4C7408: variable 'v2' is possibly undefined
// 642164: using guessed type __int16 word_642164;
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004C75B8) --------------------------------------------------------
void __fastcall format_ipv6_router_static_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 4 )
    snprintf(a3, a4, "{\"dst\":\"%s\",\"gw\":\"%s\",\"dev\":\"%s\",\"name\":\"%s\"},", *a1, a1[1], a1[2], a1[3]);
}

//----- (004C7648) --------------------------------------------------------
int __fastcall get_ipv6_router_static_data(char *a1, int a2)
{
  int v4; // $s2
  int v5; // $s0
  const char **v6; // $s4
  void *v7; // $v0
  _DWORD *v8; // $s7
  void *v9; // $fp
  int v10; // $s6
  _DWORD *v11; // $s3
  int i; // $s2
  int v13; // $v0
  int v14; // $v0
  char *v15; // $a0
  int v16; // $s1
  int v17; // $v0

  v4 = nvram_get("ipv6_router_static");
  v5 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v5 >= a2 )
    v5 = a2 - 1;
  if ( v4 )
  {
    v6 = (const char **)malloc(0x18u);
    v8 = malloc(0x4008u);
    v7 = malloc(0x200000u);
    v9 = v7;
    if ( v7 )
    {
      if ( v6 )
      {
        if ( v8 )
        {
          strlcpy(v7, v4, 0x200000);
          v10 = split_string(v9, 60, v8, 4096);
          if ( v10 > 0 )
          {
            v11 = v8;
            for ( i = 0; i != v10; ++i )
            {
              v13 = split_string(*v11, 124, v6, 4);
              format_ipv6_router_static_data(v6, v13, &a1[v5], a2 - v5);
              v5 += v14;
              ++v11;
            }
          }
        }
      }
      free(v9);
    }
    if ( v6 )
      free(v6);
    if ( v8 )
      free(v8);
  }
  v15 = &a1[v5];
  if ( v5 > 0 && *(v15 - 1) == 44 )
    v15 = &a1[--v5];
  v16 = a2 - v5;
  *v15 = 0;
  v17 = snprintf(v15, v16, &byte_6445A0);
  if ( v17 >= v16 )
    v17 = v16 - 1;
  return v5 + v17;
}
// 4C77B4: variable 'v14' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C7890) --------------------------------------------------------
void __fastcall format_ipv6_router_data(const char **a1, int a2, char *a3, int a4)
{
  if ( a2 >= 3 )
    snprintf(a3, a4, "{\"dst\":\"%s\",\"gw\":\"%s\",\"dev\":\"%s\"},", *a1, a1[1], a1[2]);
}

//----- (004C7918) --------------------------------------------------------
int __fastcall get_ipv6_router_data(char *a1, int a2)
{
  int v4; // $s2
  int v5; // $s0
  const char **v6; // $s4
  void *v7; // $v0
  _DWORD *v8; // $s7
  void *v9; // $fp
  int v10; // $s6
  _DWORD *v11; // $s3
  int i; // $s2
  int v13; // $v0
  int v14; // $v0
  char *v15; // $a0
  int v16; // $s1
  int v17; // $v0

  v4 = nvram_get("ipv6_router");
  v5 = snprintf(a1, a2, (char *)&word_642A04);
  if ( v5 >= a2 )
    v5 = a2 - 1;
  if ( v4 )
  {
    v6 = (const char **)malloc(0x14u);
    v8 = malloc(0x4008u);
    v7 = malloc(0x200000u);
    v9 = v7;
    if ( v7 )
    {
      if ( v6 )
      {
        if ( v8 )
        {
          strlcpy(v7, v4, 0x200000);
          v10 = split_string(v9, 60, v8, 4096);
          if ( v10 > 0 )
          {
            v11 = v8;
            for ( i = 0; i != v10; ++i )
            {
              v13 = split_string(*v11, 124, v6, 3);
              format_ipv6_router_data(v6, v13, &a1[v5], a2 - v5);
              v5 += v14;
              ++v11;
            }
          }
        }
      }
      free(v9);
    }
    if ( v6 )
      free(v6);
    if ( v8 )
      free(v8);
  }
  v15 = &a1[v5];
  if ( v5 > 0 && *(v15 - 1) == 44 )
    v15 = &a1[--v5];
  v16 = a2 - v5;
  *v15 = 0;
  v17 = snprintf(v15, v16, &byte_6445A0);
  if ( v17 >= v16 )
    v17 = v16 - 1;
  return v5 + v17;
}
// 4C7A84: variable 'v14' is possibly undefined
// 642A04: using guessed type __int16 word_642A04;
// 6445A0: using guessed type char byte_6445A0;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C7B60) --------------------------------------------------------
int __fastcall sub_4C7B60(int a1)
{
  int v2; // $v0
  int v3; // $v0
  const char *v4; // $v0
  int v5; // $v0
  int v6; // $v0
  char v8[102400]; // [sp+20h] [-19028h] BYREF
  _DWORD v9[5]; // [sp+19020h] [-28h] BYREF
  char *v10; // [sp+19034h] [-14h] BYREF
  int v11; // [sp+19038h] [-10h]
  int v12; // [sp+1903Ch] [-Ch]
  int v13; // [sp+19040h] [-8h]
  int v14; // [sp+19044h] [-4h]

  memset(v8, 0, sizeof(v8));
  v11 = 102400;
  v10 = v8;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  nvram_set("ipv6_router", "");
  v9[0] = "wys";
  v9[1] = "ipv6";
  v9[2] = "router";
  v9[3] = "info";
  v9[4] = 0;
  eval(v9, 0, 0, 0);
  strcpy(v8, "{\"code\":0,\"error\":\"\",\"data\":{");
  v12 = 29;
  mcl_bytearray_printf(&v10, (const char *)&dword_6459A8);
  v12 += get_ipv6_router_data(&v10[v12], v11 - v12);
  mcl_bytearray_printf(&v10, ",\"static\":");
  v12 += get_ipv6_router_static_data(&v10[v12], v11 - v12);
  mcl_bytearray_printf(&v10, (const char *)&dword_64BD3C);
  v12 += asp_activeroutes(&v10[v12], v11 - v12);
  mcl_bytearray_printf(&v10, ",\"lan\":[");
  lan_iface_foreach(&v10, sub_4C5A3C);
  v2 = v12;
  if ( v12 > 0 && v10[v12 - 1] == 44 )
    v2 = --v12;
  v10[v2] = 0;
  mcl_bytearray_printf(&v10, &byte_6445A0);
  mcl_bytearray_printf(&v10, ",\"wan\":[");
  wan_iface_foreach(&v10, sub_4C4F78);
  v3 = v12;
  if ( v12 > 0 && v10[v12 - 1] == 44 )
    v3 = --v12;
  v10[v3] = 0;
  mcl_bytearray_printf(&v10, &byte_6445A0);
  v4 = (const char *)nvram_get("pppoesrv");
  if ( !v4 )
    v4 = "";
  mcl_bytearray_printf(&v10, ",\"tun\":[{\"iface\":\"%u\",\"ifname\":\"%s\",\"showname\":\"%s\"}],", 99, v4, "PPPOE");
  v5 = v12;
  if ( v12 > 0 && v10[v12 - 1] == 44 )
    v5 = --v12;
  v10[v5] = 0;
  v6 = snprintf(&v10[v12], v11 - v12, "}}");
  if ( v6 >= v11 - v12 )
    v6 = v11 - v12 - 1;
  return httpd_cgi_ret(a1, v10, v6 + v12, 4);
}
// 642164: using guessed type __int16 word_642164;
// 6445A0: using guessed type char byte_6445A0;
// 6459A8: using guessed type int dword_6459A8;
// 64BD3C: using guessed type int dword_64BD3C;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83DC: using guessed type int __fastcall eval(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A83F0: using guessed type int __fastcall wan_iface_foreach(_DWORD, _DWORD);
// 6A8414: using guessed type int mcl_bytearray_printf(_DWORD, const char *, ...);
// 6A84EC: using guessed type int __fastcall lan_iface_foreach(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C7FD0) --------------------------------------------------------
int __fastcall websocket_console_do_rcv(int a1)
{
  int v2; // $s1
  int v4; // $s1
  int v5; // $v0
  int v6; // $v0
  int v7; // $v0
  int v8; // $a1
  int v9; // $v0
  int v10; // $s3
  const char *v11; // $s4
  size_t v12; // $a2
  int v13; // $a0
  ssize_t v14; // $v0
  int v15; // $a2
  int v16; // $v0
  int v17; // $v0
  const char *v18; // $s4
  char *v19; // $v0
  char *v20; // $s3
  __int16 v21; // $v0
  int v22; // $a0
  __int16 v23; // [sp+18h] [-2000h] BYREF
  __int16 v24; // [sp+1Ah] [-1FFEh]
  __int16 v25; // [sp+1Ch] [-1FFCh]
  __int16 v26; // [sp+1Eh] [-1FFAh]

  if ( *(_BYTE *)(a1 + 41) != 9 )
    return httpd_conn_close((int *)a1);
  v4 = a1 + 196608;
  v5 = *(_DWORD *)(a1 + 205412);
  if ( v5 == *(_DWORD *)(a1 + 205416) )
  {
    if ( *(_DWORD *)(a1 + 209984) )
    {
      v7 = https_ssl_read(a1);
      if ( v7 != -2 )
      {
        if ( v7 <= 0 )
          return httpd_conn_close((int *)a1);
        goto LABEL_10;
      }
    }
    else
    {
      v7 = recv(
             *(_DWORD *)(a1 + 205412),
             (void *)(*(_DWORD *)(a1 + 210016) + *(_DWORD *)(a1 + 210024)),
             102400 - *(_DWORD *)(a1 + 210024),
             0);
      if ( v7 > 0 )
      {
LABEL_10:
        v8 = v7 + *(_DWORD *)(v4 + 13416);
        *(_DWORD *)(v4 + 13416) = v8;
        goto LABEL_11;
      }
      if ( !v7 || *_errno_location() != 11 )
        return httpd_conn_close((int *)a1);
    }
    v8 = *(_DWORD *)(v4 + 13416);
LABEL_11:
    websocket_recv_data(
      *(_BYTE **)(a1 + 210016),
      v8,
      (_BYTE *)(*(_DWORD *)(a1 + 210020) + *(_DWORD *)(a1 + 210028)),
      102400 - *(_DWORD *)(a1 + 210028));
    v10 = v9;
    if ( v9 < 0 )
      goto LABEL_6;
    *(_DWORD *)(a1 + 210024) = 0;
    if ( v9 >= 10 )
    {
      v11 = *(const char **)(a1 + 210020);
      v2 = strncmp(v11, "resize:", 7u);
      if ( !v2 )
      {
        v18 = v11 + 7;
        v23 = 0;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v19 = strchr(v18, 44);
        v20 = v19;
        if ( v19 )
        {
          *v19 = 0;
          v24 = J_atoi(v18);
          v21 = J_atoi(v20 + 1);
          v22 = *(_DWORD *)(a1 + 205420);
          v23 = v21;
          ioctl(v22, 0x80087467, &v23);
        }
        *(_DWORD *)(a1 + 210028) = 0;
        return v2;
      }
    }
    else
    {
      if ( !v9 )
        goto LABEL_6;
      v11 = *(const char **)(a1 + 210020);
    }
    v12 = v10 + *(_DWORD *)(a1 + 210028);
    v13 = *(_DWORD *)(a1 + 205420);
    *(_DWORD *)(a1 + 210028) = v12;
    v14 = write(v13, v11, v12);
    if ( v14 < 0 )
    {
      if ( *_errno_location() != 11 )
        return httpd_conn_close((int *)a1);
      v16 = a1 + 196608;
    }
    else
    {
      if ( v14 )
      {
        v15 = *(_DWORD *)(a1 + 210028) - v14;
        *(_DWORD *)(a1 + 210028) = v15;
        if ( v15 <= 0 )
          goto LABEL_6;
        memmove(*(void **)(a1 + 210020), (void *)(*(_DWORD *)(a1 + 210020) + v14), v15);
      }
      v16 = a1 + 196608;
    }
    if ( *(int *)(v16 + 13420) > 0 )
      httpd_conn_epoll_write_pty(a1);
    goto LABEL_6;
  }
  if ( v5 == *(_DWORD *)(a1 + 205420) )
  {
    v17 = read(*(_DWORD *)(a1 + 205412), &v23, 0x2000u);
    if ( v17 > 0 )
    {
      websocket_send_data(a1, (int)&v23, v17);
      goto LABEL_6;
    }
    if ( v17 && *_errno_location() == 11 )
      goto LABEL_6;
    return httpd_conn_close((int *)a1);
  }
LABEL_6:
  v6 = jiffies_get();
  mod_timer(a1 + 205540, v6 + 900000);
  return 0;
}
// 4C814C: variable 'v9' is possibly undefined
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004C83A8) --------------------------------------------------------
int __fastcall sub_4C83A8(int a1)
{
  char *v1; // $v0
  const char *v3; // $s0
  int result; // $v0
  void *v5; // $a0
  int v6; // $v0
  void *v7; // $a0
  int v8; // $v0
  int v9; // $a3
  int *v10; // $v0
  int v11; // $a2
  int v12; // $a1
  int v13; // $v1
  char v14; // $v0
  int v15[4]; // [sp+18h] [-218h] BYREF
  char v16; // [sp+28h] [-208h]
  int v17[6]; // [sp+218h] [-18h] BYREF

  v17[0] = (int)"echo";
  v17[1] = 0;
  v17[2] = 0;
  v17[3] = 0;
  v17[4] = 0;
  v17[5] = 0;
  v1 = httpd_get_parm(a1, "id");
  v3 = v1;
  if ( v1 && *v1 && !strchr(v1, 38) && !strchr(v3, 124) && !websocket_respond_head(a1) )
  {
    v5 = *(void **)(a1 + 210016);
    if ( v5 )
    {
      _mem_free(v5);
      *(_DWORD *)(a1 + 210016) = 0;
    }
    *(_DWORD *)(a1 + 210024) = 0;
    _mem_malloc(102400, "websocket_console_cgi", 2494);
    *(_DWORD *)(a1 + 210016) = v6;
    if ( !v6 )
      goto LABEL_20;
    v7 = *(void **)(a1 + 210020);
    if ( v7 )
    {
      _mem_free(v7);
      *(_DWORD *)(a1 + 210020) = 0;
    }
    *(_DWORD *)(a1 + 210028) = 0;
    _mem_malloc(102400, "websocket_console_cgi", 2509);
    *(_DWORD *)(a1 + 210020) = v8;
    if ( v8 )
    {
      if ( !eval_nowait_tty(v3, v17, a1 + 205420, a1 + 205456) && *(int *)(a1 + 205420) >= 0 )
      {
        result = httpd_conn_epoll_add_pty((_DWORD *)a1);
        if ( !result )
        {
          *(_DWORD *)(a1 + 205560) = websocket_console_do_rcv;
          *(_BYTE *)(a1 + 41) = 9;
          return result;
        }
      }
      v9 = 1919250543;
      v10 = &dword_650CA4;
    }
    else
    {
LABEL_20:
      v9 = 1819042157;
      v10 = &dword_650C90;
    }
    v11 = v10[1];
    v12 = v10[2];
    v13 = v10[3];
    v14 = *((_BYTE *)v10 + 16);
    v15[1] = v11;
    v15[2] = v12;
    v15[0] = v9;
    v15[3] = v13;
    v16 = v14;
    websocket_send_data(a1, (int)v15, 16);
  }
  return httpd_conn_close((int *)a1);
}
// 4C8500: variable 'v6' is possibly undefined
// 4C8558: variable 'v8' is possibly undefined
// 650C90: using guessed type int dword_650C90;
// 650CA4: using guessed type int dword_650CA4;
// 6A81E0: using guessed type int __fastcall eval_nowait_tty(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C8630) --------------------------------------------------------
int __fastcall sub_4C8630(int a1)
{
  char *v2; // $s1
  char *v3; // $s2
  char *v4; // $v0
  char *v5; // $s4
  char *v6; // $s3
  int v7; // $a2
  const char *v9; // $a1
  const char *v10; // $v0
  _DWORD *v11; // $v1
  int v12; // $t0
  int v13; // $a3
  int v14; // $a2
  int v15; // $a1
  const char *v16; // $v0
  _DWORD *v17; // $v1
  int v18; // $t0
  int v19; // $a3
  int v20; // $a2
  int v21; // $a1
  int v22; // $a0
  __int16 v23; // $v0
  const char *v24; // $v0
  _DWORD *v25; // $v1
  int v26; // $t0
  int v27; // $a3
  int v28; // $a2
  int v29; // $a1
  int v30; // $a0
  char v31; // $v0
  _DWORD v32[7]; // [sp+18h] [-400h] BYREF
  const char *v33; // [sp+34h] [-3E4h]
  char *v34; // [sp+38h] [-3E0h]
  int v35; // [sp+3Ch] [-3DCh]

  v2 = httpd_get_parm(a1, "mode");
  v3 = httpd_get_parm(a1, "action");
  v5 = httpd_get_parm(a1, "ip");
  v4 = httpd_get_parm(a1, "port");
  if ( v2 && v3 )
  {
    v6 = v4;
    if ( !strcmp(v2, "server") )
    {
      if ( !strcmp(v3, "start") )
      {
        if ( v6 && J_atoi(v6) )
        {
          v32[0] = "iperf";
          v32[1] = "-s";
          v32[2] = "-p";
          v32[3] = v6;
          v32[4] = "-D";
          v32[5] = 0;
          eval_nowait(v32, 0, 0, 0);
        }
        else
        {
          v32[0] = "iperf";
          v32[1] = "-s";
          v32[2] = "-D";
          v32[3] = 0;
          eval_nowait(v32, 0, 0, 0);
        }
        goto LABEL_8;
      }
      if ( !strcmp(v3, "stop") )
      {
        v9 = "-s";
LABEL_20:
        killall_arg("iperf", v9, 9);
LABEL_8:
        v7 = 16;
        strcpy((char *)v32, "{ret:0,msg:'ok'}");
        return httpd_cgi_ret(a1, (char *)v32, v7, 4);
      }
LABEL_21:
      v10 = "{ret:-1,msg:'aciton is start/stop'}";
      v11 = v32;
      do
      {
        v12 = *(_DWORD *)v10;
        v13 = *((_DWORD *)v10 + 1);
        v14 = *((_DWORD *)v10 + 2);
        v15 = *((_DWORD *)v10 + 3);
        v10 += 16;
        *v11 = v12;
        v11[1] = v13;
        v11[2] = v14;
        v11[3] = v15;
        v11 += 4;
      }
      while ( v10 != "p'}" );
      v7 = 35;
      *v11 = *(_DWORD *)v10;
      return httpd_cgi_ret(a1, (char *)v32, v7, 4);
    }
    if ( !strcmp(v2, "client") )
    {
      if ( !strcmp(v3, "start") )
      {
        v7 = 25;
        if ( !v5 )
        {
          strcpy((char *)v32, "{ret:-1,msg:'ip is null'}");
          return httpd_cgi_ret(a1, (char *)v32, v7, 4);
        }
        if ( v6 && J_atoi(v6) )
        {
          v32[0] = "iperf";
          v32[1] = "-c";
          v32[3] = "-p";
          v32[5] = "-t";
          v32[6] = "86400000";
          v33 = "-P";
          v32[2] = v5;
          v32[4] = v6;
          v34 = "10";
          v35 = 0;
          eval_nowait(v32, 0, 0, 0);
        }
        else
        {
          v32[0] = "iperf";
          v32[1] = "-c";
          v32[3] = "-t";
          v32[4] = "86400000";
          v32[5] = "-P";
          v32[2] = v5;
          v32[6] = "10";
          v33 = 0;
          eval_nowait(v32, 0, 0, 0);
        }
        goto LABEL_8;
      }
      if ( !strcmp(v3, "stop") )
      {
        v9 = "-c";
        goto LABEL_20;
      }
      goto LABEL_21;
    }
    v24 = "{ret:-1,msg:'mode is server/client'}";
    v25 = v32;
    do
    {
      v26 = *(_DWORD *)v24;
      v27 = *((_DWORD *)v24 + 1);
      v28 = *((_DWORD *)v24 + 2);
      v29 = *((_DWORD *)v24 + 3);
      v24 += 16;
      *v25 = v26;
      v25[1] = v27;
      v25[2] = v28;
      v25[3] = v29;
      v25 += 4;
    }
    while ( v24 != "nt'}" );
    v30 = *(_DWORD *)v24;
    v31 = v24[4];
    *v25 = v30;
    *((_BYTE *)v25 + 4) = v31;
    v7 = 36;
  }
  else
  {
    v16 = "{ret:-1,msg:'mode or action is null'}";
    v17 = v32;
    do
    {
      v18 = *(_DWORD *)v16;
      v19 = *((_DWORD *)v16 + 1);
      v20 = *((_DWORD *)v16 + 2);
      v21 = *((_DWORD *)v16 + 3);
      v16 += 16;
      *v17 = v18;
      v17[1] = v19;
      v17[2] = v20;
      v17[3] = v21;
      v17 += 4;
    }
    while ( v16 != "ull'}" );
    v22 = *(_DWORD *)v16;
    v23 = *((_WORD *)v16 + 2);
    *v17 = v22;
    *((_WORD *)v17 + 2) = v23;
    v7 = 37;
  }
  return httpd_cgi_ret(a1, (char *)v32, v7, 4);
}
// 6A852C: using guessed type int __fastcall eval_nowait(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A866C: using guessed type int __fastcall killall_arg(_DWORD, _DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004C8B80) --------------------------------------------------------
int switch_reboot_auto_get()
{
  int v0; // $v0
  int v1; // $v0
  int v2; // $s0
  bool v3; // dc
  int result; // $v0

  v0 = jhl_nv_get_def("mqtt_ai_switch_auto_reboot");
  v1 = cJSON_Parse(v0);
  v2 = v1;
  if ( !v1 || (v3 = cJSON_IsObject(v1) != 0, result = v2, !v3) )
  {
    cJSON_Delete(v2);
    result = cJSON_CreateObject();
  }
  return result;
}
// 6A822C: using guessed type int __fastcall cJSON_IsObject(_DWORD);
// 6A8258: using guessed type int cJSON_CreateObject(void);
// 6A84C8: using guessed type int __fastcall jhl_nv_get_def(_DWORD);
// 6A8780: using guessed type int __fastcall cJSON_Parse(_DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);

//----- (004C8C28) --------------------------------------------------------
int __fastcall switch_reboot_auto_set(int a1)
{
  int v1; // $v0
  const char *v2; // $v0
  const char *v3; // $s0
  int v4; // $s1

  v1 = cJSON_PrintUnformatted(a1);
  if ( !v1 )
    return 0;
  v3 = (const char *)v1;
  v2 = (const char *)nvram_get("mqtt_ai_switch_auto_reboot");
  if ( v2 && !strcmp(v2, v3) )
  {
    v4 = 0;
  }
  else
  {
    nvram_set("mqtt_ai_switch_auto_reboot", v3);
    v4 = 1;
  }
  cJSON_free(v3);
  return v4;
}
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8324: using guessed type int __fastcall cJSON_free(_DWORD);
// 6A85D0: using guessed type int __fastcall cJSON_PrintUnformatted(_DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);

//----- (004C8CFC) --------------------------------------------------------
void __fastcall is_in_wday(_BYTE *a1, int a2)
{
  int v2; // $v1
  int v3; // $v0
  const char *v5; // $s0
  int v6; // $s1

  v2 = (char)*a1;
  if ( *a1 )
  {
    v3 = -1;
    v5 = a1 + 1;
    v6 = -1;
    do
    {
      if ( v6 >= 0 || v2 < 48 )
      {
        if ( v2 == 45 )
        {
          v3 = atoi(v5);
        }
        else if ( v2 == 44 )
        {
          if ( a2 >= v6 && v3 >= a2 )
            return;
          v3 = -1;
          v6 = -1;
        }
      }
      else if ( v2 < 58 )
      {
        v3 = atoi(v5 - 1);
        v6 = v3;
      }
      v2 = *v5++;
    }
    while ( v2 );
  }
}

//----- (004C8E54) --------------------------------------------------------
int __fastcall is_in_time(int a1, int a2, int a3)
{
  const char **v5; // $s0
  int v6; // $s3
  int v7; // $s1
  char *v8; // $v0
  char *v9; // $s2
  bool v10; // dc
  int result; // $v0
  char v12[1024]; // [sp+18h] [-604h] BYREF
  char v13[516]; // [sp+418h] [-204h] BYREF

  strlcpy(v12, a1, 1024);
  v5 = (const char **)v13;
  v6 = split_string(v12, 44, v13, 120);
  if ( v6 <= 0 )
    return 0;
  v7 = 0;
  while ( 1 )
  {
    v8 = strchr(*v5, 58);
    v9 = v8;
    ++v7;
    if ( v8 )
    {
      *v8 = 0;
      if ( atoi(*v5) == a2 )
      {
        v10 = atoi(v9 + 1) != a3;
        result = 1;
        if ( !v10 )
          break;
      }
    }
    ++v5;
    if ( v6 == v7 )
      return 0;
  }
  return result;
}
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8778: using guessed type int __fastcall split_string(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C8F6C) --------------------------------------------------------
int __fastcall switch_reboot_auto_runing(_DWORD *a1)
{
  int v2; // $s6
  _DWORD *v3; // $s0
  int v4; // $s3
  char *v5; // $v0
  char *v6; // $fp
  int v7; // $a1
  int v8; // $v0
  const char *v9; // $a3
  unsigned int v10; // $v0
  int v11; // $s3
  unsigned int v13; // $v0
  char v14[4096]; // [sp+18h] [-1108h] BYREF
  char v15[256]; // [sp+1018h] [-108h] BYREF
  unsigned int v16; // [sp+1118h] [-8h]

  memset(v14, 0, sizeof(v14));
  memset(v15, 0, sizeof(v15));
  v2 = switch_reboot_auto_get();
  v3 = *(_DWORD **)(v2 + 8);
  strcpy(v14, "{\"sn\":[");
  if ( v3 )
  {
    v4 = 7;
    do
    {
      while ( 1 )
      {
        strlcpy(v15, v3[4], 256);
        v5 = strchr(v15, 59);
        v6 = v5;
        if ( v5 )
        {
          v7 = a1[6];
          *v5 = 0;
          is_in_wday(v15, v7);
          if ( v8 )
          {
            if ( is_in_time((int)(v6 + 1), a1[2], a1[1]) )
              break;
          }
        }
        v3 = (_DWORD *)*v3;
        if ( !v3 )
          goto LABEL_10;
      }
      v9 = (const char *)v3[8];
      v16 = 4096 - v4;
      v10 = snprintf(&v14[v4], 4096 - v4, "\"%s\",", v9);
      if ( v10 >= v16 )
        v10 = 4095 - v4;
      v3 = (_DWORD *)*v3;
      v4 += v10;
    }
    while ( v3 );
LABEL_10:
    v11 = v4 - 1;
  }
  else
  {
    v11 = 6;
  }
  if ( v14[v11] == 44 )
  {
    v13 = snprintf(&v14[v11], 4096 - v11, "]}");
    if ( v13 >= 4096 - v11 )
      v13 = 4095 - v11;
    ai_unix_cgi_send(0x272Cu, 0xFFFFFFFF, v14, v13 + v11);
  }
  return cJSON_Delete(v2);
}
// 4C909C: variable 'v8' is possibly undefined
// 6A8480: using guessed type int __fastcall strlcpy(_DWORD, _DWORD, _DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);

//----- (004C91C0) --------------------------------------------------------
int switch_reboot_auto_timeout()
{
  struct tm *v0; // $v0
  int *v1; // $v1
  struct tm *v2; // $t1
  int v3; // $t0
  int v4; // $a3
  int v5; // $a2
  int v6; // $a1
  int v7; // $a1
  int v8; // $a2
  int v9; // $v0
  int v11; // [sp+18h] [-34h] BYREF
  int v12; // [sp+1Ch] [-30h]
  time_t v13; // [sp+44h] [-8h] BYREF

  v13 = time(0);
  v0 = localtime(&v13);
  v1 = &v11;
  v2 = (struct tm *)&v0->tm_isdst;
  do
  {
    v3 = v0->tm_sec;
    v4 = v0->tm_min;
    v5 = v0->tm_hour;
    v6 = v0->tm_mday;
    v0 = (struct tm *)((char *)v0 + 16);
    *v1 = v3;
    v1[1] = v4;
    v1[2] = v5;
    v1[3] = v6;
    v1 += 4;
  }
  while ( v0 != v2 );
  v7 = v0->tm_hour;
  v8 = v0->tm_min;
  *v1 = v0->tm_sec;
  v1[1] = v8;
  v1[2] = v7;
  if ( v12 != dword_67A5D0 )
  {
    dword_67A5D0 = v12;
    switch_reboot_auto_runing(&v11);
  }
  v9 = jiffies_get();
  return mod_timer(&switch_reboot_timer, v9 + 5000);
}
// 67A5D0: using guessed type int dword_67A5D0;
// 6A81A4: using guessed type int __fastcall mod_timer(_DWORD, _DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (004C92D4) --------------------------------------------------------
int switch_reboot_auto_timer_init()
{
  dword_6A7D60 = 0;
  dword_6A7D58 = jiffies_get() + 2000;
  dword_6A7D5C = (int)switch_reboot_auto_timeout;
  init_timer(&switch_reboot_timer);
  return add_timer(&switch_reboot_timer);
}
// 6A7D58: using guessed type int dword_6A7D58;
// 6A7D5C: using guessed type int dword_6A7D5C;
// 6A7D60: using guessed type int dword_6A7D60;
// 6A8368: using guessed type int __fastcall init_timer(_DWORD);
// 6A838C: using guessed type int __fastcall add_timer(_DWORD);
// 6A8824: using guessed type int jiffies_get(void);

//----- (004C933C) --------------------------------------------------------
int __fastcall sub_4C933C(int a1)
{
  int v2; // $v0
  int v3; // $s0
  int v4; // $s5
  size_t v5; // $v0
  int v6; // $s2
  int v7; // $v0
  size_t v8; // $s1
  int v9; // $s1
  int result; // $v0
  const char *v11; // $v0
  unsigned int v12; // $v0
  char v13[260]; // [sp+20h] [-104h] BYREF

  memset(v13, 0, 0x100u);
  _mem_malloc(0x200000, "switch_reboot_data", 190);
  if ( v2 )
  {
    v3 = v2;
    v4 = switch_reboot_auto_get();
    strcpy((char *)v3, "{\"code\":0,\"error\":\"\",\"data\":");
    qmemcpy((void *)v3, "{\"code\":0,\"error\":\"\"", 20);
    *(_DWORD *)(v3 + 24) = *(_DWORD *)"ta\":";
    cJSON_PrintPreallocated(v4, v3 + 28, 2097124, 0);
    v5 = strlen((const char *)v3);
    v6 = 0x200000 - v5;
    v8 = v5;
    v7 = snprintf((char *)(v3 + v5), 0x200000 - v5, "}");
    if ( v7 >= v6 )
      v7 = 0x1FFFFF - v8;
    v9 = v7 + v8;
    cJSON_Delete(v4);
    result = httpd_cgi_ret(a1, (char *)v3, v9, 8);
  }
  else
  {
    v11 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
    v12 = snprintf(v13, 256, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v11);
    if ( v12 >= 0x100 )
      v12 = 255;
    result = httpd_cgi_ret(a1, v13, v12, 4);
  }
  return result;
}
// 4C93A8: variable 'v2' is possibly undefined
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8740: using guessed type int __fastcall cJSON_PrintPreallocated(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);

//----- (004C9560) --------------------------------------------------------
int __fastcall switch_reboot_auto_asp(int a1)
{
  int v2; // $v0
  int v3; // $s0
  _DWORD *v4; // $s0
  int i; // $s3
  int v6; // $s2
  _BYTE *v7; // $s1
  int v8; // $v0
  void (*v9)(void); // $t9
  char *v10; // $v1
  const char *v11; // $v0
  int v12; // $t1
  int v13; // $t0
  int v14; // $a3
  int v15; // $a2
  char v17[1024]; // [sp+18h] [-400h] BYREF

  v3 = httpd_get_json_parm(a1, (int)"list");
  v2 = switch_reboot_auto_get();
  v4 = *(_DWORD **)(v3 + 8);
  for ( i = v2; v4; v4 = (_DWORD *)*v4 )
  {
    v6 = GetJSONItemValueAsString(v4, "sn");
    v7 = (_BYTE *)GetJSONItemValueAsString(v4, "time");
    v8 = cJSON_GetObjectItem(i, v6);
    v9 = (void (*)(void))&cJSON_SetValuestring;
    if ( *v7 )
    {
      if ( !v8 )
      {
        cJSON_AddStringToObject(i, v6, v7);
        continue;
      }
    }
    else
    {
      v9 = (void (*)(void))&cJSON_DetachItemFromObject;
      if ( !v8 )
        continue;
    }
    v9();
  }
  if ( switch_reboot_auto_set(i) )
    nvram_commit();
  cJSON_Delete(i);
  v10 = v17;
  v11 = "{\"code\":0,\"error\":\"\",\"data\":null}";
  do
  {
    v12 = *(_DWORD *)v11;
    v13 = *((_DWORD *)v11 + 1);
    v14 = *((_DWORD *)v11 + 2);
    v15 = *((_DWORD *)v11 + 3);
    v11 += 16;
    *(_DWORD *)v10 = v12;
    *((_DWORD *)v10 + 1) = v13;
    *((_DWORD *)v10 + 2) = v14;
    *((_DWORD *)v10 + 3) = v15;
    v10 += 16;
  }
  while ( v11 != "}" );
  *(_WORD *)v10 = *(_WORD *)v11;
  return httpd_cgi_ret(a1, v17, 33, 4);
}
// 6A83A8: using guessed type int __fastcall cJSON_AddStringToObject(_DWORD, _DWORD, _DWORD);
// 6A87C4: using guessed type int nvram_commit(void);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A887C: using guessed type int __fastcall GetJSONItemValueAsString(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);

//----- (004C975C) --------------------------------------------------------
int __fastcall sub_4C975C(int a1)
{
  int v2; // $v0
  char *v3; // $s2
  int v4; // $s1
  size_t v5; // $v0
  unsigned int v6; // $s2
  unsigned int v7; // $v0
  size_t v8; // $s3
  const char *v10; // $v0
  unsigned int v11; // $a2
  const char *v12; // $v0
  char *v13; // $v1
  int v14; // $t0
  int v15; // $a3
  int v16; // $a2
  int v17; // $a1
  char v18[4100]; // [sp+20h] [-1004h] BYREF

  v3 = httpd_get_parm(a1, "opt");
  v2 = httpd_get_json_parm(a1, (int)"list");
  if ( !v2 || (v4 = v2, !cJSON_IsArray(v2)) )
  {
    v10 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "error list");
    v11 = snprintf(v18, 4096, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v10);
    if ( v11 >= 0x1000 )
      v11 = 4095;
    return httpd_cgi_ret(a1, v18, v11, 4);
  }
  if ( v3 && !strcmp(v3, "auto") )
    return switch_reboot_auto_asp(a1);
  if ( !ai_is_running(0) )
  {
    v12 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v13 = v18;
    do
    {
      v14 = *(_DWORD *)v12;
      v15 = *((_DWORD *)v12 + 1);
      v16 = *((_DWORD *)v12 + 2);
      v17 = *((_DWORD *)v12 + 3);
      v12 += 16;
      *(_DWORD *)v13 = v14;
      *((_DWORD *)v13 + 1) = v15;
      *((_DWORD *)v13 + 2) = v16;
      *((_DWORD *)v13 + 3) = v17;
      v13 += 16;
    }
    while ( v12 != "}" );
    v11 = 33;
    *(_WORD *)v13 = *(_WORD *)v12;
    return httpd_cgi_ret(a1, v18, v11, 4);
  }
  strcpy(v18, "{\"sn\":");
  cJSON_PrintPreallocated(v4, &v18[6], 4090, 0);
  v5 = strlen(v18);
  v6 = 4096 - v5;
  v8 = v5;
  v7 = snprintf(&v18[v5], 4096 - v5, "}");
  if ( v7 >= v6 )
    v7 = 4095 - v8;
  ai_unix_cgi_send(0x272Cu, *(_DWORD *)(a1 + 205416), v18, v7 + v8);
  *(_DWORD *)(a1 + 210096) = 10028;
  *(_DWORD *)(a1 + 205572) = 0;
  ai_cgi_common_timeout((_DWORD *)a1);
  return 0;
}
// 6A82B4: using guessed type int __fastcall cJSON_IsArray(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A8740: using guessed type int __fastcall cJSON_PrintPreallocated(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (004C99F8) --------------------------------------------------------
int __fastcall sub_4C99F8(_DWORD *a1)
{
  const char *v2; // $v0
  char *v3; // $v1
  int v4; // $t1
  int v5; // $t0
  int v6; // $a3
  int v7; // $a2
  int result; // $v0
  char v9[1028]; // [sp+18h] [-404h] BYREF

  if ( ai_is_running(0) )
  {
    ai_unix_cgi_send(0x2728u, a1[51354], 0, 0);
    a1[52524] = 10024;
    a1[51393] = 0;
    ai_cgi_common_timeout(a1);
    result = 0;
  }
  else
  {
    v2 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v3 = v9;
    do
    {
      v4 = *(_DWORD *)v2;
      v5 = *((_DWORD *)v2 + 1);
      v6 = *((_DWORD *)v2 + 2);
      v7 = *((_DWORD *)v2 + 3);
      v2 += 16;
      *(_DWORD *)v3 = v4;
      *((_DWORD *)v3 + 1) = v5;
      *((_DWORD *)v3 + 2) = v6;
      *((_DWORD *)v3 + 3) = v7;
      v3 += 16;
    }
    while ( v2 != "}" );
    *(_WORD *)v3 = *(_WORD *)v2;
    result = httpd_cgi_ret((int)a1, v9, 33, 4);
  }
  return result;
}

//----- (004C9AF8) --------------------------------------------------------
int __fastcall sub_4C9AF8(int a1)
{
  char *v1; // $v0
  const char *v3; // $s2
  const char *v4; // $v0
  char *v5; // $v1
  int v6; // $t0
  int v7; // $a3
  int v8; // $a2
  int v9; // $a1
  unsigned int v10; // $a2
  unsigned int v12; // $v0
  const char *v13; // $v0
  char v14[1024]; // [sp+20h] [-400h] BYREF

  v1 = httpd_get_parm(a1, "sn");
  if ( !v1 )
  {
    v13 = (const char *)_GET_LANG_TEXT(12, *(unsigned __int8 *)(a1 + 210102), "not sn");
    v10 = snprintf(v14, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v13);
    if ( v10 >= 0x400 )
      v10 = 1023;
    return httpd_cgi_ret(a1, v14, v10, 4);
  }
  v3 = v1;
  if ( !ai_is_running(0) )
  {
    v4 = "{\"code\":0,\"error\":\"\",\"data\":null}";
    v5 = v14;
    do
    {
      v6 = *(_DWORD *)v4;
      v7 = *((_DWORD *)v4 + 1);
      v8 = *((_DWORD *)v4 + 2);
      v9 = *((_DWORD *)v4 + 3);
      v4 += 16;
      *(_DWORD *)v5 = v6;
      *((_DWORD *)v5 + 1) = v7;
      *((_DWORD *)v5 + 2) = v8;
      *((_DWORD *)v5 + 3) = v9;
      v5 += 16;
    }
    while ( v4 != "}" );
    v10 = 33;
    *(_WORD *)v5 = *(_WORD *)v4;
    return httpd_cgi_ret(a1, v14, v10, 4);
  }
  v12 = snprintf(v14, 1024, "{\"sn\":\"%s\"}", v3);
  if ( v12 >= 0x400 )
    v12 = 1023;
  ai_unix_cgi_send(0x2729u, *(_DWORD *)(a1 + 205416), v14, v12);
  *(_DWORD *)(a1 + 210096) = 10025;
  *(_DWORD *)(a1 + 205572) = 0;
  ai_cgi_common_timeout((_DWORD *)a1);
  return 0;
}
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);

//----- (004C9CC0) --------------------------------------------------------
int https_ssl_init()
{
  int v0; // $v0
  int v1; // $v0
  const char *v2; // $v0
  int v3; // $s1
  int v5; // $a3
  int v6; // $a3
  FILE *stream; // [sp+18h] [-Ch]
  FILE *streamb; // [sp+18h] [-Ch]
  FILE *streamc; // [sp+18h] [-Ch]
  FILE *streama; // [sp+18h] [-Ch]
  FILE *streamd; // [sp+18h] [-Ch]

  if ( https_init )
  {
    SSL_library_init();
    https_init = 0;
  }
  SSL_load_error_strings();
  v0 = TLSv1_2_server_method();
  v1 = SSL_CTX_new(v0);
  https_ssl_ctx = v1;
  if ( !v1 )
  {
    v3 = -1;
    streamd = stderr;
    ERR_print_errors_fp(stderr);
    fprintf(streamd, "%s[%d]: SSL_CTX_new failed!\n", "https_ssl_init", 56);
    return v3;
  }
  SSL_CTX_ctrl(v1, 77, 50331648, 0);
  if ( SSL_CTX_set_cipher_list(https_ssl_ctx, "HIGH:!aNULL:!MD5") )
  {
    SSL_CTX_set_verify(https_ssl_ctx, 0, 0);
    v2 = (const char *)nvram_get("mqtt_ai_ssl_file_sw");
    if ( v2 && !strcmp(v2, "1") && f_exists("/tmp/mqtt_ai_ssl_file/https_ca.crt") )
    {
      SSL_CTX_load_verify_locations(https_ssl_ctx, "/tmp/mqtt_ai_ssl_file/https_ca.crt", 0);
      SSL_CTX_set_default_passwd_cb_userdata(https_ssl_ctx, "123456");
      if ( SSL_CTX_use_certificate_file(https_ssl_ctx, "/tmp/mqtt_ai_ssl_file/https_server.crt", 1) )
      {
        if ( !SSL_CTX_use_PrivateKey_file(https_ssl_ctx, "/tmp/mqtt_ai_ssl_file/https_server.key", 1) )
        {
          stream = stderr;
          ERR_print_errors_fp(stderr);
          v5 = 90;
LABEL_18:
          fprintf(stream, "%s[%d]: https SSL_CTX_use_PrivateKey_file failed!\n", "https_ssl_init", v5);
          return -1;
        }
        goto LABEL_9;
      }
      streama = stderr;
      ERR_print_errors_fp(stderr);
      v6 = 83;
    }
    else
    {
      SSL_CTX_load_verify_locations(https_ssl_ctx, "/etc/https_ca.crt", 0);
      SSL_CTX_set_default_passwd_cb_userdata(https_ssl_ctx, "123456");
      if ( SSL_CTX_use_certificate_file(https_ssl_ctx, "/etc/https_server.crt", 1) )
      {
        if ( !SSL_CTX_use_PrivateKey_file(https_ssl_ctx, "/etc/https_server.key", 1) )
        {
          stream = stderr;
          ERR_print_errors_fp(stderr);
          v5 = 110;
          goto LABEL_18;
        }
LABEL_9:
        if ( SSL_CTX_check_private_key(https_ssl_ctx) )
        {
          v3 = 0;
          fprintf(stderr, "%s[%d]: ssl ctx init success !\n", "https_ssl_init", 121);
        }
        else
        {
          v3 = -1;
          streamc = stderr;
          ERR_print_errors_fp(stderr);
          fprintf(streamc, "%s[%d]: set https crt file failed!\n", "https_ssl_init", 118);
        }
        return v3;
      }
      streama = stderr;
      ERR_print_errors_fp(stderr);
      v6 = 103;
    }
    fprintf(streama, "%s[%d]: https SSL_CTX_use_certificate_file failed!\n", "https_ssl_init", v6);
    return -1;
  }
  streamb = stderr;
  ERR_print_errors_fp(stderr);
  fprintf(streamb, "%s[%d]: SSL_CTX_set_cipher_list!\n", "https_ssl_init", 67);
  return 0;
}
// 67BD40: using guessed type int https_init;
// 681504: using guessed type int https_ssl_ctx;
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8200: using guessed type int __fastcall ERR_print_errors_fp(_DWORD);
// 6A827C: using guessed type int __fastcall SSL_CTX_check_private_key(_DWORD);
// 6A831C: using guessed type int SSL_load_error_strings(void);
// 6A8408: using guessed type int __fastcall SSL_CTX_set_cipher_list(_DWORD, _DWORD);
// 6A8418: using guessed type int __fastcall SSL_CTX_use_PrivateKey_file(_DWORD, _DWORD, _DWORD);
// 6A846C: using guessed type int __fastcall f_exists(_DWORD);
// 6A849C: using guessed type int TLSv1_2_server_method(void);
// 6A84B4: using guessed type int __fastcall SSL_CTX_load_verify_locations(_DWORD, _DWORD, _DWORD);
// 6A8544: using guessed type int __fastcall SSL_CTX_new(_DWORD);
// 6A8620: using guessed type int __fastcall SSL_CTX_use_certificate_file(_DWORD, _DWORD, _DWORD);
// 6A8664: using guessed type int __fastcall SSL_CTX_ctrl(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A86C0: using guessed type int SSL_library_init(void);
// 6A87AC: using guessed type int __fastcall SSL_CTX_set_default_passwd_cb_userdata(_DWORD, _DWORD);
// 6A882C: using guessed type int __fastcall SSL_CTX_set_verify(_DWORD, _DWORD, _DWORD);

//----- (004CA138) --------------------------------------------------------
int __fastcall https_ssl_uninit(int a1)
{
  int result; // $v0

  if ( a1 )
    https_conn_clear();
  result = ERR_free_strings();
  if ( https_ssl_ctx )
  {
    result = SSL_CTX_free();
    https_ssl_ctx = 0;
  }
  return result;
}
// 681504: using guessed type int https_ssl_ctx;
// 6A833C: using guessed type int SSL_CTX_free(void);
// 6A85C0: using guessed type int ERR_free_strings(void);

//----- (004CA1BC) --------------------------------------------------------
int __fastcall https_sever_init(int a1, uint16_t a2, int a3)
{
  int v5; // $v0
  uint16_t v6; // $v0
  uint32_t v7; // $t1
  uint32_t v8; // $t0
  uint32_t v9; // $v1
  int v10; // $s0
  int result; // $v0
  struct sockaddr v12; // [sp+20h] [-28h] BYREF
  uint32_t v13; // [sp+30h] [-18h]
  uint32_t v14; // [sp+34h] [-14h]
  int v15; // [sp+38h] [-10h]
  int v16; // [sp+3Ch] [-Ch] BYREF
  int v17; // [sp+40h] [-8h]

  v16 = 1;
  v5 = socket(10, 2, 0);
  https_fd = v5;
  if ( v5 == -1 )
  {
    perror("socket");
    result = -1;
  }
  else
  {
    setnonblocking(v5);
    *(_DWORD *)&v12.sa_data[2] = 0;
    *(_DWORD *)&v12.sa_data[6] = 0;
    *(_DWORD *)&v12.sa_data[10] = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    *(_DWORD *)&v12.sa_family = 10;
    v6 = htons(a2);
    v7 = in6addr_any.in6_u.u6_addr32[1];
    v8 = in6addr_any.in6_u.u6_addr32[2];
    v9 = in6addr_any.in6_u.u6_addr32[3];
    *(_DWORD *)&v12.sa_data[6] = in6addr_any.in6_u.u6_addr32[0];
    *(_DWORD *)&v12.sa_data[10] = v7;
    v13 = v8;
    v14 = v9;
    v16 = 1;
    *(_WORD *)v12.sa_data = v6;
    setsockopt(https_fd, 0xFFFF, 4, &v16, 4u);
    v10 = 10;
    if ( bind(https_fd, &v12, 0x1Cu) == -1 )
    {
      while ( 1 )
      {
        --v10;
        if ( bind(https_fd, &v12, 0x1Cu) != -1 )
          break;
        if ( !v10 )
        {
          v17 = -1;
          perror("bind");
          return v17;
        }
      }
    }
    if ( listen(https_fd, a3) == -1 )
    {
      v17 = -1;
      perror("listen");
      result = v17;
    }
    else
    {
      fprintf(stderr, "%s[%d]:https_sever_init ipv6 ok, sock:%d\n", "https_sever_init", 183, https_fd);
      result = 0;
    }
  }
  return result;
}
// 67BD44: using guessed type int https_fd;

//----- (004CA3F0) --------------------------------------------------------
int __fastcall sub_4CA3F0(int a1)
{
  int v1; // $s0
  int v2; // $s1
  int v3; // $v0
  const char *v4; // $s2
  int v5; // $a0
  const char *v6; // $v0
  const char *v7; // $s1
  int v8; // $v0
  int v9; // $v0

  v1 = a1 + 196608;
  v2 = SSL_get_current_cipher(*(_DWORD *)(a1 + 209984));
  v4 = (const char *)SSL_get_version(*(_DWORD *)(v1 + 13376));
  v3 = SSL_CIPHER_get_version(v2);
  v5 = v2;
  v7 = (const char *)v3;
  v6 = (const char *)SSL_CIPHER_get_name(v5);
  printf("\n%s, cipher %s %s ", v4, v7, v6);
  v8 = SSL_get_ciphers(*(_DWORD *)(v1 + 13376));
  v9 = sk_num(v8);
  return printf("CIPHER_num:%d\n", v9);
}
// 6A8214: using guessed type int __fastcall SSL_CIPHER_get_name(_DWORD);
// 6A8240: using guessed type int __fastcall SSL_CIPHER_get_version(_DWORD);
// 6A8374: using guessed type int __fastcall sk_num(_DWORD);
// 6A8448: using guessed type int __fastcall SSL_get_ciphers(_DWORD);
// 6A8678: using guessed type int __fastcall SSL_get_current_cipher(_DWORD);
// 6A8734: using guessed type int __fastcall SSL_get_version(_DWORD);

//----- (004CA4F0) --------------------------------------------------------
int __fastcall https_ssl_read(int a1)
{
  int v1; // $s0
  int v3; // $s1
  int result; // $v0

  v1 = a1 + 196608;
  v3 = SSL_read(*(_DWORD *)(a1 + 209984));
  switch ( SSL_get_error(*(_DWORD *)(v1 + 13376), v3) )
  {
    case 1:
    case 5:
      result = -1;
      break;
    case 2:
      result = -2;
      break;
    case 3:
      result = -(httpd_conn_epoll_write(a1) != 0);
      break;
    case 6:
      v3 = 0;
      goto LABEL_3;
    default:
LABEL_3:
      result = v3;
      break;
  }
  return result;
}
// 6A8690: using guessed type int __fastcall SSL_read(_DWORD);
// 6A8990: using guessed type int __fastcall SSL_get_error(_DWORD, _DWORD);

//----- (004CA610) --------------------------------------------------------
int __fastcall https_ssl_write(int a1)
{
  int v2; // $s0
  int result; // $v0

  v2 = SSL_write(*(_DWORD *)(a1 + 209984));
  if ( v2 == -1 && *_errno_location() == 11 )
    return 0;
  switch ( SSL_get_error(*(_DWORD *)(a1 + 209984), v2) )
  {
    case 1:
    case 4:
    case 5:
      result = -1;
      break;
    case 2:
    case 6:
      return 0;
    case 3:
      result = -(httpd_conn_epoll_write(a1) != 0);
      break;
    default:
      result = v2;
      break;
  }
  return result;
}
// 6A8908: using guessed type int __fastcall SSL_write(_DWORD);
// 6A8990: using guessed type int __fastcall SSL_get_error(_DWORD, _DWORD);

//----- (004CA740) --------------------------------------------------------
int __fastcall https_do_accept_recv(int a1)
{
  int v1; // $s0
  int v2; // $v0
  int v3; // $v0

  v1 = a1 + 196608;
  v2 = SSL_accept(*(_DWORD *)(a1 + 209984));
  if ( v2 <= 0 )
    return -(SSL_get_error(*(_DWORD *)(v1 + 13376), v2) != 2);
  v3 = https_accept_num + 1;
  *(_DWORD *)(v1 + 13380) = 1;
  https_accept_num = v3;
  return 0;
}
// 681500: using guessed type int https_accept_num;
// 6A8570: using guessed type int __fastcall SSL_accept(_DWORD);
// 6A8990: using guessed type int __fastcall SSL_get_error(_DWORD, _DWORD);

//----- (004CA7E0) --------------------------------------------------------
int __fastcall sub_4CA7E0(int a1)
{
  const char *v1; // $v0
  char *v2; // $v1
  int v3; // $t2
  int v4; // $t1
  int v5; // $t0
  int v6; // $a3
  char v7; // $a3
  int v8; // $v0
  char v10[2052]; // [sp+18h] [-804h] BYREF

  v1 = "{\"ret\":\"0\",\"msg\":\"ok\",\"data\":{}}";
  v2 = v10;
  do
  {
    v3 = *(_DWORD *)v1;
    v4 = *((_DWORD *)v1 + 1);
    v5 = *((_DWORD *)v1 + 2);
    v6 = *((_DWORD *)v1 + 3);
    v1 += 16;
    *(_DWORD *)v2 = v3;
    *((_DWORD *)v2 + 1) = v4;
    *((_DWORD *)v2 + 2) = v5;
    *((_DWORD *)v2 + 3) = v6;
    v2 += 16;
  }
  while ( v1 != "" );
  v7 = *v1;
  v8 = *(_DWORD *)(a1 + 36) | 0x8000;
  *v2 = v7;
  *(_DWORD *)(a1 + 36) = v8;
  return httpd_cgi_ret(a1, v10, 32, 4);
}

//----- (004CA86C) --------------------------------------------------------
int __fastcall sub_4CA86C(int a1)
{
  const char *v1; // $v0
  char *v2; // $v1
  int v3; // $t2
  int v4; // $t1
  int v5; // $t0
  int v6; // $a3
  int v7; // $t2
  int v8; // $t1
  int v9; // $t0
  char v10; // $a3
  int v11; // $v0
  char v13[2052]; // [sp+18h] [-804h] BYREF

  v1 = "{\"ret\":\"1\",\"msg\":\"ok\",\"data\":{\"hotelCode\":}}";
  v2 = v13;
  do
  {
    v3 = *(_DWORD *)v1;
    v4 = *((_DWORD *)v1 + 1);
    v5 = *((_DWORD *)v1 + 2);
    v6 = *((_DWORD *)v1 + 3);
    v1 += 16;
    *(_DWORD *)v2 = v3;
    *((_DWORD *)v2 + 1) = v4;
    *((_DWORD *)v2 + 2) = v5;
    *((_DWORD *)v2 + 3) = v6;
    v2 += 16;
  }
  while ( v1 != "otelCode\":}}" );
  v7 = *(_DWORD *)v1;
  v8 = *((_DWORD *)v1 + 1);
  v9 = *((_DWORD *)v1 + 2);
  v10 = v1[12];
  v11 = *(_DWORD *)(a1 + 36) | 0x8000;
  v2[12] = v10;
  *(_DWORD *)v2 = v7;
  *((_DWORD *)v2 + 1) = v8;
  *((_DWORD *)v2 + 2) = v9;
  *(_DWORD *)(a1 + 36) = v11;
  return httpd_cgi_ret(a1, v13, 44, 4);
}

//----- (004CA910) --------------------------------------------------------
int __fastcall sub_4CA910(int a1)
{
  const char *v1; // $v0
  char *v2; // $v1
  int v3; // $t2
  int v4; // $t1
  int v5; // $t0
  int v6; // $a3
  int v7; // $t1
  __int16 v8; // $t0
  char v9; // $a3
  int v10; // $v0
  char v12[2052]; // [sp+18h] [-804h] BYREF

  v1 = "{\"ret\":\"0\",\"msg\":\"not info\",\"data\":{}}";
  v2 = v12;
  do
  {
    v3 = *(_DWORD *)v1;
    v4 = *((_DWORD *)v1 + 1);
    v5 = *((_DWORD *)v1 + 2);
    v6 = *((_DWORD *)v1 + 3);
    v1 += 16;
    *(_DWORD *)v2 = v3;
    *((_DWORD *)v2 + 1) = v4;
    *((_DWORD *)v2 + 2) = v5;
    *((_DWORD *)v2 + 3) = v6;
    v2 += 16;
  }
  while ( v1 != "a\":{}}" );
  v7 = *(_DWORD *)v1;
  v8 = *((_WORD *)v1 + 2);
  v9 = v1[6];
  v10 = *(_DWORD *)(a1 + 36) | 0x8000;
  v2[6] = v9;
  *(_DWORD *)v2 = v7;
  *((_WORD *)v2 + 2) = v8;
  *(_DWORD *)(a1 + 36) = v10;
  return httpd_cgi_ret(a1, v12, 38, 4);
}

//----- (004CA9AC) --------------------------------------------------------
int __fastcall sub_4CA9AC(int a1)
{
  const char *v1; // $v0
  char *v2; // $v1
  int v3; // $t2
  int v4; // $t1
  int v5; // $t0
  int v6; // $a3
  char v7; // $a3
  int v8; // $v0
  char v10[2052]; // [sp+18h] [-804h] BYREF

  v1 = "{\"ret\":\"1\",\"msg\":\"ok\",\"data\":[]}";
  v2 = v10;
  do
  {
    v3 = *(_DWORD *)v1;
    v4 = *((_DWORD *)v1 + 1);
    v5 = *((_DWORD *)v1 + 2);
    v6 = *((_DWORD *)v1 + 3);
    v1 += 16;
    *(_DWORD *)v2 = v3;
    *((_DWORD *)v2 + 1) = v4;
    *((_DWORD *)v2 + 2) = v5;
    *((_DWORD *)v2 + 3) = v6;
    v2 += 16;
  }
  while ( v1 != "" );
  v7 = *v1;
  v8 = *(_DWORD *)(a1 + 36) | 0x8000;
  *v2 = v7;
  *(_DWORD *)(a1 + 36) = v8;
  return httpd_cgi_ret(a1, v10, 32, 4);
}

//----- (004CAA38) --------------------------------------------------------
int __fastcall sub_4CAA38(int a1)
{
  const char *v1; // $v0
  char *v2; // $v1
  int v3; // $t2
  int v4; // $t1
  int v5; // $t0
  int v6; // $a3
  __int16 v7; // $t0
  char v8; // $a3
  int v9; // $v0
  char v11[2052]; // [sp+18h] [-804h] BYREF

  v1 = "{\"ret\":\"1\",\"msg\":\"ok\",\"data\":{\"countdownStatus\":\"off\",\"switchoverPic\":[],\"templateMark\":\"1\",\""
       "androidStartupVideo\":[],\"advertisingVideo\":[],\"countdown\":30,\"advertisingPic\":[],\"switchoverText\":\"\",\""
       "startupVideo\":[],\"welcome\":{\"Chinese\":{\"appellation\":\"\",\"position\":\"\",\"text\":\"\",\"place\":\"\",\""
       "title\":\"\",\"signPic\":\"\",\"logo\":\"\",\"signText\":\"\",\"signType\":\"text\"},\"English\":{\"appellation\""
       ":\"\",\"position\":\"\",\"text\":\"\",\"place\":\"\",\"title\":\"\",\"signPic\":\"\",\"logo\":\"\",\"signText\":\""
       "\",\"signType\":\"text\"}},\"backgroundVideo\":[],\"backgroundMusic\":[],\"backgroundPic\":[]}}";
  v2 = v11;
  do
  {
    v3 = *(_DWORD *)v1;
    v4 = *((_DWORD *)v1 + 1);
    v5 = *((_DWORD *)v1 + 2);
    v6 = *((_DWORD *)v1 + 3);
    v1 += 16;
    *(_DWORD *)v2 = v3;
    *((_DWORD *)v2 + 1) = v4;
    *((_DWORD *)v2 + 2) = v5;
    *((_DWORD *)v2 + 3) = v6;
    v2 += 16;
  }
  while ( v1 != "}}" );
  v7 = *(_WORD *)v1;
  v8 = v1[2];
  v9 = *(_DWORD *)(a1 + 36) | 0x8000;
  v2[2] = v8;
  *(_WORD *)v2 = v7;
  *(_DWORD *)(a1 + 36) = v9;
  return httpd_cgi_ret(a1, v11, 546, 4);
}

//----- (004CAACC) --------------------------------------------------------
int __fastcall sub_4CAACC(int a1)
{
  const char *v1; // $v0
  char *v2; // $v1
  int v3; // $t2
  int v4; // $t1
  int v5; // $t0
  int v6; // $a3
  int v7; // $t0
  int v8; // $a3
  int v9; // $v0
  char v11[2052]; // [sp+18h] [-804h] BYREF

  v1 = "{\"ret\":\"0\",\"msg\":\"not found\",\"data\":\"\"}";
  v2 = v11;
  do
  {
    v3 = *(_DWORD *)v1;
    v4 = *((_DWORD *)v1 + 1);
    v5 = *((_DWORD *)v1 + 2);
    v6 = *((_DWORD *)v1 + 3);
    v1 += 16;
    *(_DWORD *)v2 = v3;
    *((_DWORD *)v2 + 1) = v4;
    *((_DWORD *)v2 + 2) = v5;
    *((_DWORD *)v2 + 3) = v6;
    v2 += 16;
  }
  while ( v1 != "ta\":\"\"}" );
  v7 = *(_DWORD *)v1;
  v8 = *((_DWORD *)v1 + 1);
  v9 = *(_DWORD *)(a1 + 36) | 0x8000;
  *((_DWORD *)v2 + 1) = v8;
  *(_DWORD *)v2 = v7;
  *(_DWORD *)(a1 + 36) = v9;
  return httpd_cgi_ret(a1, v11, 39, 4);
}

//----- (004CAB60) --------------------------------------------------------
int __fastcall sub_4CAB60(int a1)
{
  char v2[2052]; // [sp+18h] [-804h] BYREF

  *(_DWORD *)(a1 + 36) |= 0x8000u;
  return httpd_cgi_ret(a1, v2, 0, 4);
}

//----- (004CABA8) --------------------------------------------------------
int __fastcall sub_4CABA8(int a1)
{
  const char *v1; // $v0
  char *v2; // $v1
  int v4; // $t1
  int v5; // $t0
  int v6; // $a3
  int v7; // $a1
  int v8; // $t0
  int v9; // $a3
  __int16 v10; // $v0
  int v11; // $v0
  char v13[2048]; // [sp+18h] [-1004h] BYREF
  char v14[2052]; // [sp+818h] [-804h] BYREF

  v1 = (const char *)&unk_65139C;
  v2 = v14;
  do
  {
    v4 = *(_DWORD *)v1;
    v5 = *((_DWORD *)v1 + 1);
    v6 = *((_DWORD *)v1 + 2);
    v7 = *((_DWORD *)v1 + 3);
    v1 += 16;
    *(_DWORD *)v2 = v4;
    *((_DWORD *)v2 + 1) = v5;
    *((_DWORD *)v2 + 2) = v6;
    *((_DWORD *)v2 + 3) = v7;
    v2 += 16;
  }
  while ( v1 != "\"CAST\"}]}" );
  v8 = *(_DWORD *)v1;
  v9 = *((_DWORD *)v1 + 1);
  v10 = *((_WORD *)v1 + 4);
  *(_DWORD *)v2 = v8;
  *((_DWORD *)v2 + 1) = v9;
  *((_WORD *)v2 + 4) = v10;
  v11 = gbk_to_utf8(v14, v13, 2047);
  *(_DWORD *)(a1 + 36) |= 0x8000u;
  return httpd_cgi_ret(a1, v13, v11, 4);
}
// 6A85C8: using guessed type int __fastcall gbk_to_utf8(_DWORD, _DWORD, _DWORD);

//----- (004CAC78) --------------------------------------------------------
int __fastcall sub_4CAC78(int a1)
{
  int result; // $v0
  time_t v3; // $v0
  unsigned int v4; // $v0
  char v5[1028]; // [sp+18h] [-404h] BYREF

  httpd_get_parm(a1, "token");
  httpd_get_parm(a1, (char *)&off_646724);
  httpd_get_parm(a1, "roomId");
  if ( !sq_file_get_device_id() || !nvram_get_int("iptv_en") )
    return httpd_cgi_ret(a1, v5, 59, 4);
  v3 = time(0);
  v4 = snprintf(v5, 1024, "{\"ret\":\"1\",\"msg\":\"ok\",\"channelGmt\":%lu,\"notice\":[]}", v3);
  *(_DWORD *)(a1 + 36) |= 0x8000u;
  if ( v4 >= 0x400 )
    result = httpd_cgi_ret(a1, v5, 1023, 4);
  else
    result = httpd_cgi_ret(a1, v5, v4, 4);
  return result;
}
// 646724: using guessed type void *off_646724;
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A83B8: using guessed type int sq_file_get_device_id(void);

//----- (004CADF0) --------------------------------------------------------
int __fastcall sub_4CADF0(int a1)
{
  char *v2; // $s4
  char *v3; // $s5
  char *v4; // $s6
  char *v5; // $s2
  char *v6; // $s3
  int v7; // $v0
  int v8; // $s1
  unsigned int v9; // $s6
  int v10; // $s5
  const char *v11; // $v0
  int v12; // $s7
  const char *v13; // $v0
  int v14; // $v0
  int v15; // $v0
  int result; // $v0
  unsigned int v17; // $v0
  unsigned int v18; // $s7
  char *v19; // $v0
  int v20; // $a2
  char *v21; // $s7
  int v22; // $v0
  int v23; // $s7
  _DWORD *v24; // $s7
  int v25; // $v0
  int v26; // $fp
  int v27; // $v0
  int v28; // $s5
  void *v29; // $s4
  int v30; // $a0
  const char *v31; // $v0
  unsigned int v32; // $a2
  char v33[1024]; // [sp+20h] [-860h] BYREF
  char v34[1024]; // [sp+420h] [-460h] BYREF
  int v35[16]; // [sp+820h] [-60h] BYREF
  char *format; // [sp+860h] [-20h]
  char *name; // [sp+864h] [-1Ch]
  int v38; // [sp+868h] [-18h]
  const char *v39; // [sp+86Ch] [-14h]
  char *v40; // [sp+870h] [-10h]
  const char *v41; // [sp+874h] [-Ch]
  char *v42; // [sp+878h] [-8h]
  int v43; // [sp+87Ch] [-4h]

  v2 = httpd_get_parm(a1, "province");
  v3 = httpd_get_parm(a1, "city");
  v4 = httpd_get_parm(a1, "operator");
  v5 = httpd_get_parm(a1, "en");
  v6 = httpd_get_parm(a1, "host");
  if ( sq_file_get_device_id() )
  {
    _mem_malloc(102400, "iptv_channel_asp", 399);
    v8 = v7;
    if ( v7 )
    {
      if ( !v5 )
      {
        v9 = 0;
        if ( !v6 )
          return httpd_cgi_ret(a1, v33, v9, 4);
        v12 = 0;
        v10 = 0;
        goto LABEL_10;
      }
      if ( *v5 != 49 )
      {
        v9 = 0;
        v10 = 0;
        goto LABEL_6;
      }
      if ( !v2 || !v3 || !v4 )
        goto LABEL_44;
      name = (char *)v35;
      memset(v35, 0, sizeof(v35));
      v18 = snprintf(v34, 1024, "opt=sync&province=%s&city=%s&operator=%s", v2, v3, v4);
      v19 = name;
      v35[0] = *(_DWORD *)"/tmp/iptv_cgiXXXXXX";
      *((_DWORD *)name + 1) = *(_DWORD *)"/iptv_cgiXXXXXX";
      strcpy(v19 + 8, "v_cgiXXXXXX");
      wys_mkstemp(v19);
      v20 = v18;
      if ( v18 >= 0x400 )
        v20 = 1023;
      v21 = name;
      if ( https_post("https://itv.wayos.com/channel/getChannelList.cgi", v34, v20, name, 0, 0) > 0 )
      {
        do_file(v21, v8, 102400);
        v22 = cJSON_Parse(v8);
        v43 = v22;
        if ( v22 )
        {
          v23 = cJSON_GetObjectItem(v22, "data");
          if ( v23 )
          {
            v38 = cJSON_CreateArray();
            memset(v33, 0, sizeof(v33));
            v24 = *(_DWORD **)(v23 + 8);
            if ( v24 )
            {
              v39 = "name";
              format = "%s";
              v40 = "n";
              v41 = "sourceLink";
              v42 = "u";
              do
              {
                v26 = cJSON_CreateObject();
                v25 = GetJSONItemValueAsString(v24, v39);
                snprintf(v33, 1024, format, v25);
                cJSON_AddStringToObject(v26, v40, v33);
                v27 = GetJSONItemValueAsString(v24, v41);
                snprintf(v33, 1024, format, v27);
                cJSON_AddStringToObject(v26, v42, v33);
                cJSON_AddItemToArray(v38, v26);
                v24 = (_DWORD *)*v24;
              }
              while ( v24 );
            }
            nvram_set("iptv_province", v2);
            nvram_set("iptv_city", v3);
            nvram_set("iptv_operator", v4);
            cJSON_Delete(v43);
            unlink(name);
            if ( v38 )
            {
              v9 = snprintf(v33, 1024, "{\"code\":0,\"error\":\"\",\"message\":\"%s\",\"data\":null}", "ok");
              if ( v9 >= 0x400 )
                v9 = 1023;
              v28 = v38;
              v29 = (void *)cJSON_PrintUnformatted(v38);
              nvram_set("iptv_channel_list", v29);
              free(v29);
              v30 = v28;
              v10 = 1;
              cJSON_Delete(v30);
              start_igmp_snooping();
              goto LABEL_6;
            }
            goto LABEL_42;
          }
          cJSON_Delete(v43);
        }
      }
      unlink(name);
LABEL_42:
      v9 = 0;
      if ( *v5 != 49 )
      {
        v10 = 0;
        goto LABEL_6;
      }
LABEL_44:
      v9 = snprintf(v33, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, "failed");
      v10 = 0;
      if ( v9 >= 0x400 )
        v9 = 1023;
LABEL_6:
      v11 = (const char *)nvram_get("iptv_en");
      if ( v11 && !strcmp(v11, v5) )
      {
        v12 = 0;
        if ( !v6 )
        {
LABEL_15:
          if ( !v10 )
            return httpd_cgi_ret(a1, v33, v9, 4);
LABEL_22:
          nvram_commit();
          return httpd_cgi_ret(a1, v33, v9, 4);
        }
      }
      else
      {
        nvram_set("iptv_en", v5);
        v12 = 1;
        if ( !v6 )
          goto LABEL_13;
        v10 = 1;
      }
LABEL_10:
      v13 = (const char *)nvram_get("iptv_host");
      if ( v13 && !strcmp(v13, v6) )
      {
        if ( !v12 )
        {
          if ( !v10 )
            return httpd_cgi_ret(a1, v33, v9, 4);
          goto LABEL_22;
        }
        goto LABEL_14;
      }
      v14 = nvram_get("iptv_host");
      iptv_channel_wan_set(v14, 0);
      nvram_set("iptv_host", v6);
LABEL_13:
      v10 = 1;
LABEL_14:
      v15 = J_atoi(v5);
      iptv_channel_wan_set(v6, v15);
      goto LABEL_15;
    }
    v31 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 102400);
    v32 = snprintf(v33, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v31);
    if ( v32 >= 0x400 )
      v32 = 1023;
    result = httpd_cgi_ret(a1, v33, v32, 4);
  }
  else
  {
    v17 = snprintf(v33, 1024, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, "no sq");
    if ( v17 >= 0x400 )
      v17 = 1023;
    result = httpd_cgi_ret(a1, v33, v17, 4);
  }
  return result;
}
// 4CAEF4: variable 'v7' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8258: using guessed type int cJSON_CreateObject(void);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83A8: using guessed type int __fastcall cJSON_AddStringToObject(_DWORD, _DWORD, _DWORD);
// 6A83B8: using guessed type int sq_file_get_device_id(void);
// 6A8490: using guessed type int cJSON_CreateArray(void);
// 6A84D8: using guessed type int __fastcall iptv_channel_wan_set(_DWORD, _DWORD);
// 6A85D0: using guessed type int __fastcall cJSON_PrintUnformatted(_DWORD);
// 6A863C: using guessed type int __fastcall wys_mkstemp(_DWORD);
// 6A867C: using guessed type int __fastcall https_post(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6A8760: using guessed type int start_igmp_snooping(void);
// 6A8780: using guessed type int __fastcall cJSON_Parse(_DWORD);
// 6A87C4: using guessed type int nvram_commit(void);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);
// 6A887C: using guessed type int __fastcall GetJSONItemValueAsString(_DWORD, _DWORD);
// 6A8910: using guessed type int __fastcall cJSON_GetObjectItem(_DWORD, _DWORD);
// 6A8918: using guessed type int __fastcall nvram_set(_DWORD, _DWORD);
// 6A89B4: using guessed type int __fastcall J_atoi(_DWORD);

//----- (004CB624) --------------------------------------------------------
_DWORD *__fastcall iptv_token_create(const char *a1)
{
  int v2; // $v0
  _DWORD *v3; // $s1
  void **v4; // $s2
  _DWORD *v5; // $a2
  void **v6; // $v1
  int v7; // $a0
  int v8; // $v1
  int v9; // $v0
  int v10; // $v1
  int v11; // $a0
  _DWORD *v12; // $v1

  _mem_malloc(60, "iptv_token_create", 26);
  v3 = (_DWORD *)v2;
  if ( v2 )
  {
    v4 = (void **)(v2 + 44);
    *(_DWORD *)(v2 + 44) = v2 + 44;
    *(_DWORD *)(v2 + 48) = v2 + 44;
    *(_DWORD *)(v2 + 52) = 0;
    *(_DWORD *)(v2 + 56) = 0;
    snprintf((char *)(v2 + 4), 40, "%s", a1);
    get_uptime2(v3);
    v5 = v3 + 13;
    v6 = off_67BEC0;
    v3[11] = &iptv_token_list_head;
    v3[12] = v6;
    off_67BEC0 = v4;
    *v6 = v4;
    v7 = *a1;
    v8 = 0;
    if ( *a1 )
    {
      do
      {
        ++a1;
        v9 = 65600 * v8 + v7;
        v7 = *a1;
        v8 = v9 - v8;
      }
      while ( *a1 );
      v8 = (unsigned __int8)v8;
    }
    v10 = 4 * v8;
    v11 = *(_DWORD *)((char *)&iptv_token_hlist_head + v10);
    v3[13] = v11;
    if ( v11 )
      *(_DWORD *)(v11 + 4) = v5;
    v12 = (_DWORD *)((char *)&iptv_token_hlist_head + v10);
    *v12 = v5;
    v3[14] = v12;
  }
  return v3;
}
// 4CB66C: variable 'v2' is possibly undefined
// 67BEBC: using guessed type void *iptv_token_list_head;
// 67BEC0: using guessed type void **off_67BEC0;
// 6A8804: using guessed type int __fastcall get_uptime2(_DWORD);

//----- (004CB75C) --------------------------------------------------------
void __fastcall iptv_token_del(void *a1)
{
  char *v1; // $v0
  _DWORD *v2; // $a1
  int v3; // $a2
  _DWORD *v4; // $v1
  int v5; // $v0

  v1 = (char *)a1 + 44;
  if ( a1 )
  {
    v2 = (_DWORD *)*((_DWORD *)a1 + 12);
    v3 = *((_DWORD *)a1 + 11);
    v4 = (_DWORD *)*((_DWORD *)a1 + 14);
    *(_DWORD *)(v3 + 4) = v2;
    *v2 = v3;
    *((_DWORD *)a1 + 11) = v1;
    *((_DWORD *)a1 + 12) = v1;
    if ( v4 )
    {
      v5 = *((_DWORD *)a1 + 13);
      *v4 = v5;
      if ( v5 )
        *(_DWORD *)(v5 + 4) = v4;
      *((_DWORD *)a1 + 13) = 0;
      *((_DWORD *)a1 + 14) = 0;
    }
    _mem_free(a1);
  }
}

//----- (004CB7C8) --------------------------------------------------------
void **iptv_token_init_and_check_timeout()
{
  _DWORD *v0; // $v0
  void **result; // $v0
  void **v2; // $a0
  void **v3; // $s0
  int v4[3]; // [sp+18h] [-Ch] BYREF

  if ( !dword_681510 )
  {
    v0 = &iptv_token_hlist_head;
    do
      *v0++ = 0;
    while ( v0 != (_DWORD *)&end );
    dword_681510 = 1;
  }
  result = (void **)get_uptime2(v4);
  v2 = (void **)iptv_token_list_head;
  v3 = *(void ***)iptv_token_list_head;
  if ( iptv_token_list_head != &iptv_token_list_head )
  {
    while ( 1 )
    {
      if ( (unsigned int)(v4[0] - (_DWORD)*(v2 - 11)) < 0x3D )
      {
        result = (void **)*v3;
        v2 = v3;
        if ( v3 == &iptv_token_list_head )
          return result;
      }
      else
      {
        iptv_token_del(v2 - 11);
        result = (void **)*v3;
        v2 = v3;
        if ( v3 == &iptv_token_list_head )
          return result;
      }
      v3 = result;
    }
  }
  return result;
}
// 67BEBC: using guessed type void *iptv_token_list_head;
// 681510: using guessed type int dword_681510;
// 6A8804: using guessed type int __fastcall get_uptime2(_DWORD);

//----- (004CB8A8) --------------------------------------------------------
char *iptv_get_new_token()
{
  const char *v0; // $v0
  _DWORD *v1; // $v0
  char *result; // $v0

  iptv_token_init_and_check_timeout();
  v0 = (const char *)common_get_token();
  v1 = iptv_token_create(v0);
  if ( v1 )
    result = (char *)(v1 + 1);
  else
    result = "";
  return result;
}
// 6A8320: using guessed type int common_get_token(void);

//----- (004CB92C) --------------------------------------------------------
int __fastcall sub_4CB92C(int a1)
{
  char *v2; // $s1
  const char *v3; // $v0
  char *v4; // $v1
  int v5; // $t0
  int v6; // $a3
  int v7; // $a2
  int v8; // $a1
  int v9; // $a0
  char v10; // $v0
  unsigned int v11; // $a2
  char *v13; // $v0
  char v14[1028]; // [sp+18h] [-404h] BYREF

  v2 = httpd_get_parm(a1, "key");
  if ( !sq_file_get_device_id() || !nvram_get_int("iptv_en") )
    return httpd_cgi_ret(a1, v14, 43, 4);
  if ( v2 && !strcmp(v2, "11778438-7062-4520-b24f-14ed345421b7") )
  {
    v13 = iptv_get_new_token();
    v11 = snprintf(v14, 1024, "{\"ret\":\"1\",\"msg\":\"ok\",\"data\":{\"token\":\"%s\"}}", v13);
    if ( v11 >= 0x400 )
      v11 = 1023;
  }
  else
  {
    v3 = "{\"ret\":\"-1\",\"msg\":\"error\",\"data\":{}}";
    v4 = v14;
    do
    {
      v5 = *(_DWORD *)v3;
      v6 = *((_DWORD *)v3 + 1);
      v7 = *((_DWORD *)v3 + 2);
      v8 = *((_DWORD *)v3 + 3);
      v3 += 16;
      *(_DWORD *)v4 = v5;
      *((_DWORD *)v4 + 1) = v6;
      *((_DWORD *)v4 + 2) = v7;
      *((_DWORD *)v4 + 3) = v8;
      v4 += 16;
    }
    while ( v3 != ":{}}" );
    v9 = *(_DWORD *)v3;
    v10 = v3[4];
    *(_DWORD *)v4 = v9;
    v4[4] = v10;
    v11 = 36;
  }
  *(_DWORD *)(a1 + 36) |= 0x8000u;
  return httpd_cgi_ret(a1, v14, v11, 4);
}
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A83B8: using guessed type int sq_file_get_device_id(void);

//----- (004CBACC) --------------------------------------------------------
const char *__fastcall sub_4CBACC(const char *a1)
{
  int v2; // $a0
  const char *v3; // $a1
  int v4; // $v1
  int v5; // $v0
  const char *v6; // $s0

  iptv_token_init_and_check_timeout();
  v2 = *a1;
  if ( *a1 )
  {
    v3 = a1;
    v4 = 0;
    do
    {
      ++v3;
      v5 = 65600 * v4 + v2;
      v2 = *v3;
      v4 = v5 - v4;
    }
    while ( *v3 );
    v4 = (unsigned __int8)v4;
  }
  else
  {
    v4 = 0;
  }
  v6 = (const char *)iptv_token_hlist_head[v4];
  if ( !v6 )
    return 0;
  while ( strcmp(v6 - 48, a1) )
  {
    v6 = *(const char **)v6;
    if ( !v6 )
      return 0;
  }
  get_uptime2(v6 - 52);
  return v6 - 52;
}
// 6A8804: using guessed type int __fastcall get_uptime2(_DWORD);

//----- (004CBBDC) --------------------------------------------------------
int __fastcall iptv_get_channel_list(int a1, int a2)
{
  int v4; // $s1
  int v5; // $s0
  int v6; // $v0
  _DWORD *v7; // $s0
  int v8; // $s6
  int v9; // $s3
  int v10; // $v0
  int v11; // $v1
  const char *v12; // $v0
  int v13; // $s1
  int v14; // $v0
  char *v15; // $a2
  int v16; // $a2
  int v17; // $a3
  int v18; // $v0
  char *v19; // $a2
  int v20; // $v0
  char *v21; // $a2
  int v22; // $v0
  char *v23; // $a2
  int v24; // $v0
  char *v25; // $a2
  int v26; // $v0
  char *v27; // $a2
  char v29[1024]; // [sp+18h] [-420h] BYREF
  int v30; // [sp+418h] [-20h]
  char *format; // [sp+41Ch] [-1Ch]
  char *v32; // [sp+420h] [-18h]
  char *v33; // [sp+424h] [-14h]
  char *v34; // [sp+428h] [-10h]
  char *v35; // [sp+42Ch] [-Ch]
  int v36; // [sp+430h] [-8h]

  v4 = cJSON_CreateObject();
  v30 = v4;
  if ( v4 )
  {
    v5 = cJSON_Parse(a1);
    v36 = v5;
    if ( v5 )
    {
      memset(v29, 0, sizeof(v29));
      v6 = cJSON_AddArrayToObject(v4, "list");
      v7 = *(_DWORD **)(v5 + 8);
      v8 = v6;
      if ( v7 )
      {
        v34 = "1\"";
        format = "%d";
        v32 = "number";
        v9 = 1;
        v33 = "0";
        v35 = "%s";
        do
        {
          v13 = cJSON_CreateObject();
          v12 = (const char *)GetJSONItemValueAsString(v7, "n");
          snprintf(v29, 1024, "%s", v12);
          cJSON_AddStringToObject(v13, "name", v29);
          if ( a2 )
          {
            snprintf(v29, 1024, format, v9);
            cJSON_AddStringToObject(v13, v32, v29);
            cJSON_AddStringToObject(v13, v34 + 5772, v33);
            snprintf(v29, 1024, "%08X", v9);
            cJSON_AddStringToObject(v13, "id", v29);
            v14 = GetJSONItemValueAsString(v7, "u");
            snprintf(v29, 1024, v35, v14);
            ++v9;
            if ( !memcmp(v29, "rtp", 3u) || !memcmp(v29, "udp", 3u) )
            {
              cJSON_AddStringToObject(v13, "multicast", v29);
              v15 = "";
            }
            else
            {
              cJSON_AddStringToObject(v13, "multicast", "");
              v15 = v29;
            }
            cJSON_AddStringToObject(v13, "unicast", v15);
          }
          v10 = cJSON_AddItemToArray(v8, v13);
          v7 = (_DWORD *)*v7;
        }
        while ( v7 );
        v16 = v10;
        v17 = v11;
      }
      else
      {
        v16 = 0;
        v17 = 0;
      }
      cJSON_AddNumberToObject(v30, "count", v16, v17);
      if ( !a2 )
      {
        v18 = nvram_get("iptv_province");
        if ( v18 )
          v19 = (char *)v18;
        else
          v19 = "";
        cJSON_AddStringToObject(v30, "province", v19);
        v20 = nvram_get("iptv_city");
        if ( v20 )
          v21 = (char *)v20;
        else
          v21 = "";
        cJSON_AddStringToObject(v30, "city", v21);
        v22 = nvram_get("iptv_operator");
        if ( v22 )
          v23 = (char *)v22;
        else
          v23 = "";
        cJSON_AddStringToObject(v30, "operator", v23);
        v24 = nvram_get("iptv_en");
        if ( v24 )
          v25 = (char *)v24;
        else
          v25 = "";
        cJSON_AddStringToObject(v30, "en", v25);
        v26 = nvram_get("iptv_host");
        if ( v26 )
          v27 = (char *)v26;
        else
          v27 = "";
        cJSON_AddStringToObject(v30, "host", v27);
      }
      cJSON_Delete(v36);
    }
  }
  return v30;
}
// 4CBED4: variable 'v11' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8258: using guessed type int cJSON_CreateObject(void);
// 6A83A8: using guessed type int __fastcall cJSON_AddStringToObject(_DWORD, _DWORD, _DWORD);
// 6A86D4: using guessed type int __fastcall cJSON_AddArrayToObject(_DWORD, _DWORD);
// 6A8780: using guessed type int __fastcall cJSON_Parse(_DWORD);
// 6A87C8: using guessed type int __fastcall cJSON_AddNumberToObject(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);
// 6A8858: using guessed type int __fastcall cJSON_AddItemToArray(_DWORD, _DWORD);
// 6A887C: using guessed type int __fastcall GetJSONItemValueAsString(_DWORD, _DWORD);

//----- (004CC0F4) --------------------------------------------------------
int __fastcall sub_4CC0F4(int a1)
{
  int v2; // $v0
  int v3; // $s0
  char *v4; // $v0
  int v5; // $s5
  size_t v6; // $s2
  int v7; // $v0
  int v8; // $s2
  int v9; // $a3
  int v10; // $a2
  char *v11; // $a1

  _mem_malloc(0x200000, "channel_list_cgi", 234);
  v3 = v2;
  if ( sq_file_get_device_id() && nvram_get_int("iptv_en") )
  {
    if ( !v3 )
    {
      v9 = 4;
      v10 = 42;
      v11 = 0;
      return httpd_cgi_ret(a1, v11, v10, v9);
    }
    httpd_get_parm(a1, "token");
    strcpy((char *)v3, "{\"ret\":\"1\",\"msg\":\"ok\",\"data\":");
    qmemcpy((void *)v3, "{\"ret\":\"1\",\"msg\":\"ok", 20);
    v4 = (char *)nvram_get("iptv_channel_list");
    if ( !v4 )
      v4 = "";
    v5 = iptv_get_channel_list((int)v4, 1);
    cJSON_PrintPreallocated(v5, v3 + 29, 2097117, 0);
    v6 = strlen((const char *)(v3 + 29)) + 29;
    v7 = snprintf((char *)(v3 + v6), 0x200000 - v6, "}");
    if ( v7 >= (int)(0x200000 - v6) )
      v7 = 0x1FFFFF - v6;
    v8 = v7 + v6;
    cJSON_Delete(v5);
    *(_DWORD *)(a1 + 36) |= 0x8000u;
    v9 = 8;
    v10 = v8;
  }
  else
  {
    v9 = 4;
    v10 = 42;
  }
  v11 = (char *)v3;
  return httpd_cgi_ret(a1, v11, v10, v9);
}
// 4CC154: variable 'v2' is possibly undefined
// 6A81B4: using guessed type int __fastcall nvram_get_int(_DWORD);
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A83B8: using guessed type int sq_file_get_device_id(void);
// 6A8740: using guessed type int __fastcall cJSON_PrintPreallocated(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);

//----- (004CC344) --------------------------------------------------------
int __fastcall sub_4CC344(int a1)
{
  int v2; // $v0
  int v3; // $s0
  char *v4; // $v0
  int v5; // $v0
  int v6; // $s3
  size_t v7; // $s3
  int v8; // $s1
  int v9; // $a0
  int v10; // $a1
  int v11; // $a2
  int result; // $v0
  unsigned int v13; // $v0
  const char *v14; // $v0
  unsigned int v15; // $v0
  char v16[132]; // [sp+20h] [-84h] BYREF

  _mem_malloc(0x200000, "iptv_channel_data", 494);
  v3 = v2;
  if ( sq_file_get_device_id() )
  {
    if ( v3 )
    {
      strcpy((char *)v3, "{\"code\":0,\"error\":\"\",\"data\":");
      qmemcpy((void *)v3, "{\"code\":0,\"error", 16);
      v4 = (char *)nvram_get("iptv_channel_list");
      if ( !v4 )
        v4 = "";
      v5 = iptv_get_channel_list((int)v4, 0);
      v6 = v5;
      if ( v5 )
      {
        cJSON_PrintPreallocated(v5, v3 + 28, 2097118, 0);
        cJSON_Delete(v6);
        v7 = strlen((const char *)(v3 + 28)) + 28;
        v8 = 0x200000 - v7;
        v9 = v7;
        v10 = 0x200000 - v7;
      }
      else
      {
        v10 = 2097124;
        v8 = 2097124;
        v9 = 28;
        v7 = 28;
      }
      v11 = snprintf((char *)(v3 + v9), v10, "}");
      if ( v11 >= v8 )
        v11 = 0x1FFFFF - v7;
      *(_DWORD *)(a1 + 36) |= 0x8000u;
      result = httpd_cgi_ret(a1, (char *)v3, v7 + v11, 8);
    }
    else
    {
      v14 = (const char *)_GET_LANG_TEXT(4, *(unsigned __int8 *)(a1 + 210102), 0x200000);
      v15 = snprintf(v16, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, v14);
      if ( v15 >= 0x80 )
        v15 = 127;
      result = httpd_cgi_ret(a1, 0, v15, 4);
    }
  }
  else
  {
    v13 = snprintf(v16, 128, "{\"code\":%d,\"error\":\"%s\",\"data\":null}", 1, "no sq");
    if ( v13 >= 0x80 )
      result = httpd_cgi_ret(a1, (char *)v3, 127, 4);
    else
      result = httpd_cgi_ret(a1, (char *)v3, v13, 4);
  }
  return result;
}
// 4CC39C: variable 'v2' is possibly undefined
// 6A81BC: using guessed type int __fastcall nvram_get(_DWORD);
// 6A8318: using guessed type int __fastcall _GET_LANG_TEXT(_DWORD, _DWORD, _DWORD);
// 6A83B8: using guessed type int sq_file_get_device_id(void);
// 6A8740: using guessed type int __fastcall cJSON_PrintPreallocated(_DWORD, _DWORD, _DWORD, _DWORD);
// 6A8844: using guessed type int __fastcall cJSON_Delete(_DWORD);

//----- (004CC640) --------------------------------------------------------
int sub_4CC640()
{
  int (**v0)(void); // $s0
  int (*i)(void); // $t9
  int result; // $v0

  v0 = &off_665230;
  for ( i = off_665230; i != (int (*)(void))-1; i = *v0 )
  {
    --v0;
    result = i();
  }
  return result;
}
// 665230: using guessed type int (*off_665230)();

//----- (004CC690) --------------------------------------------------------
int printf(char *format, ...)
{
  MEMORY[0](format);
  return start_qos_iface();
}
// 4CC6A0: using guessed type int start_qos_iface(void);

//----- (004CC6A0) --------------------------------------------------------
int start_qos_iface()
{
  MEMORY[0]();
  return J_atoi();
}
// 4CC6B0: using guessed type int J_atoi(void);

//----- (004CC6B0) --------------------------------------------------------
int J_atoi()
{
  MEMORY[0]();
  return jhl_wan_route_id();
}
// 4CC6C0: using guessed type int jhl_wan_route_id(void);

//----- (004CC6C0) --------------------------------------------------------
void jhl_wan_route_id()
{
  int v0; // $a0

  MEMORY[0]();
  exit(v0);
}
// 4CC6C9: variable 'v0' is possibly undefined

//----- (004CC6D0) --------------------------------------------------------
void __noreturn exit(int status)
{
  MEMORY[0](status);
  jhl_stop_redial();
}
// 4CC6E0: using guessed type int jhl_stop_redial(void);

//----- (004CC6E0) --------------------------------------------------------
int jhl_stop_redial()
{
  MEMORY[0]();
  return ping_wan_gw_stop();
}
// 4CC6F0: using guessed type int ping_wan_gw_stop(void);

//----- (004CC6F0) --------------------------------------------------------
int ping_wan_gw_stop()
{
  MEMORY[0]();
  return kill_by_pid_name();
}
// 4CC700: using guessed type int kill_by_pid_name(void);

//----- (004CC700) --------------------------------------------------------
int kill_by_pid_name()
{
  MEMORY[0]();
  return qos_default_low_limit_check();
}
// 4CC710: using guessed type int qos_default_low_limit_check(void);

//----- (004CC710) --------------------------------------------------------
int qos_default_low_limit_check()
{
  MEMORY[0]();
  return ipv6wan_start();
}
// 4CC720: using guessed type int ipv6wan_start(void);

//----- (004CC720) --------------------------------------------------------
int ipv6wan_start()
{
  MEMORY[0]();
  return jhl_langet();
}
// 4CC730: using guessed type int jhl_langet(void);

//----- (004CC730) --------------------------------------------------------
int jhl_langet()
{
  MEMORY[0]();
  return SSL_get_error();
}
// 4CC740: using guessed type int SSL_get_error(void);

//----- (004CC740) --------------------------------------------------------
int SSL_get_error()
{
  MEMORY[0]();
  return ip_get_tbm();
}
// 4CC750: using guessed type int ip_get_tbm(void);

//----- (004CC750) --------------------------------------------------------
int ip_get_tbm()
{
  MEMORY[0]();
  return jhl_parm_get_def();
}
// 4CC760: using guessed type int jhl_parm_get_def(void);

//----- (004CC760) --------------------------------------------------------
in_addr_t jhl_parm_get_def()
{
  const char *v0; // $a0

  MEMORY[0]();
  return inet_addr(v0);
}
// 4CC769: variable 'v0' is possibly undefined

//----- (004CC770) --------------------------------------------------------
in_addr_t inet_addr(const char *cp)
{
  MEMORY[0](cp);
  return user_get_ddate();
}
// 4CC780: using guessed type int user_get_ddate(void);

//----- (004CC780) --------------------------------------------------------
int user_get_ddate()
{
  MEMORY[0]();
  return start_wan_gw_ping_check();
}
// 4CC790: using guessed type int start_wan_gw_ping_check(void);

//----- (004CC790) --------------------------------------------------------
int start_wan_gw_ping_check()
{
  MEMORY[0]();
  return start_rzgl();
}
// 4CC7A0: using guessed type int start_rzgl(void);

//----- (004CC7A0) --------------------------------------------------------
int start_rzgl()
{
  MEMORY[0]();
  return read_tg_html_from_usb();
}
// 4CC7B0: using guessed type int read_tg_html_from_usb(void);

//----- (004CC7B0) --------------------------------------------------------
void read_tg_html_from_usb()
{
  void *v0; // $a0
  void *v1; // $a1
  int v2; // $a2

  MEMORY[0]();
  memmove(v0, v1, v2);
}
// 4CC7B9: variable 'v0' is possibly undefined
// 4CC7B9: variable 'v1' is possibly undefined
// 4CC7B9: variable 'v2' is possibly undefined

//----- (004CC7C0) --------------------------------------------------------
void __fastcall memmove(void *dest, void *src, int n)
{
  MEMORY[0](dest, src, n);
  del_timer();
}
// 4CC7D0: using guessed type int del_timer(void);

//----- (004CC7D0) --------------------------------------------------------
int del_timer()
{
  MEMORY[0]();
  return get_ifname_by_id();
}
// 4CC7E0: using guessed type int get_ifname_by_id(void);

//----- (004CC7E0) --------------------------------------------------------
int get_ifname_by_id()
{
  MEMORY[0]();
  return stop_mqtt_ai();
}
// 4CC7F0: using guessed type int stop_mqtt_ai(void);

//----- (004CC7F0) --------------------------------------------------------
int stop_mqtt_ai()
{
  MEMORY[0]();
  return ct_default_low_limit_check();
}
// 4CC800: using guessed type int ct_default_low_limit_check(void);

//----- (004CC800) --------------------------------------------------------
int ct_default_low_limit_check()
{
  MEMORY[0]();
  return stop_parm_auto_send_email();
}
// 4CC810: using guessed type int stop_parm_auto_send_email(void);

//----- (004CC810) --------------------------------------------------------
int stop_parm_auto_send_email()
{
  MEMORY[0]();
  return pppoe_br_user_mod();
}
// 4CC820: using guessed type int pppoe_br_user_mod(void);

//----- (004CC820) --------------------------------------------------------
int pppoe_br_user_mod()
{
  MEMORY[0]();
  return lan_showname_guess();
}
// 4CC830: using guessed type int lan_showname_guess(void);

//----- (004CC830) --------------------------------------------------------
int lan_showname_guess()
{
  MEMORY[0]();
  return f_size();
}
// 4CC840: using guessed type int f_size(void);

//----- (004CC840) --------------------------------------------------------
int f_size()
{
  MEMORY[0]();
  return usblogd_check_restart();
}
// 4CC850: using guessed type int usblogd_check_restart(void);

//----- (004CC850) --------------------------------------------------------
int usblogd_check_restart()
{
  MEMORY[0]();
  return jhl_vpnget();
}
// 4CC860: using guessed type int jhl_vpnget(void);

//----- (004CC860) --------------------------------------------------------
char *jhl_vpnget()
{
  const char *v0; // $a0
  const char *v1; // $a1

  MEMORY[0]();
  return strstr(v0, v1);
}
// 4CC869: variable 'v0' is possibly undefined
// 4CC869: variable 'v1' is possibly undefined

//----- (004CC870) --------------------------------------------------------
char *strstr(const char *haystack, const char *needle)
{
  MEMORY[0](haystack, needle);
  return (char *)f_write_string();
}
// 4CC880: using guessed type int f_write_string(void);

//----- (004CC880) --------------------------------------------------------
int f_write_string()
{
  MEMORY[0]();
  return restart_sfe();
}
// 4CC890: using guessed type int restart_sfe(void);

//----- (004CC890) --------------------------------------------------------
int restart_sfe()
{
  MEMORY[0]();
  return ai_hi_mem_json_get();
}
// 4CC8A0: using guessed type int ai_hi_mem_json_get(void);

//----- (004CC8A0) --------------------------------------------------------
int ai_hi_mem_json_get()
{
  MEMORY[0]();
  return dns_more_dnstype_get_json();
}
// 4CC8B0: using guessed type int dns_more_dnstype_get_json(void);

//----- (004CC8B0) --------------------------------------------------------
size_t dns_more_dnstype_get_json()
{
  void *v0; // $a0
  size_t v1; // $a1
  size_t v2; // $a2
  FILE *v3; // $a3

  MEMORY[0]();
  return fread(v0, v1, v2, v3);
}
// 4CC8B9: variable 'v0' is possibly undefined
// 4CC8B9: variable 'v1' is possibly undefined
// 4CC8B9: variable 'v2' is possibly undefined
// 4CC8B9: variable 'v3' is possibly undefined

//----- (004CC8C0) --------------------------------------------------------
size_t fread(void *ptr, size_t size, size_t n, FILE *stream)
{
  return MEMORY[0](ptr, size, n, stream);
}

//----- (004CC8E0) --------------------------------------------------------
int MD5Update()
{
  MEMORY[0]();
  return get_iplist_str();
}
// 4CC8F0: using guessed type int get_iplist_str(void);

//----- (004CC8F0) --------------------------------------------------------
int get_iplist_str()
{
  MEMORY[0]();
  return jhl_get_wangw();
}
// 4CC900: using guessed type int jhl_get_wangw(void);

//----- (004CC900) --------------------------------------------------------
void jhl_get_wangw()
{
  MEMORY[0]();
  sync();
}

//----- (004CC910) --------------------------------------------------------
void sync(void)
{
  MEMORY[0]();
  nvram_set();
}
// 4CC920: using guessed type int nvram_set(void);

//----- (004CC920) --------------------------------------------------------
int nvram_set()
{
  MEMORY[0]();
  return get_all_disk_info();
}
// 4CC930: using guessed type int get_all_disk_info(void);

//----- (004CC930) --------------------------------------------------------
int get_all_disk_info()
{
  MEMORY[0]();
  return cJSON_GetObjectItem();
}
// 4CC940: using guessed type int cJSON_GetObjectItem(void);

//----- (004CC940) --------------------------------------------------------
int cJSON_GetObjectItem()
{
  MEMORY[0]();
  return jhl_nvget();
}
// 4CC950: using guessed type int jhl_nvget(void);

//----- (004CC950) --------------------------------------------------------
int jhl_nvget()
{
  MEMORY[0]();
  return SSL_write();
}
// 4CC960: using guessed type int SSL_write(void);

//----- (004CC960) --------------------------------------------------------
int SSL_write()
{
  MEMORY[0]();
  return str_to_utf8();
}
// 4CC970: using guessed type int str_to_utf8(void);

//----- (004CC970) --------------------------------------------------------
int str_to_utf8()
{
  MEMORY[0]();
  return jianhl_order_opt_fun();
}
// 4CC980: using guessed type int jianhl_order_opt_fun(void);

//----- (004CC980) --------------------------------------------------------
int jianhl_order_opt_fun()
{
  MEMORY[0]();
  return wys_sj_module_del();
}
// 4CC990: using guessed type int wys_sj_module_del(void);

//----- (004CC990) --------------------------------------------------------
char *wys_sj_module_del()
{
  char *v0; // $a0
  int v1; // $a1
  FILE *v2; // $a2

  MEMORY[0]();
  return fgets(v0, v1, v2);
}
// 4CC999: variable 'v0' is possibly undefined
// 4CC999: variable 'v1' is possibly undefined
// 4CC999: variable 'v2' is possibly undefined

//----- (004CC9A0) --------------------------------------------------------
char *fgets(char *s, int n, FILE *stream)
{
  MEMORY[0](s, n, stream);
  return (char *)restart_wan_auto_conn();
}
// 4CC9B0: using guessed type int restart_wan_auto_conn(void);

//----- (004CC9B0) --------------------------------------------------------
int restart_wan_auto_conn()
{
  MEMORY[0]();
  return cJSON_IsNumber();
}
// 4CC9C0: using guessed type int cJSON_IsNumber(void);

//----- (004CC9C0) --------------------------------------------------------
int cJSON_IsNumber()
{
  int v0; // $a0

  MEMORY[0]();
  return close(v0);
}
// 4CC9C9: variable 'v0' is possibly undefined

//----- (004CC9D0) --------------------------------------------------------
int close(int fd)
{
  MEMORY[0](fd);
  return httpd_check_sys_freemem2();
}
// 4CC9E0: using guessed type int httpd_check_sys_freemem2(void);

//----- (004CC9E0) --------------------------------------------------------
int httpd_check_sys_freemem2()
{
  MEMORY[0]();
  return pppoe_srv_start();
}
// 4CC9F0: using guessed type int pppoe_srv_start(void);

//----- (004CC9F0) --------------------------------------------------------
int pppoe_srv_start()
{
  MEMORY[0]();
  return check_usb_state();
}
// 4CCA00: using guessed type int check_usb_state(void);

//----- (004CCA00) --------------------------------------------------------
char *check_usb_state()
{
  const char *v0; // $a0
  int v1; // $a1

  MEMORY[0]();
  return strchr(v0, v1);
}
// 4CCA09: variable 'v0' is possibly undefined
// 4CCA09: variable 'v1' is possibly undefined

//----- (004CCA10) --------------------------------------------------------
char *strchr(const char *s, int c)
{
  MEMORY[0](s, c);
  return (char *)user_mod();
}
// 4CCA20: using guessed type int user_mod(void);

//----- (004CCA20) --------------------------------------------------------
int user_mod()
{
  MEMORY[0]();
  return check_ip_is_lanip();
}
// 4CCA30: using guessed type int check_ip_is_lanip(void);

//----- (004CCA30) --------------------------------------------------------
int check_ip_is_lanip()
{
  MEMORY[0]();
  return set_dns_more_dnstype_item_to_kernel();
}
// 4CCA40: using guessed type int set_dns_more_dnstype_item_to_kernel(void);

//----- (004CCA40) --------------------------------------------------------
int set_dns_more_dnstype_item_to_kernel()
{
  MEMORY[0]();
  return arp_st_disonline();
}
// 4CCA50: using guessed type int arp_st_disonline(void);

//----- (004CCA50) --------------------------------------------------------
int arp_st_disonline()
{
  MEMORY[0]();
  return MacToStr();
}
// 4CCA60: using guessed type int MacToStr(void);

//----- (004CCA60) --------------------------------------------------------
void *MacToStr()
{
  size_t v0; // $a0
  size_t v1; // $a1

  MEMORY[0]();
  return calloc(v0, v1);
}
// 4CCA69: variable 'v0' is possibly undefined
// 4CCA69: variable 'v1' is possibly undefined

//----- (004CCA70) --------------------------------------------------------
void *calloc(size_t nmemb, size_t size)
{
  MEMORY[0](nmemb, size);
  return (void *)ping_wan_gw_get_state();
}
// 4CCA80: using guessed type int ping_wan_gw_get_state(void);

//----- (004CCA80) --------------------------------------------------------
int ping_wan_gw_get_state()
{
  MEMORY[0]();
  return read_log_data();
}
// 4CCA90: using guessed type int read_log_data(void);

//----- (004CCA90) --------------------------------------------------------
int read_log_data()
{
  MEMORY[0]();
  return strnicmp();
}
// 4CCAA0: using guessed type int strnicmp(void);

//----- (004CCAA0) --------------------------------------------------------
int strnicmp()
{
  MEMORY[0]();
  return wys_get_dns();
}
// 4CCAB0: using guessed type int wys_get_dns(void);

//----- (004CCAB0) --------------------------------------------------------
int wys_get_dns()
{
  const char *v0; // $a0
  const char *v1; // $a1
  size_t v2; // $a2

  MEMORY[0]();
  return strncmp(v0, v1, v2);
}
// 4CCAB9: variable 'v0' is possibly undefined
// 4CCAB9: variable 'v1' is possibly undefined
// 4CCAB9: variable 'v2' is possibly undefined

//----- (004CCAC0) --------------------------------------------------------
int strncmp(const char *s1, const char *s2, size_t n)
{
  MEMORY[0](s1, s2, n);
  return restart_shenji_ctrl();
}
// 4CCAD0: using guessed type int restart_shenji_ctrl(void);

//----- (004CCAD0) --------------------------------------------------------
int restart_shenji_ctrl()
{
  MEMORY[0]();
  return str_to_gb2312();
}
// 4CCAE0: using guessed type int str_to_gb2312(void);

//----- (004CCAE0) --------------------------------------------------------
int str_to_gb2312()
{
  MEMORY[0]();
  return SSL_free();
}
// 4CCAF0: using guessed type int SSL_free(void);

//----- (004CCAF0) --------------------------------------------------------
int SSL_free()
{
  MEMORY[0]();
  return set_port_mode();
}
// 4CCB00: using guessed type int set_port_mode(void);

//----- (004CCB00) --------------------------------------------------------
int set_port_mode()
{
  uint16_t v0; // $a0

  MEMORY[0]();
  return htons(v0);
}
// 4CCB09: variable 'v0' is possibly undefined

//----- (004CCB10) --------------------------------------------------------
uint16_t htons(uint16_t hostshort)
{
  MEMORY[0](hostshort);
  return upgrade_prepare();
}
// 4CCB20: using guessed type int upgrade_prepare(void);

//----- (004CCB20) --------------------------------------------------------
char *upgrade_prepare()
{
  const char *v0; // $a0
  int v1; // $a1

  MEMORY[0]();
  return strrchr(v0, v1);
}
// 4CCB29: variable 'v0' is possibly undefined
// 4CCB29: variable 'v1' is possibly undefined

//----- (004CCB30) --------------------------------------------------------
char *strrchr(const char *s, int c)
{
  const char *v2; // $a0
  struct stat *v3; // $a1

  MEMORY[0](s, c);
  return (char *)stat(v2, v3);
}
// 4CCB39: variable 'v2' is possibly undefined
// 4CCB39: variable 'v3' is possibly undefined

//----- (004CCB40) --------------------------------------------------------
int stat(const char *file, struct stat *buf)
{
  uint16_t v2; // $a0

  MEMORY[0](file, buf);
  return ntohs(v2);
}
// 4CCB49: variable 'v2' is possibly undefined

//----- (004CCB50) --------------------------------------------------------
uint16_t ntohs(uint16_t netshort)
{
  MEMORY[0](netshort);
  return dns_url_del();
}
// 4CCB60: using guessed type int dns_url_del(void);

//----- (004CCB60) --------------------------------------------------------
int dns_url_del()
{
  MEMORY[0]();
  return jhl_str_to_utf8_max();
}
// 4CCB70: using guessed type int jhl_str_to_utf8_max(void);

//----- (004CCB70) --------------------------------------------------------
int jhl_str_to_utf8_max()
{
  MEMORY[0]();
  return GetJSONItemValueAsString();
}
// 4CCB80: using guessed type int GetJSONItemValueAsString(void);

//----- (004CCB80) --------------------------------------------------------
int GetJSONItemValueAsString()
{
  const char *v0; // $a0

  MEMORY[0]();
  return atol(v0);
}
// 4CCB89: variable 'v0' is possibly undefined

//----- (004CCB90) --------------------------------------------------------
int atol(const char *nptr)
{
  int v1; // $a0

  MEMORY[0](nptr);
  return (int)strerror(v1);
}
// 4CCB99: variable 'v1' is possibly undefined

//----- (004CCBA0) --------------------------------------------------------
char *strerror(int errnum)
{
  void *v1; // $a0
  char *result; // $v0

  MEMORY[0](errnum);
  free(v1);
  return result;
}
// 4CCBA9: variable 'v1' is possibly undefined

//----- (004CCBB0) --------------------------------------------------------
void __fastcall free(void *ptr)
{
  MEMORY[0](ptr);
  jhl_ddns_del();
}
// 4CCBC0: using guessed type int jhl_ddns_del(void);

//----- (004CCBC0) --------------------------------------------------------
int jhl_ddns_del()
{
  MEMORY[0]();
  return start_mqtt_ai();
}
// 4CCBD0: using guessed type int start_mqtt_ai(void);

//----- (004CCBD0) --------------------------------------------------------
int start_mqtt_ai()
{
  MEMORY[0]();
  return jhl_vpnclient_route_id();
}
// 4CCBE0: using guessed type int jhl_vpnclient_route_id(void);

//----- (004CCBE0) --------------------------------------------------------
int jhl_vpnclient_route_id()
{
  MEMORY[0]();
  return SSL_set_fd();
}
// 4CCBF0: using guessed type int SSL_set_fd(void);

//----- (004CCBF0) --------------------------------------------------------
int SSL_set_fd()
{
  MEMORY[0]();
  return shenji_get_dev_info();
}
// 4CCC00: using guessed type int shenji_get_dev_info(void);

//----- (004CCC00) --------------------------------------------------------
int shenji_get_dev_info()
{
  MEMORY[0]();
  return cJSON_AddItemToArray();
}
// 4CCC10: using guessed type int cJSON_AddItemToArray(void);

//----- (004CCC10) --------------------------------------------------------
int cJSON_AddItemToArray()
{
  MEMORY[0]();
  return aes_set_key();
}
// 4CCC20: using guessed type int aes_set_key(void);

//----- (004CCC20) --------------------------------------------------------
int aes_set_key()
{
  MEMORY[0]();
  return MD5Final();
}
// 4CCC30: using guessed type int MD5Final(void);

//----- (004CCC30) --------------------------------------------------------
int MD5Final()
{
  MEMORY[0]();
  return jhl_start_3g();
}
// 4CCC40: using guessed type int jhl_start_3g(void);

//----- (004CCC40) --------------------------------------------------------
int jhl_start_3g()
{
  MEMORY[0]();
  return sq_file_get_state_new();
}
// 4CCC50: using guessed type int sq_file_get_state_new(void);

//----- (004CCC50) --------------------------------------------------------
int sq_file_get_state_new()
{
  MEMORY[0]();
  return cJSON_Delete();
}
// 4CCC60: using guessed type int cJSON_Delete(void);

//----- (004CCC60) --------------------------------------------------------
int cJSON_Delete()
{
  MEMORY[0]();
  return dns_url_get();
}
// 4CCC70: using guessed type int dns_url_get(void);

//----- (004CCC70) --------------------------------------------------------
int dns_url_get()
{
  MEMORY[0]();
  return flash_erase_mtd();
}
// 4CCC80: using guessed type int flash_erase_mtd(void);

//----- (004CCC80) --------------------------------------------------------
int flash_erase_mtd()
{
  const char *v0; // $a0
  FILE *v1; // $a1

  MEMORY[0]();
  return fputs(v0, v1);
}
// 4CCC89: variable 'v0' is possibly undefined
// 4CCC89: variable 'v1' is possibly undefined

//----- (004CCC90) --------------------------------------------------------
int fputs(const char *s, FILE *stream)
{
  MEMORY[0](s, stream);
  return split_string2();
}
// 4CCCA0: using guessed type int split_string2(void);

//----- (004CCCA0) --------------------------------------------------------
int split_string2()
{
  MEMORY[0]();
  return check_ifname_is_wan();
}
// 4CCCB0: using guessed type int check_ifname_is_wan(void);

//----- (004CCCB0) --------------------------------------------------------
int check_ifname_is_wan()
{
  MEMORY[0]();
  return SSL_CTX_set_verify();
}
// 4CCCC0: using guessed type int SSL_CTX_set_verify(void);

//----- (004CCCC0) --------------------------------------------------------
int SSL_CTX_set_verify()
{
  MEMORY[0]();
  return nvram_getdef_int();
}
// 4CCCD0: using guessed type int nvram_getdef_int(void);

//----- (004CCCD0) --------------------------------------------------------
int nvram_getdef_int()
{
  MEMORY[0]();
  return jiffies_get();
}
// 4CCCE0: using guessed type int jiffies_get(void);

//----- (004CCCE0) --------------------------------------------------------
int jiffies_get()
{
  MEMORY[0]();
  return arp_st_del();
}
// 4CCCF0: using guessed type int arp_st_del(void);

//----- (004CCCF0) --------------------------------------------------------
int arp_st_del()
{
  MEMORY[0]();
  return ip_get_duolan();
}
// 4CCD00: using guessed type int ip_get_duolan(void);

//----- (004CCD00) --------------------------------------------------------
int ip_get_duolan()
{
  const char *v0; // $a0

  MEMORY[0]();
  return unlink(v0);
}
// 4CCD09: variable 'v0' is possibly undefined

//----- (004CCD10) --------------------------------------------------------
int unlink(const char *name)
{
  MEMORY[0](name);
  return radius_server_start();
}
// 4CCD20: using guessed type int radius_server_start(void);

//----- (004CCD20) --------------------------------------------------------
int radius_server_start()
{
  MEMORY[0]();
  return wan_lan_confilict();
}
// 4CCD30: using guessed type int wan_lan_confilict(void);

//----- (004CCD30) --------------------------------------------------------
int wan_lan_confilict()
{
  MEMORY[0]();
  return jhl_get_3g_iface();
}
// 4CCD40: using guessed type int jhl_get_3g_iface(void);

//----- (004CCD40) --------------------------------------------------------
float jhl_get_3g_iface()
{
  float v0; // $f12
  float v1; // $f13

  MEMORY[0]();
  return v0 * v1;
}
// 4CCD49: variable 'v0' is possibly undefined
// 4CCD49: variable 'v1' is possibly undefined

//----- (004CCD60) --------------------------------------------------------
int get_uptime2()
{
  MEMORY[0]();
  return sq_file_get_ssid_en();
}
// 4CCD70: using guessed type int sq_file_get_ssid_en(void);

//----- (004CCD70) --------------------------------------------------------
int sq_file_get_ssid_en()
{
  MEMORY[0]();
  return jhl_string_encoding_json();
}
// 4CCD80: using guessed type int jhl_string_encoding_json(void);

//----- (004CCD80) --------------------------------------------------------
int jhl_string_encoding_json()
{
  MEMORY[0]();
  return nvparm_del_str_too_loog();
}
// 4CCD90: using guessed type int nvparm_del_str_too_loog(void);

//----- (004CCD90) --------------------------------------------------------
int nvparm_del_str_too_loog()
{
  MEMORY[0]();
  return jhl_vpndtime();
}
// 4CCDA0: using guessed type int jhl_vpndtime(void);

//----- (004CCDA0) --------------------------------------------------------
int jhl_vpndtime()
{
  MEMORY[0]();
  return dns_more_dnstype_item_buf();
}
// 4CCDB0: using guessed type int dns_more_dnstype_item_buf(void);

//----- (004CCDB0) --------------------------------------------------------
int dns_more_dnstype_item_buf()
{
  MEMORY[0]();
  return start_proxy_auto_send_email();
}
// 4CCDC0: using guessed type int start_proxy_auto_send_email(void);

//----- (004CCDC0) --------------------------------------------------------
int start_proxy_auto_send_email()
{
  MEMORY[0]();
  return jhl_stop_wan();
}
// 4CCDD0: using guessed type int jhl_stop_wan(void);

//----- (004CCDD0) --------------------------------------------------------
int jhl_stop_wan()
{
  MEMORY[0]();
  return start_wan_dns_check();
}
// 4CCDE0: using guessed type int start_wan_dns_check(void);

//----- (004CCDE0) --------------------------------------------------------
int start_wan_dns_check()
{
  MEMORY[0]();
  return IpaddrToStr2();
}
// 4CCDF0: using guessed type int IpaddrToStr2(void);

//----- (004CCDF0) --------------------------------------------------------
int IpaddrToStr2()
{
  MEMORY[0]();
  return dns_more_hitype_add();
}
// 4CCE00: using guessed type int dns_more_hitype_add(void);

//----- (004CCE00) --------------------------------------------------------
int dns_more_hitype_add()
{
  MEMORY[0]();
  return ApiFindWhiteIp();
}
// 4CCE10: using guessed type int ApiFindWhiteIp(void);

//----- (004CCE10) --------------------------------------------------------
int ApiFindWhiteIp()
{
  FILE *v0; // $a0

  MEMORY[0]();
  return fflush(v0);
}
// 4CCE19: variable 'v0' is possibly undefined

//----- (004CCE20) --------------------------------------------------------
int fflush(FILE *stream)
{
  int v1; // $a0
  int v2; // $a1

  MEMORY[0](stream);
  return dup2(v1, v2);
}
// 4CCE29: variable 'v1' is possibly undefined
// 4CCE29: variable 'v2' is possibly undefined

//----- (004CCE30) --------------------------------------------------------
int dup2(int fd, int fd2)
{
  MEMORY[0](fd, fd2);
  return user_num_get();
}
// 4CCE40: using guessed type int user_num_get(void);

//----- (004CCE40) --------------------------------------------------------
int user_num_get()
{
  MEMORY[0]();
  return cJSON_AddNumberToObject();
}
// 4CCE50: using guessed type int cJSON_AddNumberToObject(void);

//----- (004CCE50) --------------------------------------------------------
int cJSON_AddNumberToObject()
{
  MEMORY[0]();
  return nvram_commit();
}
// 4CCE60: using guessed type int nvram_commit(void);

//----- (004CCE60) --------------------------------------------------------
float nvram_commit()
{
  float v0; // $f12
  float v1; // $f13

  MEMORY[0]();
  return v0 / v1;
}
// 4CCE69: variable 'v0' is possibly undefined
// 4CCE69: variable 'v1' is possibly undefined

//----- (004CCE80) --------------------------------------------------------
char *strpbrk(const char *s, const char *accept)
{
  MEMORY[0](s, accept);
  return (char *)params_sort();
}
// 4CCE90: using guessed type int params_sort(void);

//----- (004CCE90) --------------------------------------------------------
int params_sort()
{
  MEMORY[0]();
  return find_old_sq_exist();
}
// 4CCEA0: using guessed type int find_old_sq_exist(void);

//----- (004CCEA0) --------------------------------------------------------
char *find_old_sq_exist()
{
  struct in_addr v0; // $a0

  MEMORY[0]();
  return inet_ntoa(v0);
}
// 4CCEA9: variable 'v0' is possibly undefined

//----- (004CCEB0) --------------------------------------------------------
char *inet_ntoa(struct in_addr in)
{
  MEMORY[0](in.s_addr);
  return (char *)SSL_CTX_set_default_passwd_cb_userdata();
}
// 4CCEC0: using guessed type int SSL_CTX_set_default_passwd_cb_userdata(void);

//----- (004CCEC0) --------------------------------------------------------
int SSL_CTX_set_default_passwd_cb_userdata()
{
  void *v0; // $a0
  char *v1; // $a1

  MEMORY[0]();
  return fprintf(v0, v1);
}
// 4CCEC9: variable 'v0' is possibly undefined
// 4CCEC9: variable 'v1' is possibly undefined

//----- (004CCED0) --------------------------------------------------------
int fprintf(void *stream, char *format, ...)
{
  MEMORY[0](stream, format);
  return wan_proto_check();
}
// 4CCEE0: using guessed type int wan_proto_check(void);

//----- (004CCEE0) --------------------------------------------------------
int wan_proto_check()
{
  MEMORY[0]();
  return get_lans_num();
}
// 4CCEF0: using guessed type int get_lans_num(void);

//----- (004CCEF0) --------------------------------------------------------
__pid_t get_lans_num()
{
  __pid_t v0; // $a0
  int *v1; // $a1
  int v2; // $a2

  MEMORY[0]();
  return waitpid(v0, v1, v2);
}
// 4CCEF9: variable 'v0' is possibly undefined
// 4CCEF9: variable 'v1' is possibly undefined
// 4CCEF9: variable 'v2' is possibly undefined

//----- (004CCF00) --------------------------------------------------------
__pid_t waitpid(__pid_t pid, int *stat_loc, int options)
{
  MEMORY[0](pid, stat_loc, options);
  return __gtsf2();
}
// 4CCF10: using guessed type int __gtsf2(void);

//----- (004CCF10) --------------------------------------------------------
int __gtsf2()
{
  MEMORY[0]();
  return jhl_ddns_add();
}
// 4CCF20: using guessed type int jhl_ddns_add(void);

//----- (004CCF20) --------------------------------------------------------
void jhl_ddns_add()
{
  void *v0; // $a0
  void *v1; // $a1
  int v2; // $a2

  MEMORY[0]();
  memcpy(v0, v1, v2);
}
// 4CCF29: variable 'v0' is possibly undefined
// 4CCF29: variable 'v1' is possibly undefined
// 4CCF29: variable 'v2' is possibly undefined

//----- (004CCF30) --------------------------------------------------------
void __fastcall memcpy(void *dest, void *src, int n)
{
  MEMORY[0](dest, src, n);
  nvram_set_int();
}
// 4CCF40: using guessed type int nvram_set_int(void);

//----- (004CCF40) --------------------------------------------------------
int nvram_set_int()
{
  MEMORY[0]();
  return custom_tb_version();
}
// 4CCF50: using guessed type int custom_tb_version(void);

//----- (004CCF50) --------------------------------------------------------
int custom_tb_version()
{
  MEMORY[0]();
  return dns_acc_add();
}
// 4CCF60: using guessed type int dns_acc_add(void);

//----- (004CCF60) --------------------------------------------------------
int dns_acc_add()
{
  MEMORY[0]();
  return cJSON_Parse();
}
// 4CCF70: using guessed type int cJSON_Parse(void);

//----- (004CCF70) --------------------------------------------------------
int cJSON_Parse()
{
  MEMORY[0]();
  return httpd_check_sys_freemem();
}
// 4CCF80: using guessed type int httpd_check_sys_freemem(void);

//----- (004CCF80) --------------------------------------------------------
int httpd_check_sys_freemem()
{
  MEMORY[0]();
  return split_string();
}
// 4CCF90: using guessed type int split_string(void);

//----- (004CCF90) --------------------------------------------------------
int split_string()
{
  MEMORY[0]();
  return cJSON_SetValuestring();
}
// 4CCFA0: using guessed type int cJSON_SetValuestring(void);

//----- (004CCFA0) --------------------------------------------------------
int cJSON_SetValuestring()
{
  MEMORY[0]();
  return url_member_add();
}
// 4CCFB0: using guessed type int url_member_add(void);

//----- (004CCFB0) --------------------------------------------------------
int url_member_add()
{
  __useconds_t v0; // $a0

  MEMORY[0]();
  return usleep(v0);
}
// 4CCFB9: variable 'v0' is possibly undefined

//----- (004CCFC0) --------------------------------------------------------
int usleep(__useconds_t useconds)
{
  unsigned int v1; // $a0
  int result; // $v0

  MEMORY[0](useconds);
  srand(v1);
  return result;
}
// 4CCFC9: variable 'v1' is possibly undefined

//----- (004CCFD0) --------------------------------------------------------
void srand(unsigned int seed)
{
  MEMORY[0](seed);
  cgi_signal_to_kernel();
}
// 4CCFE0: using guessed type int cgi_signal_to_kernel(void);

//----- (004CCFE0) --------------------------------------------------------
int cgi_signal_to_kernel()
{
  MEMORY[0]();
  return start_igmp_snooping();
}
// 4CCFF0: using guessed type int start_igmp_snooping(void);

//----- (004CCFF0) --------------------------------------------------------
int start_igmp_snooping()
{
  MEMORY[0]();
  return set_dns_more_dnswan_to_kernel();
}
// 4CD000: using guessed type int set_dns_more_dnswan_to_kernel(void);

//----- (004CD000) --------------------------------------------------------
int set_dns_more_dnswan_to_kernel()
{
  int v0; // $a0
  struct sockaddr *v1; // $a1
  socklen_t *v2; // $a2

  MEMORY[0]();
  return accept(v0, v1, v2);
}
// 4CD009: variable 'v0' is possibly undefined
// 4CD009: variable 'v1' is possibly undefined
// 4CD009: variable 'v2' is possibly undefined

//----- (004CD010) --------------------------------------------------------
int accept(int fd, struct sockaddr *addr, socklen_t *addr_len)
{
  MEMORY[0](fd, addr, addr_len);
  return fork();
}

//----- (004CD020) --------------------------------------------------------
__pid_t fork(void)
{
  MEMORY[0]();
  return rand();
}

//----- (004CD030) --------------------------------------------------------
int rand(void)
{
  MEMORY[0]();
  return get_ip_from_str();
}
// 4CD040: using guessed type int get_ip_from_str(void);

//----- (004CD040) --------------------------------------------------------
int get_ip_from_str()
{
  MEMORY[0]();
  return cJSON_GetIntvalue();
}
// 4CD050: using guessed type int cJSON_GetIntvalue(void);

//----- (004CD050) --------------------------------------------------------
int cJSON_GetIntvalue()
{
  MEMORY[0]();
  return cJSON_PrintPreallocated();
}
// 4CD060: using guessed type int cJSON_PrintPreallocated(void);

//----- (004CD060) --------------------------------------------------------
char *cJSON_PrintPreallocated()
{
  const struct tm *v0; // $a0

  MEMORY[0]();
  return asctime(v0);
}
// 4CD069: variable 'v0' is possibly undefined

//----- (004CD070) --------------------------------------------------------
char *asctime(const struct tm *tp)
{
  int v1; // $a0
  void *v2; // $a1
  size_t v3; // $a2
  int v4; // $a3

  MEMORY[0](tp);
  return (char *)recv(v1, v2, v3, v4);
}
// 4CD079: variable 'v1' is possibly undefined
// 4CD079: variable 'v2' is possibly undefined
// 4CD079: variable 'v3' is possibly undefined
// 4CD079: variable 'v4' is possibly undefined

//----- (004CD080) --------------------------------------------------------
ssize_t recv(int fd, void *buf, size_t n, int flags)
{
  MEMORY[0](fd, buf, n, flags);
  return SSL_get_version();
}
// 4CD090: using guessed type int SSL_get_version(void);

//----- (004CD090) --------------------------------------------------------
int SSL_get_version()
{
  MEMORY[0]();
  return get_log_data_in_sometime();
}
// 4CD0A0: using guessed type int get_log_data_in_sometime(void);

//----- (004CD0A0) --------------------------------------------------------
int get_log_data_in_sometime()
{
  int v0; // $a0

  MEMORY[0]();
  return tolower(v0);
}
// 4CD0A9: variable 'v0' is possibly undefined

//----- (004CD0B0) --------------------------------------------------------
int tolower(int c)
{
  struct tm *v1; // $a0

  MEMORY[0](c);
  return mktime(v1);
}
// 4CD0B9: variable 'v1' is possibly undefined

//----- (004CD0C0) --------------------------------------------------------
time_t mktime(struct tm *tp)
{
  MEMORY[0](tp);
  return schedule_ipsec();
}
// 4CD0D0: using guessed type int schedule_ipsec(void);

//----- (004CD0D0) --------------------------------------------------------
struct tm *schedule_ipsec()
{
  const time_t *v0; // $a0

  MEMORY[0]();
  return localtime(v0);
}
// 4CD0D9: variable 'v0' is possibly undefined

//----- (004CD0E0) --------------------------------------------------------
struct tm *localtime(const time_t *timer)
{
  MEMORY[0](timer);
  return (struct tm *)get_json_data();
}
// 4CD0F0: using guessed type int get_json_data(void);

//----- (004CD0F0) --------------------------------------------------------
int get_json_data()
{
  MEMORY[0]();
  return httpd_wget();
}
// 4CD100: using guessed type int httpd_wget(void);

//----- (004CD100) --------------------------------------------------------
int httpd_wget()
{
  MEMORY[0]();
  return uv_inet_pton4();
}
// 4CD110: using guessed type int uv_inet_pton4(void);

//----- (004CD110) --------------------------------------------------------
int uv_inet_pton4()
{
  MEMORY[0]();
  return jhl_get_wanip();
}
// 4CD120: using guessed type int jhl_get_wanip(void);

//----- (004CD120) --------------------------------------------------------
int jhl_get_wanip()
{
  MEMORY[0]();
  return uv_inet_pton6();
}
// 4CD130: using guessed type int uv_inet_pton6(void);

//----- (004CD130) --------------------------------------------------------
int uv_inet_pton6()
{
  MEMORY[0]();
  return mr_set();
}
// 4CD140: using guessed type int mr_set(void);

//----- (004CD140) --------------------------------------------------------
int mr_set()
{
  MEMORY[0]();
  return user_del();
}
// 4CD150: using guessed type int user_del(void);

//----- (004CD150) --------------------------------------------------------
int user_del()
{
  MEMORY[0]();
  return sq_file_get_state();
}
// 4CD160: using guessed type int sq_file_get_state(void);

//----- (004CD160) --------------------------------------------------------
int sq_file_get_state()
{
  MEMORY[0]();
  return cJSON_GetArraySize();
}
// 4CD170: using guessed type int cJSON_GetArraySize(void);

//----- (004CD170) --------------------------------------------------------
int cJSON_GetArraySize()
{
  MEMORY[0]();
  return Ip6ToStr();
}
// 4CD180: using guessed type int Ip6ToStr(void);

//----- (004CD180) --------------------------------------------------------
int Ip6ToStr()
{
  MEMORY[0]();
  return jhl_nv_get_only_def();
}
// 4CD190: using guessed type int jhl_nv_get_only_def(void);

//----- (004CD190) --------------------------------------------------------
int jhl_nv_get_only_def()
{
  MEMORY[0]();
  return user_get_file_csv();
}
// 4CD1A0: using guessed type int user_get_file_csv(void);

//----- (004CD1A0) --------------------------------------------------------
int user_get_file_csv()
{
  DIR *v0; // $a0

  MEMORY[0]();
  return closedir(v0);
}
// 4CD1A9: variable 'v0' is possibly undefined

//----- (004CD1B0) --------------------------------------------------------
int closedir(DIR *dirp)
{
  MEMORY[0](dirp);
  return sq_file_get_max_wan_no4g();
}
// 4CD1C0: using guessed type int sq_file_get_max_wan_no4g(void);

//----- (004CD1C0) --------------------------------------------------------
int sq_file_get_max_wan_no4g()
{
  MEMORY[0]();
  return custom_device_name();
}
// 4CD1D0: using guessed type int custom_device_name(void);

//----- (004CD1D0) --------------------------------------------------------
int custom_device_name()
{
  MEMORY[0]();
  return arp_st_get();
}
// 4CD1E0: using guessed type int arp_st_get(void);

//----- (004CD1E0) --------------------------------------------------------
int arp_st_get()
{
  MEMORY[0]();
  return macuser_conf_set();
}
// 4CD1F0: using guessed type int macuser_conf_set(void);

//----- (004CD1F0) --------------------------------------------------------
int macuser_conf_set()
{
  MEMORY[0]();
  return cJSON_DetachItemFromObject();
}
// 4CD200: using guessed type int cJSON_DetachItemFromObject(void);

//----- (004CD200) --------------------------------------------------------
int cJSON_DetachItemFromObject()
{
  MEMORY[0]();
  return cJSON_AddArrayToObject();
}
// 4CD210: using guessed type int cJSON_AddArrayToObject(void);

//----- (004CD210) --------------------------------------------------------
int cJSON_AddArrayToObject()
{
  MEMORY[0]();
  return lanip_change();
}
// 4CD220: using guessed type int lanip_change(void);

//----- (004CD220) --------------------------------------------------------
char *lanip_change()
{
  char **v0; // $a0
  const char *v1; // $a1

  MEMORY[0]();
  return strsep(v0, v1);
}
// 4CD229: variable 'v0' is possibly undefined
// 4CD229: variable 'v1' is possibly undefined

//----- (004CD230) --------------------------------------------------------
char *strsep(char **stringp, const char *delim)
{
  MEMORY[0](stringp, delim);
  return (char *)stpcpy();
}
// 4CD240: using guessed type int stpcpy(void);

//----- (004CD240) --------------------------------------------------------
int stpcpy()
{
  MEMORY[0]();
  return url_member_del();
}
// 4CD250: using guessed type int url_member_del(void);

//----- (004CD250) --------------------------------------------------------
int url_member_del()
{
  MEMORY[0]();
  return SSL_library_init();
}
// 4CD260: using guessed type int SSL_library_init(void);

//----- (004CD260) --------------------------------------------------------
int SSL_library_init()
{
  MEMORY[0]();
  return dns_more_dnstype_item_del();
}
// 4CD270: using guessed type int dns_more_dnstype_item_del(void);

//----- (004CD270) --------------------------------------------------------
void *dns_more_dnstype_item_del()
{
  void *v0; // $a0
  int v1; // $a1
  size_t v2; // $a2

  MEMORY[0]();
  return memset(v0, v1, v2);
}
// 4CD279: variable 'v0' is possibly undefined
// 4CD279: variable 'v1' is possibly undefined
// 4CD279: variable 'v2' is possibly undefined

//----- (004CD280) --------------------------------------------------------
void *memset(void *s, int c, size_t n)
{
  MEMORY[0](s, c, n);
  return (void *)stop_proxy_auto_send_email();
}
// 4CD290: using guessed type int stop_proxy_auto_send_email(void);

//----- (004CD290) --------------------------------------------------------
int stop_proxy_auto_send_email()
{
  MEMORY[0]();
  return nvparm_get_str();
}
// 4CD2A0: using guessed type int nvparm_get_str(void);

//----- (004CD2A0) --------------------------------------------------------
int nvparm_get_str()
{
  int v0; // $a0
  const struct sigaction *v1; // $a1
  struct sigaction *v2; // $a2

  MEMORY[0]();
  return sigaction(v0, v1, v2);
}
// 4CD2A9: variable 'v0' is possibly undefined
// 4CD2A9: variable 'v1' is possibly undefined
// 4CD2A9: variable 'v2' is possibly undefined

//----- (004CD2B0) --------------------------------------------------------
int sigaction(int sig, const struct sigaction *act, struct sigaction *oact)
{
  int v3; // $a0
  int v4; // $a1

  MEMORY[0](sig, act, oact);
  return listen(v3, v4);
}
// 4CD2B9: variable 'v3' is possibly undefined
// 4CD2B9: variable 'v4' is possibly undefined

//----- (004CD2C0) --------------------------------------------------------
int listen(int fd, int n)
{
  MEMORY[0](fd, n);
  return set_xwgl_ref_to_kernel();
}
// 4CD2D0: using guessed type int set_xwgl_ref_to_kernel(void);

//----- (004CD2D0) --------------------------------------------------------
int set_xwgl_ref_to_kernel()
{
  MEMORY[0]();
  return re_boot();
}
// 4CD2E0: using guessed type int re_boot(void);

//----- (004CD2E0) --------------------------------------------------------
int re_boot()
{
  MEMORY[0]();
  return f_read();
}
// 4CD2F0: using guessed type int f_read(void);

//----- (004CD2F0) --------------------------------------------------------
int f_read()
{
  MEMORY[0]();
  return start_wan_http_check();
}
// 4CD300: using guessed type int start_wan_http_check(void);

//----- (004CD300) --------------------------------------------------------
int start_wan_http_check()
{
  char *v0; // $a0
  char **__attribute__((__org_arrdim(0,0))) v1; // $a1

  MEMORY[0]();
  return execvp(v0, v1);
}
// 4CD309: variable 'v0' is possibly undefined
// 4CD309: variable 'v1' is possibly undefined

//----- (004CD310) --------------------------------------------------------
int __fastcall execvp(char *file, char *argv[])
{
  MEMORY[0](file, argv);
  return SSL_read();
}
// 4CD320: using guessed type int SSL_read(void);

//----- (004CD320) --------------------------------------------------------
int SSL_read()
{
  MEMORY[0]();
  return read_sysmessage_file();
}
// 4CD330: using guessed type int read_sysmessage_file(void);

//----- (004CD330) --------------------------------------------------------
int read_sysmessage_file()
{
  MEMORY[0]();
  return jhl_get_wan_name();
}
// 4CD340: using guessed type int jhl_get_wan_name(void);

//----- (004CD340) --------------------------------------------------------
int jhl_get_wan_name()
{
  MEMORY[0]();
  return mtd_open();
}
// 4CD350: using guessed type int mtd_open(void);

//----- (004CD350) --------------------------------------------------------
int mtd_open()
{
  MEMORY[0]();
  return https_post();
}
// 4CD360: using guessed type int https_post(void);

//----- (004CD360) --------------------------------------------------------
int https_post()
{
  MEMORY[0]();
  return SSL_get_current_cipher();
}
// 4CD370: using guessed type int SSL_get_current_cipher(void);

//----- (004CD370) --------------------------------------------------------
int SSL_get_current_cipher()
{
  MEMORY[0]();
  return url_group_add();
}
// 4CD380: using guessed type int url_group_add(void);

//----- (004CD380) --------------------------------------------------------
int url_group_add()
{
  MEMORY[0]();
  return ai_aes_cbc_decrypt();
}
// 4CD390: using guessed type int ai_aes_cbc_decrypt(void);

//----- (004CD390) --------------------------------------------------------
int ai_aes_cbc_decrypt()
{
  MEMORY[0]();
  return killall_arg();
}
// 4CD3A0: using guessed type int killall_arg(void);

//----- (004CD3A0) --------------------------------------------------------
int killall_arg()
{
  MEMORY[0]();
  return ApiDelWhiteMac();
}
// 4CD3B0: using guessed type int ApiDelWhiteMac(void);

//----- (004CD3B0) --------------------------------------------------------
int ApiDelWhiteMac()
{
  MEMORY[0]();
  return SSL_CTX_ctrl();
}
// 4CD3C0: using guessed type int SSL_CTX_ctrl(void);

//----- (004CD3C0) --------------------------------------------------------
int SSL_CTX_ctrl()
{
  MEMORY[0]();
  return getMD5Str();
}
// 4CD3D0: using guessed type int getMD5Str(void);

//----- (004CD3D0) --------------------------------------------------------
int getMD5Str()
{
  MEMORY[0]();
  return nvparm_find_str_too_loog();
}
// 4CD3E0: using guessed type int nvparm_find_str_too_loog(void);

//----- (004CD3E0) --------------------------------------------------------
int nvparm_find_str_too_loog()
{
  MEMORY[0]();
  return SSL_new();
}
// 4CD3F0: using guessed type int SSL_new(void);

//----- (004CD3F0) --------------------------------------------------------
int SSL_new()
{
  MEMORY[0]();
  return pppoe_br_user_del();
}
// 4CD400: using guessed type int pppoe_br_user_del(void);

//----- (004CD400) --------------------------------------------------------
int pppoe_br_user_del()
{
  MEMORY[0]();
  return qos_low_limit_check();
}
// 4CD410: using guessed type int qos_low_limit_check(void);

//----- (004CD410) --------------------------------------------------------
int qos_low_limit_check()
{
  MEMORY[0]();
  return get_usb_mount_dir();
}
// 4CD420: using guessed type int get_usb_mount_dir(void);

//----- (004CD420) --------------------------------------------------------
int get_usb_mount_dir()
{
  MEMORY[0]();
  return url_group_get();
}
// 4CD430: using guessed type int url_group_get(void);

//----- (004CD430) --------------------------------------------------------
int url_group_get()
{
  MEMORY[0]();
  return IpToStr();
}
// 4CD440: using guessed type int IpToStr(void);

//----- (004CD440) --------------------------------------------------------
int IpToStr()
{
  MEMORY[0]();
  return _eval_nowait_file();
}
// 4CD450: using guessed type int _eval_nowait_file(void);

//----- (004CD450) --------------------------------------------------------
int _eval_nowait_file()
{
  MEMORY[0]();
  return wys_mkstemp();
}
// 4CD460: using guessed type int wys_mkstemp(void);

//----- (004CD460) --------------------------------------------------------
int wys_mkstemp()
{
  MEMORY[0]();
  return __ltsf2();
}
// 4CD470: using guessed type int __ltsf2(void);

//----- (004CD470) --------------------------------------------------------
int __ltsf2()
{
  MEMORY[0]();
  return dns_redirect_write_hosts();
}
// 4CD480: using guessed type int dns_redirect_write_hosts(void);

//----- (004CD480) --------------------------------------------------------
int dns_redirect_write_hosts()
{
  MEMORY[0]();
  return ipv6lan_set_all();
}
// 4CD490: using guessed type int ipv6lan_set_all(void);

//----- (004CD490) --------------------------------------------------------
int ipv6lan_set_all()
{
  MEMORY[0]();
  return StrToIp();
}
// 4CD4A0: using guessed type int StrToIp(void);

//----- (004CD4A0) --------------------------------------------------------
struct hostent *StrToIp()
{
  const char *v0; // $a0

  MEMORY[0]();
  return gethostbyname(v0);
}
// 4CD4A9: variable 'v0' is possibly undefined

//----- (004CD4B0) --------------------------------------------------------
struct hostent *gethostbyname(const char *name)
{
  MEMORY[0](name);
  return (struct hostent *)start_user_deltime();
}
// 4CD4C0: using guessed type int start_user_deltime(void);

//----- (004CD4C0) --------------------------------------------------------
int start_user_deltime()
{
  MEMORY[0]();
  return SSL_CTX_use_certificate_file();
}
// 4CD4D0: using guessed type int SSL_CTX_use_certificate_file(void);

//----- (004CD4D0) --------------------------------------------------------
int SSL_CTX_use_certificate_file()
{
  MEMORY[0]();
  return nvram_set_zipfile();
}
// 4CD4E0: using guessed type int nvram_set_zipfile(void);

//----- (004CD4E0) --------------------------------------------------------
int nvram_set_zipfile()
{
  MEMORY[0]();
  return SSL_shutdown();
}
// 4CD4F0: using guessed type int SSL_shutdown(void);

//----- (004CD4F0) --------------------------------------------------------
int SSL_shutdown()
{
  MEMORY[0]();
  return pidof();
}
// 4CD500: using guessed type int pidof(void);

//----- (004CD500) --------------------------------------------------------
int pidof()
{
  MEMORY[0]();
  return stop_wan_gw_ping_check();
}
// 4CD510: using guessed type int stop_wan_gw_ping_check(void);

//----- (004CD510) --------------------------------------------------------
int stop_wan_gw_ping_check()
{
  MEMORY[0]();
  return dns_more_dns_gid_member_get();
}
// 4CD520: using guessed type int dns_more_dns_gid_member_get(void);

//----- (004CD520) --------------------------------------------------------
int dns_more_dns_gid_member_get()
{
  MEMORY[0]();
  return get_lang_type();
}
// 4CD530: using guessed type int get_lang_type(void);

//----- (004CD530) --------------------------------------------------------
int get_lang_type()
{
  MEMORY[0]();
  return user_lock();
}
// 4CD540: using guessed type int user_lock(void);

//----- (004CD540) --------------------------------------------------------
int user_lock()
{
  MEMORY[0]();
  return jhl_parm_get();
}
// 4CD550: using guessed type int jhl_parm_get(void);

//----- (004CD550) --------------------------------------------------------
int jhl_parm_get()
{
  MEMORY[0]();
  return dhcp6s_restart();
}
// 4CD560: using guessed type int dhcp6s_restart(void);

//----- (004CD560) --------------------------------------------------------
int dhcp6s_restart()
{
  MEMORY[0]();
  return set_dns_more_dnswan_rule_to_kernel();
}
// 4CD570: using guessed type int set_dns_more_dnswan_rule_to_kernel(void);

//----- (004CD570) --------------------------------------------------------
void set_dns_more_dnswan_rule_to_kernel()
{
  const char *v0; // $a0

  MEMORY[0]();
  perror(v0);
}
// 4CD579: variable 'v0' is possibly undefined

//----- (004CD580) --------------------------------------------------------
void perror(const char *s)
{
  MEMORY[0](s);
  reset_wtclient_rzgl_parm();
}
// 4CD590: using guessed type int reset_wtclient_rzgl_parm(void);

//----- (004CD590) --------------------------------------------------------
int reset_wtclient_rzgl_parm()
{
  MEMORY[0]();
  return StrToMac();
}
// 4CD5A0: using guessed type int StrToMac(void);

//----- (004CD5A0) --------------------------------------------------------
int StrToMac()
{
  MEMORY[0]();
  return jhl_stop_pptpd_srv();
}
// 4CD5B0: using guessed type int jhl_stop_pptpd_srv(void);

//----- (004CD5B0) --------------------------------------------------------
int jhl_stop_pptpd_srv()
{
  MEMORY[0]();
  return sq_file_get_jb();
}
// 4CD5C0: using guessed type int sq_file_get_jb(void);

//----- (004CD5C0) --------------------------------------------------------
int sq_file_get_jb()
{
  MEMORY[0]();
  return sq_file_get_max_wan();
}
// 4CD5D0: using guessed type int sq_file_get_max_wan(void);

//----- (004CD5D0) --------------------------------------------------------
int sq_file_get_max_wan()
{
  MEMORY[0]();
  return set_qos_to_kernel();
}
// 4CD5E0: using guessed type int set_qos_to_kernel(void);

//----- (004CD5E0) --------------------------------------------------------
int set_qos_to_kernel()
{
  MEMORY[0]();
  return create_dir();
}
// 4CD5F0: using guessed type int create_dir(void);

//----- (004CD5F0) --------------------------------------------------------
int create_dir()
{
  MEMORY[0]();
  return pppoe_group_get_username();
}
// 4CD600: using guessed type int pppoe_group_get_username(void);

//----- (004CD600) --------------------------------------------------------
int pppoe_group_get_username()
{
  MEMORY[0]();
  return cJSON_PrintUnformatted();
}
// 4CD610: using guessed type int cJSON_PrintUnformatted(void);

//----- (004CD610) --------------------------------------------------------
int cJSON_PrintUnformatted()
{
  MEMORY[0]();
  return get_memory();
}
// 4CD620: using guessed type int get_memory(void);

//----- (004CD620) --------------------------------------------------------
int get_memory()
{
  MEMORY[0]();
  return gbk_to_utf8();
}
// 4CD630: using guessed type int gbk_to_utf8(void);

//----- (004CD630) --------------------------------------------------------
int gbk_to_utf8()
{
  MEMORY[0]();
  return log_del_file_all();
}
// 4CD640: using guessed type int log_del_file_all(void);

//----- (004CD640) --------------------------------------------------------
int log_del_file_all()
{
  MEMORY[0]();
  return ERR_free_strings();
}
// 4CD650: using guessed type int ERR_free_strings(void);

//----- (004CD650) --------------------------------------------------------
char *ERR_free_strings()
{
  char *v0; // $a0
  char *v1; // $a1

  MEMORY[0]();
  return strcpy(v0, v1);
}
// 4CD659: variable 'v0' is possibly undefined
// 4CD659: variable 'v1' is possibly undefined

//----- (004CD660) --------------------------------------------------------
char *__fastcall strcpy(char *dest, char *src)
{
  MEMORY[0](dest, src);
  return (char *)dns_more_dnstype_buf();
}
// 4CD670: using guessed type int dns_more_dnstype_buf(void);

//----- (004CD670) --------------------------------------------------------
int dns_more_dnstype_buf()
{
  MEMORY[0]();
  return get_realwans_data();
}
// 4CD680: using guessed type int get_realwans_data(void);

//----- (004CD680) --------------------------------------------------------
int get_realwans_data()
{
  MEMORY[0]();
  return random();
}

//----- (004CD690) --------------------------------------------------------
int random(void)
{
  MEMORY[0]();
  return _xstart();
}
// 4CD6A0: using guessed type int _xstart(void);

//----- (004CD6A0) --------------------------------------------------------
int _xstart()
{
  MEMORY[0]();
  return jhl_start_redial();
}
// 4CD6B0: using guessed type int jhl_start_redial(void);

//----- (004CD6B0) --------------------------------------------------------
ssize_t jhl_start_redial()
{
  int v0; // $a0
  void *v1; // $a1
  size_t v2; // $a2

  MEMORY[0]();
  return read(v0, v1, v2);
}
// 4CD6B9: variable 'v0' is possibly undefined
// 4CD6B9: variable 'v1' is possibly undefined
// 4CD6B9: variable 'v2' is possibly undefined

//----- (004CD6C0) --------------------------------------------------------
ssize_t read(int fd, void *buf, size_t nbytes)
{
  MEMORY[0](fd, buf, nbytes);
  return jhl_nv_is_def();
}
// 4CD6D0: using guessed type int jhl_nv_is_def(void);

//----- (004CD6D0) --------------------------------------------------------
int jhl_nv_is_def()
{
  MEMORY[0]();
  return start_parm_auto_send_email();
}
// 4CD6E0: using guessed type int start_parm_auto_send_email(void);

//----- (004CD6E0) --------------------------------------------------------
int start_parm_auto_send_email()
{
  MEMORY[0]();
  return wayos_file_upgrade();
}
// 4CD6F0: using guessed type int wayos_file_upgrade(void);

//----- (004CD6F0) --------------------------------------------------------
int wayos_file_upgrade()
{
  MEMORY[0]();
  return jhl_system();
}
// 4CD700: using guessed type int jhl_system(void);

//----- (004CD700) --------------------------------------------------------
int jhl_system()
{
  MEMORY[0]();
  return dns_more_dnstype_item_add();
}
// 4CD710: using guessed type int dns_more_dnstype_item_add(void);

//----- (004CD710) --------------------------------------------------------
int dns_more_dnstype_item_add()
{
  MEMORY[0]();
  return jhl_start_firewall();
}
// 4CD720: using guessed type int jhl_start_firewall(void);

//----- (004CD720) --------------------------------------------------------
int jhl_start_firewall()
{
  char *v0; // $a0

  MEMORY[0]();
  return system(v0);
}
// 4CD729: variable 'v0' is possibly undefined

//----- (004CD730) --------------------------------------------------------
int __fastcall system(char *command)
{
  MEMORY[0](command);
  return create_dir2();
}
// 4CD740: using guessed type int create_dir2(void);

//----- (004CD740) --------------------------------------------------------
int create_dir2()
{
  MEMORY[0]();
  return jhl_get_dns();
}
// 4CD750: using guessed type int jhl_get_dns(void);

//----- (004CD750) --------------------------------------------------------
double jhl_get_dns()
{
  float v0; // $f12

  MEMORY[0]();
  return v0;
}
// 4CD759: variable 'v0' is possibly undefined

//----- (004CD770) --------------------------------------------------------
int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen)
{
  int v5; // $a0
  int v6; // $a1
  int v7; // $a2
  const void *v8; // $a3

  MEMORY[0](fd, level, optname, optval);
  return SSL_accept(v5, v6, v7, v8, optlen);
}
// 4CD779: variable 'v5' is possibly undefined
// 4CD779: variable 'v6' is possibly undefined
// 4CD779: variable 'v7' is possibly undefined
// 4CD779: variable 'v8' is possibly undefined

//----- (004CD780) --------------------------------------------------------
ssize_t __fastcall SSL_accept(int fd, int level, int optname, const void *optval, socklen_t optlen, socklen_t a6)
{
  int v6; // $a0
  const void *v7; // $a1
  size_t v8; // $a2
  int v9; // $a3

  MEMORY[0](fd, level, optname, optval);
  return sendto(v6, v7, v8, v9, (const struct sockaddr *)optlen, a6);
}
// 4CD789: variable 'v6' is possibly undefined
// 4CD789: variable 'v7' is possibly undefined
// 4CD789: variable 'v8' is possibly undefined
// 4CD789: variable 'v9' is possibly undefined

//----- (004CD790) --------------------------------------------------------
ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
{
  int v6; // $a0
  const void *v7; // $a1
  size_t v8; // $a2
  int v9; // $a3

  MEMORY[0](fd, buf, n, flags);
  return ipv6_router_set_to_server(v6, v7, v8, v9, addr, addr_len);
}
// 4CD799: variable 'v6' is possibly undefined
// 4CD799: variable 'v7' is possibly undefined
// 4CD799: variable 'v8' is possibly undefined
// 4CD799: variable 'v9' is possibly undefined

//----- (004CD7A0) --------------------------------------------------------
ssize_t __fastcall ipv6_router_set_to_server(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
{
  MEMORY[0](fd, buf, n, flags);
  return mkfs_disk_device();
}
// 4CD7B0: using guessed type int mkfs_disk_device(void);

//----- (004CD7B0) --------------------------------------------------------
int mkfs_disk_device()
{
  MEMORY[0]();
  return nvparm_del_str_too_too_long();
}
// 4CD7C0: using guessed type int nvparm_del_str_too_too_long(void);

//----- (004CD7C0) --------------------------------------------------------
int nvparm_del_str_too_too_long()
{
  MEMORY[0]();
  return arp_st_addall();
}
// 4CD7D0: using guessed type int arp_st_addall(void);

//----- (004CD7D0) --------------------------------------------------------
int arp_st_addall()
{
  MEMORY[0]();
  return get_duolan_ip();
}
// 4CD7E0: using guessed type int get_duolan_ip(void);

//----- (004CD7E0) --------------------------------------------------------
int get_duolan_ip()
{
  MEMORY[0]();
  return flash_sq_file_set();
}
// 4CD7F0: using guessed type int flash_sq_file_set(void);

//----- (004CD7F0) --------------------------------------------------------
int flash_sq_file_set()
{
  MEMORY[0]();
  return jhl_check_and_tran_unicode2312();
}
// 4CD800: using guessed type int jhl_check_and_tran_unicode2312(void);

//----- (004CD800) --------------------------------------------------------
char *jhl_check_and_tran_unicode2312()
{
  char *v0; // $a0
  char *v1; // $a1

  MEMORY[0]();
  return strcat(v0, v1);
}
// 4CD809: variable 'v0' is possibly undefined
// 4CD809: variable 'v1' is possibly undefined

//----- (004CD810) --------------------------------------------------------
char *__fastcall strcat(char *dest, char *src)
{
  MEMORY[0](dest, src);
  return (char *)dns_url_add();
}
// 4CD820: using guessed type int dns_url_add(void);

//----- (004CD820) --------------------------------------------------------
int dns_url_add()
{
  MEMORY[0]();
  return SSL_CTX_new();
}
// 4CD830: using guessed type int SSL_CTX_new(void);

//----- (004CD830) --------------------------------------------------------
int SSL_CTX_new()
{
  MEMORY[0]();
  return nvram_unset();
}
// 4CD840: using guessed type int nvram_unset(void);

//----- (004CD840) --------------------------------------------------------
int nvram_unset()
{
  MEMORY[0]();
  return J_ato10();
}
// 4CD850: using guessed type int J_ato10(void);

//----- (004CD850) --------------------------------------------------------
int J_ato10()
{
  MEMORY[0]();
  return jhl_check_wanup();
}
// 4CD860: using guessed type int jhl_check_wanup(void);

//----- (004CD860) --------------------------------------------------------
int jhl_check_wanup()
{
  MEMORY[0]();
  return set_usb_acc_conf();
}
// 4CD870: using guessed type int set_usb_acc_conf(void);

//----- (004CD870) --------------------------------------------------------
int set_usb_acc_conf()
{
  MEMORY[0]();
  return url_gid_member_get();
}
// 4CD880: using guessed type int url_gid_member_get(void);

//----- (004CD880) --------------------------------------------------------
int url_gid_member_get()
{
  MEMORY[0]();
  return _eval_nowait();
}
// 4CD890: using guessed type int _eval_nowait(void);

//----- (004CD890) --------------------------------------------------------
int _eval_nowait()
{
  MEMORY[0]();
  return user_namedown_set();
}
// 4CD8A0: using guessed type int user_namedown_set(void);

//----- (004CD8A0) --------------------------------------------------------
int user_namedown_set()
{
  MEMORY[0]();
  return pppoe_br_user_conf();
}
// 4CD8B0: using guessed type int pppoe_br_user_conf(void);

//----- (004CD8B0) --------------------------------------------------------
int pppoe_br_user_conf()
{
  MEMORY[0]();
  return get_md5_str();
}
// 4CD8C0: using guessed type int get_md5_str(void);

//----- (004CD8C0) --------------------------------------------------------
float get_md5_str()
{
  int v0; // $a0

  MEMORY[0]();
  return (float)v0;
}
// 4CD8C9: variable 'v0' is possibly undefined

//----- (004CD8E0) --------------------------------------------------------
int cJSON_GetArrayItem()
{
  MEMORY[0]();
  return restart_third_rzgl();
}
// 4CD8F0: using guessed type int restart_third_rzgl(void);

//----- (004CD8F0) --------------------------------------------------------
int restart_third_rzgl()
{
  MEMORY[0]();
  return ipv6in4_start();
}
// 4CD900: using guessed type int ipv6in4_start(void);

//----- (004CD900) --------------------------------------------------------
int ipv6in4_start()
{
  MEMORY[0]();
  return ipv6in4_stop();
}
// 4CD910: using guessed type int ipv6in4_stop(void);

//----- (004CD910) --------------------------------------------------------
int ipv6in4_stop()
{
  MEMORY[0]();
  return start_user_jsmod();
}
// 4CD920: using guessed type int start_user_jsmod(void);

//----- (004CD920) --------------------------------------------------------
int start_user_jsmod()
{
  MEMORY[0]();
  return jhl_stop_3g();
}
// 4CD930: using guessed type int jhl_stop_3g(void);

//----- (004CD930) --------------------------------------------------------
int jhl_stop_3g()
{
  MEMORY[0]();
  return wyaos_z_wan_out_set_macs();
}
// 4CD940: using guessed type int wyaos_z_wan_out_set_macs(void);

//----- (004CD940) --------------------------------------------------------
int wyaos_z_wan_out_set_macs()
{
  MEMORY[0]();
  return dns_more_dnswan_add();
}
// 4CD950: using guessed type int dns_more_dnswan_add(void);

//----- (004CD950) --------------------------------------------------------
int dns_more_dnswan_add()
{
  MEMORY[0]();
  return judge_ipaddr_file_valid();
}
// 4CD960: using guessed type int judge_ipaddr_file_valid(void);

//----- (004CD960) --------------------------------------------------------
int judge_ipaddr_file_valid()
{
  MEMORY[0]();
  return GenerateStr();
}
// 4CD970: using guessed type int GenerateStr(void);

//----- (004CD970) --------------------------------------------------------
int GenerateStr()
{
  MEMORY[0]();
  return set_systime();
}
// 4CD980: using guessed type int set_systime(void);

//----- (004CD980) --------------------------------------------------------
int set_systime()
{
  MEMORY[0]();
  return lan_iface_foreach();
}
// 4CD990: using guessed type int lan_iface_foreach(void);

//----- (004CD990) --------------------------------------------------------
int lan_iface_foreach()
{
  MEMORY[0]();
  return ApiFindWhiteMac();
}
// 4CD9A0: using guessed type int ApiFindWhiteMac(void);

//----- (004CD9A0) --------------------------------------------------------
int ApiFindWhiteMac()
{
  MEMORY[0]();
  return sq_file_get_id();
}
// 4CD9B0: using guessed type int sq_file_get_id(void);

//----- (004CD9B0) --------------------------------------------------------
int sq_file_get_id()
{
  MEMORY[0]();
  return jhl_get_wanstatus();
}
// 4CD9C0: using guessed type int jhl_get_wanstatus(void);

//----- (004CD9C0) --------------------------------------------------------
int jhl_get_wanstatus()
{
  MEMORY[0]();
  return user_add();
}
// 4CD9D0: using guessed type int user_add(void);

//----- (004CD9D0) --------------------------------------------------------
int user_add()
{
  MEMORY[0]();
  return iptv_channel_wan_set();
}
// 4CD9E0: using guessed type int iptv_channel_wan_set(void);

//----- (004CD9E0) --------------------------------------------------------
int iptv_channel_wan_set()
{
  const char *v0; // $a0

  MEMORY[0]();
  return atoi(v0);
}
// 4CD9E9: variable 'v0' is possibly undefined

//----- (004CD9F0) --------------------------------------------------------
int atoi(const char *nptr)
{
  MEMORY[0](nptr);
  return pppoe_group_del_kernel();
}
// 4CDA00: using guessed type int pppoe_group_del_kernel(void);

//----- (004CDA00) --------------------------------------------------------
int pppoe_group_del_kernel()
{
  MEMORY[0]();
  return GetJSONItemValueAsIntDef();
}
// 4CDA10: using guessed type int GetJSONItemValueAsIntDef(void);

//----- (004CDA10) --------------------------------------------------------
int GetJSONItemValueAsIntDef()
{
  MEMORY[0]();
  return jhl_nv_get_def();
}
// 4CDA20: using guessed type int jhl_nv_get_def(void);

//----- (004CDA20) --------------------------------------------------------
int jhl_nv_get_def()
{
  MEMORY[0]();
  return lan_name_get2();
}
// 4CDA30: using guessed type int lan_name_get2(void);

//----- (004CDA30) --------------------------------------------------------
int lan_name_get2()
{
  MEMORY[0]();
  return sq2_file_get_auth_errinfo();
}
// 4CDA40: using guessed type int sq2_file_get_auth_errinfo(void);

//----- (004CDA40) --------------------------------------------------------
size_t sq2_file_get_auth_errinfo()
{
  char *v0; // $a0
  size_t v1; // $a1
  const char *v2; // $a2
  const struct tm *v3; // $a3

  MEMORY[0]();
  return strftime(v0, v1, v2, v3);
}
// 4CDA49: variable 'v0' is possibly undefined
// 4CDA49: variable 'v1' is possibly undefined
// 4CDA49: variable 'v2' is possibly undefined
// 4CDA49: variable 'v3' is possibly undefined

//----- (004CDA50) --------------------------------------------------------
size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp)
{
  MEMORY[0](s, maxsize, format, tp);
  return start_dhcp_server();
}
// 4CDA60: using guessed type int start_dhcp_server(void);

//----- (004CDA60) --------------------------------------------------------
int start_dhcp_server()
{
  MEMORY[0]();
  return SSL_CTX_load_verify_locations();
}
// 4CDA70: using guessed type int SSL_CTX_load_verify_locations(void);

//----- (004CDA70) --------------------------------------------------------
int SSL_CTX_load_verify_locations()
{
  MEMORY[0]();
  return pppoe_br_user_get_file();
}
// 4CDA80: using guessed type int pppoe_br_user_get_file(void);

//----- (004CDA80) --------------------------------------------------------
struct tm *pppoe_br_user_get_file()
{
  const time_t *v0; // $a0

  MEMORY[0]();
  return gmtime(v0);
}
// 4CDA89: variable 'v0' is possibly undefined

//----- (004CDA90) --------------------------------------------------------
struct tm *gmtime(const time_t *timer)
{
  const char *v1; // $a0

  MEMORY[0](timer);
  return (struct tm *)opendir(v1);
}
// 4CDA99: variable 'v1' is possibly undefined

//----- (004CDAA0) --------------------------------------------------------
DIR *opendir(const char *name)
{
  MEMORY[0](name);
  return (DIR *)ct_low_limit_check();
}
// 4CDAB0: using guessed type int ct_low_limit_check(void);

//----- (004CDAB0) --------------------------------------------------------
void ct_low_limit_check()
{
  int v0; // $a0
  const char *v1; // $a1

  MEMORY[0]();
  syslog(v0, v1);
}
// 4CDAB9: variable 'v0' is possibly undefined
// 4CDAB9: variable 'v1' is possibly undefined

//----- (004CDAC0) --------------------------------------------------------
void syslog(int pri, const char *fmt, ...)
{
  MEMORY[0](pri, fmt);
  TLSv1_2_server_method();
}
// 4CDAD0: using guessed type int TLSv1_2_server_method(void);

//----- (004CDAD0) --------------------------------------------------------
int TLSv1_2_server_method()
{
  MEMORY[0]();
  return del_log_data();
}
// 4CDAE0: using guessed type int del_log_data(void);

//----- (004CDAE0) --------------------------------------------------------
int del_log_data()
{
  MEMORY[0]();
  return sq2_file_send_sq_num();
}
// 4CDAF0: using guessed type int sq2_file_send_sq_num(void);

//----- (004CDAF0) --------------------------------------------------------
int sq2_file_send_sq_num()
{
  MEMORY[0]();
  return cJSON_CreateArray();
}
// 4CDB00: using guessed type int cJSON_CreateArray(void);

//----- (004CDB00) --------------------------------------------------------
size_t cJSON_CreateArray()
{
  const void *v0; // $a0
  size_t v1; // $a1
  size_t v2; // $a2
  FILE *v3; // $a3

  MEMORY[0]();
  return fwrite(v0, v1, v2, v3);
}
// 4CDB09: variable 'v0' is possibly undefined
// 4CDB09: variable 'v1' is possibly undefined
// 4CDB09: variable 'v2' is possibly undefined
// 4CDB09: variable 'v3' is possibly undefined

//----- (004CDB10) --------------------------------------------------------
size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s)
{
  const char *v4; // $a0

  MEMORY[0](ptr, size, n, s);
  return puts(v4);
}
// 4CDB19: variable 'v4' is possibly undefined

//----- (004CDB20) --------------------------------------------------------
int puts(const char *s)
{
  MEMORY[0](s);
  return start_version_upgrade_auto();
}
// 4CDB30: using guessed type int start_version_upgrade_auto(void);

//----- (004CDB30) --------------------------------------------------------
int start_version_upgrade_auto()
{
  MEMORY[0]();
  return strlcpy();
}
// 4CDB40: using guessed type int strlcpy(void);

//----- (004CDB40) --------------------------------------------------------
int strlcpy()
{
  MEMORY[0]();
  return stop_wan_http_check();
}
// 4CDB50: using guessed type int stop_wan_http_check(void);

//----- (004CDB50) --------------------------------------------------------
FILE *stop_wan_http_check()
{
  const char *v0; // $a0
  const char *v1; // $a1

  MEMORY[0]();
  return fopen(v0, v1);
}
// 4CDB59: variable 'v0' is possibly undefined
// 4CDB59: variable 'v1' is possibly undefined

//----- (004CDB60) --------------------------------------------------------
FILE *fopen(const char *filename, const char *modes)
{
  MEMORY[0](filename, modes);
  return (FILE *)base64_encode();
}
// 4CDB70: using guessed type int base64_encode(void);

//----- (004CDB70) --------------------------------------------------------
int base64_encode()
{
  MEMORY[0]();
  return url_memberfile_buf();
}
// 4CDB80: using guessed type int url_memberfile_buf(void);

//----- (004CDB80) --------------------------------------------------------
int url_memberfile_buf()
{
  MEMORY[0]();
  return f_exists();
}
// 4CDB90: using guessed type int f_exists(void);

//----- (004CDB90) --------------------------------------------------------
uint32_t f_exists()
{
  uint32_t v0; // $a0

  MEMORY[0]();
  return ntohl(v0);
}
// 4CDB99: variable 'v0' is possibly undefined

//----- (004CDBA0) --------------------------------------------------------
uint32_t ntohl(uint32_t netlong)
{
  MEMORY[0](netlong);
  return aes_aes();
}
// 4CDBB0: using guessed type int aes_aes(void);

//----- (004CDBB0) --------------------------------------------------------
int aes_aes()
{
  MEMORY[0]();
  return jhl_get_wan_proto();
}
// 4CDBC0: using guessed type int jhl_get_wan_proto(void);

//----- (004CDBC0) --------------------------------------------------------
int jhl_get_wan_proto()
{
  MEMORY[0]();
  return get_random_seed();
}
// 4CDBD0: using guessed type int get_random_seed(void);

//----- (004CDBD0) --------------------------------------------------------
int get_random_seed()
{
  MEMORY[0]();
  return load_module();
}
// 4CDBE0: using guessed type int load_module(void);

//----- (004CDBE0) --------------------------------------------------------
int load_module()
{
  MEMORY[0]();
  return f_read_json();
}
// 4CDBF0: using guessed type int f_read_json(void);

//----- (004CDBF0) --------------------------------------------------------
int f_read_json()
{
  const char *v0; // $a0
  __mode_t v1; // $a1

  MEMORY[0]();
  return mkdir(v0, v1);
}
// 4CDBF9: variable 'v0' is possibly undefined
// 4CDBF9: variable 'v1' is possibly undefined

//----- (004CDC00) --------------------------------------------------------
int mkdir(const char *path, __mode_t mode)
{
  MEMORY[0](path, mode);
  return cJSON_CodeString();
}
// 4CDC10: using guessed type int cJSON_CodeString(void);

//----- (004CDC10) --------------------------------------------------------
int cJSON_CodeString()
{
  MEMORY[0]();
  return SSL_get_ciphers();
}
// 4CDC20: using guessed type int SSL_get_ciphers(void);

//----- (004CDC20) --------------------------------------------------------
int SSL_get_ciphers()
{
  MEMORY[0]();
  return get_uptime_sys();
}
// 4CDC30: using guessed type int get_uptime_sys(void);

//----- (004CDC30) --------------------------------------------------------
int get_uptime_sys()
{
  MEMORY[0]();
  return get_lan_ifnames();
}
// 4CDC40: using guessed type int get_lan_ifnames(void);

//----- (004CDC40) --------------------------------------------------------
int get_lan_ifnames()
{
  MEMORY[0]();
  return IpaddrToStr();
}
// 4CDC50: using guessed type int IpaddrToStr(void);

//----- (004CDC50) --------------------------------------------------------
int IpaddrToStr()
{
  MEMORY[0]();
  return wys_get_mac_by_ipaddr();
}
// 4CDC60: using guessed type int wys_get_mac_by_ipaddr(void);

//----- (004CDC60) --------------------------------------------------------
int wys_get_mac_by_ipaddr()
{
  MEMORY[0]();
  return dual_lan_get_lan_showname();
}
// 4CDC70: using guessed type int dual_lan_get_lan_showname(void);

//----- (004CDC70) --------------------------------------------------------
uint32_t dual_lan_get_lan_showname()
{
  uint32_t v0; // $a0

  MEMORY[0]();
  return htonl(v0);
}
// 4CDC79: variable 'v0' is possibly undefined

//----- (004CDC80) --------------------------------------------------------
uint32_t htonl(uint32_t hostlong)
{
  char *v1; // $a0
  int v2; // $a1
  char *v3; // $a2

  MEMORY[0](hostlong);
  return snprintf(v1, v2, v3);
}
// 4CDC89: variable 'v1' is possibly undefined
// 4CDC89: variable 'v2' is possibly undefined
// 4CDC89: variable 'v3' is possibly undefined

//----- (004CDC90) --------------------------------------------------------
int snprintf(char *str, int size, char *format, ...)
{
  MEMORY[0](str, size, format);
  return start_module_upgrade_auto();
}
// 4CDCA0: using guessed type int start_module_upgrade_auto(void);

//----- (004CDCA0) --------------------------------------------------------
int start_module_upgrade_auto()
{
  MEMORY[0]();
  return power_off();
}
// 4CDCB0: using guessed type int power_off(void);

//----- (004CDCB0) --------------------------------------------------------
int power_off()
{
  int v0; // $a0
  int v1; // $a1

  MEMORY[0]();
  return fcntl(v0, v1);
}
// 4CDCB9: variable 'v0' is possibly undefined
// 4CDCB9: variable 'v1' is possibly undefined

//----- (004CDCC0) --------------------------------------------------------
int fcntl(int fd, int cmd, ...)
{
  const char *v2; // $a0
  int v3; // $a1

  MEMORY[0](fd, cmd);
  return access(v2, v3);
}
// 4CDCC9: variable 'v2' is possibly undefined
// 4CDCC9: variable 'v3' is possibly undefined

//----- (004CDCD0) --------------------------------------------------------
int access(const char *name, int type)
{
  MEMORY[0](name, type);
  return SSL_CTX_use_PrivateKey_file();
}
// 4CDCE0: using guessed type int SSL_CTX_use_PrivateKey_file(void);

//----- (004CDCE0) --------------------------------------------------------
int SSL_CTX_use_PrivateKey_file()
{
  MEMORY[0]();
  return mcl_bytearray_printf();
}
// 4CDCF0: using guessed type int mcl_bytearray_printf(void);

//----- (004CDCF0) --------------------------------------------------------
int mcl_bytearray_printf()
{
  MEMORY[0]();
  return set_host_domain_name();
}
// 4CDD00: using guessed type int set_host_domain_name(void);

//----- (004CDD00) --------------------------------------------------------
int set_host_domain_name()
{
  MEMORY[0]();
  return ApiAddWhiteMac();
}
// 4CDD10: using guessed type int ApiAddWhiteMac(void);

//----- (004CDD10) --------------------------------------------------------
int ApiAddWhiteMac()
{
  MEMORY[0]();
  return SSL_CTX_set_cipher_list();
}
// 4CDD20: using guessed type int SSL_CTX_set_cipher_list(void);

//----- (004CDD20) --------------------------------------------------------
int SSL_CTX_set_cipher_list()
{
  MEMORY[0]();
  return strdb_del();
}
// 4CDD30: using guessed type int strdb_del(void);

//----- (004CDD30) --------------------------------------------------------
int strdb_del()
{
  MEMORY[0]();
  return __get_cpu_uptime();
}
// 4CDD40: using guessed type int __get_cpu_uptime(void);

//----- (004CDD40) --------------------------------------------------------
int __get_cpu_uptime()
{
  MEMORY[0]();
  return cJSON_CreateString();
}
// 4CDD50: using guessed type int cJSON_CreateString(void);

//----- (004CDD50) --------------------------------------------------------
int cJSON_CreateString()
{
  MEMORY[0]();
  return get_devmg_lan_id();
}
// 4CDD60: using guessed type int get_devmg_lan_id(void);

//----- (004CDD60) --------------------------------------------------------
double get_devmg_lan_id()
{
  int v0; // $a0

  MEMORY[0]();
  return (double)v0;
}
// 4CDD69: variable 'v0' is possibly undefined

//----- (004CDD80) --------------------------------------------------------
int wan_iface_foreach()
{
  MEMORY[0]();
  return stop_wan_dns_check();
}
// 4CDD90: using guessed type int stop_wan_dns_check(void);

//----- (004CDD90) --------------------------------------------------------
int stop_wan_dns_check()
{
  MEMORY[0]();
  return dns_more_dnstype_get();
}
// 4CDDA0: using guessed type int dns_more_dnstype_get(void);

//----- (004CDDA0) --------------------------------------------------------
int dns_more_dnstype_get()
{
  MEMORY[0]();
  return nvram_match_def();
}
// 4CDDB0: using guessed type int nvram_match_def(void);

//----- (004CDDB0) --------------------------------------------------------
int nvram_match_def()
{
  MEMORY[0]();
  return nvram_reset_def();
}
// 4CDDC0: using guessed type int nvram_reset_def(void);

//----- (004CDDC0) --------------------------------------------------------
int nvram_reset_def()
{
  MEMORY[0]();
  return _eval();
}
// 4CDDD0: using guessed type int _eval(void);

//----- (004CDDD0) --------------------------------------------------------
int _eval()
{
  MEMORY[0]();
  return flash_get_sec_status();
}
// 4CDDE0: using guessed type int flash_get_sec_status(void);

//----- (004CDDE0) --------------------------------------------------------
int flash_get_sec_status()
{
  MEMORY[0]();
  return f_read_string();
}
// 4CDDF0: using guessed type int f_read_string(void);

//----- (004CDDF0) --------------------------------------------------------
ssize_t f_read_string()
{
  int v0; // $a0
  const void *v1; // $a1
  size_t v2; // $a2

  MEMORY[0]();
  return write(v0, v1, v2);
}
// 4CDDF9: variable 'v0' is possibly undefined
// 4CDDF9: variable 'v1' is possibly undefined
// 4CDDF9: variable 'v2' is possibly undefined

//----- (004CDE00) --------------------------------------------------------
ssize_t write(int fd, const void *buf, size_t n)
{
  MEMORY[0](fd, buf, n);
  return duolan_do();
}
// 4CDE10: using guessed type int duolan_do(void);

//----- (004CDE10) --------------------------------------------------------
int duolan_do()
{
  MEMORY[0]();
  return nvparm_del_str();
}
// 4CDE20: using guessed type int nvparm_del_str(void);

//----- (004CDE20) --------------------------------------------------------
int nvparm_del_str()
{
  const char *v0; // $a0
  const char *v1; // $a1

  MEMORY[0]();
  return strcasecmp(v0, v1);
}
// 4CDE29: variable 'v0' is possibly undefined
// 4CDE29: variable 'v1' is possibly undefined

//----- (004CDE30) --------------------------------------------------------
int strcasecmp(const char *s1, const char *s2)
{
  MEMORY[0](s1, s2);
  return start_auto_reboot();
}
// 4CDE40: using guessed type int start_auto_reboot(void);

//----- (004CDE40) --------------------------------------------------------
int start_auto_reboot()
{
  MEMORY[0]();
  return common_qq_val_edt();
}
// 4CDE50: using guessed type int common_qq_val_edt(void);

//----- (004CDE50) --------------------------------------------------------
int common_qq_val_edt()
{
  MEMORY[0]();
  return sq_file_get_device_id();
}
// 4CDE60: using guessed type int sq_file_get_device_id(void);

//----- (004CDE60) --------------------------------------------------------
int sq_file_get_device_id()
{
  MEMORY[0]();
  return url_member_delall();
}
// 4CDE70: using guessed type int url_member_delall(void);

//----- (004CDE70) --------------------------------------------------------
int url_member_delall()
{
  MEMORY[0]();
  return J_atoi_ull();
}
// 4CDE80: using guessed type int J_atoi_ull(void);

//----- (004CDE80) --------------------------------------------------------
int J_atoi_ull()
{
  int v0; // $a0
  int v1; // $a1
  int v2; // $a2

  MEMORY[0]();
  return socket(v0, v1, v2);
}
// 4CDE89: variable 'v0' is possibly undefined
// 4CDE89: variable 'v1' is possibly undefined
// 4CDE89: variable 'v2' is possibly undefined

//----- (004CDE90) --------------------------------------------------------
int socket(int domain, int type, int protocol)
{
  MEMORY[0](domain, type, protocol);
  return cJSON_AddStringToObject();
}
// 4CDEA0: using guessed type int cJSON_AddStringToObject(void);

//----- (004CDEA0) --------------------------------------------------------
int cJSON_AddStringToObject()
{
  MEMORY[0]();
  return mr_set_by_jh_en();
}
// 4CDEB0: using guessed type int mr_set_by_jh_en(void);

//----- (004CDEB0) --------------------------------------------------------
int mr_set_by_jh_en()
{
  MEMORY[0]();
  return mng_client_restart();
}
// 4CDEC0: using guessed type int mng_client_restart(void);

//----- (004CDEC0) --------------------------------------------------------
int mng_client_restart()
{
  int *__attribute__((__org_arrdim(0,2))) v0; // $a0

  MEMORY[0]();
  return pipe(v0);
}
// 4CDEC9: variable 'v0' is possibly undefined

//----- (004CDED0) --------------------------------------------------------
int pipe(int pipedes[2])
{
  MEMORY[0](pipedes);
  return duolan_undo();
}
// 4CDEE0: using guessed type int duolan_undo(void);

//----- (004CDEE0) --------------------------------------------------------
int duolan_undo()
{
  MEMORY[0]();
  return jhl_hardversion_get();
}
// 4CDEF0: using guessed type int jhl_hardversion_get(void);

//----- (004CDEF0) --------------------------------------------------------
int jhl_hardversion_get()
{
  MEMORY[0]();
  return url_member_get();
}
// 4CDF00: using guessed type int url_member_get(void);

//----- (004CDF00) --------------------------------------------------------
int url_member_get()
{
  MEMORY[0]();
  return add_timer();
}
// 4CDF10: using guessed type int add_timer(void);

//----- (004CDF10) --------------------------------------------------------
int add_timer()
{
  MEMORY[0]();
  return ping_wan_gw_start();
}
// 4CDF20: using guessed type int ping_wan_gw_start(void);

//----- (004CDF20) --------------------------------------------------------
int ping_wan_gw_start()
{
  MEMORY[0]();
  return MD5Init();
}
// 4CDF30: using guessed type int MD5Init(void);

//----- (004CDF30) --------------------------------------------------------
int MD5Init()
{
  MEMORY[0]();
  return shared_get_sdwans_data();
}
// 4CDF40: using guessed type int shared_get_sdwans_data(void);

//----- (004CDF40) --------------------------------------------------------
int shared_get_sdwans_data()
{
  MEMORY[0]();
  return upgrade_after();
}
// 4CDF50: using guessed type int upgrade_after(void);

//----- (004CDF50) --------------------------------------------------------
int upgrade_after()
{
  MEMORY[0]();
  return wys_sj_module_add();
}
// 4CDF60: using guessed type int wys_sj_module_add(void);

//----- (004CDF60) --------------------------------------------------------
int wys_sj_module_add()
{
  MEMORY[0]();
  return sk_num();
}
// 4CDF70: using guessed type int sk_num(void);

//----- (004CDF70) --------------------------------------------------------
time_t sk_num()
{
  time_t *v0; // $a0

  MEMORY[0]();
  return time(v0);
}
// 4CDF79: variable 'v0' is possibly undefined

//----- (004CDF80) --------------------------------------------------------
time_t time(time_t *timer)
{
  FILE *v1; // $a0
  int v2; // $a1
  int v3; // $a2

  MEMORY[0](timer);
  return fseek(v1, v2, v3);
}
// 4CDF89: variable 'v1' is possibly undefined
// 4CDF89: variable 'v2' is possibly undefined
// 4CDF89: variable 'v3' is possibly undefined

//----- (004CDF90) --------------------------------------------------------
int fseek(FILE *stream, int off, int whence)
{
  MEMORY[0](stream, off, whence);
  return init_timer();
}
// 4CDFA0: using guessed type int init_timer(void);

//----- (004CDFA0) --------------------------------------------------------
int init_timer()
{
  MEMORY[0]();
  return SHA1();
}
// 4CDFB0: using guessed type int SHA1(void);

//----- (004CDFB0) --------------------------------------------------------
int SHA1()
{
  const char *v0; // $a0

  MEMORY[0]();
  return remove(v0);
}
// 4CDFB9: variable 'v0' is possibly undefined

//----- (004CDFC0) --------------------------------------------------------
int remove(const char *filename)
{
  MEMORY[0](filename);
  return auth_write_usblog();
}
// 4CDFD0: using guessed type int auth_write_usblog(void);

//----- (004CDFD0) --------------------------------------------------------
int auth_write_usblog()
{
  const void *v0; // $a0
  const void *v1; // $a1
  size_t v2; // $a2

  MEMORY[0]();
  return memcmp(v0, v1, v2);
}
// 4CDFD9: variable 'v0' is possibly undefined
// 4CDFD9: variable 'v1' is possibly undefined
// 4CDFD9: variable 'v2' is possibly undefined

//----- (004CDFE0) --------------------------------------------------------
int memcmp(const void *s1, const void *s2, size_t n)
{
  MEMORY[0](s1, s2, n);
  return wt_client_restart();
}
// 4CDFF0: using guessed type int wt_client_restart(void);

//----- (004CDFF0) --------------------------------------------------------
int wt_client_restart()
{
  FILE *v0; // $a0

  MEMORY[0]();
  return fclose(v0);
}
// 4CDFF9: variable 'v0' is possibly undefined

//----- (004CE000) --------------------------------------------------------
int fclose(FILE *stream)
{
  MEMORY[0](stream);
  return init_timers_cpu();
}
// 4CE010: using guessed type int init_timers_cpu(void);

//----- (004CE010) --------------------------------------------------------
void init_timers_cpu()
{
  unsigned int v0; // $a0

  MEMORY[0]();
  srandom(v0);
}
// 4CE019: variable 'v0' is possibly undefined

//----- (004CE020) --------------------------------------------------------
void srandom(unsigned int seed)
{
  MEMORY[0](seed);
  run_timers();
}
// 4CE030: using guessed type int run_timers(void);

//----- (004CE030) --------------------------------------------------------
char *run_timers()
{
  const char *v0; // $a0

  MEMORY[0]();
  return strdup(v0);
}
// 4CE039: variable 'v0' is possibly undefined

//----- (004CE040) --------------------------------------------------------
char *strdup(const char *s)
{
  MEMORY[0](s);
  return (char *)SSL_CTX_free();
}
// 4CE050: using guessed type int SSL_CTX_free(void);

//----- (004CE050) --------------------------------------------------------
int SSL_CTX_free()
{
  MEMORY[0]();
  return write_tg_html_to_usb();
}
// 4CE060: using guessed type int write_tg_html_to_usb(void);

//----- (004CE060) --------------------------------------------------------
const char *write_tg_html_to_usb()
{
  int v0; // $a0
  const void *v1; // $a1
  char *v2; // $a2
  socklen_t v3; // $a3

  MEMORY[0]();
  return inet_ntop(v0, v1, v2, v3);
}
// 4CE069: variable 'v0' is possibly undefined
// 4CE069: variable 'v1' is possibly undefined
// 4CE069: variable 'v2' is possibly undefined
// 4CE069: variable 'v3' is possibly undefined

//----- (004CE070) --------------------------------------------------------
const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len)
{
  int v4; // $a0
  unsigned int v5; // $a1

  MEMORY[0](af, cp, buf, len);
  return (const char *)ioctl(v4, v5);
}
// 4CE079: variable 'v4' is possibly undefined
// 4CE079: variable 'v5' is possibly undefined

//----- (004CE080) --------------------------------------------------------
int ioctl(int fd, unsigned int request, ...)
{
  MEMORY[0](fd, request);
  return set_rule_to_kernel();
}
// 4CE090: using guessed type int set_rule_to_kernel(void);

//----- (004CE090) --------------------------------------------------------
int set_rule_to_kernel()
{
  MEMORY[0]();
  return get_log_data_in_time();
}
// 4CE0A0: using guessed type int get_log_data_in_time(void);

//----- (004CE0A0) --------------------------------------------------------
int get_log_data_in_time()
{
  MEMORY[0]();
  return cJSON_free();
}
// 4CE0B0: using guessed type int cJSON_free(void);

//----- (004CE0B0) --------------------------------------------------------
int cJSON_free()
{
  MEMORY[0]();
  return common_get_token();
}
// 4CE0C0: using guessed type int common_get_token(void);

//----- (004CE0C0) --------------------------------------------------------
int common_get_token()
{
  MEMORY[0]();
  return SSL_load_error_strings();
}
// 4CE0D0: using guessed type int SSL_load_error_strings(void);

//----- (004CE0D0) --------------------------------------------------------
int SSL_load_error_strings()
{
  MEMORY[0]();
  return __GET_LANG_TEXT();
}
// 4CE0E0: using guessed type int __GET_LANG_TEXT(void);

//----- (004CE0E0) --------------------------------------------------------
int __GET_LANG_TEXT()
{
  MEMORY[0]();
  return shared_get_sd_wans_data();
}
// 4CE0F0: using guessed type int shared_get_sd_wans_data(void);

//----- (004CE0F0) --------------------------------------------------------
int shared_get_sd_wans_data()
{
  MEMORY[0]();
  return ApiAddWhiteIp();
}
// 4CE100: using guessed type int ApiAddWhiteIp(void);

//----- (004CE100) --------------------------------------------------------
ssize_t __fastcall ApiAddWhiteIp(int a1, int a2, int a3, int a4, struct sockaddr *a5, socklen_t *a6)
{
  int v6; // $a0
  void *v7; // $a1
  size_t v8; // $a2
  int v9; // $a3

  MEMORY[0]();
  return recvfrom(v6, v7, v8, v9, a5, a6);
}
// 4CE109: variable 'v6' is possibly undefined
// 4CE109: variable 'v7' is possibly undefined
// 4CE109: variable 'v8' is possibly undefined
// 4CE109: variable 'v9' is possibly undefined

//----- (004CE110) --------------------------------------------------------
ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)
{
  int v6; // $a0
  void *v7; // $a1
  size_t v8; // $a2
  int v9; // $a3

  MEMORY[0](fd, buf, n, flags);
  return jhl_parm_set(v6, v7, v8, v9, addr, addr_len);
}
// 4CE119: variable 'v6' is possibly undefined
// 4CE119: variable 'v7' is possibly undefined
// 4CE119: variable 'v8' is possibly undefined
// 4CE119: variable 'v9' is possibly undefined

//----- (004CE120) --------------------------------------------------------
ssize_t __fastcall jhl_parm_set(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)
{
  MEMORY[0](fd, buf, n, flags);
  return crypt_sha1();
}
// 4CE130: using guessed type int crypt_sha1(void);

//----- (004CE130) --------------------------------------------------------
int crypt_sha1()
{
  MEMORY[0]();
  return dns_srv_start();
}
// 4CE140: using guessed type int dns_srv_start(void);

//----- (004CE140) --------------------------------------------------------
int dns_srv_start()
{
  MEMORY[0]();
  return arp_st_delall();
}
// 4CE150: using guessed type int arp_st_delall(void);

//----- (004CE150) --------------------------------------------------------
int arp_st_delall()
{
  MEMORY[0]();
  return ApiDelWhiteIp();
}
// 4CE160: using guessed type int ApiDelWhiteIp(void);

//----- (004CE160) --------------------------------------------------------
int ApiDelWhiteIp()
{
  MEMORY[0]();
  return jhl_iface_link_up_check();
}
// 4CE170: using guessed type int jhl_iface_link_up_check(void);

//----- (004CE170) --------------------------------------------------------
int jhl_iface_link_up_check()
{
  MEMORY[0]();
  return jhl_vpnclient_stop();
}
// 4CE180: using guessed type int jhl_vpnclient_stop(void);

//----- (004CE180) --------------------------------------------------------
int jhl_vpnclient_stop()
{
  MEMORY[0]();
  return vpn_user_del();
}
// 4CE190: using guessed type int vpn_user_del(void);

//----- (004CE190) --------------------------------------------------------
int vpn_user_del()
{
  MEMORY[0]();
  return jingx_do();
}
// 4CE1A0: using guessed type int jingx_do(void);

//----- (004CE1A0) --------------------------------------------------------
int jingx_do()
{
  MEMORY[0]();
  return killall_tk();
}
// 4CE1B0: using guessed type int killall_tk(void);

//----- (004CE1B0) --------------------------------------------------------
int killall_tk()
{
  MEMORY[0]();
  return start_dhcp_server_just_check();
}
// 4CE1C0: using guessed type int start_dhcp_server_just_check(void);

//----- (004CE1C0) --------------------------------------------------------
int start_dhcp_server_just_check()
{
  const char *v0; // $a0
  struct in_addr *v1; // $a1

  MEMORY[0]();
  return inet_aton(v0, v1);
}
// 4CE1C9: variable 'v0' is possibly undefined
// 4CE1C9: variable 'v1' is possibly undefined

//----- (004CE1D0) --------------------------------------------------------
int inet_aton(const char *cp, struct in_addr *inp)
{
  int v2; // $a0
  __off_t v3; // $a1
  int v4; // $a2

  MEMORY[0](cp, inp);
  return lseek(v2, v3, v4);
}
// 4CE1D9: variable 'v2' is possibly undefined
// 4CE1D9: variable 'v3' is possibly undefined
// 4CE1D9: variable 'v4' is possibly undefined

//----- (004CE1E0) --------------------------------------------------------
__off_t lseek(int fd, __off_t offset, int whence)
{
  MEMORY[0](fd, offset, whence);
  return set_dns_more_hitype_to_kernel();
}
// 4CE1F0: using guessed type int set_dns_more_hitype_to_kernel(void);

//----- (004CE1F0) --------------------------------------------------------
int set_dns_more_hitype_to_kernel()
{
  MEMORY[0]();
  return miitool_data_buf();
}
// 4CE200: using guessed type int miitool_data_buf(void);

//----- (004CE200) --------------------------------------------------------
int miitool_data_buf()
{
  __pid_t v0; // $a0
  int v1; // $a1

  MEMORY[0]();
  return kill(v0, v1);
}
// 4CE209: variable 'v0' is possibly undefined
// 4CE209: variable 'v1' is possibly undefined

//----- (004CE210) --------------------------------------------------------
int kill(__pid_t pid, int sig)
{
  MEMORY[0](pid, sig);
  return get_upfile_version_flag();
}
// 4CE220: using guessed type int get_upfile_version_flag(void);

//----- (004CE220) --------------------------------------------------------
int get_upfile_version_flag()
{
  MEMORY[0]();
  return user_ipdown_set();
}
// 4CE230: using guessed type int user_ipdown_set(void);

//----- (004CE230) --------------------------------------------------------
unsigned int user_ipdown_set()
{
  const char *v0; // $a0
  char **v1; // $a1
  int v2; // $a2

  MEMORY[0]();
  return strtoul(v0, v1, v2);
}
// 4CE239: variable 'v0' is possibly undefined
// 4CE239: variable 'v1' is possibly undefined
// 4CE239: variable 'v2' is possibly undefined

//----- (004CE240) --------------------------------------------------------
unsigned int strtoul(const char *nptr, char **endptr, int base)
{
  MEMORY[0](nptr, endptr, base);
  return restart_wys_billing();
}
// 4CE250: using guessed type int restart_wys_billing(void);

//----- (004CE250) --------------------------------------------------------
int restart_wys_billing()
{
  MEMORY[0]();
  return jhl_setwanxx();
}
// 4CE260: using guessed type int jhl_setwanxx(void);

//----- (004CE260) --------------------------------------------------------
int jhl_setwanxx()
{
  MEMORY[0]();
  return cJSON_IsArray();
}
// 4CE270: using guessed type int cJSON_IsArray(void);

//----- (004CE270) --------------------------------------------------------
int cJSON_IsArray()
{
  MEMORY[0]();
  return reset_billing_rzgl_parm();
}
// 4CE280: using guessed type int reset_billing_rzgl_parm(void);

//----- (004CE280) --------------------------------------------------------
int reset_billing_rzgl_parm()
{
  MEMORY[0]();
  return jhl_set_wan_name();
}
// 4CE290: using guessed type int jhl_set_wan_name(void);

//----- (004CE290) --------------------------------------------------------
int jhl_set_wan_name()
{
  MEMORY[0]();
  return pppoe_br_user_add();
}
// 4CE2A0: using guessed type int pppoe_br_user_add(void);

//----- (004CE2A0) --------------------------------------------------------
int pppoe_br_user_add()
{
  const char *v0; // $a0
  int v1; // $a1

  MEMORY[0]();
  return open(v0, v1);
}
// 4CE2A9: variable 'v0' is possibly undefined
// 4CE2A9: variable 'v1' is possibly undefined

//----- (004CE2B0) --------------------------------------------------------
int open(const char *file, int oflag, ...)
{
  MEMORY[0](file, oflag);
  return user_delall();
}
// 4CE2C0: using guessed type int user_delall(void);

//----- (004CE2C0) --------------------------------------------------------
int user_delall()
{
  char *v0; // $a0
  char *v1; // $a1

  MEMORY[0]();
  return sprintf(v0, v1);
}
// 4CE2C9: variable 'v0' is possibly undefined
// 4CE2C9: variable 'v1' is possibly undefined

//----- (004CE2D0) --------------------------------------------------------
int sprintf(char *str, char *format, ...)
{
  MEMORY[0](str, format);
  return get_time_group();
}
// 4CE2E0: using guessed type int get_time_group(void);

//----- (004CE2E0) --------------------------------------------------------
int get_time_group()
{
  MEMORY[0]();
  return read_ovpn_file();
}
// 4CE2F0: using guessed type int read_ovpn_file(void);

//----- (004CE2F0) --------------------------------------------------------
int read_ovpn_file()
{
  MEMORY[0]();
  return dns_more_dnstype_item_delall();
}
// 4CE300: using guessed type int dns_more_dnstype_item_delall(void);

//----- (004CE300) --------------------------------------------------------
unsigned int dns_more_dnstype_item_delall()
{
  unsigned int v0; // $a0

  MEMORY[0]();
  return sleep(v0);
}
// 4CE309: variable 'v0' is possibly undefined

//----- (004CE310) --------------------------------------------------------
unsigned int sleep(unsigned int seconds)
{
  MEMORY[0](seconds);
  return arp_st_add();
}
// 4CE320: using guessed type int arp_st_add(void);

//----- (004CE320) --------------------------------------------------------
int arp_st_add()
{
  MEMORY[0]();
  return StrToIpaddr();
}
// 4CE330: using guessed type int StrToIpaddr(void);

//----- (004CE330) --------------------------------------------------------
int StrToIpaddr()
{
  struct sysinfo *v0; // $a0

  MEMORY[0]();
  return sysinfo(v0);
}
// 4CE339: variable 'v0' is possibly undefined

//----- (004CE340) --------------------------------------------------------
int sysinfo(struct sysinfo *info)
{
  MEMORY[0](info);
  return SSL_CTX_check_private_key();
}
// 4CE350: using guessed type int SSL_CTX_check_private_key(void);

//----- (004CE350) --------------------------------------------------------
int SSL_CTX_check_private_key()
{
  MEMORY[0]();
  return set_dns_more_dnstype_to_kernel();
}
// 4CE360: using guessed type int set_dns_more_dnstype_to_kernel(void);

//----- (004CE360) --------------------------------------------------------
__sighandler_t set_dns_more_dnstype_to_kernel()
{
  int v0; // $a0
  __sighandler_t v1; // $a1

  MEMORY[0]();
  return signal(v0, v1);
}
// 4CE369: variable 'v0' is possibly undefined
// 4CE369: variable 'v1' is possibly undefined

//----- (004CE370) --------------------------------------------------------
__sighandler_t signal(int sig, __sighandler_t handler)
{
  MEMORY[0](sig, handler);
  return (__sighandler_t)mr_parm_default();
}
// 4CE380: using guessed type int mr_parm_default(void);

//----- (004CE380) --------------------------------------------------------
int mr_parm_default()
{
  int v0; // $a0
  const struct sockaddr *v1; // $a1
  socklen_t v2; // $a2

  MEMORY[0]();
  return connect(v0, v1, v2);
}
// 4CE389: variable 'v0' is possibly undefined
// 4CE389: variable 'v1' is possibly undefined
// 4CE389: variable 'v2' is possibly undefined

//----- (004CE390) --------------------------------------------------------
int connect(int fd, const struct sockaddr *addr, socklen_t len)
{
  int v3; // $a0
  fd_set *v4; // $a1
  fd_set *v5; // $a2
  fd_set *v6; // $a3
  struct timeval *v8; // [sp+10h] [+10h]

  MEMORY[0](fd, addr, len);
  return select(v3, v4, v5, v6, v8);
}
// 4CE399: variable 'v3' is possibly undefined
// 4CE399: variable 'v4' is possibly undefined
// 4CE399: variable 'v5' is possibly undefined
// 4CE399: variable 'v6' is possibly undefined

//----- (004CE3A0) --------------------------------------------------------
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
{
  struct pollfd *v5; // $a0
  nfds_t v6; // $a1
  int v7; // $a2

  MEMORY[0](nfds, readfds, writefds, exceptfds);
  return poll(v5, v6, v7);
}
// 4CE3A9: variable 'v5' is possibly undefined
// 4CE3A9: variable 'v6' is possibly undefined
// 4CE3A9: variable 'v7' is possibly undefined

//----- (004CE3B0) --------------------------------------------------------
int poll(struct pollfd *fds, nfds_t nfds, int timeout)
{
  char *v3; // $a0

  MEMORY[0](fds, nfds, timeout);
  return sscanf(v3);
}
// 4CE3B9: variable 'v3' is possibly undefined

//----- (004CE3C0) --------------------------------------------------------
int sscanf(char *format, ...)
{
  int v1; // $a0
  const struct sockaddr *v2; // $a1
  socklen_t v3; // $a2

  MEMORY[0](format);
  return bind(v1, v2, v3);
}
// 4CE3C9: variable 'v1' is possibly undefined
// 4CE3C9: variable 'v2' is possibly undefined
// 4CE3C9: variable 'v3' is possibly undefined

//----- (004CE3D0) --------------------------------------------------------
int bind(int fd, const struct sockaddr *addr, socklen_t len)
{
  MEMORY[0](fd, addr, len);
  return cJSON_CreateObject();
}
// 4CE3E0: using guessed type int cJSON_CreateObject(void);

//----- (004CE3E0) --------------------------------------------------------
size_t cJSON_CreateObject()
{
  const char *v0; // $a0

  MEMORY[0]();
  return strlen(v0);
}
// 4CE3E9: variable 'v0' is possibly undefined

//----- (004CE3F0) --------------------------------------------------------
size_t strlen(const char *s)
{
  MEMORY[0](s);
  return set_pppoe_group_to_kernel();
}
// 4CE400: using guessed type int set_pppoe_group_to_kernel(void);

//----- (004CE400) --------------------------------------------------------
int set_pppoe_group_to_kernel()
{
  MEMORY[0]();
  return stop_dhcp_server_just_check();
}
// 4CE410: using guessed type int stop_dhcp_server_just_check(void);

//----- (004CE410) --------------------------------------------------------
int stop_dhcp_server_just_check()
{
  MEMORY[0]();
  return cJSON_IsString();
}
// 4CE420: using guessed type int cJSON_IsString(void);

//----- (004CE420) --------------------------------------------------------
int cJSON_IsString()
{
  MEMORY[0]();
  return J_atohx16();
}
// 4CE430: using guessed type int J_atohx16(void);

//----- (004CE430) --------------------------------------------------------
int J_atohx16()
{
  MEMORY[0]();
  return SSL_CIPHER_get_version();
}
// 4CE440: using guessed type int SSL_CIPHER_get_version(void);

//----- (004CE440) --------------------------------------------------------
int SSL_CIPHER_get_version()
{
  const char *v0; // $a0
  char **v1; // $a1
  int v2; // $a2

  MEMORY[0]();
  return strtol(v0, v1, v2);
}
// 4CE449: variable 'v0' is possibly undefined
// 4CE449: variable 'v1' is possibly undefined
// 4CE449: variable 'v2' is possibly undefined

//----- (004CE450) --------------------------------------------------------
int strtol(const char *nptr, char **endptr, int base)
{
  MEMORY[0](nptr, endptr, base);
  return pppoe_br_user_delall();
}
// 4CE460: using guessed type int pppoe_br_user_delall(void);

//----- (004CE460) --------------------------------------------------------
int pppoe_br_user_delall()
{
  MEMORY[0]();
  return dns_more_hitype_delall();
}
// 4CE470: using guessed type int dns_more_hitype_delall(void);

//----- (004CE470) --------------------------------------------------------
int dns_more_hitype_delall()
{
  MEMORY[0]();
  return cJSON_IsObject();
}
// 4CE480: using guessed type int cJSON_IsObject(void);

//----- (004CE480) --------------------------------------------------------
int cJSON_IsObject()
{
  MEMORY[0]();
  return set_link_status_by_id();
}
// 4CE490: using guessed type int set_link_status_by_id(void);

//----- (004CE490) --------------------------------------------------------
int set_link_status_by_id()
{
  MEMORY[0]();
  return is_domain();
}
// 4CE4A0: using guessed type int is_domain(void);

//----- (004CE4A0) --------------------------------------------------------
int is_domain()
{
  MEMORY[0]();
  return str2mac();
}
// 4CE4B0: using guessed type int str2mac(void);

//----- (004CE4B0) --------------------------------------------------------
int str2mac()
{
  MEMORY[0]();
  return GET_MENU_JS_TEXT();
}
// 4CE4C0: using guessed type int GET_MENU_JS_TEXT(void);

//----- (004CE4C0) --------------------------------------------------------
int GET_MENU_JS_TEXT()
{
  MEMORY[0]();
  return get_link_status_by_id();
}
// 4CE4D0: using guessed type int get_link_status_by_id(void);

//----- (004CE4D0) --------------------------------------------------------
int get_link_status_by_id()
{
  MEMORY[0]();
  return SSL_CIPHER_get_name();
}
// 4CE4E0: using guessed type int SSL_CIPHER_get_name(void);

//----- (004CE4E0) --------------------------------------------------------
int SSL_CIPHER_get_name()
{
  MEMORY[0]();
  return jhl_start_l2tpd_srv();
}
// 4CE4F0: using guessed type int jhl_start_l2tpd_srv(void);

//----- (004CE4F0) --------------------------------------------------------
int jhl_start_l2tpd_srv()
{
  MEMORY[0]();
  return vpn_user_add();
}
// 4CE500: using guessed type int vpn_user_add(void);

//----- (004CE500) --------------------------------------------------------
int vpn_user_add()
{
  MEMORY[0]();
  return f_write();
}
// 4CE510: using guessed type int f_write(void);

//----- (004CE510) --------------------------------------------------------
int f_write()
{
  MEMORY[0]();
  return ERR_print_errors_fp();
}
// 4CE520: using guessed type int ERR_print_errors_fp(void);

//----- (004CE520) --------------------------------------------------------
int ERR_print_errors_fp()
{
  MEMORY[0]();
  return get_json_data_safe2();
}
// 4CE530: using guessed type int get_json_data_safe2(void);

//----- (004CE530) --------------------------------------------------------
int get_json_data_safe2()
{
  const char *v0; // $a0
  const char *v1; // $a1

  MEMORY[0]();
  return rename(v0, v1);
}
// 4CE539: variable 'v0' is possibly undefined
// 4CE539: variable 'v1' is possibly undefined

//----- (004CE540) --------------------------------------------------------
int rename(const char *old, const char *a2)
{
  MEMORY[0](old, a2);
  return nvparm_find_str();
}
// 4CE550: using guessed type int nvparm_find_str(void);

//----- (004CE550) --------------------------------------------------------
int nvparm_find_str()
{
  MEMORY[0]();
  return jhl_stop_l2tpd_srv();
}
// 4CE560: using guessed type int jhl_stop_l2tpd_srv(void);

//----- (004CE560) --------------------------------------------------------
int jhl_stop_l2tpd_srv()
{
  MEMORY[0]();
  return start_arp_sys();
}
// 4CE570: using guessed type int start_arp_sys(void);

//----- (004CE570) --------------------------------------------------------
int start_arp_sys()
{
  MEMORY[0]();
  return jhl_ctreate_dmresolv();
}
// 4CE580: using guessed type int jhl_ctreate_dmresolv(void);

//----- (004CE580) --------------------------------------------------------
int jhl_ctreate_dmresolv()
{
  MEMORY[0]();
  return sys_runinfo_get();
}
// 4CE590: using guessed type int sys_runinfo_get(void);

//----- (004CE590) --------------------------------------------------------
int sys_runinfo_get()
{
  MEMORY[0]();
  return eval_nowait_tty();
}
// 4CE5A0: using guessed type int eval_nowait_tty(void);

//----- (004CE5A0) --------------------------------------------------------
int __fastcall eval_nowait_tty(int a1, int a2, int a3, int a4, socklen_t *a5)
{
  int v5; // $a0
  int v6; // $a1
  int v7; // $a2
  void *v8; // $a3

  MEMORY[0]();
  return getsockopt(v5, v6, v7, v8, a5);
}
// 4CE5A9: variable 'v5' is possibly undefined
// 4CE5A9: variable 'v6' is possibly undefined
// 4CE5A9: variable 'v7' is possibly undefined
// 4CE5A9: variable 'v8' is possibly undefined

//----- (004CE5B0) --------------------------------------------------------
int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen)
{
  int v5; // $a0
  int v6; // $a1
  int v7; // $a2
  void *v8; // $a3

  MEMORY[0](fd, level, optname, optval);
  return get_sn(v5, v6, v7, v8, optlen);
}
// 4CE5B9: variable 'v5' is possibly undefined
// 4CE5B9: variable 'v6' is possibly undefined
// 4CE5B9: variable 'v7' is possibly undefined
// 4CE5B9: variable 'v8' is possibly undefined

//----- (004CE5C0) --------------------------------------------------------
int __fastcall get_sn(int fd, int level, int optname, void *optval, socklen_t *optlen)
{
  MEMORY[0](fd, level, optname, optval);
  return dns_acc_del();
}
// 4CE5D0: using guessed type int dns_acc_del(void);

//----- (004CE5D0) --------------------------------------------------------
int dns_acc_del()
{
  MEMORY[0]();
  return strdb_add();
}
// 4CE5E0: using guessed type int strdb_add(void);

//----- (004CE5E0) --------------------------------------------------------
int strdb_add()
{
  MEMORY[0]();
  return base64_decode();
}
// 4CE5F0: using guessed type int base64_decode(void);

//----- (004CE5F0) --------------------------------------------------------
int base64_decode()
{
  MEMORY[0]();
  return jhl_mr_set_dns();
}
// 4CE600: using guessed type int jhl_mr_set_dns(void);

//----- (004CE600) --------------------------------------------------------
int jhl_mr_set_dns()
{
  MEMORY[0]();
  return jiffies_init();
}
// 4CE610: using guessed type int jiffies_init(void);

//----- (004CE610) --------------------------------------------------------
int jiffies_init()
{
  MEMORY[0]();
  return prepare_upgrade();
}
// 4CE620: using guessed type int prepare_upgrade(void);

//----- (004CE620) --------------------------------------------------------
int prepare_upgrade()
{
  MEMORY[0]();
  return nvram_get();
}
// 4CE630: using guessed type int nvram_get(void);

//----- (004CE630) --------------------------------------------------------
int *nvram_get()
{
  MEMORY[0]();
  return __errno_location();
}

//----- (004CE640) --------------------------------------------------------
int *__errno_location(void)
{
  MEMORY[0]();
  return (int *)nvram_get_int();
}
// 4CE650: using guessed type int nvram_get_int(void);

//----- (004CE650) --------------------------------------------------------
int nvram_get_int()
{
  MEMORY[0]();
  return get_dhcp_left_num();
}
// 4CE660: using guessed type int get_dhcp_left_num(void);

//----- (004CE660) --------------------------------------------------------
int get_dhcp_left_num()
{
  MEMORY[0]();
  return get_netmask_wei();
}
// 4CE670: using guessed type int get_netmask_wei(void);

//----- (004CE670) --------------------------------------------------------
int get_netmask_wei()
{
  MEMORY[0]();
  return jhl_start_pptpd_srv();
}
// 4CE680: using guessed type int jhl_start_pptpd_srv(void);

//----- (004CE680) --------------------------------------------------------
int jhl_start_pptpd_srv()
{
  MEMORY[0]();
  return mod_timer();
}
// 4CE690: using guessed type int mod_timer(void);

//----- (004CE690) --------------------------------------------------------
int mod_timer()
{
  MEMORY[0]();
  return dns_more_hitype_del();
}
// 4CE6A0: using guessed type int dns_more_hitype_del(void);

//----- (004CE6A0) --------------------------------------------------------
int dns_more_hitype_del()
{
  MEMORY[0]();
  return url_group_del();
}
// 4CE6B0: using guessed type int url_group_del(void);

//----- (004CE6B0) --------------------------------------------------------
void *url_group_del()
{
  size_t v0; // $a0

  MEMORY[0]();
  return malloc(v0);
}
// 4CE6B9: variable 'v0' is possibly undefined

//----- (004CE6C0) --------------------------------------------------------
void *malloc(size_t size)
{
  int v1; // $a0
  const void *v2; // $a1
  size_t v3; // $a2
  int v4; // $a3

  MEMORY[0](size);
  return (void *)send(v1, v2, v3, v4);
}
// 4CE6C9: variable 'v1' is possibly undefined
// 4CE6C9: variable 'v2' is possibly undefined
// 4CE6C9: variable 'v3' is possibly undefined
// 4CE6C9: variable 'v4' is possibly undefined

//----- (004CE6D0) --------------------------------------------------------
ssize_t send(int fd, const void *buf, size_t n, int flags)
{
  MEMORY[0](fd, buf, n, flags);
  return dual_getIfMac();
}
// 4CE6E0: using guessed type int dual_getIfMac(void);

//----- (004CE6E0) --------------------------------------------------------
int dual_getIfMac()
{
  const char *v0; // $a0
  const char *v1; // $a1

  MEMORY[0]();
  return strcmp(v0, v1);
}
// 4CE6E9: variable 'v0' is possibly undefined
// 4CE6E9: variable 'v1' is possibly undefined

//----- (004CE6F0) --------------------------------------------------------
int strcmp(const char *s1, const char *s2)
{
  MEMORY[0](s1, s2);
  return check_ip_is_wanip();
}
// 4CE700: using guessed type int check_ip_is_wanip(void);

//----- (004CE700) --------------------------------------------------------
int check_ip_is_wanip()
{
  MEMORY[0]();
  return cJSON_NumberToString();
}
// 4CE710: using guessed type int cJSON_NumberToString(void);

//----- (004CE710) --------------------------------------------------------
int cJSON_NumberToString()
{
  MEMORY[0]();
  return jhl_parm_commit();
}
// 4CE720: using guessed type int jhl_parm_commit(void);

//----- (004CE720) --------------------------------------------------------
int jhl_parm_commit()
{
  MEMORY[0]();
  return shared_get_sd_vpns_data();
}
// 4CE730: using guessed type int shared_get_sd_vpns_data(void);

//----- (004CE730) --------------------------------------------------------
int shared_get_sd_vpns_data()
{
  MEMORY[0]();
  return killall();
}
// 4CE740: using guessed type int killall(void);

//----- (004CE740) --------------------------------------------------------
struct dirent *killall()
{
  DIR *v0; // $a0

  MEMORY[0]();
  return readdir(v0);
}
// 4CE749: variable 'v0' is possibly undefined

//----- (004CE750) --------------------------------------------------------
struct dirent *readdir(DIR *dirp)
{
  MEMORY[0](dirp);
  return (struct dirent *)term_proc();
}
// 4CE770: using guessed type int term_proc(void);

//----- (004CE770) --------------------------------------------------------
int term_proc()
{
  return sub_41FE70();
}

// nfuncs=2070 queued=1533 decompiled=1533 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1533 function(s)"
